export const command_docs = [
{
    "command": "dihedral_style charmm",
    "html_filename": "dihedral_charmm.html",
    "short_description": "The charmm and charmmfsw dihedral styles use the potential  \\[E = K [ 1 + \\cos (n \\phi - d) ]\\] See (MacKerell) for a description of the CHARMM force field",
    "description": "The charmm and charmmfsw dihedral styles use the potential\n\n\\[E = K [ 1 + \\cos (n \\phi - d) ]\\]\nSee (MacKerell) for a description of the CHARMM\nforce field.  This dihedral style can also be used for the AMBER force\nfield (see comment on weighting factors below).  See\n(Cornell) for a description of the AMBER force\nfield.\n\nNote\nThe newer charmmfsw style was released in March 2017.  We\nrecommend it be used instead of the older charmm style when running\na simulation with the CHARMM force field, either with long-range\nCoulombics or a Coulombic cutoff, via the pair_style lj/charmmfsw/coul/long and pair_style lj/charmmfsw/coul/charmmfsh commands respectively.\nOtherwise the older charmm style is fine to use.  See the discussion\nbelow and more details on the pair_style charmm doc\npage.\n\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(n\\) (integer >= 0)\n\\(d\\) (integer value of degrees)\nweighting factor (1.0, 0.5, or 0.0)\n\nThe weighting factor is required to correct for double counting\npairwise non-bonded Lennard-Jones interactions in cyclic systems or\nwhen using the CHARMM dihedral style with non-CHARMM force fields.\nWith the CHARMM dihedral style, interactions between the 1st and 4th\natoms in a dihedral are skipped during the normal non-bonded force\ncomputation and instead evaluated as part of the dihedral using\nspecial epsilon and sigma values specified with the\npair_coeff command of pair styles that contain\n“lj/charmm” (e.g. pair_style lj/charmm/coul/long)\nIn 6-membered rings, the same 1-4 interaction would be computed twice\n(once for the clockwise 1-4 pair in dihedral 1-2-3-4 and once in the\ncounterclockwise dihedral 1-6-5-4) and thus the weighting factor has\nto be 0.5 in this case.  In 4-membered or 5-membered rings, the 1-4\ndihedral also is counted as a 1-2 or 1-3 interaction when going around\nthe ring in the opposite direction and thus the weighting factor is\n0.0, as the 1-2 and 1-3 exclusions take precedence.\nNote that this dihedral weighting factor is unrelated to the scaling\nfactor specified by the special bonds command\nwhich applies to all 1-4 interactions in the system.  For CHARMM force\nfields, the special_bonds 1-4 interaction scaling factor should be set\nto 0.0. Since the corresponding 1-4 non-bonded interactions are\ncomputed with the dihedral.  This means that if any of the weighting\nfactors defined as dihedral coefficients (4th coeff above) are\nnon-zero, then you must use a pair style with “lj/charmm” and set the\nspecial_bonds 1-4 scaling factor to 0.0 (which is the\ndefault). Otherwise 1-4 non-bonded interactions in dihedrals will be\ncomputed twice.\nFor simulations using the CHARMM force field with a Coulombic cutoff,\nthe difference between the charmm and charmmfsw styles is in the\ncomputation of the 1-4 non-bond interactions, though only if the\ndistance between the two atoms is within the switching region of the\npairwise potential defined by the corresponding CHARMM pair style,\ni.e. within the outer cutoff specified for the pair style.  The\ncharmmfsw style should only be used when using the corresponding\npair_style lj/charmmfsw/coul/charmmfsw or\npair_style lj/charmmfsw/coul/long commands.  Use\nthe charmm style with the older pair_style\ncommands that have just “charmm” in their style name.  See the\ndiscussion on the CHARMM pair_style doc page for\ndetails.\nNote that for AMBER force fields, which use pair styles with “lj/cut”,\nthe special_bonds 1-4 scaling factor should be set to the AMBER\ndefaults (1/2 and 5/6) and all the dihedral weighting factors (4th\ncoeff above) must be set to 0.0. In this case, you can use any pair\nstyle you wish, since the dihedral does not need any Lennard-Jones\nparameter information and will not compute any 1-4 non-bonded\ninteractions.  Likewise the charmm or charmmfsw styles are\nidentical in this case since no 1-4 non-bonded interactions are\ncomputed.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style style",
    "parameters": " * style = charmm or charmmfsw",
    "examples": "dihedral_style charmm\ndihedral_style charmmfsw\ndihedral_coeff  1 0.2 1 180 1.0\ndihedral_coeff  2 1.8 1   0 1.0\ndihedral_coeff  1 3.1 2 180 0.5",
    "restrictions": "When using run_style respa, these dihedral styles\nmust be assigned to the same r-RESPA level as pair or outer.\nWhen used in combination with CHARMM pair styles, the 1-4\nspecial_bonds scaling factors must be set to 0.0.\nOtherwise non-bonded contributions for these 1-4 pairs will be\ncomputed multiple times.\nThese dihedral styles can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "dihedral_style class2",
    "html_filename": "dihedral_class2.html",
    "short_description": "The class2 dihedral style uses the potential  \\[\\begin{split}E        = & E_d + E_{mbt} + E_{ebt} + E_{at} + E_{aat} + E_{bb13} \\\\ E_d      = & \\sum_{n=1}^{3} K_n [ 1 - \\cos (n \\phi - \\phi_n) ] \\\\ E_{mbt}  = & (r_{jk} - r_2) [ A_1 \\cos (\\phi) + A_2 \\cos (2\\phi) + A_3 \\cos (3\\phi) ] \\\\ E_{ebt}  = & (r_{ij} - r_1) [ B_1 \\cos (\\phi) + B_2 \\cos (2\\phi) + B_3 \\cos (3\\phi) ] + \\\\            & (r_{kl} - r_3) [ C_1 \\cos (\\phi) + C_2 \\cos (2\\phi) + C_3 \\cos (3\\phi) ] \\\\ E_{at}   = & (\\theta_{ijk} - \\theta_1) [ D_1 \\cos (\\phi) + D_2 \\cos (2\\phi) + D_3 \\cos (3\\phi) ] + \\\\            & (\\theta_{jkl} - \\theta_2) [ E_1 \\cos (\\phi) + E_2 \\cos (2\\phi) + E_3 \\cos (3\\phi) ] \\\\ E_{aat}  = & M (\\theta_{ijk} - \\theta_1) (\\theta_{jkl} - \\theta_2) \\cos (\\phi) \\\\ E_{bb13} = & N (r_{ij} - r_1) (r_{kl} - r_3)\\end{split}\\] where \\(E_d\\) is the dihedral term, \\(E_{mbt}\\) is a middle-bond-torsion term, \\(E_{ebt}\\) is an end-bond-torsion term, \\(E_{at}\\) is an angle-torsion term, \\(E_{aat}\\) is an angle-angle-torsion term, and \\(E_{bb13}\\) is a bond-bond-13 term",
    "description": "The class2 dihedral style uses the potential\n\n\\[\\begin{split}E        = & E_d + E_{mbt} + E_{ebt} + E_{at} + E_{aat} + E_{bb13} \\\\\nE_d      = & \\sum_{n=1}^{3} K_n [ 1 - \\cos (n \\phi - \\phi_n) ] \\\\\nE_{mbt}  = & (r_{jk} - r_2) [ A_1 \\cos (\\phi) + A_2 \\cos (2\\phi) + A_3 \\cos (3\\phi) ] \\\\\nE_{ebt}  = & (r_{ij} - r_1) [ B_1 \\cos (\\phi) + B_2 \\cos (2\\phi) + B_3 \\cos (3\\phi) ] + \\\\\n           & (r_{kl} - r_3) [ C_1 \\cos (\\phi) + C_2 \\cos (2\\phi) + C_3 \\cos (3\\phi) ] \\\\\nE_{at}   = & (\\theta_{ijk} - \\theta_1) [ D_1 \\cos (\\phi) + D_2 \\cos (2\\phi) + D_3 \\cos (3\\phi) ] + \\\\\n           & (\\theta_{jkl} - \\theta_2) [ E_1 \\cos (\\phi) + E_2 \\cos (2\\phi) + E_3 \\cos (3\\phi) ] \\\\\nE_{aat}  = & M (\\theta_{ijk} - \\theta_1) (\\theta_{jkl} - \\theta_2) \\cos (\\phi) \\\\\nE_{bb13} = & N (r_{ij} - r_1) (r_{kl} - r_3)\\end{split}\\]\nwhere \\(E_d\\) is the dihedral term, \\(E_{mbt}\\) is a middle-bond-torsion term,\n\\(E_{ebt}\\) is an end-bond-torsion term, \\(E_{at}\\) is an angle-torsion term, \\(E_{aat}\\)\nis an angle-angle-torsion term, and \\(E_{bb13}\\) is a bond-bond-13 term.\n\\(\\theta_1\\) and \\(\\theta_2\\) are equilibrium angles and \\(r_1\\), \\(r_2\\), and\n\\(r_3\\) are equilibrium bond lengths.\nSee (Sun) for a description of the COMPASS class2 force field.\nCoefficients for the \\(E_d\\), \\(E_{mbt}\\), \\(E_{ebt}\\),\n\\(E_{at}\\), \\(E_{aat}\\), and \\(E_{bb13}\\) formulas must be\ndefined for each dihedral type via the dihedral_coeff\ncommand as in the example above, or in the data file\nor restart files read by the read_data or\nread_restart commands.\nThese are the 6 coefficients for the \\(E_d\\) formula:\n\n\\(K_1\\) (energy)\n\\(\\phi_1\\) (degrees)\n\\(K_2\\) (energy)\n\\(\\phi_2\\) (degrees)\n\\(K_3\\) (energy)\n\\(phi_3\\) (degrees)\n\nFor the \\(E_{mbt}\\) formula, each line in a\ndihedral_coeff command in the input script lists\n5 coefficients, the first of which is mbt to indicate they are\nMiddleBondTorsion coefficients.  In a data file, these coefficients\nshould be listed under a MiddleBondTorsion Coeffs heading and you\nmust leave out the mbt, i.e. only list 4 coefficients after the\ndihedral type.\n\nmbt\n\\(A_1\\) (energy/distance)\n\\(A_2\\) (energy/distance)\n\\(A_3\\) (energy/distance)\n\\(r_2\\) (distance)\n\nFor the \\(E_{ebt}\\) formula, each line in a\ndihedral_coeff command in the input script lists\n9 coefficients, the first of which is ebt to indicate they are\nEndBondTorsion coefficients.  In a data file, these coefficients\nshould be listed under a EndBondTorsion Coeffs heading and you must\nleave out the ebt, i.e. only list 8 coefficients after the dihedral\ntype.\n\nebt\n\\(B_1\\) (energy/distance)\n\\(B_2\\) (energy/distance)\n\\(B_3\\) (energy/distance)\n\\(C_1\\) (energy/distance)\n\\(C_2\\) (energy/distance)\n\\(C_3\\) (energy/distance)\n\\(r_1\\) (distance)\n\\(r_3\\) (distance)\n\nFor the \\(E_{at}\\) formula, each line in a\ndihedral_coeff command in the input script lists\n9 coefficients, the first of which is at to indicate they are\nAngleTorsion coefficients.  In a data file, these coefficients should\nbe listed under a AngleTorsion Coeffs heading and you must leave out\nthe at, i.e. only list 8 coefficients after the dihedral type.\n\nat\n\\(D_1\\) (energy/radian)\n\\(D_2\\) (energy/radian)\n\\(D_3\\) (energy/radian)\n\\(E_1\\) (energy/radian)\n\\(E_2\\) (energy/radian)\n\\(E_3\\) (energy/radian)\n\\(\\theta_1\\) (degrees)\n\\(\\theta_2\\) (degrees)\n\n\\(\\theta_1\\) and \\(\\theta_2\\) are specified in degrees, but LAMMPS converts\nthem to radians internally; hence the units of \\(D\\) and \\(E\\) are in\nenergy/radian.\nFor the \\(E_{aat}\\) formula, each line in a\ndihedral_coeff command in the input script lists\n4 coefficients, the first of which is aat to indicate they are\nAngleAngleTorsion coefficients.  In a data file, these coefficients\nshould be listed under a AngleAngleTorsion Coeffs heading and you\nmust leave out the aat, i.e. only list 3 coefficients after the\ndihedral type.\n\naat\n\\(M\\) (energy/radian^2)\n\\(\\theta_1\\) (degrees)\n\\(\\theta_2\\) (degrees)\n\n\\(\\theta_1\\) and \\(\\theta_2\\) are specified in degrees, but LAMMPS converts\nthem to radians internally; hence the units of M are in energy/radian^2.\nFor the \\(E_{bb13}\\) formula, each line in a\ndihedral_coeff command in the input script lists\n4 coefficients, the first of which is bb13 to indicate they are\nBondBond13 coefficients.  In a data file, these coefficients should be\nlisted under a BondBond13 Coeffs heading and you must leave out the\nbb13, i.e. only list 3 coefficients after the dihedral type.\n\nbb13\n\\(N\\) (energy/distance^2)\n\\(r_1\\) (distance)\n\\(r_3\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style class2",
    "parameters": " * ",
    "examples": "dihedral_style class2\ndihedral_coeff 1 100 75 100 70 80 60\ndihedral_coeff * mbt 3.5945 0.1704 -0.5490 1.5228\ndihedral_coeff * ebt 0.3417 0.3264 -0.9036 0.1368 0.0 -0.8080 1.0119 1.1010\ndihedral_coeff 2 at 0.0 -0.1850 -0.7963 -2.0220 0.0 -0.3991 110.2453 105.1270\ndihedral_coeff * aat -13.5271 110.2453 105.1270\ndihedral_coeff * bb13 0.0 1.0119 1.1010",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nCLASS2 package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_coeff",
    "html_filename": "dihedral_coeff.html",
    "short_description": "Specify the dihedral force field coefficients for one or more dihedral types",
    "description": "Specify the dihedral force field coefficients for one or more dihedral types.\nThe number and meaning of the coefficients depends on the dihedral style.\nDihedral coefficients can also be set in the data file read by the\nread_data command or in a restart file.\nN can be specified in one of two ways.  An explicit numeric value can\nbe used, as in the 1st example above.  Or a wild-card asterisk can be\nused to set the coefficients for multiple dihedral types.  This takes the\nform “*” or “*n” or “n*” or “m*n”.  If N = the number of dihedral types,\nthen an asterisk with no numeric values means all types from 1 to N.  A\nleading asterisk means all types from 1 to n (inclusive).  A trailing\nasterisk means all types from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).\nNote that using a dihedral_coeff command can override a previous setting\nfor the same dihedral type.  For example, these commands set the coeffs\nfor all dihedral types, then overwrite the coeffs for just dihedral type 2:\ndihedral_coeff * 80.0 1 3\ndihedral_coeff 2 200.0 1 3\n\n\nA line in a data file that specifies dihedral coefficients uses the exact\nsame format as the arguments of the dihedral_coeff command in an input\nscript, except that wild-card asterisks should not be used since\ncoefficients for all N types must be listed in the file.  For example,\nunder the “Dihedral Coeffs” section of a data file, the line that\ncorresponds to the 1st example above would be listed as\n1 80.0 1 3\n\n\nThe dihedral_style class2 is an exception to\nthis rule, in that an additional argument is used in the input script\nto allow specification of the cross-term coefficients.  See its doc\npage for details.\n\nNote\nWhen comparing the formulas and coefficients for various LAMMPS\ndihedral styles with dihedral equations defined by other force fields,\nnote that some force field implementations divide/multiply the energy\nprefactor K by the multiple number of torsions that contain the J-K\nbond in an I-J-K-L torsion.  LAMMPS does not do this, i.e. the listed\ndihedral equation applies to each individual dihedral.  Thus you need\nto define K appropriately to account for this difference if\nnecessary.\n\n\nThe list of all dihedral styles defined in LAMMPS is given on the\ndihedral_style doc page.  They are also listed\nin more compact form on the Commands dihedral doc page.\nOn either of those pages, click on the style to display the formula it\ncomputes and its coefficients as specified by the associated\ndihedral_coeff command.",
    "syntax": "dihedral_coeff N args",
    "parameters": " * N = dihedral type (see asterisk form below)\n * args = coefficients for one or more dihedral types",
    "examples": "dihedral_coeff 1 80.0 1 3\ndihedral_coeff * 80.0 1 3 0.5\ndihedral_coeff 2* 80.0 1 3 0.5",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command.\nA dihedral style must be defined before any dihedral coefficients are\nset, either in the input script or in a data file."
},
{
    "command": "dihedral_style cosine/shift/exp",
    "html_filename": "dihedral_cosine_shift_exp.html",
    "short_description": "The cosine/shift/exp dihedral style uses the potential  \\[E = -U_{min}\\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad\\mbox{with}\\quad U(\\theta,\\theta_0)=-0",
    "description": "The cosine/shift/exp dihedral style uses the potential\n\n\\[E = -U_{min}\\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad\\mbox{with}\\quad U(\\theta,\\theta_0)=-0.5 \\left(1+\\cos(\\theta-\\theta_0) \\right)\\]\nwhere \\(U_{min}\\), \\(\\theta\\), and \\(a\\) are defined for\neach dihedral type.\nThe potential is bounded between \\(\\left[-U_{min}:0\\right]\\) and the minimum is located\nat the angle \\(\\theta_0\\). The a parameter can be both positive or negative\nand is used to control the spring constant at the equilibrium.\nThe spring constant is given by \\(k=a e^a \\frac{U_{min}}{2 \\left(e^a-1\\right)}\\).\nFor \\(a>3\\) and  \\(\\frac{k}{U_{min}} = \\frac{a}{2}\\) to better than 5% relative error. For negative\nvalues of the a parameter, the spring constant is essentially zero,\nand anharmonic terms takes over. The potential is furthermore well\nbehaved in the limit \\(a \\rightarrow 0\\), where it has been implemented to linear\norder in \\(a\\) for \\(a < 0.001\\).\nThe following coefficients must be defined for each dihedral type via\nthe dihedral_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(U_{min}\\) (energy)\n\\(\\theta\\) (angle)\n\\(a\\) (real number)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style cosine/shift/exp",
    "parameters": " * ",
    "examples": "dihedral_style cosine/shift/exp\ndihedral_coeff 1 10.0 45.0 2.0",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style fourier",
    "html_filename": "dihedral_fourier.html",
    "short_description": "The fourier dihedral style uses the potential:  \\[E = \\sum_{i=1,m} K_i  [ 1",
    "description": "The fourier dihedral style uses the potential:\n\n\\[E = \\sum_{i=1,m} K_i  [ 1.0 + \\cos ( n_i \\phi - d_i ) ]\\]\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(m\\) (integer >=1)\n\\(K_1\\) (energy)\n\\(n_1\\) (integer >= 0)\n\\(d_1\\) (degrees)\n[…]\n\\(K_m\\) (energy)\n\\(n_m\\) (integer >= 0)\n\\(d_m\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style fourier",
    "parameters": " * ",
    "examples": "dihedral_style fourier\ndihedral_coeff 1 3 -0.846200 3 0.0 7.578800 1 0 0.138000 2 -180.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style harmonic",
    "html_filename": "dihedral_harmonic.html",
    "short_description": "The harmonic dihedral style uses the potential  \\[E = K [ 1 + d  \\cos (n \\phi) ]\\] The following coefficients must be defined for each dihedral type via the dihedral_coeff command as in the example above, or in the data file or restart files read by the read_data or read_restart commands:  \\(K\\) (energy) \\(d\\) (+1 or -1) \\(n\\) (integer >= 0)   Note Here are important points to take note of when defining LAMMPS dihedral coefficients for the harmonic style, so that they are compatible with how harmonic dihedrals are defined by other force fields:   The LAMMPS convention is that the trans position = 180 degrees, while in some force fields trans = 0 degrees",
    "description": "The harmonic dihedral style uses the potential\n\n\\[E = K [ 1 + d  \\cos (n \\phi) ]\\]\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(d\\) (+1 or -1)\n\\(n\\) (integer >= 0)\n\n\nNote\nHere are important points to take note of when defining LAMMPS\ndihedral coefficients for the harmonic style, so that they are\ncompatible with how harmonic dihedrals are defined by other force\nfields:\n\n\nThe LAMMPS convention is that the trans position = 180 degrees, while\nin some force fields trans = 0 degrees.\nSome force fields reverse the sign convention on \\(d\\).\nSome force fields let \\(n\\) be positive or negative which corresponds to\n\\(d = 1\\) or \\(d = -1\\) for the harmonic style.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style harmonic",
    "parameters": " * ",
    "examples": "dihedral_style harmonic\ndihedral_coeff 1 80.0 1 2",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "dihedral_style helix",
    "html_filename": "dihedral_helix.html",
    "short_description": "The helix dihedral style uses the potential  \\[E = A [1 - \\cos(\\theta)] + B [1 + \\cos(3 \\theta)] +     C [1 + \\cos(\\theta + \\frac{\\pi}{4})]\\] This coarse-grain dihedral potential is described in (Guo)",
    "description": "The helix dihedral style uses the potential\n\n\\[E = A [1 - \\cos(\\theta)] + B [1 + \\cos(3 \\theta)] +\n    C [1 + \\cos(\\theta + \\frac{\\pi}{4})]\\]\nThis coarse-grain dihedral potential is described in (Guo).\nFor dihedral angles in the helical region, the energy function is\nrepresented by a standard potential consisting of three minima, one\ncorresponding to the trans (t) state and the other to gauche states\n(g+ and g-).  The paper describes how the \\(A\\), \\(B\\) and,\n\\(C\\) parameters are chosen so as to balance secondary (largely\ndriven by local interactions) and\ntertiary structure (driven by long-range interactions).\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(A\\) (energy)\n\\(B\\) (energy)\n\\(C\\) (energy)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style helix",
    "parameters": " * ",
    "examples": "dihedral_style helix\ndihedral_coeff 1 80.0 100.0 40.0",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "dihedral_style hybrid",
    "html_filename": "dihedral_hybrid.html",
    "short_description": "The hybrid style enables the use of multiple dihedral styles in one simulation",
    "description": "The hybrid style enables the use of multiple dihedral styles in one\nsimulation.  An dihedral style is assigned to each dihedral type.  For\nexample, dihedrals in a polymer flow (of dihedral type 1) could be\ncomputed with a harmonic potential and dihedrals in the wall\nboundary (of dihedral type 2) could be computed with a helix\npotential.  The assignment of dihedral type to style is made via the\ndihedral_coeff command or in the data file.\nIn the dihedral_coeff commands, the name of a dihedral style must be\nadded after the dihedral type, with the remaining coefficients being\nthose appropriate to that style.  In the example above, the 2\ndihedral_coeff commands set dihedrals of dihedral type 1 to be\ncomputed with a harmonic potential with coefficients 6.0, 1, 3 for\nK, d, n.  All other dihedral types (2-N) are computed with a helix\npotential with coefficients 10, 10, 10 for A, B, C.\nIf dihedral coefficients are specified in the data file read via the\nread_data command, then the same rule applies.\nE.g. “harmonic” or “helix”, must be added after the dihedral type, for\neach line in the “Dihedral Coeffs” section, e.g.\nDihedral Coeffs\n\n1 harmonic 6.0 1 3\n2 helix 10 10 10\n...\n\n\nIf class2 is one of the dihedral hybrid styles, the same rule holds\nfor specifying additional AngleTorsion (and EndBondTorsion, etc)\ncoefficients either via the input script or in the data file.\nI.e. class2 must be added to each line after the dihedral type.  For\nlines in the AngleTorsion (or EndBondTorsion, etc) section of the data\nfile for dihedral types that are not class2, you must use an\ndihedral style of skip as a placeholder, e.g.\nAngleTorsion Coeffs\n\n1 skip\n2 class2 1.0 1.0 1.0 3.0 3.0 3.0 30.0 50.0\n...\n\n\nNote that it is not necessary to use the dihedral style skip in the\ninput script, since AngleTorsion (or EndBondTorsion, etc) coefficients\nneed not be specified at all for dihedral types that are not class2.\nA dihedral style of none with no additional coefficients can be used\nin place of a dihedral style, either in a input script dihedral_coeff\ncommand or in the data file, if you desire to turn off interactions\nfor specific dihedral types.",
    "syntax": "dihedral_style hybrid style1 style2 ...",
    "parameters": " * style1,style2 = list of one or more dihedral styles",
    "examples": "dihedral_style hybrid harmonic helix\ndihedral_coeff 1 harmonic 6.0 1 3\ndihedral_coeff 2* helix 10 10 10",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info.\nUnlike other dihedral styles, the hybrid dihedral style does not store\ndihedral coefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a\nrestart file, you need to re-specify dihedral_coeff commands."
},
{
    "command": "dihedral_style multi/harmonic",
    "html_filename": "dihedral_multi_harmonic.html",
    "short_description": "The multi/harmonic dihedral style uses the potential  \\[E = \\sum_{n=1,5} A_n  \\cos^{n-1}(\\phi)\\] The following coefficients must be defined for each dihedral type via the dihedral_coeff command as in the example above, or in the data file or restart files read by the read_data or read_restart commands:  \\(A_1\\) (energy) \\(A_2\\) (energy) \\(A_3\\) (energy) \\(A_4\\) (energy) \\(A_5\\) (energy)   Styles with a gpu, intel, kk, omp, or opt suffix are functionally the same as the corresponding style without the suffix",
    "description": "The multi/harmonic dihedral style uses the potential\n\n\\[E = \\sum_{n=1,5} A_n  \\cos^{n-1}(\\phi)\\]\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(A_1\\) (energy)\n\\(A_2\\) (energy)\n\\(A_3\\) (energy)\n\\(A_4\\) (energy)\n\\(A_5\\) (energy)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style multi/harmonic",
    "parameters": " * ",
    "examples": "dihedral_style multi/harmonic\ndihedral_coeff 1 20 20 20 20 20",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "dihedral_style nharmonic",
    "html_filename": "dihedral_nharmonic.html",
    "short_description": "The nharmonic dihedral style uses the potential:  \\[E = \\sum_{n=1,n} A_n  \\cos^{n-1}(\\phi)\\] The following coefficients must be defined for each dihedral type via the dihedral_coeff command as in the example above, or in the data file or restart files read by the read_data or read_restart commands:  \\(n\\) (integer >=1) \\(A_1\\) (energy) \\(A_2\\) (energy) … \\(A_n\\) (energy)   Styles with a gpu, intel, kk, omp, or opt suffix are functionally the same as the corresponding style without the suffix",
    "description": "The nharmonic dihedral style uses the potential:\n\n\\[E = \\sum_{n=1,n} A_n  \\cos^{n-1}(\\phi)\\]\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(n\\) (integer >=1)\n\\(A_1\\) (energy)\n\\(A_2\\) (energy)\n…\n\\(A_n\\) (energy)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style nharmonic",
    "parameters": " * ",
    "examples": "dihedral_style nharmonic\ndihedral_coeff * 3 10.0 20.0 30.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style none",
    "html_filename": "dihedral_none.html",
    "short_description": "Using a dihedral style of none means dihedral forces and energies are not computed, even if quadruplets of dihedral atoms were listed in the data file read by the read_data command",
    "description": "Using a dihedral style of none means dihedral forces and energies are\nnot computed, even if quadruplets of dihedral atoms were listed in the\ndata file read by the read_data command.\nSee the dihedral_style zero command for a way to\ncalculate dihedral statistics, but compute no dihedral interactions.",
    "syntax": "dihedral_style none",
    "parameters": " * ",
    "examples": "dihedral_style none",
    "restrictions": "\nnone"
},
{
    "command": "dihedral_style opls",
    "html_filename": "dihedral_opls.html",
    "short_description": "The opls dihedral style uses the potential  \\[\\begin{split}E = & \\frac{1}{2} K_1 [1 + \\cos(\\phi)] + \\frac{1}{2} K_2 [1 - \\cos(2 \\phi)] + \\\\     & \\frac{1}{2} K_3 [1 + \\cos(3 \\phi)] + \\frac{1}{2} K_4 [1 - \\cos(4 \\phi)]\\end{split}\\] Note that the usual 1/2 factor is not included in the K values",
    "description": "The opls dihedral style uses the potential\n\n\\[\\begin{split}E = & \\frac{1}{2} K_1 [1 + \\cos(\\phi)] + \\frac{1}{2} K_2 [1 - \\cos(2 \\phi)] + \\\\\n    & \\frac{1}{2} K_3 [1 + \\cos(3 \\phi)] + \\frac{1}{2} K_4 [1 - \\cos(4 \\phi)]\\end{split}\\]\nNote that the usual 1/2 factor is not included in the K values.\nThis dihedral potential is used in the OPLS force field and is\ndescribed in (Watkins).\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K_1\\) (energy)\n\\(K_2\\) (energy)\n\\(K_3\\) (energy)\n\\(K_4\\) (energy)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style opls",
    "parameters": " * ",
    "examples": "dihedral_style opls\ndihedral_coeff 1 1.740 -0.157 0.279 0.00   # CT-CT-CT-CT\ndihedral_coeff 2 0.000 0.000 0.366 0.000   # CT-CT-CT-HC\ndihedral_coeff 3 0.000 0.000 0.318 0.000   # HC-CT-CT-HC",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "dihedral_style quadratic",
    "html_filename": "dihedral_quadratic.html",
    "short_description": "The quadratic dihedral style uses the potential:  \\[E = K (\\phi - \\phi_0)^2\\] This dihedral potential can be used to keep a dihedral in a predefined value (cis=zero, right-hand convention is used)",
    "description": "The quadratic dihedral style uses the potential:\n\n\\[E = K (\\phi - \\phi_0)^2\\]\nThis dihedral potential can be used to keep a dihedral in a predefined\nvalue (cis=zero, right-hand convention is used).\nThe following coefficients must be defined for each dihedral type via\nthe dihedral_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy/radian^2)\n\\(\\phi_0\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "dihedral_style quadratic",
    "parameters": " * ",
    "examples": "dihedral_style quadratic\ndihedral_coeff 100.0 80.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style",
    "html_filename": "dihedral_style.html",
    "short_description": "Set the formula(s) LAMMPS uses to compute dihedral interactions between quadruplets of atoms, which remain in force for the duration of the simulation",
    "description": "Set the formula(s) LAMMPS uses to compute dihedral interactions\nbetween quadruplets of atoms, which remain in force for the duration\nof the simulation.  The list of dihedral quadruplets is read in by a\nread_data or read_restart command\nfrom a data or restart file.\nHybrid models where dihedrals are computed using different dihedral\npotentials can be setup using the hybrid dihedral style.\nThe coefficients associated with a dihedral style can be specified in\na data or restart file or via the dihedral_coeff\ncommand.\nAll dihedral potentials store their coefficient data in binary restart\nfiles which means dihedral_style and\ndihedral_coeff commands do not need to be\nre-specified in an input script that restarts a simulation.  See the\nread_restart command for details on how to do\nthis.  The one exception is that dihedral_style hybrid only stores\nthe list of sub-styles in the restart file; dihedral coefficients need\nto be re-specified.\n\nNote\nWhen both a dihedral and pair style is defined, the\nspecial_bonds command often needs to be used to\nturn off (or weight) the pairwise interaction that would otherwise\nexist between 4 bonded atoms.\n\nIn the formulas listed for each dihedral style, phi is the torsional\nangle defined by the quadruplet of atoms.  This angle has a sign\nconvention as shown in this diagram:\n\nwhere the I,J,K,L ordering of the 4 atoms that define the dihedral\nis from left to right.\nThis sign convention effects several of the dihedral styles listed\nbelow (e.g. charmm, helix) in the sense that the energy formula\ndepends on the sign of phi, which may be reflected in the value of the\ncoefficients you specify.\n\nNote\nWhen comparing the formulas and coefficients for various LAMMPS\ndihedral styles with dihedral equations defined by other force fields,\nnote that some force field implementations divide/multiply the energy\nprefactor K by the multiple number of torsions that contain the J-K\nbond in an I-J-K-L torsion.  LAMMPS does not do this, i.e. the listed\ndihedral equation applies to each individual dihedral.  Thus you need\nto define K appropriately via the\ndihedral_coeff command to account for this\ndifference if necessary.\n\n\nHere is an alphabetic list of dihedral styles defined in LAMMPS.  Click on\nthe style to display the formula it computes and coefficients\nspecified by the associated dihedral_coeff command.\nClick on the style to display the formula it computes, any additional\narguments specified in the dihedral_style command, and coefficients\nspecified by the associated dihedral_coeff\ncommand.\nThere are also additional accelerated pair styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands dihedral doc page are followed by one or\nmore of (g,i,k,o,t) to indicate which accelerated styles exist.\n\nnone - turn off dihedral interactions\nzero - topology but no interactions\nhybrid - define multiple styles of dihedral interactions\ncharmm - CHARMM dihedral\ncharmmfsw - CHARMM dihedral with force switching\nclass2 - COMPASS (class 2) dihedral\ncosine/shift/exp - dihedral with exponential in spring constant\nfourier - dihedral with multiple cosine terms\nharmonic - harmonic dihedral\nhelix - helix dihedral\nmulti/harmonic - dihedral with 5 harmonic terms\nnharmonic - same as multi-harmonic with N terms\nopls - OPLS dihedral\nquadratic - dihedral with quadratic term in angle\nspherical - dihedral which includes angle terms to avoid singularities\ntable - tabulated dihedral\ntable/cut - tabulated dihedral with analytic cutoff",
    "syntax": "dihedral_style style",
    "parameters": " * style = none or hybrid or charmm or class2 or harmonic or helix or         multi/harmonic or opls",
    "examples": "dihedral_style harmonic\ndihedral_style multi/harmonic\ndihedral_style hybrid harmonic charmm",
    "restrictions": "Dihedral styles can only be set for atom styles that allow dihedrals\nto be defined.\nMost dihedral styles are part of the MOLECULE package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual dihedral potentials tell if it is part of a package."
},
{
    "command": "dihedral_style table",
    "html_filename": "dihedral_table.html",
    "short_description": "The table dihedral style creates interpolation tables of length Ntable from dihedral potential and derivative values listed in a file(s) as a function of the dihedral angle “phi”",
    "description": "The table dihedral style creates interpolation tables of length\nNtable from dihedral potential and derivative values listed in a\nfile(s) as a function of the dihedral angle “phi”.  The files are read\nby the dihedral_coeff command.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy and derivative values at each of\nNtable dihedral angles. During a simulation, these tables are used\nto interpolate energy and force values on individual atoms as\nneeded. The interpolation is done in one of 2 styles: linear or\nspline.\nFor the linear style, the dihedral angle (phi) is used to find 2\nsurrounding table values from which an energy or its derivative is\ncomputed by linear interpolation.\nFor the spline style, cubic spline coefficients are computed and\nstored at each of the Ntable evenly-spaced values in the\ninterpolated table.  For a given dihedral angle (phi), the appropriate\ncoefficients are chosen from this list, and a cubic polynomial is used\nto compute the energy and the derivative at this angle.\nThe following coefficients must be defined for each dihedral type via\nthe dihedral_coeff command as in the example\nabove.\n\nfilename\nkeyword\n\nThe filename specifies a file containing tabulated energy and\nderivative values. The keyword specifies a section of the file.  The\nformat of this file is described below.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments).  It can begin with one or more comment\nor blank lines.\n# Table of the potential and its negative derivative\n\nDIH_TABLE1                   (keyword is the first text on line)\nN 30 DEGREES                 (N, NOF, DEGREES, RADIANS, CHECKU/F)\n                             (blank line)\n1 -168.0 -1.40351172223 0.0423346818422\n2 -156.0 -1.70447981034 0.00811786522531\n3 -144.0 -1.62956100432 -0.0184129719987\n...\n30 180.0 -0.707106781187 0.0719306095245\n\n# Example 2: table of the potential. Forces omitted\n\nDIH_TABLE2\nN 30 NOF CHECKU testU.dat CHECKF testF.dat\n\n1 -168.0 -1.40351172223\n2 -156.0 -1.70447981034\n3 -144.0 -1.62956100432\n...\n30 180.0 -0.707106781187\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections. The first line begins with a keyword which\nidentifies the section. The line can contain additional text, but the\ninitial text must match the argument specified in the\ndihedral_coeff command. The next line lists (in\nany order) one or more parameters for the table. Each parameter is a\nkeyword followed by one or more numeric values.\nFollowing a blank line, the next N lines list the tabulated values. On\neach line, the 1st value is the index from 1 to N, the 2nd value is\nthe angle value, the 3rd value is the energy (in energy units), and\nthe 4th is -dE/d(phi) also in energy units). The 3rd term is the\nenergy of the 4-atom configuration for the specified angle.  The 4th\nterm (when present) is the negative derivative of the energy with\nrespect to the angle (in degrees, or radians depending on whether the\nuser selected DEGREES or RADIANS).  Thus the units of the last term\nare still energy, not force. The dihedral angle values must increase\nfrom one line to the next.\nDihedral table splines are cyclic.  There is no discontinuity at 180\ndegrees (or at any other angle).  Although in the examples above, the\nangles range from -180 to 180 degrees, in general, the first angle in\nthe list can have any value (positive, zero, or negative).  However\nthe range of angles represented in the table must be strictly less\nthan 360 degrees (2pi radians) to avoid angle overlap.  (You may not\nsupply entries in the table for both 180 and -180, for example.)  If\nthe user’s table covers only a narrow range of dihedral angles,\nstrange numerical behavior can occur in the large remaining gap.\nParameters:\nThe parameter “N” is required and its value is the number of table\nentries that follow. Note that this may be different than the N\nspecified in the dihedral_style table command.\nLet Ntable is the number of table entries requested dihedral_style\ncommand, and let Nfile be the parameter following “N” in the\ntabulated file (“30” in the sparse example above).  What LAMMPS does\nis a preliminary interpolation by creating splines using the Nfile\ntabulated values as nodal points.  It uses these to interpolate as\nneeded to generate energy and derivative values at Ntable different\npoints (which are evenly spaced over a 360 degree range, even if the\nangles in the file are not).  The resulting tables of length Ntable\nare then used as described above, when computing energy and force for\nindividual dihedral angles and their atoms.  This means that if you\nwant the interpolation tables of length Ntable to match exactly what\nis in the tabulated file (with effectively nopreliminary\ninterpolation), you should set Ntable = Nfile.  To insure the\nnodal points in the user’s file are aligned with the interpolated\ntable entries, the angles in the table should be integer multiples of\n360/Ntable degrees, or 2*PI/Ntable radians (depending on your\nchoice of angle units).\nThe optional “NOF” keyword allows the user to omit the forces\n(negative energy derivatives) from the table file (normally located in\nthe 4th column).  In their place, forces will be calculated\nautomatically by differentiating the potential energy function\nindicated by the 3rd column of the table (using either linear or\nspline interpolation).\nThe optional “DEGREES” keyword allows the user to specify angles in\ndegrees instead of radians (default).\nThe optional “RADIANS” keyword allows the user to specify angles in\nradians instead of degrees.  (Note: This changes the way the forces\nare scaled in the 4th column of the data file.)\nThe optional “CHECKU” keyword is followed by a filename.  This allows\nthe user to save all of the Ntable different entries in the\ninterpolated energy table to a file to make sure that the interpolated\nfunction agrees with the user’s expectations.  (Note: You can\ntemporarily increase the Ntable parameter to a high value for this\npurpose.  “Ntable” is explained above.)\nThe optional “CHECKF” keyword is analogous to the “CHECKU” keyword.\nIt is followed by a filename, and it allows the user to check the\ninterpolated force table.  This option is available even if the user\nselected the “NOF” option.\nNote that one file can contain many sections, each with a tabulated\npotential. LAMMPS reads the file section by section until it finds one\nthat matches the specified keyword.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart info:\nThis dihedral style writes the settings for the “dihedral_style table”\ncommand to binary restart files, so a dihedral_style\ncommand does not need to specified in an input script that reads a\nrestart file.  However, the coefficient information is not stored in\nthe restart file, since it is tabulated in the potential files.  Thus,\ndihedral_coeff commands do need to be specified in the restart input\nscript.",
    "syntax": "dihedral_style table style Ntable",
    "parameters": " * style = linear or spline = method of interpolation\n * Ntable = size of the internal lookup table",
    "examples": "dihedral_style table spline 400\ndihedral_style table linear 1000\ndihedral_coeff 1 file.table DIH_TABLE1\ndihedral_coeff 2 file.table DIH_TABLE2",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style table/cut",
    "html_filename": "dihedral_table_cut.html",
    "short_description": "The table/cut dihedral style creates interpolation tables of length Ntable from dihedral potential and derivative values listed in a file(s) as a function of the dihedral angle “phi”",
    "description": "The table/cut dihedral style creates interpolation tables of length\nNtable from dihedral potential and derivative values listed in a\nfile(s) as a function of the dihedral angle “phi”.  In addition, an\nanalytic cutoff that is quadratic in the bond-angle (theta) is applied\nin order to regularize the dihedral interaction.  The dihedral table\nfiles are read by the dihedral_coeff command.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy and derivative values at each of\nNtable dihedral angles. During a simulation, these tables are used\nto interpolate energy and force values on individual atoms as\nneeded. The interpolation is done in one of 2 styles: linear or\nspline.\nFor the linear style, the dihedral angle (phi) is used to find 2\nsurrounding table values from which an energy or its derivative is\ncomputed by linear interpolation.\nFor the spline style, cubic spline coefficients are computed and\nstored at each of the Ntable evenly-spaced values in the\ninterpolated table.  For a given dihedral angle (phi), the appropriate\ncoefficients are chosen from this list, and a cubic polynomial is used\nto compute the energy and the derivative at this angle.\nThe following coefficients must be defined for each dihedral type via\nthe dihedral_coeff command as in the example\nabove.\n\nstyle (aat)\ncutoff prefactor\ncutoff angle1\ncutoff angle2\nfilename\nkeyword\n\nThe cutoff dihedral style uses a tabulated dihedral interaction with a\ncutoff function:\n\n\\[\\begin{split}f(\\theta) & = K \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\theta < \\theta_1 \\\\\nf(\\theta) & = K \\left(1-\\frac{(\\theta - \\theta_1)^2}{(\\theta_2 - \\theta_1)^2}\\right) \\qquad \\theta_1 < \\theta < \\theta_2\\end{split}\\]\nThe cutoff specifies an prefactor to the cutoff function.  While this value\nwould ordinarily equal 1 there may be situations where the value should change.\nThe cutoff \\(\\theta_1\\) specifies the angle (in degrees) below which the dihedral\ninteraction is unmodified, i.e. the cutoff function is 1.\nThe cutoff function is applied between \\(\\theta_1\\) and \\(\\theta_2\\), which is\nthe angle at which the cutoff function drops to zero.  The value of zero effectively\n“turns off” the dihedral interaction.\nThe filename specifies a file containing tabulated energy and\nderivative values. The keyword specifies a section of the file.  The\nformat of this file is described below.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments).  It can begin with one or more comment\nor blank lines.\n# Table of the potential and its negative derivative\n\nDIH_TABLE1                   (keyword is the first text on line)\nN 30 DEGREES                 (N, NOF, DEGREES, RADIANS, CHECKU/F)\n                             (blank line)\n1 -168.0 -1.40351172223 0.0423346818422\n2 -156.0 -1.70447981034 0.00811786522531\n3 -144.0 -1.62956100432 -0.0184129719987\n...\n30 180.0 -0.707106781187 0.0719306095245\n\n# Example 2: table of the potential. Forces omitted\n\nDIH_TABLE2\nN 30 NOF CHECKU testU.dat CHECKF testF.dat\n\n1 -168.0 -1.40351172223\n2 -156.0 -1.70447981034\n3 -144.0 -1.62956100432\n...\n30 180.0 -0.707106781187\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections. The first line begins with a keyword which\nidentifies the section. The line can contain additional text, but the\ninitial text must match the argument specified in the\ndihedral_coeff command. The next line lists (in\nany order) one or more parameters for the table. Each parameter is a\nkeyword followed by one or more numeric values.\nFollowing a blank line, the next N lines list the tabulated values. On\neach line, the 1st value is the index from 1 to N, the 2nd value is\nthe angle value, the 3rd value is the energy (in energy units), and\nthe 4th is -dE/d(phi) also in energy units). The 3rd term is the\nenergy of the 4-atom configuration for the specified angle.  The 4th\nterm (when present) is the negative derivative of the energy with\nrespect to the angle (in degrees, or radians depending on whether the\nuser selected DEGREES or RADIANS).  Thus the units of the last term\nare still energy, not force. The dihedral angle values must increase\nfrom one line to the next.\nDihedral table splines are cyclic.  There is no discontinuity at 180\ndegrees (or at any other angle).  Although in the examples above, the\nangles range from -180 to 180 degrees, in general, the first angle in\nthe list can have any value (positive, zero, or negative).  However\nthe range of angles represented in the table must be strictly less\nthan 360 degrees (2pi radians) to avoid angle overlap.  (You may not\nsupply entries in the table for both 180 and -180, for example.)  If\nthe user’s table covers only a narrow range of dihedral angles,\nstrange numerical behavior can occur in the large remaining gap.\nParameters:\nThe parameter “N” is required and its value is the number of table\nentries that follow. Note that this may be different than the N\nspecified in the dihedral_style table command.\nLet Ntable is the number of table entries requested dihedral_style\ncommand, and let Nfile be the parameter following “N” in the\ntabulated file (“30” in the sparse example above).  What LAMMPS does\nis a preliminary interpolation by creating splines using the Nfile\ntabulated values as nodal points.  It uses these to interpolate as\nneeded to generate energy and derivative values at Ntable different\npoints (which are evenly spaced over a 360 degree range, even if the\nangles in the file are not).  The resulting tables of length Ntable\nare then used as described above, when computing energy and force for\nindividual dihedral angles and their atoms.  This means that if you\nwant the interpolation tables of length Ntable to match exactly what\nis in the tabulated file (with effectively nopreliminary\ninterpolation), you should set Ntable = Nfile.  To insure the\nnodal points in the user’s file are aligned with the interpolated\ntable entries, the angles in the table should be integer multiples of\n360/Ntable degrees, or 2*PI/Ntable radians (depending on your\nchoice of angle units).\nThe optional “NOF” keyword allows the user to omit the forces\n(negative energy derivatives) from the table file (normally located in\nthe 4th column).  In their place, forces will be calculated\nautomatically by differentiating the potential energy function\nindicated by the 3rd column of the table (using either linear or\nspline interpolation).\nThe optional “DEGREES” keyword allows the user to specify angles in\ndegrees instead of radians (default).\nThe optional “RADIANS” keyword allows the user to specify angles in\nradians instead of degrees.  (Note: This changes the way the forces\nare scaled in the 4th column of the data file.)\nThe optional “CHECKU” keyword is followed by a filename.  This allows\nthe user to save all of the Ntable different entries in the\ninterpolated energy table to a file to make sure that the interpolated\nfunction agrees with the user’s expectations.  (Note: You can\ntemporarily increase the Ntable parameter to a high value for this\npurpose.  “Ntable” is explained above.)\nThe optional “CHECKF” keyword is analogous to the “CHECKU” keyword.\nIt is followed by a filename, and it allows the user to check the\ninterpolated force table.  This option is available even if the user\nselected the “NOF” option.\nNote that one file can contain many sections, each with a tabulated\npotential. LAMMPS reads the file section by section until it finds one\nthat matches the specified keyword.\nRestart info:\nThis dihedral style writes the settings for the “dihedral_style table/cut”\ncommand to binary restart files, so a dihedral_style\ncommand does not need to specified in an input script that reads a\nrestart file.  However, the coefficient information is not stored in\nthe restart file, since it is tabulated in the potential files.  Thus,\ndihedral_coeff commands do need to be specified in the restart input\nscript.",
    "syntax": "dihedral_style table/cut style Ntable",
    "parameters": " * style = linear or spline = method of interpolation\n * Ntable = size of the internal lookup table",
    "examples": "dihedral_style table/cut spline 400\ndihedral_style table/cut linear 1000\ndihedral_coeff 1 aat 1.0 177 180 file.table DIH_TABLE1\ndihedral_coeff 2 aat 0.5 170 180 file.table DIH_TABLE2",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "dihedral_style zero",
    "html_filename": "dihedral_zero.html",
    "short_description": "Using a dihedral style of zero means dihedral forces and energies are not computed, but the geometry of dihedral quadruplets is still accessible to other commands",
    "description": "Using a dihedral style of zero means dihedral forces and energies are\nnot computed, but the geometry of dihedral quadruplets is still\naccessible to other commands.\nAs an example, the compute dihedral/local command can be used to\ncompute the theta values for the list of quadruplets of dihedral atoms\nlisted in the data file read by the read_data\ncommand.  If no dihedral style is defined, this command cannot be\nused.\nThe optional nocoeff flag allows to read data files with a DihedralCoeff\nsection for any dihedral style. Similarly, any dihedral_coeff commands\nwill only be checked for the dihedral type number and the rest ignored.\nNote that the dihedral_coeff command must be\nused for all dihedral types, though no additional values are\nspecified.",
    "syntax": "dihedral_style zero [nocoeff]",
    "parameters": " * ",
    "examples": "dihedral_style zero\ndihedral_style zero nocoeff\ndihedral_coeff *",
    "restrictions": "\nnone\n\nRelated commands: none\ndihedral_style none\nDefault: none"
},
{
    "command": "fix adapt",
    "html_filename": "fix_adapt.html",
    "short_description": "Change or adapt one or more specific simulation attributes or settings over time as a simulation runs",
    "description": "Change or adapt one or more specific simulation attributes or settings\nover time as a simulation runs.  Pair potential and K-space and atom\nattributes which can be varied by this fix are discussed below.  Many\nother fixes can also be used to time-vary simulation parameters,\ne.g. the “fix deform” command will change the simulation box\nsize/shape and the “fix move” command will change atom positions and\nvelocities in a prescribed manner.  Also note that many commands allow\nvariables as arguments for specific parameters, if described in that\nmanner on their doc pages.  An equal-style variable can calculate a\ntime-dependent quantity, so this is another way to vary a simulation\nparameter over time.\nIf N is specified as 0, the specified attributes are only changed\nonce, before the simulation begins.  This is all that is needed if the\nassociated variables are not time-dependent.  If N > 0, then changes\nare made every N steps during the simulation, presumably with a\nvariable that is time-dependent.\nDepending on the value of the reset keyword, attributes changed by\nthis fix will or will not be reset back to their original values at\nthe end of a simulation.  Even if reset is specified as yes, a\nrestart file written during a simulation will contain the modified\nsettings.\nIf the scale keyword is set to no, then the value the parameter is\nset to will be whatever the variable generates.  If the scale\nkeyword is set to yes, then the value of the altered parameter will\nbe the initial value of that parameter multiplied by whatever the\nvariable generates.  I.e. the variable is now a “scale factor” applied\nin (presumably) a time-varying fashion to the parameter.\nNote that whether scale is no or yes, internally, the parameters\nthemselves are actually altered by this fix.  Make sure you use the\nreset yes option if you want the parameters to be restored to their\ninitial values after the run.\n\nThe pair keyword enables various parameters of potentials defined by\nthe pair_style command to be changed, if the pair\nstyle supports it.  Note that the pair_style and\npair_coeff commands must be used in the usual manner\nto specify these parameters initially; the fix adapt command simply\noverrides the parameters.\nThe pstyle argument is the name of the pair style.  If pair_style hybrid or hybrid/overlay is used, pstyle should be\na sub-style name.  If there are multiple sub-styles using the same\npair style, then pstyle should be specified as “style:N” where N is\nwhich instance of the pair style you wish to adapt, e.g. the first,\nsecond, etc.  For example, pstyle could be specified as “soft” or\n“lubricate” or “lj/cut:1” or “lj/cut:2”.  The pparam argument is the\nname of the parameter to change.  This is the current list of pair\nstyles and parameters that can be varied by this fix.  See the doc\npages for individual pair styles and their energy formulas for the\nmeaning of these parameters:\n\n\n\n\n\n\n\nborn\na,b,c\ntype pairs\n\nborn/coul/long, born/coul/msm\ncoulombic_cutoff\ntype global\n\nbuck\na,c\ntype pairs\n\nbuck/coul/long, buck/coul/msm\ncoulombic_cutoff\ntype global\n\nbuck/mdf\na,c\ntype pairs\n\ncoul/cut\nscale\ntype pairs\n\ncoul/cut/soft\nlambda\ntype pairs\n\ncoul/debye\nscale\ntype pairs\n\ncoul/dsf\ncoulombic_cutoff\ntype global\n\ncoul/long, coul/msm\ncoulombic_cutoff, scale\ntype pairs\n\ncoul/long/soft\nscale, lambda, coulombic_cutoff\ntype pairs\n\neam, eam/alloy, eam/fs\nscale\ntype pairs\n\ngauss\na\ntype pairs\n\nlennard/mdf\nA,B\ntype pairs\n\nlj/class2\nepsilon,sigma\ntype pairs\n\nlj/class2/coul/cut, lj/class2/coul/long\nepsilon,sigma,coulombic_cutoff\ntype pairs\n\nlj/cut\nepsilon,sigma\ntype pairs\n\nlj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\nepsilon,sigma,coulombic_cutoff\ntype pairs\n\nlj/cut/coul/cut/soft, lj/cut/coul/long/soft\nepsilon,sigma,lambda,coulombic_cutoff\ntype pairs\n\nlj/cut/coul/dsf\ncutoff\ntype global\n\nlj/cut/tip4p/cut\nepsilon,sigma,coulombic_cutoff\ntype pairs\n\nlj/cut/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/expand\nepsilon,sigma,delta\ntype pairs\n\nlj/mdf\nepsilon,sigma\ntype pairs\n\nlj/sf/dipole/sf\nepsilon,sigma,scale\ntype pairs\n\nlubricate\nmu\nglobal\n\nmie/cut\nepsilon,sigma,gamma_repulsive,gamma_attractive\ntype pairs\n\nmorse, morse/smooth/linear\nD0,R0,alpha\ntype pairs\n\nmorse/soft\nD0,R0,alpha,lambda\ntype pairs\n\nnm/cut\nE0,R0,m,n\ntype pairs\n\nnm/cut/coul/cut, nm/cut/coul/long\nE0,R0,m,n,coulombic_cutoff\ntype pairs\n\nreax/c\nchi, eta, gamma\ntype global\n\nspin/dmi\ncoulombic_cutoff\ntype global\n\nspin/exchange\ncoulombic_cutoff\ntype global\n\nspin/magelec\ncoulombic_cutoff\ntype global\n\nspin/neel\ncoulombic_cutoff\ntype global\n\ntable\ntable_cutoff\ntype pairs\n\nufm\nepsilon,sigma\ntype pairs\n\nsoft\na\ntype pairs\n\n\n\n\n\n\n\n\nNote\nIt is easy to add new pairwise potentials and their parameters\nto this list.  All it typically takes is adding an extract() method to\nthe pair_*.cpp file associated with the potential.\n\nSome parameters are global settings for the pair style, e.g. the\nviscosity setting “mu” for pair_style lubricate.\nOther parameters apply to atom type pairs within the pair style,\ne.g. the prefactor “a” for pair_style soft.\nNote that for many of the potentials, the parameter that can be varied\nis effectively a prefactor on the entire energy expression for the\npotential, e.g. the lj/cut epsilon.  The parameters listed as “scale”\nare exactly that, since the energy expression for the\ncoul/cut potential (for example) has no labeled\nprefactor in its formula.  To apply an effective prefactor to some\npotentials, multiple parameters need to be altered.  For example, the\nBuckingham potential needs both the A and C terms\naltered together.  To scale the Buckingham potential, you should thus\nlist the pair style twice, once for A and once for C.\nIf a type pair parameter is specified, the I and J settings should\nbe specified to indicate which type pairs to apply it to.  If a global\nparameter is specified, the I and J settings still need to be\nspecified, but are ignored.\nSimilar to the pair_coeff command, I and J can be\nspecified in one of two ways.  Explicit numeric values can be used for\neach, as in the 1st example above.  I <= J is required.  LAMMPS sets\nthe coefficients for the symmetric J,I interaction to the same values.\nA wild-card asterisk can be used in place of or in conjunction with\nthe I,J arguments to set the coefficients for multiple pairs of atom\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).  Note that only type pairs with I <= J are considered; if\nasterisks imply type pairs where J < I, they are ignored.\nIMPROTANT NOTE: If pair_style hybrid or hybrid/overlay is being used, then the pstyle will\nbe a sub-style name.  You must specify I,J arguments that correspond\nto type pair values defined (via the pair_coeff\ncommand) for that sub-style.\nThe v_name argument for keyword pair is the name of an\nequal-style variable which will be evaluated each time\nthis fix is invoked to set the parameter to a new value.  It should be\nspecified as v_name, where name is the variable name.  Equal-style\nvariables can specify formulas with various mathematical functions,\nand include thermo_style command keywords for the\nsimulation box parameters and timestep and elapsed time.  Thus it is\neasy to specify parameters that change as a function of time or span\nconsecutive runs in a continuous fashion.  For the latter, see the\nstart and stop keywords of the run command and the\nelaplong keyword of thermo_style custom for\ndetails.\nFor example, these commands would change the prefactor coefficient of\nthe pair_style soft potential from 10.0 to 30.0 in a\nlinear fashion over the course of a simulation:\nvariable prefactor equal ramp(10,30)\nfix 1 all adapt 1 pair soft a * * v_prefactor\n\nThe bond keyword uses the specified variable to change the value of\na bond coefficient over time, very similar to how the pair keyword\noperates. The only difference is that now a bond coefficient for a\ngiven bond type is adapted.\nA wild-card asterisk can be used in place of or in conjunction with\nthe bond type argument to set the coefficients for multiple bond types.\nThis takes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\natom types, then an asterisk with no numeric values means all types\nfrom 1 to N.  A leading asterisk means all types from 1 to n (inclusive).\nA trailing asterisk means all types from n to N (inclusive).  A middle\nasterisk means all types from m to n (inclusive).\nCurrently bond does not support bond_style hybrid nor bond_style\nhybrid/overlay as bond styles. The only bonds that currently are\nworking with fix_adapt are\n\n\n\n\n\n\n\ngromos\nk, r0\ntype bonds\n\nharmonic\nk,r0\ntype bonds\n\n\n\n\nThe kspace keyword used the specified variable as a scale factor on\nthe energy, forces, virial calculated by whatever K-Space solver is\ndefined by the kspace_style command.  If the\nvariable has a value of 1.0, then the solver is unaltered.\nThe kspace keyword works this way whether the scale keyword\nis set to no or yes.\n\nThe atom keyword enables various atom properties to be changed.  The\naparam argument is the name of the parameter to change.  This is the\ncurrent list of atom parameters that can be varied by this fix:\n\ncharge = charge on particle\ndiameter = diameter of particle\n\nThe v_name argument of the atom keyword is the name of an\nequal-style variable which will be evaluated each time\nthis fix is invoked to set the parameter to a new value.  It should be\nspecified as v_name, where name is the variable name.  See the\ndiscussion above describing the formulas associated with equal-style\nvariables.  The new value is assigned to the corresponding attribute\nfor all atoms in the fix group.\n\nNote\nThe atom keyword works this way whether the scale keyword is\nset to no or yes.  I.e. the use of scale yes is not yet supported\nby the atom keyword.\n\nIf the atom parameter is diameter and per-atom density and per-atom\nmass are defined for particles (e.g. atom_style granular), then the mass of each particle is also\nchanged when the diameter changes (density is assumed to stay\nconstant).\nFor example, these commands would shrink the diameter of all granular\nparticles in the “center” group from 1.0 to 0.1 in a linear fashion\nover the course of a 1000-step simulation:\nvariable size equal ramp(1.0,0.1)\nfix 1 center adapt 10 atom diameter v_size\n\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\nFor rRESPA time integration, this fix changes\nparameters on the outermost rRESPA level.",
    "syntax": "fix ID group-ID adapt N attribute args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * adapt = style name of this fix command\n * N = adapt simulation settings every this many timesteps\n * one or more attribute/arg pairs may be appended\n * attribute = pair or kspace or atom\n * pair args = pstyle pparam I J v_name\n *   pstyle = pair style name, e.g. lj/cut\n *   pparam = parameter to adapt over time\n *   I,J = type pair(s) to set parameter for\n *   v_name = variable with name that calculates value of pparam\n * bond args = bstyle bparam I v_name\n *   bstyle = bond style name, e.g. harmonic\n *   bparam = parameter to adapt over time\n *   I = type bond to set parameter for\n *   v_name = variable with name that calculates value of bparam\n * kspace arg = v_name\n *   v_name = variable with name that calculates scale factor on K-space terms\n * atom args = aparam v_name\n *   aparam = parameter to adapt over time\n *   v_name = variable with name that calculates value of aparam\n * zero or more keyword/value pairs may be appended\n * keyword = scale or reset\n * scale value = no or yes\n *   no = the variable value is the new setting\n *   yes = the variable value multiplies the original setting\n * reset value = no or yes\n *   no = values will remain altered at the end of a run\n *   yes = reset altered values to their original values at the end of a run",
    "examples": "fix 1 all adapt 1 pair soft a 1 1 v_prefactor\nfix 1 all adapt 1 pair soft a 2* 3 v_prefactor\nfix 1 all adapt 1 pair lj/cut epsilon * * v_scale1 coul/cut scale 3 3 v_scale2 scale yes reset yes\nfix 1 all adapt 10 atom diameter v_size\n\nvariable ramp_up equal \"ramp(0.01,0.5)\"\nfix stretch all adapt 1 bond harmonic r0 1 v_ramp_up",
    "restrictions": "\nnone"
},
{
    "command": "fix adapt/fep",
    "html_filename": "fix_adapt_fep.html",
    "short_description": "Change or adapt one or more specific simulation attributes or settings over time as a simulation runs",
    "description": "Change or adapt one or more specific simulation attributes or settings\nover time as a simulation runs.\nThis is an enhanced version of the fix adapt command\nwith two differences,\n\nIt is possible to modify the charges of chosen atom types only,\ninstead of scaling all the charges in the system.\nThere is a new option after for better compatibility with “fix\nave/time”.\n\nThis version is suited for free energy calculations using\ncompute ti or compute fep.\nIf N is specified as 0, the specified attributes are only changed\nonce, before the simulation begins.  This is all that is needed if the\nassociated variables are not time-dependent.  If N > 0, then changes\nare made every N steps during the simulation, presumably with a\nvariable that is time-dependent.\nDepending on the value of the reset keyword, attributes changed by\nthis fix will or will not be reset back to their original values at\nthe end of a simulation.  Even if reset is specified as yes, a\nrestart file written during a simulation will contain the modified\nsettings.\nIf the scale keyword is set to no, then the value the parameter is\nset to will be whatever the variable generates.  If the scale\nkeyword is set to yes, then the value of the altered parameter will\nbe the initial value of that parameter multiplied by whatever the\nvariable generates.  I.e. the variable is now a “scale factor” applied\nin (presumably) a time-varying fashion to the parameter.  Internally,\nthe parameters themselves are actually altered; make sure you use the\nreset yes option if you want the parameters to be restored to their\ninitial values after the run.\nIf the after keyword is set to yes, then the parameters are\nchanged one timestep after the multiple of N. In this manner, if a fix\nsuch as “fix ave/time” is used to calculate averages at every N\ntimesteps, all the contributions to the average will be obtained with\nthe same values of the parameters.\n\nThe pair keyword enables various parameters of potentials defined by\nthe pair_style command to be changed, if the pair\nstyle supports it.  Note that the pair_style and\npair_coeff commands must be used in the usual manner\nto specify these parameters initially; the fix adapt command simply\noverrides the parameters.\nThe pstyle argument is the name of the pair style.  If pair_style hybrid or hybrid/overlay is used, pstyle should be\na sub-style name.  For example, pstyle could be specified as “soft”\nor “lubricate”.  The pparam argument is the name of the parameter to\nchange.  This is the current list of pair styles and parameters that\ncan be varied by this fix.  See the doc pages for individual pair\nstyles and their energy formulas for the meaning of these parameters:\n\n\n\n\n\n\n\nborn\na,b,c\ntype pairs\n\nbuck\na,c\ntype pairs\n\nbuck/mdf\na,c\ntype pairs\n\ncoul/cut\nscale\ntype pairs\n\ncoul/cut/soft\nlambda\ntype pairs\n\ncoul/long, coul/msm\nscale\ntype pairs\n\ncoul/long/soft\nscale, lambda\ntype pairs\n\neam\nscale\ntype pairs\n\ngauss\na\ntype pairs\n\nlennard/mdf\na,b\ntype pairs\n\nlj/class2\nepsilon,sigma\ntype pairs\n\nlj/class2/coul/cut, lj/class2/coul/long\nepsilon,sigma\ntype pairs\n\nlj/cut\nepsilon,sigma\ntype pairs\n\nlj/cut/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\nepsilon,sigma\ntype pairs\n\nlj/cut/coul/cut/soft, lj/cut/coul/long/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/cut/tip4p/cut, lj/cut/tip4p/long\nepsilon,sigma\ntype pairs\n\nlj/cut/tip4p/long/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/expand\nepsilon,sigma,delta\ntype pairs\n\nlj/mdf\nepsilon,sigma\ntype pairs\n\nlj/sf/dipole/sf\nepsilon,sigma,scale\ntype pairs\n\nmie/cut\nepsilon,sigma,gamR,gamA\ntype pairs\n\nmorse, morse/smooth/linear\nd0,r0,alpha\ntype pairs\n\nmorse/soft\nd0,r0,alpha,lambda\ntype pairs\n\nnm/cut\ne0,r0,nn,mm\ntype pairs\n\nnm/cut/coul/cut, nm/cut/coul/long\ne0,r0,nn,mm\ntype pairs\n\nufm\nepsilon,sigma,scale\ntype pairs\n\nsoft\na\ntype pairs\n\n\n\n\nNote\nIt is easy to add new potentials and their parameters to this\nlist.  All it typically takes is adding an extract() method to the\npair_*.cpp file associated with the potential.\n\nNote that for many of the potentials, the parameter that can be varied\nis effectively a prefactor on the entire energy expression for the\npotential, e.g. the lj/cut epsilon.  The parameters listed as “scale”\nare exactly that, since the energy expression for the\ncoul/cut potential (for example) has no labeled\nprefactor in its formula.  To apply an effective prefactor to some\npotentials, multiple parameters need to be altered.  For example, the\nBuckingham potential needs both the A and C terms\naltered together.  To scale the Buckingham potential, you should thus\nlist the pair style twice, once for A and once for C.\nIf a type pair parameter is specified, the I and J settings should\nbe specified to indicate which type pairs to apply it to.  If a global\nparameter is specified, the I and J settings still need to be\nspecified, but are ignored.\nSimilar to the pair_coeff command, I and J can be\nspecified in one of two ways.  Explicit numeric values can be used for\neach, as in the 1st example above.  I <= J is required.  LAMMPS sets\nthe coefficients for the symmetric J,I interaction to the same values.\nA wild-card asterisk can be used in place of or in conjunction with\nthe I,J arguments to set the coefficients for multiple pairs of atom\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).  Note that only type pairs with I <= J are considered; if\nasterisks imply type pairs where J < I, they are ignored.\nIMPROTANT NOTE: If pair_style hybrid or hybrid/overlay is being used, then the pstyle will\nbe a sub-style name.  You must specify I,J arguments that correspond\nto type pair values defined (via the pair_coeff\ncommand) for that sub-style.\nThe v_name argument for keyword pair is the name of an\nequal-style variable which will be evaluated each time\nthis fix is invoked to set the parameter to a new value.  It should be\nspecified as v_name, where name is the variable name.  Equal-style\nvariables can specify formulas with various mathematical functions,\nand include thermo_style command keywords for the\nsimulation box parameters and timestep and elapsed time.  Thus it is\neasy to specify parameters that change as a function of time or span\nconsecutive runs in a continuous fashion.  For the latter, see the\nstart and stop keywords of the run command and the\nelaplong keyword of thermo_style custom for\ndetails.\nFor example, these commands would change the prefactor coefficient of\nthe pair_style soft potential from 10.0 to 30.0 in a\nlinear fashion over the course of a simulation:\nvariable prefactor equal ramp(10,30)\nfix 1 all adapt 1 pair soft a * * v_prefactor\n\nThe kspace keyword used the specified variable as a scale factor on\nthe energy, forces, virial calculated by whatever K-Space solver is\ndefined by the kspace_style command.  If the\nvariable has a value of 1.0, then the solver is unaltered.\nThe kspace keyword works this way whether the scale keyword\nis set to no or yes.\n\nThe atom keyword enables various atom properties to be changed.  The\naparam argument is the name of the parameter to change.  This is the\ncurrent list of atom parameters that can be varied by this fix:\n\ncharge = charge on particle\ndiameter = diameter of particle\n\nThe I argument indicates which atom types are affected. A wild-card\nasterisk can be used in place of or in conjunction with the I argument\nto set the coefficients for multiple atom types.\nThe v_name argument of the atom keyword is the name of an\nequal-style variable which will be evaluated each time\nthis fix is invoked to set the parameter to a new value.  It should be\nspecified as v_name, where name is the variable name.  See the\ndiscussion above describing the formulas associated with equal-style\nvariables.  The new value is assigned to the corresponding attribute\nfor all atoms in the fix group.\nIf the atom parameter is diameter and per-atom density and per-atom\nmass are defined for particles (e.g. atom_style granular), then the mass of each particle is also\nchanged when the diameter changes (density is assumed to stay\nconstant).\nFor example, these commands would shrink the diameter of all granular\nparticles in the “center” group from 1.0 to 0.1 in a linear fashion\nover the course of a 1000-step simulation:\nvariable size equal ramp(1.0,0.1)\nfix 1 center adapt 10 atom diameter * v_size\nFor rRESPA time integration, this fix changes\nparameters on the outermost rRESPA level.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID adapt/fep N attribute args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * adapt/fep = style name of this fix command\n * N = adapt simulation settings every this many timesteps\n * one or more attribute/arg pairs may be appended\n * attribute = pair or kspace or atom\n * pair args = pstyle pparam I J v_name\n *   pstyle = pair style name, e.g. lj/cut\n *   pparam = parameter to adapt over time\n *   I,J = type pair(s) to set parameter for\n *   v_name = variable with name that calculates value of pparam\n * kspace arg = v_name\n *   v_name = variable with name that calculates scale factor on K-space terms\n * atom args = aparam v_name\n *   aparam = parameter to adapt over time\n *   I = type(s) to set parameter for\n *   v_name = variable with name that calculates value of aparam\n * zero or more keyword/value pairs may be appended\n * keyword = scale or reset or after\n * scale value = no or yes\n *   no = the variable value is the new setting\n *   yes = the variable value multiplies the original setting\n * reset value = no or yes\n *   no = values will remain altered at the end of a run\n *   yes = reset altered values to their original values at the end\n *   of a run\n * after value = no or yes\n *   no = parameters are adapted at timestep N\n *   yes = parameters are adapted one timestep after N",
    "examples": "fix 1 all adapt/fep 1 pair soft a 1 1 v_prefactor\nfix 1 all adapt/fep 1 pair soft a 2* 3 v_prefactor\nfix 1 all adapt/fep 1 pair lj/cut epsilon * * v_scale1 coul/cut scale 3 3 v_scale2 scale yes reset yes\nfix 1 all adapt/fep 10 atom diameter 1 v_size",
    "restrictions": "\nnone"
},
{
    "command": "fix addforce",
    "html_filename": "fix_addforce.html",
    "short_description": "Add fx,fy,fz to the corresponding component of force for each atom in the group",
    "description": "Add fx,fy,fz to the corresponding component of force for each atom in\nthe group.  This command can be used to give an additional push to\natoms in a simulation, such as for a simulation of Poiseuille flow in\na channel.\nAny of the 3 quantities defining the force components can be specified\nas an equal-style or atom-style variable, namely fx,\nfy, fz.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value(s) used to determine\nthe force component.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent force field.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent force\nfield with optional time-dependence as well.\nIf the every keyword is used, the Nevery setting determines how\noften the forces are applied.  The default value is 1, for every\ntimestep.\nIf the region keyword is used, the atom must also be in the\nspecified geometric region in order to have force added\nto it.\n\nAdding a force to atoms implies a change in their potential energy as\nthey move due to the applied force field.  For dynamics via the “run”\ncommand, this energy can be optionally added to the system’s potential\nenergy for thermodynamic output (see below).  For energy minimization\nvia the “minimize” command, this energy must be added to the system’s\npotential energy to formulate a self-consistent minimization problem\n(see below).\nThe energy keyword is not allowed if the added force is a constant\nvector F = (fx,fy,fz), with all components defined as numeric\nconstants and not as variables.  This is because LAMMPS can compute\nthe energy for each atom directly as E = -x dot F = -(x*fx + y*fy +\nz*fz), so that -Grad(E) = F.\nThe energy keyword is optional if the added force is defined with\none or more variables, and if you are performing dynamics via the\nrun command.  If the keyword is not used, LAMMPS will set\nthe energy to 0.0, which is typically fine for dynamics.\nThe energy keyword is required if the added force is defined with\none or more variables, and you are performing energy minimization via\nthe “minimize” command.  The keyword specifies the name of an\natom-style variable which is used to compute the\nenergy of each atom as function of its position.  Like variables used\nfor fx, fy, fz, the energy variable is specified as v_name,\nwhere name is the variable name.\nNote that when the energy keyword is used during an energy\nminimization, you must insure that the formula defined for the\natom-style variable is consistent with the force\nvariable formulas, i.e. that -Grad(E) = F.  For example, if the force\nwere a spring-like F = kx, then the energy formula should be E =\n-0.5kx^2.  If you don’t do this correctly, the minimization will not\nconverge properly.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential “energy” inferred by the added force to the\nsystem’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\nneeded so that the minimize command can include the\nforces added by this fix in a consistent manner.  I.e. there is a\ndecrease in potential energy when atoms move in the direction of the\nadded force.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the added forces on atoms to the\nsystem’s virial as part of thermodynamic output.\nThe default is virial no\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost\nlevel.\nThis fix computes a global scalar and a global 3-vector of forces,\nwhich can be accessed by various output commands.\nThe scalar is the potential energy discussed above.  The vector is the\ntotal force on the group of atoms before the forces on individual\natoms are changed by the fix.  The scalar and vector values calculated\nby this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  You should not\nspecify force components with a variable that has time-dependence for\nuse with a minimizer, since the minimizer increments the timestep as\nthe iteration count during the minimization.\n\nNote\nIf you want the fictitious potential energy associated with the\nadded forces to be included in the total potential energy of the\nsystem (the quantity being minimized), you MUST enable the\nfix_modify energy option for this fix.",
    "syntax": "fix ID group-ID addforce fx fy fz keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * addforce = style name of this fix command\n * fx,fy,fz = force component values (force units)\n * any of fx,fy,fz can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = every or region or energy\n * every value = Nevery\n *   Nevery = add force every this many timesteps\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to have added force\n * energy value = v_name\n *   v_name = variable with name that calculates the potential energy of each atom in the added force field",
    "examples": "fix kick flow addforce 1.0 0.0 0.0\nfix kick flow addforce 1.0 0.0 v_oscillate\nfix ff boundary addforce 0.0 0.0 v_push energy v_espace",
    "restrictions": "\nnone"
},
{
    "command": "fix addtorque",
    "html_filename": "fix_addtorque.html",
    "short_description": "Add a set of forces to each atom in the group such that:  the components of the total torque applied on the group (around its center of mass) are Tx,Ty,Tz the group would move as a rigid body in the absence of other forces",
    "description": "Add a set of forces to each atom in\nthe group such that:\n\nthe components of the total torque applied on the group (around its\ncenter of mass) are Tx,Ty,Tz\nthe group would move as a rigid body in the absence of other\nforces.\n\nThis command can be used to drive a group of atoms into rotation.\nAny of the 3 quantities defining the torque components can be specified\nas an equal-style variable, namely Tx,\nTy, Tz.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value used to determine the\ntorque component.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent torque.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential “energy” inferred by the added forces to the\nsystem’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\nneeded so that the minimize command can include the\nforces added by this fix in a consistent manner.  I.e. there is a\ndecrease in potential energy when atoms move in the direction of the\nadded forces.\nThe fix_modify respa option is supported by\nthis fix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its torque. Default is the outermost level.\nThis fix computes a global scalar and a global 3-vector, which can be\naccessed by various output commands.  The scalar\nis the potential energy discussed above.  The vector is the total\ntorque on the group of atoms before the forces on individual atoms are\nchanged by the fix.  The scalar and vector values calculated by this\nfix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  You should not\nspecify force components with a variable that has time-dependence for\nuse with a minimizer, since the minimizer increments the timestep as\nthe iteration count during the minimization.",
    "syntax": "fix ID group-ID addtorque Tx Ty Tz",
    "parameters": " * ID, group-ID are documented in fix command\n * addtorque = style name of this fix command\n * Tx,Ty,Tz = torque component values (torque units)\n * any of Tx,Ty,Tz can be a variable (see below)",
    "examples": "fix kick bead addtorque 2.0 3.0 5.0\nfix kick bead addtorque 0.0 0.0 v_oscillate",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix append/atoms",
    "html_filename": "fix_append_atoms.html",
    "short_description": "This fix creates atoms on a lattice, appended on the zhi edge of the system box",
    "description": "This fix creates atoms on a lattice, appended on the zhi edge of the\nsystem box.  This can be useful when a shock or wave is propagating\nfrom zlo.  This allows the system to grow with time to accommodate an\nexpanding wave.  A simulation box must already exist, which is\ntypically created via the create_box command.\nBefore using this command, a lattice must also be defined using the\nlattice command.\nThis fix will automatically freeze atoms on the zhi edge of the\nsystem, so that overlaps are avoided when new atoms are appended.\nThe basis keyword specifies an atom type that will be assigned to\nspecific basis atoms as they are created.  See the\nlattice command for specifics on how basis atoms are\ndefined for the unit cell of the lattice.  By default, all created\natoms are assigned type = 1 unless this keyword specifies differently.\nThe size keyword defines the size in z of the chunk of material to\nbe added.\nThe random keyword will give the atoms random displacements around\ntheir lattice points to simulate some initial temperature.\nThe temp keyword will cause a region to be thermostatted with a\nLangevin thermostat on the zhi boundary.  The size of the region is\nmeasured from zhi and is set with the extent argument.\nThe units keyword determines the meaning of the distance units used\nto define a wall position, but only when a numeric constant is used.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID append/atoms face ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * append/atoms = style name of this fix command\n * face = zhi\n * zero or more keyword/value pairs may be appended\n * keyword = basis or size or freq or temp or random or units\n * basis values = M itype\n *   M = which basis atom\n *   itype = atom type (1-N) to assign to this basis atom\n * size args = Lz\n *   Lz = z size of lattice region appended in a single event(distance units)\n * freq args = freq\n *   freq = the number of timesteps between append events\n * temp args = target damp seed extent\n *   target = target temperature for the region between zhi-extent and zhi (temperature units)\n *   damp = damping parameter (time units)\n *   seed = random number seed for langevin kicks\n *   extent = extent of thermostatted region (distance units)\n * random args = xmax ymax zmax seed\n *   xmax, ymax, zmax = maximum displacement in particular direction (distance units)\n *   seed = random number seed for random displacement\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units",
    "examples": "fix 1 all append/atoms zhi size 5.0 freq 295 units lattice\nfix 4 all append/atoms zhi size 15.0 freq 5 units box\nfix A all append/atoms zhi size 1.0 freq 1000 units lattice",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nThe boundary on which atoms are added with append/atoms must be\nshrink/minimum.  The opposite boundary may be any boundary type other\nthan periodic."
},
{
    "command": "fix atc",
    "html_filename": "fix_atc.html",
    "short_description": "This fix is the beginning to creating a coupled FE/MD simulation and/or an on-the-fly estimation of continuum fields",
    "description": "This fix is the beginning to creating a coupled FE/MD simulation and/or an on-the-fly estimation of continuum fields. The coupled versions of this fix do Verlet integration and the post-processing does not. After instantiating this fix, several other fix_modify commands will be needed to set up the problem, e.g. define the finite element mesh and prescribe initial and boundary conditions.\n\nThe following coupling example is typical, but non-exhaustive:\n # ... commands to create and initialize the MD system\n\n # initial fix to designate coupling type and group to apply it to\n # tag group physics material_file\n fix AtC internal atc thermal Ar_thermal.mat\n\n # create a uniform 12 x 2 x 2 mesh that covers region contain the group\n # nx ny nz region periodicity\n fix_modify AtC mesh create 12 2 2 mdRegion f p p\n\n # specify the control method for the type of coupling\n # physics control_type\n fix_modify AtC thermal control flux\n\n # specify the initial values for the empirical field \"temperature\"\n # field node_group value\n fix_modify AtC initial temperature all 30\n\n # create an output stream for nodal fields\n # filename output_frequency\n fix_modify AtC output atc_fe_output 100\n\n run 1000\n\n\nlikewise for this post-processing example:\n# ... commands to create and initialize the MD system\n\n# initial fix to designate post-processing and the group to apply it to\n# no material file is allowed nor required\nfix AtC internal atc hardy\n\n# for hardy fix, specific kernel function (function type and range) to # be used as a localization function\nfix AtC kernel quartic_sphere 10.0\n\n# create a uniform 1 x 1 x 1 mesh that covers region contain the group\n# with periodicity this effectively creats a system average\nfix_modify AtC mesh create 1 1 1 box p p p\n\n# change from default lagrangian map to eulerian\n# refreshed every 100 steps\nfix_modify AtC atom_element_map eulerian 100\n\n# start with no field defined\n# add mass density, potential energy density, stress and temperature\nfix_modify AtC fields add density energy stress temperature\n\n# create an output stream for nodal fields\n# filename output_frequency\nfix_modify AtC output nvtFE 100 text\n\nrun 1000\n\n\nthe mesh’s linear interpolation functions can be used as the localization function\nby using the field option:\nfix AtC internal atc field\nfix_modify AtC mesh create 1 1 1 box p p p\n...\n\n\nNote coupling and post-processing can be combined in the same simulations using separate fixes.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  The fix_modify options\nrelevant to this fix are listed below.  No global scalar or vector or\nper-atom quantities are stored by this fix for access by various\noutput commands.  No parameter of this fix can be\nused with the start/stop keywords of the run command.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix <fixID> <group> atc <type> <parameter_file>",
    "parameters": " * fixID = name of fix\n * group = name of group fix is to be applied\n * type = thermal or two_temperature or hardy or field\n * thermal = thermal coupling with fields: temperature\n * two_temperature = electron-phonon coupling with field: temperature and electron_temperature\n * hardy = on-the-fly post-processing using kernel localization functions (see \"related\" section for possible fields)\n * field = on-the-fly post-processing using mesh-based localization functions (see \"related\" section for possible fields)\n * parameter_file = name of the file with material parameters. Note: Neither hardy nor field requires a parameter file",
    "examples": "fix AtC internal atc thermal Ar_thermal.dat\nfix AtC internal atc two_temperature Ar_ttm.mat\nfix AtC internal atc hardy\nfix AtC internal atc field",
    "restrictions": "Thermal and two_temperature (coupling) types use a Verlet time-integration algorithm. The hardy type does not contain its own time-integrator and must be used with a separate fix that does contain one, e.g. nve, nvt, etc. In addition, currently:\n\nthe coupling is restricted to thermal physics\nthe FE computations are done in serial on each processor."
},
{
    "command": "fix atom/swap",
    "html_filename": "fix_atom_swap.html",
    "short_description": "This fix performs Monte Carlo swaps of atoms of one given atom type with atoms of the other given atom types",
    "description": "This fix performs Monte Carlo swaps of atoms of one given atom type\nwith atoms of the other given atom types. The specified T is used in\nthe Metropolis criterion dictating swap probabilities.\nPerform X swaps of atoms of one type with atoms of another type\naccording to a Monte Carlo probability. Swap candidates must be in the\nfix group, must be in the region (if specified), and must be of one of\nthe listed types. Swaps are attempted between candidates that are\nchosen randomly with equal probability among the candidate\natoms. Swaps are not attempted between atoms of the same type since\nnothing would happen.\nAll atoms in the simulation domain can be moved using regular time\nintegration displacements, e.g. via fix nvt, resulting\nin a hybrid MC+MD simulation. A smaller-than-usual timestep size may\nbe needed when running such a hybrid simulation, especially if the\nswapped atoms are not well equilibrated.\nThe types keyword is required. At least two atom types must be\nspecified.\nThe ke keyword can be set to no to turn off kinetic energy\nconservation for swaps. The default is yes, which means that swapped\natoms have their velocities scaled by the ratio of the masses of the\nswapped atom types. This ensures that the kinetic energy of each atom\nis the same after the swap as it was before the swap, even though the\natom masses have changed.\nThe semi-grand keyword can be set to yes to switch to the\nsemi-grand canonical ensemble as discussed in (Sadigh). This\nmeans that the total number of each particle type does not need to be\nconserved. The default is no, which means that the only kind of swap\nallowed exchanges an atom of one type with an atom of a different\ngiven type. In other words, the relative mole fractions of the swapped\natoms remains constant. Whereas in the semi-grand canonical ensemble,\nthe composition of the system can change. Note that when using\nsemi-grand, atoms in the fix group whose type is not listed\nin the types keyword are ineligible for attempted\nconversion. An attempt is made to switch\nthe selected atom (if eligible) to one of the other listed types\nwith equal probability. Acceptance of each attempt depends upon the Metropolis criterion.\nThe mu keyword allows users to specify chemical\npotentials. This is required and allowed only when using semi-grand.\nAll chemical potentials are absolute, so there is one for\neach swap type listed following the types keyword.\nIn semi-grand canonical ensemble simulations the chemical composition\nof the system is controlled by the difference in these values. So\nshifting all values by a constant amount will have no effect\non the simulation.\nThis command may optionally use the region keyword to define swap\nvolume.  The specified region must have been previously defined with a\nregion command.  It must be defined with side = in.\nSwap attempts occur only between atoms that are both within the\nspecified region. Swaps are not otherwise attempted.\nYou should ensure you do not swap atoms belonging to a molecule, or\nLAMMPS will soon generate an error when it tries to find those atoms.\nLAMMPS will warn you if any of the atoms eligible for swapping have a\nnon-zero molecule ID, but does not check for this at the time of\nswapping.\nIf not using semi-grand this fix checks to ensure all atoms of the\ngiven types have the same atomic charge. LAMMPS doesn’t enforce this\nin general, but it is needed for this fix to simplify the\nswapping procedure. Successful swaps will swap the atom type and charge\nof the swapped atoms. Conversely, when using semi-grand, it is assumed that all the atom\ntypes involved in switches have the same charge. Otherwise, charge\nwould not be conserved. As a consequence, no checks on atomic charges are\nperformed, and successful switches update the atom type but not the\natom charge. While it is possible to use semi-grand with groups of\natoms that have different charges, these charges will not be changed when the\natom types change.\nSince this fix computes total potential energies before and after\nproposed swaps, so even complicated potential energy calculations are\nOK, including the following:\n\nlong-range electrostatics (kspace)\nmany body pair styles\nhybrid pair styles\neam pair styles\ntriclinic systems\nneed to include potential energy contributions from other fixes\n\nSome fixes have an associated potential energy. Examples of such fixes\ninclude: efield, gravity,\naddforce, langevin,\nrestrain, temp/berendsen,\ntemp/rescale, and wall fixes.\nFor that energy to be included in the total potential energy of the\nsystem (the quantity used when performing GCMC moves),\nyou MUST enable the fix_modify energy option for\nthat fix.  The doc pages for individual fix commands\nspecify if this should be done.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the fix to binary restart files.  This includes information about the random\nnumber generator seed, the next timestep for MC exchanges, the number\nof exchange attempts and successes etc.  See\nthe read_restart command for info on how to\nre-specify a fix in an input script that reads a restart file, so that\nthe operation of the fix continues in an uninterrupted fashion.\n\nNote\nFor this to work correctly, the timestep must not be changed\nafter reading the restart with reset_timestep.\nThe fix will try to detect it and stop with an error.\n\nNone of the fix_modify options are relevant to this\nfix.\nThis fix computes a global vector of length 2, which can be accessed\nby various output commands.  The vector values are\nthe following global cumulative quantities:\n\n1 = swap attempts\n2 = swap successes\n\nThe vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID atom/swap N X seed T keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * atom/swap = style name of this fix command\n * N = invoke this fix every N steps\n * X = number of swaps to attempt every N steps\n * seed = random # seed (positive integer)\n * T = scaling temperature of the MC swaps (temperature units)\n * one or more keyword/value pairs may be appended to args\n * keyword = types or mu or ke or semi-grand or region\n * types values = two or more atom types\n * mu values = chemical potential of swap types (energy units)\n * ke value = no or yes\n *   no = no conservation of kinetic energy after atom swaps\n *   yes = kinetic energy is conserved after atom swaps\n * semi-grand value = no or yes\n *   no = particle type counts and fractions conserved\n *   yes = semi-grand canonical ensemble, particle fractions not conserved\n * region value = region-ID\n *   region-ID = ID of region to use as an exchange/move volume",
    "examples": "fix 2 all atom/swap 1 1 29494 300.0 ke no types 1 2\nfix myFix all atom/swap 100 1 12345 298.0 region my_swap_region types 5 6\nfix SGMC all atom/swap 1 100 345 1.0 semi-grand yes types 1 2 3 mu 0.0 4.3 -5.0",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info."
},
{
    "command": "fix ave/atom",
    "html_filename": "fix_ave_atom.html",
    "short_description": "Use one or more per-atom vectors as inputs every few timesteps, and average them atom by atom over longer timescales",
    "description": "Use one or more per-atom vectors as inputs every few timesteps, and\naverage them atom by atom over longer timescales.  The resulting\nper-atom averages can be used by other output commands such as the fix ave/chunk or dump custom commands.\nThe group specified with the command means only atoms within the group\nhave their averages computed.  Results are set to 0.0 for atoms not in\nthe group.\nEach input value can be an atom attribute (position, velocity, force\ncomponent) or can be the result of a compute or\nfix or the evaluation of an atom-style\nvariable.  In the latter cases, the compute, fix, or\nvariable must produce a per-atom vector, not a global quantity or\nlocal quantity.  If you wish to time-average global quantities from a\ncompute, fix, or variable, then see the fix ave/time command.\nEach per-atom value of each input vector is averaged independently.\nComputes that produce per-atom vectors or arrays are\nthose which have the word atom in their style name.  See the doc\npages for individual fixes to determine which ones produce\nper-atom vectors or arrays.  Variables of style atom\nare the only ones that can be used with this fix since they produce\nper-atom vectors.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 fix ave/atom commands are\nequivalent, since the compute stress/atom\ncommand creates a per-atom array with 6 columns:\ncompute my_stress all stress/atom NULL\nfix 1 all ave/atom 10 20 1000 c_my_stress[*]\nfix 1 all ave/atom 10 20 1000 c_my_stress[1] c_my_stress[2] &\n                              c_my_stress[3] c_my_stress[4] &\n                              c_my_stress[5] c_my_stress[6]\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be used in order to contribute to the\naverage.  The final averaged quantities are generated on timesteps\nthat are a multiple of Nfreq.  The average is over Nrepeat\nquantities, computed in the preceding portion of the simulation every\nNevery timesteps.  Nfreq must be a multiple of Nevery and\nNevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\ncontributing to the average value cannot overlap,\ni.e. Nrepeat*Nevery can not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\ntimesteps 90,92,94,96,98,100 will be used to compute the final average\non timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\ntimestep 200, etc.\n\nThe atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\nself-explanatory.  Note that other atom attributes can be used as\ninputs to this fix by using the compute property/atom command and then specifying\nan input value from that compute.\n\nNote\nThe x,y,z attributes are values that are re-wrapped inside the\nperiodic box whenever an atom crosses a periodic boundary.  Thus if\nyou time average an atom that spends half its time on either side of\nthe periodic box, you will get a value in the middle of the box.  If\nthis is not what you want, consider averaging unwrapped coordinates,\nwhich can be provided by the compute property/atom command via its xu,yu,zu\nattributes.\n\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the per-atom vector calculated by the compute is used.  If a\nbracketed term containing an index I is appended, the Ith column of\nthe per-atom array calculated by the compute is used.  Users can also\nwrite code for their own compute styles and add them to LAMMPS.  See the discussion above for how I can\nbe specified with a wildcard asterisk to effectively specify multiple\nvalues.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the per-atom vector calculated by the fix is used.  If a\nbracketed term containing an index I is appended, the Ith column of\nthe per-atom array calculated by the fix is used.  Note that some\nfixes only produce their values on certain timesteps, which must be\ncompatible with Nevery, else an error will result.  Users can also\nwrite code for their own fix styles and add them to LAMMPS.  See the discussion above for how I can be\nspecified with a wildcard asterisk to effectively specify multiple\nvalues.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script as an atom-style variable Variables of style atom can reference\nthermodynamic keywords, or invoke other computes, fixes, or variables\nwhen they are evaluated, so this is a very general means of generating\nper-atom quantities to time average.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global scalar or vector quantities are\nstored by this fix for access by various output commands.\nThis fix produces a per-atom vector or array which can be accessed by\nvarious output commands.  A vector is produced if\nonly a single quantity is averaged by this fix.  If two or more\nquantities are averaged, then an array of values is produced.  The\nper-atom values can only be accessed on timesteps that are multiples\nof Nfreq since that is when averaging is performed.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ave/atom Nevery Nrepeat Nfreq value1 value2 ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ave/atom = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of times to use input values for calculating averages\n * Nfreq = calculate averages every this many timesteps\n * one or more input values can be listed\n * value = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[i], f_ID, f_ID[i], v_name\n * x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = per-atom vector calculated by an atom-style variable with name",
    "examples": "fix 1 all ave/atom 1 100 100 vx vy vz\nfix 1 all ave/atom 10 20 1000 c_my_stress[1]\nfix 1 all ave/atom 10 20 1000 c_my_stress[*]",
    "restrictions": "\nnone"
},
{
    "command": "fix ave/chunk",
    "html_filename": "fix_ave_chunk.html",
    "short_description": "Use one or more per-atom vectors as inputs every few timesteps, sum the values over the atoms in each chunk at each timestep, then average the per-chunk values over longer timescales",
    "description": "Use one or more per-atom vectors as inputs every few timesteps, sum\nthe values over the atoms in each chunk at each timestep, then average\nthe per-chunk values over longer timescales.  The resulting chunk\naverages can be used by other output commands such\nas thermo_style custom, and can also be written to\na file.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom doc page and the Howto chunk doc page for details of how chunks can be\ndefined and examples of how they can be used to measure properties of\na system.\nNote that only atoms in the specified group contribute to the summing\nand averaging calculations.  The compute chunk/atom command defines its own group as\nwell as an optional region.  Atoms will have a chunk ID = 0, meaning\nthey belong to no chunk, if they are not in that group or region.\nThus you can specify the “all” group for this command if you simply\nwant to use the chunk definitions provided by chunkID.\nEach specified per-atom value can be an atom attribute (position,\nvelocity, force component), a mass or number density, or the result of\na compute or fix or the evaluation of an\natom-style variable.  In the latter cases, the\ncompute, fix, or variable must produce a per-atom quantity, not a\nglobal quantity.  Note that the compute property/atom command provides access to\nany attribute defined and stored by atoms.  If you wish to\ntime-average global quantities from a compute, fix, or variable, then\nsee the fix ave/time command.\nThe per-atom values of each input vector are summed and averaged\nindependently of the per-atom values in other input vectors.\nComputes that produce per-atom quantities are those\nwhich have the word atom in their style name.  See the doc pages for\nindividual fixes to determine which ones produce per-atom\nquantities.  Variables of style atom are the only\nones that can be used with this fix since all other styles of variable\nproduce global quantities.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 fix ave/chunk commands are\nequivalent, since the compute property/atom command creates, in this\ncase, a per-atom array with 3 columns:\ncompute myAng all property/atom angmomx angmomy angmomz\nfix 1 all ave/chunk 100 1 100 cc1 c_myAng[*] file tmp.angmom\nfix 2 all ave/chunk 100 1 100 cc1 c_myAng[1] c_myAng[2] c_myAng[3] file tmp.angmom\n\nNote\nThis fix works by creating an array of size Nchunk by Nvalues\non each processor.  Nchunk is the number of chunks which is defined\nby the compute chunk/atom command.\nNvalues is the number of input values specified.  Each processor loops\nover its atoms, tallying its values to the appropriate chunk.  Then\nthe entire array is summed across all processors.  This means that\nusing a large number of chunks will incur an overhead in memory and\ncomputational cost (summing across processors), so be careful to\ndefine a reasonable number of chunks.\n\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be accessed and contribute to the\naverage.  The final averaged quantities are generated on timesteps\nthat are a multiples of Nfreq.  The average is over Nrepeat\nquantities, computed in the preceding portion of the simulation every\nNevery timesteps.  Nfreq must be a multiple of Nevery and\nNevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\ncontributing to the average value cannot overlap, i.e. Nrepeat*Nevery\ncan not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\ntimesteps 90,92,94,96,98,100 will be used to compute the final average\non timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\ntimestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\naveraging is done; values are simply generated on timesteps\n100,200,etc.\nEach input value can also be averaged over the atoms in each chunk.\nThe way the averaging is done across the Nrepeat timesteps to\nproduce output on the Nfreq timesteps, and across multiple Nfreq\noutputs, is determined by the norm and ave keyword settings, as\ndiscussed below.\n\nNote\nTo perform per-chunk averaging within a Nfreq time window, the\nnumber of chunks Nchunk defined by the compute chunk/atom command must remain constant.  If\nthe ave keyword is set to running or window then Nchunk must\nremain constant for the duration of the simulation.  This fix forces\nthe chunk/atom compute specified by chunkID to hold Nchunk constant\nfor the appropriate time windows, by not allowing it to re-calculate\nNchunk, which can also affect how it assigns chunk IDs to atoms.\nThis is particularly important to understand if the chunks defined by\nthe compute chunk/atom command are spatial\nbins.  If its units keyword is set to box or lattice, then the\nnumber of bins Nchunk and size of each bin will be fixed over the\nNfreq time window, which can affect which atoms are discarded if the\nsimulation box size changes.  If its units keyword is set to\nreduced, then the number of bins Nchunk will still be fixed, but\nthe size of each bin can vary at each timestep if the simulation box\nsize changes, e.g. for an NPT simulation.\n\n\nThe atom attribute values (vx,vy,vz,fx,fy,fz) are self-explanatory.\nAs noted above, any other atom attributes can be used as input values\nto this fix by using the compute property/atom command and then specifying\nan input value from that compute.\nThe density/number value means the number density is computed for\neach chunk, i.e. number/volume.  The density/mass value means the\nmass density is computed for each chunk, i.e. total-mass/volume.  The\noutput values are in units of 1/volume or density (mass/volume).  See\nthe units command doc page for the definition of density\nfor each choice of units, e.g. gram/cm^3.  If the chunks defined by\nthe compute chunk/atom command are spatial\nbins, the volume is the bin volume.  Otherwise it is the volume of the\nentire simulation box.\nThe temp value means the temperature is computed for each chunk, by\nthe formula KE = DOF/2 k T, where KE = total kinetic energy of the\nchunk of atoms (sum of 1/2 m v^2), DOF = the total number of degrees\nof freedom for all atoms in the chunk, k = Boltzmann constant, and T =\ntemperature.\nThe DOF is calculated as N*adof + cdof, where N = number of atoms in\nthe chunk, adof = degrees of freedom per atom, and cdof = degrees of\nfreedom per chunk.  By default adof = 2 or 3 = dimensionality of\nsystem, as set via the dimension command, and cdof =\n0.0.  This gives the usual formula for temperature.\nNote that currently this temperature only includes translational\ndegrees of freedom for each atom.  No rotational degrees of freedom\nare included for finite-size particles.  Also no degrees of freedom\nare subtracted for any velocity bias or constraints that are applied,\nsuch as compute temp/partial, or fix shake or fix rigid.  This is because\nthose degrees of freedom (e.g. a constrained bond) could apply to sets\nof atoms that are both included and excluded from a specific chunk,\nand hence the concept is somewhat ill-defined.  In some cases, you can\nuse the adof and cdof keywords to adjust the calculated degrees of\nfreedom appropriately, as explained below.\nAlso note that a bias can be subtracted from atom velocities before\nthey are used in the above formula for KE, by using the bias\nkeyword.  This allows, for example, a thermal temperature to be\ncomputed after removal of a flow velocity profile.\nNote that the per-chunk temperature calculated by this fix and the\ncompute temp/chunk command can be different.\nThe compute calculates the temperature for each chunk for a single\nsnapshot.  This fix can do that but can also time average those values\nover many snapshots, or it can compute a temperature as if the atoms\nin the chunk on different timesteps were collected together as one set\nof atoms to calculate their temperature.  The compute allows the\ncenter-of-mass velocity of each chunk to be subtracted before\ncalculating the temperature; this fix does not.\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If no bracketed integer is\nappended, the per-atom vector calculated by the compute is used.  If a\nbracketed integer is appended, the Ith column of the per-atom array\ncalculated by the compute is used.  Users can also write code for\ntheir own compute styles and add them to LAMMPS.\nSee the discussion above for how I can be specified with a wildcard\nasterisk to effectively specify multiple values.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If no bracketed integer is\nappended, the per-atom vector calculated by the fix is used.  If a\nbracketed integer is appended, the Ith column of the per-atom array\ncalculated by the fix is used.  Note that some fixes only produce\ntheir values on certain timesteps, which must be compatible with\nNevery, else an error results.  Users can also write code for their\nown fix styles and add them to LAMMPS.  See the\ndiscussion above for how I can be specified with a wildcard asterisk\nto effectively specify multiple values.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  Variables of style\natom can reference thermodynamic keywords and various per-atom\nattributes, or invoke other computes, fixes, or variables when they\nare evaluated, so this is a very general means of generating per-atom\nquantities to average within chunks.\n\nAdditional optional keywords also affect the operation of this fix\nand its outputs.\nThe norm keyword affects how averaging is done for the per-chunk\nvalues that are output every Nfreq timesteps.\nIt the norm setting is all, which is the default, a chunk value is\nsummed over all atoms in all Nrepeat samples, as is the count of\natoms in the chunk.  The averaged output value for the chunk on the\nNfreq timesteps is Total-sum / Total-count.  In other words it is an\naverage over atoms across the entire Nfreq timescale.  For the\ndensity/number and density/mass values, the volume (bin volume or\nsystem volume) used in the final normalization will be the volume at\nthe final Nfreq timestep.\nIf the norm setting is sample, the chunk value is summed over\natoms for each sample, as is the count, and an “average sample value”\nis computed for each sample, i.e. Sample-sum / Sample-count.  The\noutput value for the chunk on the Nfreq timesteps is the average of\nthe Nrepeat “average sample values”, i.e. the sum of Nrepeat\n“average sample values” divided by Nrepeat.  In other words it is an\naverage of an average.  For the density/number and density/mass\nvalues, the volume (bin volume or system volume) used in the\nper-sample normalization will be the current volume at each sampling\nstep.\nIf the norm setting is none, a similar computation as for the\nsample setting is done, except the individual “average sample\nvalues” are “summed sample values”.  A summed sample value is simply\nthe chunk value summed over atoms in the sample, without dividing by\nthe number of atoms in the sample.  The output value for the chunk on\nthe Nfreq timesteps is the average of the Nrepeat “summed sample\nvalues”, i.e. the sum of Nrepeat “summed sample values” divided by\nNrepeat.  For the density/number and density/mass values, the\nvolume (bin volume or system volume) used in the per-sample sum\nnormalization will be the current volume at each sampling step.\nThe ave keyword determines how the per-chunk values produced every\nNfreq steps are averaged with values produced on previous steps that\nwere multiples of Nfreq, before they are accessed by another output\ncommand or written to a file.\nIf the ave setting is one, which is the default, then the chunk\nvalues produced on timesteps that are multiples of Nfreq are\nindependent of each other; they are output as-is without further\naveraging.\nIf the ave setting is running, then the chunk values produced on\ntimesteps that are multiples of Nfreq are summed and averaged in a\ncumulative sense before being output.  Each output chunk value is thus\nthe average of the chunk value produced on that timestep with all\npreceding values for the same chunk.  This running average begins when\nthe fix is defined; it can only be restarted by deleting the fix via\nthe unfix command, or re-defining the fix by\nre-specifying it.\nIf the ave setting is window, then the chunk values produced on\ntimesteps that are multiples of Nfreq are summed and averaged within\na moving “window” of time, so that the last M values for the same\nchunk are used to produce the output.  E.g. if M = 3 and Nfreq = 1000,\nthen the output on step 10000 will be the average of the individual\nchunk values on steps 8000,9000,10000.  Outputs on early steps will\naverage over less than M values if they are not available.\nThe bias keyword specifies the ID of a temperature compute that\nremoves a “bias” velocity from each atom, specified as bias-ID.  It\nis only used when the temp value is calculated, to compute the\nthermal temperature of each chunk after the translational kinetic\nenergy components have been altered in a prescribed way, e.g.  to\nremove a flow velocity profile.  See the doc pages for individual\ncomputes that calculate a temperature to see which ones implement a\nbias.\nThe adof and cdof keywords define the values used in the degree of\nfreedom (DOF) formula described above for temperature calculation\nfor each chunk.  They are only used when the temp value is\ncalculated.  They can be used to calculate a more appropriate\ntemperature for some kinds of chunks.  Here are 3 examples:\nIf spatially binned chunks contain some number of water molecules and\nfix shake is used to make each molecule rigid, then\nyou could calculate a temperature with 6 degrees of freedom (DOF) (3\ntranslational, 3 rotational) per molecule by setting adof to 2.0.\nIf compute temp/partial is used with the\nbias keyword to only allow the x component of velocity to contribute\nto the temperature, then adof = 1.0 would be appropriate.\nIf each chunk consists of a large molecule, with some number of its\nbonds constrained by fix shake or the entire molecule\nby fix rigid/small, adof = 0.0 and cdof could be\nset to the remaining degrees of freedom for the entire molecule\n(entire chunk in this case), e.g. 6 for 3d, or 3 for 2d, for a rigid\nmolecule.\nThe file keyword allows a filename to be specified.  Every Nfreq\ntimesteps, a section of chunk info will be written to a text file in\nthe following format.  A line with the timestep and number of chunks\nis written.  Then one line per chunk is written, containing the chunk\nID (1-Nchunk), an optional original ID value, optional coordinate\nvalues for chunks that represent spatial bins, the number of atoms in\nthe chunk, and one or more calculated values.  More explanation of the\noptional values is given below.  The number of values in each line\ncorresponds to the number of values specified in the fix ave/chunk\ncommand.  The number of atoms and the value(s) are summed or average\nquantities, as explained above.\nThe overwrite keyword will continuously overwrite the output file\nwith the latest output, so that it only contains one timestep worth of\noutput.  This option can only be used with the ave running setting.\nThe format keyword sets the numeric format of each value when it is\nprinted to a file via the file keyword.  Note that all values are\nfloating point quantities.  The default format is %g.  You can specify\na higher precision if desired, e.g. %20.16g.\nThe title1 and title2 and title3 keywords allow specification of\nthe strings that will be printed as the first 3 lines of the output\nfile, assuming the file keyword was used.  LAMMPS uses default\nvalues for each of these, so they do not need to be specified.\nBy default, these header lines are as follows:\n# Chunk-averaged data for fix ID and group name\n# Timestep Number-of-chunks\n# Chunk (OrigID) (Coord1) (Coord2) (Coord3) Ncount value1 value2 ...\n\n\nIn the first line, ID and name are replaced with the fix-ID and group\nname.  The second line describes the two values that are printed at\nthe first of each section of output.  In the third line the values are\nreplaced with the appropriate value names, e.g. fx or c_myCompute[2].\nThe words in parenthesis only appear with corresponding columns if the\nchunk style specified for the compute chunk/atom command supports them.  The OrigID\ncolumn is only used if the compress keyword was set to yes for the\ncompute chunk/atom command.  This means that\nthe original chunk IDs (e.g. molecule IDs) will have been compressed\nto remove chunk IDs with no atoms assigned to them.  Thus a compressed\nchunk ID of 3 may correspond to an original chunk ID or molecule ID of\n415.  The OrigID column will list 415 for the 3rd chunk.\nThe CoordN columns only appear if a binning style was used in the\ncompute chunk/atom command.  For bin/1d,\nbin/2d, and bin/3d styles the column values are the center point\nof the bin in the corresponding dimension.  Just Coord1 is used for\nbin/1d, Coord2 is added for bin/2d, Coord3 is added for bin/3d.\nFor bin/sphere, just Coord1 is used, and it is the radial\ncoordinate.  For bin/cylinder, Coord1 and Coord2 are used.  Coord1\nis the radial coordinate (away from the cylinder axis), and coord2 is\nthe coordinate along the cylinder axis.\nNote that if the value of the units keyword used in the compute chunk/atom command is box or lattice, the\ncoordinate values will be in distance units.  If the\nvalue of the units keyword is reduced, the coordinate values will\nbe in unitless reduced units (0-1).  This is not true for the Coord1 value\nof style bin/sphere or bin/cylinder which both represent radial\ndimensions.  Those values are always in distance units.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global array of values which can be accessed by\nvarious output commands.  The values can only be\naccessed on timesteps that are multiples of Nfreq since that is when\naveraging is performed.  The global array has # of rows = the number\nof chunks Nchunk as calculated by the specified compute chunk/atom command.  The # of columns =\nM+1+Nvalues, where M = 1 to 4, depending on whether the optional\ncolumns for OrigID and CoordN are used, as explained above.  Following\nthe optional columns, the next column contains the count of atoms in\nthe chunk, and the remaining columns are the Nvalue quantities.  When\nthe array is accessed with a row I that exceeds the current number of\nchunks, than a 0.0 is returned by the fix instead of an error, since\nthe number of chunks can vary as a simulation runs depending on how\nthat value is computed by the compute chunk/atom command.\nThe array values calculated by this fix are treated as “intensive”,\nsince they are typically already normalized by the count of atoms in\neach chunk.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ave/chunk Nevery Nrepeat Nfreq chunkID value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ave/chunk = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of times to use input values for calculating averages\n * Nfreq = calculate averages every this many timesteps\n * chunkID = ID of compute chunk/atom command\n * one or more input values can be listed\n * value = vx, vy, vz, fx, fy, fz, density/mass, density/number, temp, c_ID, c_ID[I], f_ID, f_ID[I], v_name\n * vx,vy,vz,fx,fy,fz = atom attribute (velocity, force component)\n * density/number, density/mass = number or mass density\n * temp = temperature\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = per-atom vector calculated by an atom-style variable with name\n * zero or more keyword/arg pairs may be appended\n * keyword = norm or ave or bias or adof or cdof or file or overwrite or title1 or title2 or title3\n * norm arg = all or sample or none = how output on Nfreq steps is normalized\n *   all = output is sum of atoms across all Nrepeat samples, divided by atom count\n *   sample = output is sum of Nrepeat sample averages, divided by Nrepeat\n *   none = output is sum of Nrepeat sample sums, divided by Nrepeat\n * ave args = one or running or window M\n *   one = output new average value every Nfreq steps\n *   running = output cumulative average of all previous Nfreq steps\n *   window M = output average of M most recent Nfreq steps\n * bias arg = bias-ID\n *   bias-ID = ID of a temperature compute that removes a velocity bias for temperature calculation\n * adof value = dof_per_atom\n *   dof_per_atom = define this many degrees-of-freedom per atom for temperature calculation\n * cdof value = dof_per_chunk\n *   dof_per_chunk = define this many degrees-of-freedom per chunk for temperature calculation\n * file arg = filename\n *   filename = file to write results to\n * overwrite arg = none = overwrite output file with only latest output\n * format arg = string\n *   string = C-style format string\n * title1 arg = string\n *   string = text to print as 1st line of output file\n * title2 arg = string\n *   string = text to print as 2nd line of output file\n * title3 arg = string\n *   string = text to print as 3rd line of output file",
    "examples": "fix 1 all ave/chunk 10000 1 10000 binchunk c_myCentro title1 \"My output values\"\nfix 1 flow ave/chunk 100 10 1000 molchunk vx vz norm sample file vel.profile\nfix 1 flow ave/chunk 100 5 1000 binchunk density/mass ave running\nfix 1 flow ave/chunk 100 5 1000 binchunk density/mass ave running\n\n\nNOTE:\nIf you are trying to replace a deprecated fix ave/spatial command\nwith the newer, more flexible fix ave/chunk and compute chunk/atom commands, you simply need to split\nthe fix ave/spatial arguments across the two new commands.  For\nexample, this command:\nfix 1 flow ave/spatial 100 10 1000 y 0.0 1.0 vx vz norm sample file vel.profile\n\n\ncould be replaced by:\ncompute cc1 flow chunk/atom bin/1d y 0.0 1.0\nfix 1 flow ave/chunk 100 10 1000 cc1 vx vz norm sample file vel.profile",
    "restrictions": "\nnone"
},
{
    "command": "fix ave/correlate",
    "html_filename": "fix_ave_correlate.html",
    "short_description": "Use one or more global scalar values as inputs every few timesteps, calculate time correlations between them at varying time intervals, and average the correlation data over longer timescales",
    "description": "Use one or more global scalar values as inputs every few timesteps,\ncalculate time correlations between them at varying time intervals,\nand average the correlation data over longer timescales.  The\nresulting correlation values can be time integrated by\nvariables or used by other output commands such as thermo_style custom, and can also be written to a file.  See the\nfix ave/correlate/long command for an\nalternate method for computing correlation functions efficiently over\nvery long time windows.\nThe group specified with this command is ignored.  However, note that\nspecified values may represent calculations performed by computes and\nfixes which store their own “group” definitions.\nEach listed value can be the result of a compute or\nfix or the evaluation of an equal-style or vector-style\nvariable.  In each case, the compute, fix, or variable\nmust produce a global quantity, not a per-atom or local quantity.  If\nyou wish to spatial- or time-average or histogram per-atom quantities\nfrom a compute, fix, or variable, then see the fix ave/chunk, fix ave/atom, or\nfix ave/histo commands.  If you wish to convert a\nper-atom quantity into a single global value, see the compute reduce command.\nThe input values must either be all scalars.  What kinds of\ncorrelations between input values are calculated is determined by the\ntype keyword as discussed below.\nComputes that produce global quantities are those which\ndo not have the word atom in their style name.  Only a few\nfixes produce global quantities.  See the doc pages for\nindividual fixes for info on which ones produce such values.\nVariables of style equal and vector are the only\nones that can be used with this fix.  Variables of style atom cannot\nbe used, since they produce per-atom values.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual elements of the\nvector had been listed one by one.  E.g. these 2 fix ave/correlate\ncommands are equivalent, since the compute pressure command creates a global vector with 6\nvalues.\ncompute myPress all pressure NULL\nfix 1 all ave/correlate 1 50 10000 c_myPress[*]\nfix 1 all ave/correlate 1 50 10000 &\n          c_myPress[1] c_myPress[2] c_myPress[3] &\n          c_myPress[4] c_myPress[5] c_myPress[6]\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be used to calculate correlation data.\nThe input values are sampled every Nevery timesteps.  The\ncorrelation data for the preceding samples is computed on timesteps\nthat are a multiple of Nfreq.  Consider a set of samples from some\ninitial time up to an output timestep.  The initial time could be the\nbeginning of the simulation or the last output time; see the ave\nkeyword for options.  For the set of samples, the correlation value\nCij is calculated as:\nCij(delta) = ave(Vi(t)*Vj(t+delta))\nwhich is the correlation value between input values Vi and Vj,\nseparated by time delta.  Note that the second value Vj in the pair is\nalways the one sampled at the later time.  The ave() represents an\naverage over every pair of samples in the set that are separated by\ntime delta.  The maximum delta used is of size (Nrepeat-1)*Nevery.\nThus the correlation between a pair of input values yields Nrepeat\ncorrelation datums:\nCij(0), Cij(Nevery), Cij(2*Nevery), ..., Cij((Nrepeat-1)*Nevery)\nFor example, if Nevery=5, Nrepeat=6, and Nfreq=100, then values on\ntimesteps 0,5,10,15,…,100 will be used to compute the final averages\non timestep 100.  Six averages will be computed: Cij(0), Cij(5),\nCij(10), Cij(15), Cij(20), and Cij(25).  Cij(10) on timestep 100 will\nbe the average of 19 samples, namely Vi(0)*Vj(10), Vi(5)*Vj(15),\nVi(10)*V j20), Vi(15)*Vj(25), …, Vi(85)*Vj(95), Vi(90)*Vj(100).\nNfreq must be a multiple of Nevery; Nevery and Nrepeat must be\nnon-zero.  Also, if the ave keyword is set to one which is the\ndefault, then Nfreq >= (Nrepeat-1)*Nevery is required.\n\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the global scalar calculated by the compute is used.  If a\nbracketed term is appended, the Ith element of the global vector\ncalculated by the compute is used.  See the discussion above for how I\ncan be specified with a wildcard asterisk to effectively specify\nmultiple values.\nNote that there is a compute reduce command\nwhich can sum per-atom quantities into a global scalar or vector which\ncan thus be accessed by fix ave/correlate.  Or it can be a compute\ndefined not in your input script, but by thermodynamic output or other fixes such as fix nvt\nor fix temp/rescale.  See the doc pages for\nthese commands which give the IDs of these computes.  Users can also\nwrite code for their own compute styles and add them to LAMMPS.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the global scalar calculated by the fix is used.  If a\nbracketed term is appended, the Ith element of the global vector\ncalculated by the fix is used.  See the discussion above for how I can\nbe specified with a wildcard asterisk to effectively specify multiple\nvalues.\nNote that some fixes only produce their values on certain timesteps,\nwhich must be compatible with Nevery, else an error will result.\nUsers can also write code for their own fix styles and add them to LAMMPS.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  Only equal-style or\nvector-style variables can be referenced; the latter requires a\nbracketed term to specify the Ith element of the vector calculated by\nthe variable.  See the variable command for details.\nNote that variables of style equal or vector define a formula\nwhich can reference individual atom properties or thermodynamic\nkeywords, or they can invoke other computes, fixes, or variables when\nthey are evaluated, so this is a very general means of specifying\nquantities to time correlate.\n\nAdditional optional keywords also affect the operation of this fix.\nThe type keyword determines which pairs of input values are\ncorrelated with each other.  For N input values Vi, for i = 1 to N,\nlet the number of pairs = Npair.  Note that the second value in the\npair Vi(t)*Vj(t+delta) is always the one sampled at the later time.\n\nIf type is set to auto then each input value is correlated with\nitself.  I.e. Cii = Vi*Vi, for i = 1 to N, so Npair = N.\nIf type is set\nto upper then each input value is correlated with every succeeding\nvalue.  I.e. Cij = Vi*Vj, for i < j, so Npair = N*(N-1)/2.\nIf type is set\nto lower then each input value is correlated with every preceding\nvalue.  I.e. Cij = Vi*Vj, for i > j, so Npair = N*(N-1)/2.\nIf type is set to auto/upper then each input value is correlated\nwith itself and every succeeding value.  I.e. Cij = Vi*Vj, for i >= j,\nso Npair = N*(N+1)/2.\nIf type is set to auto/lower then each input value is correlated\nwith itself and every preceding value.  I.e. Cij = Vi*Vj, for i <= j,\nso Npair = N*(N+1)/2.\nIf type is set to full then each input value is correlated with\nitself and every other value.  I.e. Cij = Vi*Vj, for i,j = 1,N so\nNpair = N^2.\n\nThe ave keyword determines what happens to the accumulation of\ncorrelation samples every Nfreq timesteps.  If the ave setting is\none, then the accumulation is restarted or zeroed every Nfreq\ntimesteps.  Thus the outputs on successive Nfreq timesteps are\nessentially independent of each other.  The exception is that the\nCij(0) = Vi(T)*Vj(T) value at a timestep T, where T is a multiple of\nNfreq, contributes to the correlation output both at time T and at\ntime T+Nfreq.\nIf the ave setting is running, then the accumulation is never\nzeroed.  Thus the output of correlation data at any timestep is the\naverage over samples accumulated every Nevery steps since the fix\nwas defined.  it can only be restarted by deleting the fix via the\nunfix command, or by re-defining the fix by re-specifying\nit.\nThe start keyword specifies what timestep the accumulation of\ncorrelation samples will begin on.  The default is step 0.  Setting it\nto a larger value can avoid adding non-equilibrated data to the\ncorrelation averages.\nThe prefactor keyword specifies a constant which will be used as a\nmultiplier on the correlation data after it is averaged.  It is\neffectively a scale factor on Vi*Vj, which can be used to account for\nthe size of the time window or other unit conversions.\nThe file keyword allows a filename to be specified.  Every Nfreq\nsteps, an array of correlation data is written to the file.  The\nnumber of rows is Nrepeat, as described above.  The number of\ncolumns is the Npair+2, also as described above.  Thus the file ends\nup to be a series of these array sections.\nThe overwrite keyword will continuously overwrite the output file\nwith the latest output, so that it only contains one timestep worth of\noutput.  This option can only be used with the ave running setting.\nThe title1 and title2 and title3 keywords allow specification of\nthe strings that will be printed as the first 3 lines of the output\nfile, assuming the file keyword was used.  LAMMPS uses default\nvalues for each of these, so they do not need to be specified.\nBy default, these header lines are as follows:\n# Time-correlated data for fix ID\n# TimeStep Number-of-time-windows\n# Index TimeDelta Ncount valueI*valueJ valueI*valueJ ...\nIn the first line, ID is replaced with the fix-ID.  The second line\ndescribes the two values that are printed at the first of each section\nof output.  In the third line the value pairs are replaced with the\nappropriate fields from the fix ave/correlate command.\n\nLet Sij = a set of time correlation data for input values I and J,\nnamely the Nrepeat values:\nSij = Cij(0), Cij(Nevery), Cij(2*Nevery), ..., Cij(*Nrepeat-1)*Nevery)\nAs explained below, these datums are output as one column of a global\narray, which is effectively the correlation matrix.\nThe trap function defined for equal-style variables\ncan be used to perform a time integration of this vector of datums,\nusing a trapezoidal rule.  This is useful for calculating various\nquantities which can be derived from time correlation data.  If a\nnormalization factor is needed for the time integration, it can be\nincluded in the variable formula or via the prefactor keyword.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global array of values which can be accessed by\nvarious output commands.  The values can only be\naccessed on timesteps that are multiples of Nfreq since that is when\naveraging is performed.  The global array has # of rows = Nrepeat\nand # of columns = Npair+2.  The first column has the time delta (in\ntimesteps) between the pairs of input values used to calculate the\ncorrelation, as described above.  The 2nd column has the number of\nsamples contributing to the correlation average, as described above.\nThe remaining Npair columns are for I,J pairs of the N input values,\nas determined by the type keyword, as described above.\n\nFor type = auto, the Npair = N columns are ordered: C11, C22, …,\nCNN.\nFor type = upper, the Npair = N*(N-1)/2 columns are ordered: C12,\nC13, …, C1N, C23, …, C2N, C34, …, CN-1N.\nFor type = lower, the Npair = N*(N-1)/2 columns are ordered: C21,\nC31, C32, C41, C42, C43, …, CN1, CN2, …, CNN-1.\nFor type = auto/upper, the Npair = N*(N+1)/2 columns are ordered:\nC11, C12, C13, …, C1N, C22, C23, …, C2N, C33, C34, …, CN-1N,\nCNN.\nFor type = auto/lower, the Npair = N*(N+1)/2 columns are ordered:\nC11, C21, C22, C31, C32, C33, C41, …, C44, CN1, CN2, …, CNN-1,\nCNN.\nFor type = full, the Npair = N^2 columns are ordered: C11, C12,\n…, C1N, C21, C22, …, C2N, C31, …, C3N, …, CN1, …, CNN-1,\nCNN.\n\nThe array values calculated by this fix are treated as intensive.  If\nyou need to divide them by the number of atoms, you must do this in a\nlater processing step, e.g. when using them in a\nvariable.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ave/correlate Nevery Nrepeat Nfreq value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ave/correlate = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of correlation time windows to accumulate\n * Nfreq = calculate time window averages every this many timesteps\n * one or more input values can be listed\n * value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = global scalar calculated by a compute with ID\n * c_ID[I] = Ith component of global vector calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = global scalar calculated by a fix with ID\n * f_ID[I] = Ith component of global vector calculated by a fix with ID, I can include wildcard (see below)\n * v_name = global value calculated by an equal-style variable with name\n * v_name[I] = Ith component of a vector-style variable with name\n * zero or more keyword/arg pairs may be appended\n * keyword = type or ave or start or prefactor or file or overwrite or title1 or title2 or title3\n * type arg = auto or upper or lower or auto/upper or auto/lower or full\n *   auto = correlate each value with itself\n *   upper = correlate each value with each succeeding value\n *   lower = correlate each value with each preceding value\n *   auto/upper = auto + upper\n *   auto/lower = auto + lower\n *   full = correlate each value with every other value, including itself = auto + upper + lower\n * ave args = one or running\n *   one = zero the correlation accumulation every Nfreq steps\n *   running = accumulate correlations continuously\n * start args = Nstart\n *   Nstart = start accumulating correlations on this timestep\n * prefactor args = value\n *   value = prefactor to scale all the correlation data by\n * file arg = filename\n *   filename = name of file to output correlation data to\n * overwrite arg = none = overwrite output file with only latest output\n * title1 arg = string\n *   string = text to print as 1st line of output file\n * title2 arg = string\n *   string = text to print as 2nd line of output file\n * title3 arg = string\n *   string = text to print as 3rd line of output file",
    "examples": "fix 1 all ave/correlate 5 100 1000 c_myTemp file temp.correlate\nfix 1 all ave/correlate 1 50 10000 &\n          c_thermo_press[1] c_thermo_press[2] c_thermo_press[3] &\n          type upper ave running title1 \"My correlation data\"\n\n\nfix 1 all ave/correlate 1 50 10000 c_thermo_press[*]",
    "restrictions": "\nnone"
},
{
    "command": "fix ave/correlate/long",
    "html_filename": "fix_ave_correlate_long.html",
    "short_description": "This fix is similar in spirit and syntax to the fix ave/correlate",
    "description": "This fix is similar in spirit and syntax to the fix ave/correlate.\nHowever, this fix allows the efficient calculation of time correlation\nfunctions on-the-fly over extremely long time windows with little\nadditional CPU overhead, using a multiple-tau method\n(Ramirez) that decreases the resolution of the stored\ncorrelation function with time.  It is not a full drop-in replacement.\nThe group specified with this command is ignored.  However, note that\nspecified values may represent calculations performed by computes and\nfixes which store their own “group” definitions.\nEach listed value can be the result of a compute or fix or the\nevaluation of an equal-style variable. See the fix ave/correlate doc page for details.\nThe Nevery and Nfreq arguments specify on what timesteps the input\nvalues will be used to calculate correlation data, and the frequency\nwith which the time correlation functions will be output to a file.\nNote that there is no Nrepeat argument, unlike the fix ave/correlate command.\nThe optional keywords ncorr, nlen, and ncount are unique to this\ncommand and determine the number of correlation points calculated and\nthe memory and CPU overhead used by this calculation. Nlen and\nncount determine the amount of averaging done at longer correlation\ntimes.  The default values nlen=16, ncount=2 ensure that the\nsystematic error of the multiple-tau correlator is always below the\nlevel of the statistical error of a typical simulation (which depends\non the ensemble size and the simulation length).\nThe maximum correlation time (in time steps) that can be reached is\ngiven by the formula (nlen-1) * ncount^(ncorr-1).  Longer correlation\ntimes are discarded and not calculated.  With the default values of\nthe parameters (ncorr=20, nlen=16 and ncount=2), this corresponds to\n7864320 time steps.  If longer correlation times are needed, the value\nof ncorr should be increased. Using nlen=16 and ncount=2, with\nncorr=30, the maximum number of steps that can be correlated is\n80530636808.  If ncorr=40, correlation times in excess of 8e12 time\nsteps can be calculated.\nThe total memory needed for each correlation pair is roughly\n4*ncorr*nlen*8 bytes. With the default values of the parameters, this\ncorresponds to about 10 KB.\nFor the meaning of the additional optional keywords, see the fix ave/correlate doc page.\nRestart, fix_modify, output, run start/stop, minimize info:\nContrary to fix ave/correlate this fix\ndoes not provide access to its internal data to various output\noptions. Since this fix in intended for the calculation of time\ncorrelation functions over very long MD simulations, the information\nabout this fix is written automatically to binary restart files, so\nthat the time correlation calculation can continue in subsequent\nsimulations. None of the fix_modify options are relevant to this fix.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command. This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ave/correlate/long Nevery Nfreq value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ave/correlate/long = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nfreq = save state of the time correlation functions every this many timesteps\n * one or more input values can be listed\n * value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = global scalar calculated by a compute with ID\n * c_ID[I] = Ith component of global vector calculated by a compute with ID\n * f_ID = global scalar calculated by a fix with ID\n * f_ID[I] = Ith component of global vector calculated by a fix with ID\n * v_name = global value calculated by an equal-style variable with name\n * zero or more keyword/arg pairs may be appended\n * keyword = type or start or file or overwrite or title1 or title2 or ncorr or p or m\n * type arg = auto or upper or lower or auto/upper or auto/lower or full\n *   auto = correlate each value with itself\n *   upper = correlate each value with each succeeding value\n *   lower = correlate each value with each preceding value\n *   auto/upper = auto + upper\n *   auto/lower = auto + lower\n *   full = correlate each value with every other value, including itself = auto + upper + lower\n * start args = Nstart\n *   Nstart = start accumulating correlations on this timestep\n * file arg = filename\n *   filename = name of file to output correlation data to\n * overwrite arg = none = overwrite output file with only latest output\n * title1 arg = string\n *   string = text to print as 1st line of output file\n * title2 arg = string\n *   string = text to print as 2nd line of output file\n * ncorr arg = Ncorrelators\n *   Ncorrelators = number of correlators to store\n * nlen args = Nlen\n *   Nlen = length of each correlator\n * ncount args = Ncount\n *   Ncount = number of values over which succesive correlators are averaged",
    "examples": "fix 1 all ave/correlate/long 5 1000 c_myTemp file temp.correlate\nfix 1 all ave/correlate/long 1 10000 &\n          c_thermo_press[1] c_thermo_press[2] c_thermo_press[3] &\n          type upper title1 \"My correlation data\" nlen 15 ncount 3",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix ave/histo",
    "html_filename": "fix_ave_histo.html",
    "short_description": "Use one or more values as inputs every few timesteps to create a single histogram",
    "description": "Use one or more values as inputs every few timesteps to create a\nsingle histogram.  The histogram can then be averaged over longer\ntimescales.  The resulting histogram can be used by other output commands, and can also be written to a file.  The\nfix ave/histo/weight command has identical syntax to fix ave/histo,\nexcept that exactly two values must be specified.  See details below.\nThe group specified with this command is ignored for global and local\ninput values.  For per-atom input values, only atoms in the group\ncontribute to the histogram.  Note that regardless of the specified\ngroup, specified values may represent calculations performed by\ncomputes and fixes which store their own “group” definition.\nA histogram is simply a count of the number of values that fall within\na histogram bin.  Nbins are defined, with even spacing between lo\nand hi.  Values that fall outside the lo/hi bounds can be treated in\ndifferent ways; see the discussion of the beyond keyword below.\nEach input value can be an atom attribute (position, velocity, force\ncomponent) or can be the result of a compute or\nfix or the evaluation of an equal-style or vector-style or\natom-style variable.  The set of input values can be\neither all global, all per-atom, or all local quantities.  Inputs of\ndifferent kinds (e.g. global and per-atom) cannot be mixed.  Atom\nattributes are per-atom vector values.  See the doc page for\nindividual “compute” and “fix” commands to see what kinds of\nquantities they generate.  See the optional kind keyword below for\nhow to force the fix ave/histo command to disambiguate if necessary.\nNote that the output of this command is a single histogram for all\ninput values combined together, not one histogram per input value.\nSee below for details on the format of the output of this fix.\nThe input values must either be all scalars or all vectors (or\narrays), depending on the setting of the mode keyword.\nIf mode = scalar, then the input values must be scalars, or vectors\nwith a bracketed term appended, indicating the Ith value of the vector\nis used.\nIf mode = vector, then the input values must be vectors, or arrays\nwith a bracketed term appended, indicating the Ith column of the array\nis used.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual elements of the\nvector or columns of the array had been listed one by one.  E.g. these\n2 fix ave/histo commands are equivalent, since the compute com/chunk command creates a global array with\n3 columns:\ncompute myCOM all com/chunk\nfix 1 all ave/histo 100 1 100 c_myCOM[*] file tmp1.com mode vector\nfix 2 all ave/histo 100 1 100 c_myCOM[1] c_myCOM[2] c_myCOM[3] file tmp2.com mode vector\nIf the fix ave/histo/weight command is used, exactly two values must\nbe specified.  If the values are vectors, they must be the same\nlength.  The first value (a scalar or vector) is what is histogrammed\ninto bins, in the same manner the fix ave/histo command operates.  The\nsecond value (a scalar or vector) is used as a “weight”.  This means\nthat instead of each value tallying a “1” to its bin, the\ncorresponding weight is tallied.  E.g. The Nth entry (weight) in the\nsecond vector is tallied to the bin corresponding to the Nth entry in\nthe first vector.\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be used in order to contribute to the\nhistogram.  The final histogram is generated on timesteps that are\nmultiple of Nfreq.  It is averaged over Nrepeat histograms,\ncomputed in the preceding portion of the simulation every Nevery\ntimesteps.  Nfreq must be a multiple of Nevery and Nevery must\nbe non-zero even if Nrepeat is 1.  Also, the timesteps\ncontributing to the histogram value cannot overlap,\ni.e. Nrepeat*Nevery can not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then input values\non timesteps 90,92,94,96,98,100 will be used to compute the final\nhistogram on timestep 100.  Similarly for timesteps\n190,192,194,196,198,200 on timestep 200, etc.  If Nrepeat=1 and Nfreq\n= 100, then no time averaging of the histogram is done; a histogram is\nsimply generated on timesteps 100,200,etc.\n\nThe atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\nself-explanatory.  Note that other atom attributes can be used as\ninputs to this fix by using the compute property/atom command and then specifying\nan input value from that compute.\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If mode = scalar, then if\nno bracketed term is appended, the global scalar calculated by the\ncompute is used.  If a bracketed term is appended, the Ith element of\nthe global vector calculated by the compute is used.  If mode =\nvector, then if no bracketed term is appended, the global or per-atom\nor local vector calculated by the compute is used.  If a bracketed\nterm is appended, the Ith column of the global or per-atom or local\narray calculated by the compute is used.  See the discussion above for\nhow I can be specified with a wildcard asterisk to effectively specify\nmultiple values.\nNote that there is a compute reduce command\nwhich can sum per-atom quantities into a global scalar or vector which\ncan thus be accessed by fix ave/histo.  Or it can be a compute defined\nnot in your input script, but by thermodynamic output or other fixes such as fix nvt\nor fix temp/rescale.  See the doc pages for\nthese commands which give the IDs of these computes.  Users can also\nwrite code for their own compute styles and add them to LAMMPS.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If mode = scalar, then if\nno bracketed term is appended, the global scalar calculated by the fix\nis used.  If a bracketed term is appended, the Ith element of the\nglobal vector calculated by the fix is used.  If mode = vector, then\nif no bracketed term is appended, the global or per-atom or local\nvector calculated by the fix is used.  If a bracketed term is\nappended, the Ith column of the global or per-atom or local array\ncalculated by the fix is used.  See the discussion above for how I can\nbe specified with a wildcard asterisk to effectively specify multiple\nvalues.\nNote that some fixes only produce their values on certain timesteps,\nwhich must be compatible with Nevery, else an error will result.\nUsers can also write code for their own fix styles and add them to LAMMPS.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  If mode = scalar, then\nonly equal-style or vector-style variables can be used, which both\nproduce global values.  In this mode, a vector-style variable requires\na bracketed term to specify the Ith element of the vector calculated\nby the variable.  If mode = vector, then only vector-style or\natom-style variables can be used, which produce a global or per-atom\nvector respectively.  The vector-style variable must be used without a\nbracketed term.  See the variable command for details.\nNote that variables of style equal, vector, and atom define a\nformula which can reference individual atom properties or\nthermodynamic keywords, or they can invoke other computes, fixes, or\nvariables when they are evaluated, so this is a very general means of\nspecifying quantities to histogram.\n\nAdditional optional keywords also affect the operation of this fix.\nIf the mode keyword is set to scalar, then all input values must\nbe global scalars, or elements of global vectors.  If the mode\nkeyword is set to vector, then all input values must be global or\nper-atom or local vectors, or columns of global or per-atom or local\narrays.\nThe kind keyword only needs to be set if a compute or fix produces\nmore than one kind of output (global, per-atom, local).  If this is\nnot the case, then LAMMPS will determine what kind of input is\nprovided and whether all the input arguments are consistent.  If a\ncompute or fix produces more than one kind of output, the kind\nkeyword should be used to specify which output will be used.  The\nremaining input arguments must still be consistent.\nThe beyond keyword determines how input values that fall outside the\nlo to hi bounds are treated.  Values such that lo <= value <=\nhi are assigned to one bin.  Values on a bin boundary are assigned\nto the lower of the 2 bins.  If beyond is set to ignore then\nvalues < lo and values > hi are ignored, i.e. they are not binned.\nIf beyond is set to end then values < lo are counted in the\nfirst bin and values > hi are counted in the last bin.  If beyond\nis set to extend then two extra bins are created, so that there are\nNbins+2 total bins.  Values < lo are counted in the first bin and\nvalues > hi are counted in the last bin (Nbins+2).  Values between\nlo and hi (inclusive) are counted in bins 2 through Nbins+1.  The\n“coordinate” stored and printed for these two extra bins is lo and\nhi.\nThe ave keyword determines how the histogram produced every Nfreq\nsteps are averaged with histograms produced on previous steps that\nwere multiples of Nfreq, before they are accessed by another output\ncommand or written to a file.\nIf the ave setting is one, then the histograms produced on\ntimesteps that are multiples of Nfreq are independent of each other;\nthey are output as-is without further averaging.\nIf the ave setting is running, then the histograms produced on\ntimesteps that are multiples of Nfreq are summed and averaged in a\ncumulative sense before being output.  Each bin value in the histogram\nis thus the average of the bin value produced on that timestep with\nall preceding values for the same bin.  This running average begins\nwhen the fix is defined; it can only be restarted by deleting the fix\nvia the unfix command, or by re-defining the fix by\nre-specifying it.\nIf the ave setting is window, then the histograms produced on\ntimesteps that are multiples of Nfreq are summed within a moving\n“window” of time, so that the last M histograms are used to produce\nthe output.  E.g. if M = 3 and Nfreq = 1000, then the output on step\n10000 will be the combined histogram of the individual histograms on\nsteps 8000,9000,10000.  Outputs on early steps will be sums over less\nthan M histograms if they are not available.\nThe start keyword specifies what timestep histogramming will begin\non.  The default is step 0.  Often input values can be 0.0 at time 0,\nso setting start to a larger value can avoid including a 0.0 in\na running or windowed histogram.\nThe file keyword allows a filename to be specified.  Every Nfreq\nsteps, one histogram is written to the file.  This includes a leading\nline that contains the timestep, number of bins, the total count of\nvalues contributing to the histogram, the count of values that were\nnot histogrammed (see the beyond keyword), the minimum value\nencountered, and the maximum value encountered.  The min/max values\ninclude values that were not histogrammed.  Following the leading\nline, one line per bin is written into the file.  Each line contains\nthe bin #, the coordinate for the center of the bin (between lo and\nhi), the count of values in the bin, and the normalized count.  The\nnormalized count is the bin count divided by the total count (not\nincluding values not histogrammed), so that the normalized values sum\nto 1.0 across all bins.\nThe overwrite keyword will continuously overwrite the output file\nwith the latest output, so that it only contains one timestep worth of\noutput.  This option can only be used with the ave running setting.\nThe title1 and title2 and title3 keywords allow specification of\nthe strings that will be printed as the first 3 lines of the output\nfile, assuming the file keyword was used.  LAMMPS uses default\nvalues for each of these, so they do not need to be specified.\nBy default, these header lines are as follows:\n# Histogram for fix ID\n# TimeStep Number-of-bins Total-counts Missing-counts Min-value Max-value\n# Bin Coord Count Count/Total\n\n\nIn the first line, ID is replaced with the fix-ID.  The second line\ndescribes the six values that are printed at the first of each section\nof output.  The third describes the 4 values printed for each bin in\nthe histogram.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix produces a global vector and global array which can be\naccessed by various output commands.  The values\ncan only be accessed on timesteps that are multiples of Nfreq since\nthat is when a histogram is generated.  The global vector has 4\nvalues:\n\n1 = total counts in the histogram\n2 = values that were not histogrammed (see beyond keyword)\n3 = min value of all input values, including ones not histogrammed\n4 = max value of all input values, including ones not histogrammed\n\nThe global array has # of rows = Nbins and # of columns = 3.  The\nfirst column has the bin coordinate, the 2nd column has the count of\nvalues in that histogram bin, and the 3rd column has the bin count\ndivided by the total count (not including missing counts), so that the\nvalues in the 3rd column sum to 1.0.\nThe vector and array values calculated by this fix are all treated as\nintensive.  If this is not the case, e.g. due to histogramming\nper-atom input values, then you will need to account for that when\ninterpreting the values produced by this fix.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID style Nevery Nrepeat Nfreq lo hi Nbin value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = ave/histo or ave/histo/weight = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of times to use input values for calculating histogram\n * Nfreq = calculate histogram every this many timesteps\n * lo,hi = lo/hi bounds within which to histogram\n * Nbin = # of histogram bins\n * one or more input values can be listed\n * value = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n * c_ID = scalar or vector calculated by a compute with ID\n * c_ID[I] = Ith component of vector or Ith column of array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = scalar or vector calculated by a fix with ID\n * f_ID[I] = Ith component of vector or Ith column of array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = value(s) calculated by an equal-style or vector-style or atom-style variable with name\n * v_name[I] = value calculated by a vector-style variable with name\n * zero or more keyword/arg pairs may be appended\n * keyword = mode or file or ave or start or beyond or overwrite or title1 or title2 or title3\n * mode arg = scalar or vector\n *   scalar = all input values are scalars\n *   vector = all input values are vectors\n * kind arg = global or peratom or local\n * file arg = filename\n *   filename = name of file to output histogram(s) to\n * ave args = one or running or window\n *   one = output a new average value every Nfreq steps\n *   running = output cumulative average of all previous Nfreq steps\n *   window M = output average of M most recent Nfreq steps\n * start args = Nstart\n *   Nstart = start averaging on this timestep\n * beyond arg = ignore or end or extra\n *   ignore = ignore values outside histogram lo/hi bounds\n *   end = count values outside histogram lo/hi bounds in end bins\n *   extra = create 2 extra bins for value outside histogram lo/hi bounds\n * overwrite arg = none = overwrite output file with only latest output\n * title1 arg = string\n *   string = text to print as 1st line of output file\n * title2 arg = string\n *   string = text to print as 2nd line of output file\n * title3 arg = string\n *   string = text to print as 3rd line of output file, only for vector mode",
    "examples": "fix 1 all ave/histo 100 5 1000 0.5 1.5 50 c_myTemp file temp.histo ave running\nfix 1 all ave/histo 100 5 1000 -5 5 100 c_thermo_press[2] c_thermo_press[3] title1 \"My output values\"\nfix 1 all ave/histo 100 5 1000 -5 5 100 c_thermo_press[*]\nfix 1 all ave/histo 1 100 1000 -2.0 2.0 18 vx vy vz mode vector ave running beyond extra\nfix 1 all ave/histo/weight 1 1 1 10 100 2000 c_XRD[1] c_XRD[2]",
    "restrictions": "\nnone"
},
{
    "command": "fix ave/time",
    "html_filename": "fix_ave_time.html",
    "short_description": "Use one or more global values as inputs every few timesteps, and average them over longer timescales",
    "description": "Use one or more global values as inputs every few timesteps, and\naverage them over longer timescales.  The resulting averages can be\nused by other output commands such as\nthermo_style custom, and can also be written to a\nfile.  Note that if no time averaging is done, this command can be\nused as a convenient way to simply output one or more global values to\na file.\nThe group specified with this command is ignored.  However, note that\nspecified values may represent calculations performed by computes and\nfixes which store their own “group” definitions.\nEach listed value can be the result of a compute or\nfix or the evaluation of an equal-style or vector-style\nvariable.  In each case, the compute, fix, or variable\nmust produce a global quantity, not a per-atom or local quantity.  If\nyou wish to spatial- or time-average or histogram per-atom quantities\nfrom a compute, fix, or variable, then see the fix ave/chunk, fix ave/atom,\nor fix ave/histo commands.  If you wish to sum a\nper-atom quantity into a single global quantity, see the compute reduce command.\nComputes that produce global quantities are those which\ndo not have the word atom in their style name.  Only a few\nfixes produce global quantities.  See the doc pages for\nindividual fixes for info on which ones produce such values.\nVariables of style equal and vector are the only\nones that can be used with this fix.  Variables of style atom cannot\nbe used, since they produce per-atom values.\nThe input values must either be all scalars or all vectors depending\non the setting of the mode keyword.  In both cases, the averaging is\nperformed independently on each input value.  I.e. each input scalar\nis averaged independently or each element of each input vector is\naveraged independently.\nIf mode = scalar, then the input values must be scalars, or vectors\nwith a bracketed term appended, indicating the Ith value of the vector\nis used.\nIf mode = vector, then the input values must be vectors, or arrays\nwith a bracketed term appended, indicating the Ith column of the array\nis used.  All vectors must be the same length, which is the length of\nthe vector or number of rows in the array.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual elements of the\nvector or columns of the array had been listed one by one.  E.g. these\n2 fix ave/time commands are equivalent, since the compute rdf command creates, in this case, a global array\nwith 3 columns, each of length 50:\ncompute myRDF all rdf 50 1 2\nfix 1 all ave/time 100 1 100 c_myRDF[*] file tmp1.rdf mode vector\nfix 2 all ave/time 100 1 100 c_myRDF[1] c_myRDF[2] c_myRDF[3] file tmp2.rdf mode vector\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be used in order to contribute to the\naverage.  The final averaged quantities are generated on timesteps\nthat are a multiple of Nfreq.  The average is over Nrepeat\nquantities, computed in the preceding portion of the simulation every\nNevery timesteps.  Nfreq must be a multiple of Nevery and\nNevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\ncontributing to the average value cannot overlap,\ni.e. Nrepeat*Nevery can not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\ntimesteps 90,92,94,96,98,100 will be used to compute the final average\non timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\ntimestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\naveraging is done; values are simply generated on timesteps\n100,200,etc.\n\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If mode = scalar, then if\nno bracketed term is appended, the global scalar calculated by the\ncompute is used.  If a bracketed term is appended, the Ith element of\nthe global vector calculated by the compute is used.  If mode =\nvector, then if no bracketed term is appended, the global vector\ncalculated by the compute is used.  If a bracketed term is appended,\nthe Ith column of the global array calculated by the compute is used.\nSee the discussion above for how I can be specified with a wildcard\nasterisk to effectively specify multiple values.\nNote that there is a compute reduce command\nwhich can sum per-atom quantities into a global scalar or vector which\ncan thus be accessed by fix ave/time.  Or it can be a compute defined\nnot in your input script, but by thermodynamic output or other fixes such as fix nvt or fix temp/rescale.  See\nthe doc pages for these commands which give the IDs of these computes.\nUsers can also write code for their own compute styles and add them to LAMMPS.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If mode = scalar, then if\nno bracketed term is appended, the global scalar calculated by the fix\nis used.  If a bracketed term is appended, the Ith element of the\nglobal vector calculated by the fix is used.  If mode = vector, then\nif no bracketed term is appended, the global vector calculated by the\nfix is used.  If a bracketed term is appended, the Ith column of the\nglobal array calculated by the fix is used.  See the discussion above\nfor how I can be specified with a wildcard asterisk to effectively\nspecify multiple values.\nNote that some fixes only produce their values on certain timesteps,\nwhich must be compatible with Nevery, else an error will result.\nUsers can also write code for their own fix styles and add them to LAMMPS.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  If mode = scalar, then\nonly equal-style or vector-style variables can be used, which both\nproduce global values.  In this mode, a vector-style variable requires\na bracketed term to specify the Ith element of the vector calculated\nby the variable.  If mode = vector, then only a vector-style\nvariable can be used, without a bracketed term.  See the\nvariable command for details.\nNote that variables of style equal and vector define a formula\nwhich can reference individual atom properties or thermodynamic\nkeywords, or they can invoke other computes, fixes, or variables when\nthey are evaluated, so this is a very general means of specifying\nquantities to time average.\n\nAdditional optional keywords also affect the operation of this fix.\nIf the mode keyword is set to scalar, then all input values must\nbe global scalars, or elements of global vectors.  If the mode\nkeyword is set to vector, then all input values must be global\nvectors, or columns of global arrays.  They can also be global arrays,\nwhich are converted into a series of global vectors (one per column),\nas explained above.\nThe ave keyword determines how the values produced every Nfreq\nsteps are averaged with values produced on previous steps that were\nmultiples of Nfreq, before they are accessed by another output\ncommand or written to a file.\nIf the ave setting is one, then the values produced on timesteps\nthat are multiples of Nfreq are independent of each other; they are\noutput as-is without further averaging.\nIf the ave setting is running, then the values produced on\ntimesteps that are multiples of Nfreq are summed and averaged in a\ncumulative sense before being output.  Each output value is thus the\naverage of the value produced on that timestep with all preceding\nvalues.  This running average begins when the fix is defined; it can\nonly be restarted by deleting the fix via the unfix\ncommand, or by re-defining the fix by re-specifying it.\nIf the ave setting is window, then the values produced on\ntimesteps that are multiples of Nfreq are summed and averaged within\na moving “window” of time, so that the last M values are used to\nproduce the output.  E.g. if M = 3 and Nfreq = 1000, then the output\non step 10000 will be the average of the individual values on steps\n8000,9000,10000.  Outputs on early steps will average over less than M\nvalues if they are not available.\nThe start keyword specifies what timestep averaging will begin on.\nThe default is step 0.  Often input values can be 0.0 at time 0, so\nsetting start to a larger value can avoid including a 0.0 in a\nrunning or windowed average.\nThe off keyword can be used to flag any of the input values.  If a\nvalue is flagged, it will not be time averaged.  Instead the most\nrecent input value will always be stored and output.  This is useful\nif one of more of the inputs produced by a compute or fix or variable\nare effectively constant or are simply current values.  E.g. they are\nbeing written to a file with other time-averaged values for purposes\nof creating well-formatted output.\nThe file keyword allows a filename to be specified.  Every Nfreq\nsteps, one quantity or vector of quantities is written to the file for\neach input value specified in the fix ave/time command.  For mode =\nscalar, this means a single line is written each time output is\nperformed.  Thus the file ends up to be a series of lines, i.e. one\ncolumn of numbers for each input value.  For mode = vector, an array\nof numbers is written each time output is performed.  The number of\nrows is the length of the input vectors, and the number of columns is\nthe number of values.  Thus the file ends up to be a series of these\narray sections.\nThe overwrite keyword will continuously overwrite the output file\nwith the latest output, so that it only contains one timestep worth of\noutput.  This option can only be used with the ave running setting.\nThe format keyword sets the numeric format of each value when it is\nprinted to a file via the file keyword.  Note that all values are\nfloating point quantities.  The default format is %g.  You can specify\na higher precision if desired, e.g. %20.16g.\nThe title1 and title2 and title3 keywords allow specification of\nthe strings that will be printed as the first 2 or 3 lines of the\noutput file, assuming the file keyword was used.  LAMMPS uses\ndefault values for each of these, so they do not need to be specified.\nBy default, these header lines are as follows for mode = scalar:\n# Time-averaged data for fix ID\n# TimeStep value1 value2 ...\n\n\nIn the first line, ID is replaced with the fix-ID.  In the second line\nthe values are replaced with the appropriate fields from the fix\nave/time command.  There is no third line in the header of the file,\nso the title3 setting is ignored when mode = scalar.\nBy default, these header lines are as follows for mode = vector:\n# Time-averaged data for fix ID\n# TimeStep Number-of-rows\n# Row value1 value2 ...\n\n\nIn the first line, ID is replaced with the fix-ID.  The second line\ndescribes the two values that are printed at the first of each section\nof output.  In the third line the values are replaced with the\nappropriate fields from the fix ave/time command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix produces a global scalar or global vector or global array\nwhich can be accessed by various output commands.\nThe values can only be accessed on timesteps that are multiples of\nNfreq since that is when averaging is performed.\nA scalar is produced if only a single input value is averaged and\nmode = scalar.  A vector is produced if multiple input values are\naveraged for mode = scalar, or a single input value for mode =\nvector.  In the first case, the length of the vector is the number of\ninputs.  In the second case, the length of the vector is the same as\nthe length of the input vector.  An array is produced if multiple\ninput values are averaged and mode = vector.  The global array has #\nof rows = length of the input vectors and # of columns = number of\ninputs.\nIf the fix produces a scalar or vector, then the scalar and each\nelement of the vector can be either “intensive” or “extensive”,\ndepending on whether the values contributing to the scalar or vector\nelement are “intensive” or “extensive”.  If the fix produces an array,\nthen all elements in the array must be the same, either “intensive” or\n“extensive”.  If a compute or fix provides the value being time\naveraged, then the compute or fix determines whether the value is\nintensive or extensive; see the doc page for that compute or fix for\nfurther info.  Values produced by a variable are treated as intensive.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ave/time Nevery Nrepeat Nfreq value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ave/time = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of times to use input values for calculating averages\n * Nfreq = calculate averages every this many timesteps\n * one or more input values can be listed\n * value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = global scalar or vector calculated by a compute with ID\n * c_ID[I] = Ith component of global vector or Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = global scalar or vector calculated by a fix with ID\n * f_ID[I] = Ith component of global vector or Ith column of global array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = value(s) calculated by an equal-style or vector-style variable with name\n * v_name[I] = value calculated by a vector-style variable with name\n * zero or more keyword/arg pairs may be appended\n * keyword = mode or file or ave or start or off or overwrite or title1 or title2 or title3\n * mode arg = scalar or vector\n *   scalar = all input values are global scalars\n *   vector = all input values are global vectors or global arrays\n * ave args = one or running or window M\n *   one = output a new average value every Nfreq steps\n *   running = output cumulative average of all previous Nfreq steps\n *   window M = output average of M most recent Nfreq steps\n * start args = Nstart\n *   Nstart = start averaging on this timestep\n * off arg = M = do not average this value\n *   M = value # from 1 to Nvalues\n * file arg = filename\n *   filename = name of file to output time averages to\n * overwrite arg = none = overwrite output file with only latest output\n * format arg = string\n *   string = C-style format string\n * title1 arg = string\n *   string = text to print as 1st line of output file\n * title2 arg = string\n *   string = text to print as 2nd line of output file\n * title3 arg = string\n *   string = text to print as 3rd line of output file, only for vector mode",
    "examples": "fix 1 all ave/time 100 5 1000 c_myTemp c_thermo_temp file temp.profile\nfix 1 all ave/time 100 5 1000 c_thermo_press[2] ave window 20 &\n                              title1 \"My output values\"\nfix 1 all ave/time 100 5 1000 c_thermo_press[*]\nfix 1 all ave/time 1 100 1000 f_indent f_indent[1] file temp.indent off 1",
    "restrictions": "\nnone"
},
{
    "command": "fix aveforce",
    "html_filename": "fix_aveforce.html",
    "short_description": "Apply an additional external force to a group of atoms in such a way that every atom experiences the same force",
    "description": "Apply an additional external force to a group of atoms in such a way\nthat every atom experiences the same force.  This is useful for\npushing on wall or boundary atoms so that the structure of the wall\ndoes not change over time.\nThe existing force is averaged for the group of atoms, component by\ncomponent.  The actual force on each atom is then set to the average\nvalue plus the component specified in this command.  This means each\natom in the group receives the same force.\nAny of the fx,fy,fz values can be specified as NULL which means the\nforce in that dimension is not changed.  Note that this is not the\nsame as specifying a 0.0 value, since that sets all forces to the same\naverage value without adding in any additional force.\nAny of the 3 quantities defining the force components can be specified\nas an equal-style variable, namely fx, fy, fz.\nIf the value is a variable, it should be specified as v_name, where\nname is the variable name.  In this case, the variable will be\nevaluated each timestep, and its value used to determine the average\nforce.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent average force.\nIf the region keyword is used, the atom must also be in the\nspecified geometric region in order to have force added\nto it.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global 3-vector of forces, which can be accessed\nby various output commands.  This is the total\nforce on the group of atoms before the forces on individual atoms are\nchanged by the fix.  The vector values calculated by this fix are\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  You should not\nspecify force components with a variable that has time-dependence for\nuse with a minimizer, since the minimizer increments the timestep as\nthe iteration count during the minimization.",
    "syntax": "fix ID group-ID aveforce fx fy fz keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * aveforce = style name of this fix command\n * fx,fy,fz = force component values (force units)\n * any of fx,fy,fz can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to have added force",
    "examples": "fix pressdown topwall aveforce 0.0 -1.0 0.0\nfix 2 bottomwall aveforce NULL -1.0 0.0 region top\nfix 2 bottomwall aveforce NULL -1.0 v_oscillate region top",
    "restrictions": "\nnone"
},
{
    "command": "fix balance",
    "html_filename": "fix_balance.html",
    "short_description": "This command adjusts the size and shape of processor sub-domains within the simulation box, to attempt to balance the number of particles and thus the computational cost (load) evenly across processors",
    "description": "This command adjusts the size and shape of processor sub-domains\nwithin the simulation box, to attempt to balance the number of\nparticles and thus the computational cost (load) evenly across\nprocessors.  The load balancing is “dynamic” in the sense that\nre-balancing is performed periodically during the simulation.  To\nperform “static” balancing, before or between runs, see the\nbalance command.\nLoad-balancing is typically most useful if the particles in the\nsimulation box have a spatially-varying density distribution or\nwhere the computational cost varies significantly between different\natoms. E.g. a model of a vapor/liquid interface, or a solid with\nan irregular-shaped geometry containing void regions, or\nhybrid pair style simulations which combine\npair styles with different computational cost.  In these cases, the\nLAMMPS default of dividing the simulation box volume into a\nregular-spaced grid of 3d bricks, with one equal-volume sub-domain\nper processor, may assign numbers of particles per processor in a\nway that the computational effort varies significantly.  This can\nlead to poor performance when the simulation is run in parallel.\nThe balancing can be performed with or without per-particle weighting.\nWith no weighting, the balancing attempts to assign an equal number of\nparticles to each processor.  With weighting, the balancing attempts\nto assign an equal aggregate computational weight to each processor,\nwhich typically induces a different number of atoms assigned to each\nprocessor.\n\nNote\nThe weighting options listed above are documented with the\nbalance command in this section of the balance command doc page.  That section\ndescribes the various weighting options and gives a few examples of\nhow they can be used.  The weighting options are the same for both the\nfix balance and balance commands.\n\nNote that the processors command allows some control\nover how the box volume is split across processors.  Specifically, for\na Px by Py by Pz grid of processors, it allows choice of Px, Py, and\nPz, subject to the constraint that Px * Py * Pz = P, the total number\nof processors.  This is sufficient to achieve good load-balance for\nsome problems on some processor counts.  However, all the processor\nsub-domains will still have the same shape and same volume.\nOn a particular timestep, a load-balancing operation is only performed\nif the current “imbalance factor” in particles owned by each processor\nexceeds the specified thresh parameter.  The imbalance factor is\ndefined as the maximum number of particles (or weight) owned by any\nprocessor, divided by the average number of particles (or weight) per\nprocessor.  Thus an imbalance factor of 1.0 is perfect balance.\nAs an example, for 10000 particles running on 10 processors, if the\nmost heavily loaded processor has 1200 particles, then the factor is\n1.2, meaning there is a 20% imbalance.  Note that re-balances can be\nforced even if the current balance is perfect (1.0) be specifying a\nthresh < 1.0.\n\nNote\nThis command attempts to minimize the imbalance factor, as\ndefined above.  But depending on the method a perfect balance (1.0)\nmay not be achieved.  For example, “grid” methods (defined below) that\ncreate a logical 3d grid cannot achieve perfect balance for many\nirregular distributions of particles.  Likewise, if a portion of the\nsystem is a perfect lattice, e.g. the initial system is generated by\nthe create_atoms command, then “grid” methods may\nbe unable to achieve exact balance.  This is because entire lattice\nplanes will be owned or not owned by a single processor.\n\n\nNote\nThe imbalance factor is also an estimate of the maximum speed-up\nyou can hope to achieve by running a perfectly balanced simulation\nversus an imbalanced one.  In the example above, the 10000 particle\nsimulation could run up to 20% faster if it were perfectly balanced,\nversus when imbalanced.  However, computational cost is not strictly\nproportional to particle count, and changing the relative size and\nshape of processor sub-domains may lead to additional computational\nand communication overheads, e.g. in the PPPM solver used via the\nkspace_style command.  Thus you should benchmark\nthe run times of a simulation before and after balancing.\n\n\nThe method used to perform a load balance is specified by one of the\nlisted styles, which are described in detail below.  There are 2 kinds\nof styles.\nThe shift style is a “grid” method which produces a logical 3d grid\nof processors.  It operates by changing the cutting planes (or lines)\nbetween processors in 3d (or 2d), to adjust the volume (area in 2d)\nassigned to each processor, as in the following 2d diagram where\nprocessor sub-domains are shown and atoms are colored by the processor\nthat owns them.  The leftmost diagram is the default partitioning of\nthe simulation box across processors (one sub-box for each of 16\nprocessors); the middle diagram is after a “grid” method has been\napplied.\n\n\n\nThe rcb style is a “tiling” method which does not produce a logical\n3d grid of processors.  Rather it tiles the simulation domain with\nrectangular sub-boxes of varying size and shape in an irregular\nfashion so as to have equal numbers of particles (or weight) in each\nsub-box, as in the rightmost diagram above.\nThe “grid” methods can be used with either of the\ncomm_style command options, brick or tiled.  The\n“tiling” methods can only be used with comm_style tiled.\nWhen a “grid” method is specified, the current domain partitioning can\nbe either a logical 3d grid or a tiled partitioning.  In the former\ncase, the current logical 3d grid is used as a starting point and\nchanges are made to improve the imbalance factor.  In the latter case,\nthe tiled partitioning is discarded and a logical 3d grid is created\nwith uniform spacing in all dimensions.  This is the starting point\nfor the balancing operation.\nWhen a “tiling” method is specified, the current domain partitioning\n(“grid” or “tiled”) is ignored, and a new partitioning is computed\nfrom scratch.\n\nThe group-ID is ignored.  However the impact of balancing on\ndifferent groups of atoms can be affected by using the group weight\nstyle as described below.\nThe Nfreq setting determines how often a re-balance is performed.  If\nNfreq > 0, then re-balancing will occur every Nfreq steps.  Each\ntime a re-balance occurs, a reneighboring is triggered, so Nfreq\nshould not be too small.  If Nfreq = 0, then re-balancing will be\ndone every time reneighboring normally occurs, as determined by the\nthe neighbor and neigh_modify\ncommand settings.\nOn re-balance steps, re-balancing will only be attempted if the current\nimbalance factor, as defined above, exceeds the thresh setting.\n\nThe shift style invokes a “grid” method for balancing, as described\nabove.  It changes the positions of cutting planes between processors\nin an iterative fashion, seeking to reduce the imbalance factor.\nThe dimstr argument is a string of characters, each of which must be\nan “x” or “y” or “z”.  Eacn character can appear zero or one time,\nsince there is no advantage to balancing on a dimension more than\nonce.  You should normally only list dimensions where you expect there\nto be a density variation in the particles.\nBalancing proceeds by adjusting the cutting planes in each of the\ndimensions listed in dimstr, one dimension at a time.  For a single\ndimension, the balancing operation (described below) is iterated on up\nto Niter times.  After each dimension finishes, the imbalance factor\nis re-computed, and the balancing operation halts if the stopthresh\ncriterion is met.\nA re-balance operation in a single dimension is performed using a\ndensity-dependent recursive multisectioning algorithm, where the\nposition of each cutting plane (line in 2d) in the dimension is\nadjusted independently.  This is similar to a recursive bisectioning\nfor a single value, except that the bounds used for each bisectioning\ntake advantage of information from neighboring cuts if possible, as\nwell as counts of particles at the bounds on either side of each cuts,\nwhich themselves were cuts in previous iterations.  The latter is used\nto infer a density of particles near each of the current cuts.  At\neach iteration, the count of particles on either side of each plane is\ntallied.  If the counts do not match the target value for the plane,\nthe position of the cut is adjusted based on the local density.  The\nlow and high bounds are adjusted on each iteration, using new count\ninformation, so that they become closer together over time.  Thus as\nthe recursion progresses, the count of particles on either side of the\nplane gets closer to the target value.\nThe density-dependent part of this algorithm is often an advantage\nwhen you re-balance a system that is already nearly balanced.  It\ntypically converges more quickly than the geometric bisectioning\nalgorithm used by the balance command.  However, if can\nbe a disadvantage if you attempt to re-balance a system that is far\nfrom balanced, and converge more slowly.  In this case you probably\nwant to use the balance command before starting a run,\nso that you begin the run with a balanced system.\nOnce the re-balancing is complete and final processor sub-domains\nassigned, particles migrate to their new owning processor as part of\nthe normal reneighboring procedure.\n\nNote\nAt each re-balance operation, the bisectioning for each cutting\nplane (line in 2d) typically starts with low and high bounds separated\nby the extent of a processor’s sub-domain in one dimension.  The size\nof this bracketing region shrinks based on the local density, as\ndescribed above, which should typically be 1/2 or more every\niteration.  Thus if Niter is specified as 10, the cutting plane will\ntypically be positioned to better than 1 part in 1000 accuracy\n(relative to the perfect target position).  For Niter = 20, it will\nbe accurate to better than 1 part in a million.  Thus there is no need\nto set Niter to a large value.  This is especially true if you are\nre-balancing often enough that each time you expect only an incremental\nadjustment in the cutting planes is necessary.  LAMMPS will check if\nthe threshold accuracy is reached (in a dimension) is less iterations\nthan Niter and exit early.\n\n\nThe rcb style invokes a “tiled” method for balancing, as described\nabove.  It performs a recursive coordinate bisectioning (RCB) of the\nsimulation domain. The basic idea is as follows.\nThe simulation domain is cut into 2 boxes by an axis-aligned cut in\nthe longest dimension, leaving one new box on either side of the cut.\nAll the processors are also partitioned into 2 groups, half assigned\nto the box on the lower side of the cut, and half to the box on the\nupper side.  (If the processor count is odd, one side gets an extra\nprocessor.)  The cut is positioned so that the number of atoms in the\nlower box is exactly the number that the processors assigned to that\nbox should own for load balance to be perfect.  This also makes load\nbalance for the upper box perfect.  The positioning is done\niteratively, by a bisectioning method.  Note that counting atoms on\neither side of the cut requires communication between all processors\nat each iteration.\nThat is the procedure for the first cut.  Subsequent cuts are made\nrecursively, in exactly the same manner.  The subset of processors\nassigned to each box make a new cut in the longest dimension of that\nbox, splitting the box, the subset of processors, and the atoms in\nthe box in two.  The recursion continues until every processor is\nassigned a sub-box of the entire simulation domain, and owns the atoms\nin that sub-box.\n\nThe out keyword writes text to the specified filename with the\nresults of each re-balancing operation.  The file contains the bounds\nof the sub-domain for each processor after the balancing operation\ncompletes.  The format of the file is compatible with the\nPizza.py mdump tool which has support for manipulating and\nvisualizing mesh files.  An example is shown here for a balancing by 4\nprocessors for a 2d problem:\nITEM: TIMESTEP\n0\nITEM: NUMBER OF NODES\n16\nITEM: BOX BOUNDS\n0 10\n0 10\n0 10\nITEM: NODES\n1 1 0 0 0\n2 1 5 0 0\n3 1 5 5 0\n4 1 0 5 0\n5 1 5 0 0\n6 1 10 0 0\n7 1 10 5 0\n8 1 5 5 0\n9 1 0 5 0\n10 1 5 5 0\n11 1 5 10 0\n12 1 10 5 0\n13 1 5 5 0\n14 1 10 5 0\n15 1 10 10 0\n16 1 5 10 0\nITEM: TIMESTEP\n0\nITEM: NUMBER OF SQUARES\n4\nITEM: SQUARES\n1 1 1 2 3 4\n2 1 5 6 7 8\n3 1 9 10 11 12\n4 1 13 14 15 16\n\n\nThe coordinates of all the vertices are listed in the NODES section, 5\nper processor.  Note that the 4 sub-domains share vertices, so there\nwill be duplicate nodes in the list.\nThe “SQUARES” section lists the node IDs of the 4 vertices in a\nrectangle for each processor (1 to 4).\nFor a 3d problem, the syntax is similar with 8 vertices listed for\neach processor, instead of 4, and “SQUARES” replaced by “CUBES”.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which is the imbalance factor\nafter the most recent re-balance and a global vector of length 3 with\nadditional information about the most recent re-balancing.  The 3\nvalues in the vector are as follows:\n\n1 = max # of particles per processor\n2 = total # iterations performed in last re-balance\n3 = imbalance factor right before the last re-balance was performed\n\nAs explained above, the imbalance factor is the ratio of the maximum\nnumber of particles (or total weight) on any processor to the average\nnumber of particles (or total weight) per processor.\nThese quantities can be accessed by various output commands.  The scalar and vector values calculated\nby this fix are “intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID balance Nfreq thresh style args keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * balance = style name of this fix command\n * Nfreq = perform dynamic load balancing every this many steps\n * thresh = imbalance threshold that must be exceeded to perform a re-balance\n * style = shift or rcb\n * shift args = dimstr Niter stopthresh\n *   dimstr = sequence of letters containing \"x\" or \"y\" or \"z\", each not more than once\n *   Niter = # of times to iterate within each dimension of dimstr sequence\n *   stopthresh = stop balancing when this imbalance threshold is reached\n * rcb args = none\n * zero or more keyword/arg pairs may be appended\n * keyword = weight or out\n * weight style args = use weighted particle counts for the balancing\n *   style = group or neigh or time or var or store\n *     group args = Ngroup group1 weight1 group2 weight2 ...\n *       Ngroup = number of groups with assigned weights\n *       group1, group2, ... = group IDs\n *       weight1, weight2, ...   = corresponding weight factors\n *     neigh factor = compute weight based on number of neighbors\n *       factor = scaling factor (> 0)\n *     time factor = compute weight based on time spend computing\n *       factor = scaling factor (> 0)\n *     var name = take weight from atom-style variable\n *       name = name of the atom-style variable\n *     store name = store weight in custom atom property defined by fix property/atom command\n *       name = atom property name (without d_ prefix)\n * out arg = filename\n *   filename = write each processor's sub-domain to a file, at each re-balancing",
    "examples": "fix 2 all balance 1000 1.05 shift x 10 1.05\nfix 2 all balance 100 0.9 shift xy 20 1.1 out tmp.balance\nfix 2 all balance 100 0.9 shift xy 20 1.1 weight group 3 substrate 3.0 solvent 1.0 solute 0.8 out tmp.balance\nfix 2 all balance 100 1.0 shift x 10 1.1 weight time 0.8\nfix 2 all balance 100 1.0 shift xy 5 1.1 weight var myweight weight neigh 0.6 weight store allweight\nfix 2 all balance 1000 1.1 rcb",
    "restrictions": "For 2d simulations, the z style cannot be used.  Nor can a “z”\nappear in dimstr for the shift style.\nBalancing through recursive bisectioning (rcb style) requires\ncomm_style tiled"
},
{
    "command": "fix bocs",
    "html_filename": "fix_bocs.html",
    "short_description": "These commands incorporate a pressure correction as described by Dunn and Noid in (Dunn1) to the standard MTTK barostat by Martyna et",
    "description": "These commands incorporate a pressure correction as described by\nDunn and Noid in (Dunn1) to the standard MTTK\nbarostat by Martyna et. al. in (Martyna) .\nThe first half of the command mimics a standard fix npt command:\nfix 1 all bocs temp Tstart Tstop Tcoupl cgiso Pstart Pstop Pdamp\n\n\nThe two differences are replacing npt with bocs, and replacing\niso/aniso/etc with cgiso.\nThe rest of the command details what form you would like to use for\nthe pressure correction equation. The choices are: analytic, linear_spline,\nor cubic_spline.\nWith either spline method, the only argument that needs to follow it\nis the name of a file that contains the desired pressure correction\nas a function of volume. The file must be formatted so each line has:\nVolume_i, PressureCorrection_i\n\n\nNote both the COMMA and the SPACE separating the volume’s\nvalue and its corresponding pressure correction. The volumes in the file\nmust be uniformly spaced. Both the volumes and the pressure corrections\nshould be provided in the proper units, e.g. if you are using units real,\nthe volumes should all be in cubic angstroms, and the pressure corrections\nshould all be in atmospheres. Furthermore, the table should start/end at a\nvolume considerably smaller/larger than you expect your system to sample\nduring the simulation. If the system ever reaches a volume outside of the\nrange provided, the simulation will stop.\nWith the analytic option, the arguments are as follows:\n... analytic V_avg N_particles N_coeff Coeff_1 Coeff_2 ... Coeff_N\n\n\nNote that V_avg and Coeff_i should all be in the proper units, e.g. if you\nare using units real, V_avg should be in cubic angstroms, and the\ncoefficients should all be in atmospheres * cubic angstroms.",
    "syntax": "fix  ID group-ID bocs keyword values ...",
    "parameters": " * keyword = temp or cgiso or analytic or linear_spline or cubic_spline\n *   temp values = Tstart Tstop Tdamp\n *   cgiso values = Pstart Pstop Pdamp\n *   basis set\n *     analytic values = V_avg N_particles N_coeff Coeff_1 Coeff_2 ... Coeff_N\n *     linear_spline values = input_filename\n *     cubic_spline values = input_filename",
    "examples": "fix 1 all bocs temp 300.0 300.0 100.0 cgiso 0.986 0.986 1000.0 analytic 66476.015 968 2 245030.10 8962.20\n\nfix 1 all bocs temp 300.0 300.0 100.0 cgiso 0.986 0.986 1000.0 cubic_spline input_Fv.dat\n\nthermo_modify press 1_press",
    "restrictions": "As this is computing a (modified) pressure, group-ID should be all.\nThe pressure correction has only been tested for use with an isotropic\npressure coupling in 3 dimensions.\nBy default, LAMMPS will still report the normal value for the pressure\nif the pressure is printed via a thermo command, or if the pressures\nare written to a file every so often. In order to have LAMMPS report the\nmodified pressure, you must include the thermo_modify command given in\nthe examples. For the last argument in the command, you should put\nXXXX_press, where XXXX is the ID given to the fix bocs command (in the\nexample, the ID of the fix bocs command is 1 ).\nThis fix is part of the USER-BOCS package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nRelated:\nFor more details about the pressure correction and the entire BOCS software\npackage, visit the BOCS package on GitHub and read the release\npaper by Dunn et. al. (Dunn2) .\n\n(Dunn1) Dunn and Noid, J Chem Phys, 143, 243148 (2015).\n(Martyna) Martyna, Tobias, and Klein, J Chem Phys, 101, 4177 (1994).\n(Dunn2) Dunn, Lebold, DeLyser, Rudzinski, and Noid, J. Phys. Chem. B, 122, 3363 (2018)."
},
{
    "command": "fix bond/break",
    "html_filename": "fix_bond_break.html",
    "short_description": "Break bonds between pairs of atoms as a simulation runs according to specified criteria",
    "description": "Break bonds between pairs of atoms as a simulation runs according to\nspecified criteria.  This can be used to model the dissolution of a\npolymer network due to stretching of the simulation box or other\ndeformations.  In this context, a bond means an interaction between a\npair of atoms computed by the bond_style command.\nOnce the bond is broken it will be permanently deleted, as will all\nangle, dihedral, and improper interactions that bond is part of.\nThis is different than a pairwise bond-order\npotential such as Tersoff or AIREBO which infers bonds and many-body\ninteractions based on the current geometry of a small cluster of atoms\nand effectively creates and destroys bonds and higher-order many-body\ninteractions from timestep to timestep as atoms move.\nA check for possible bond breakage is performed every Nevery\ntimesteps.  If two bonded atoms I,J are further than a distance Rmax\nof each other, if the bond is of type bondtype, and if both I and J\nare in the specified fix group, then I,J is labeled as a “possible”\nbond to break.\nIf several bonds involving an atom are stretched, it may have multiple\npossible bonds to break.  Every atom checks its list of possible bonds\nto break and labels the longest such bond as its “sole” bond to break.\nAfter this is done, if atom I is bonded to atom J in its sole bond,\nand atom J is bonded to atom I in its sole bond, then the I,J bond is\n“eligible” to be broken.\nNote that these rules mean an atom will only be part of at most one\nbroken bond on a given timestep.  It also means that if atom I chooses\natom J as its sole partner, but atom J chooses atom K is its sole\npartner (due to Rjk > Rij), then this means atom I will not be part of\na broken bond on this timestep, even if it has other possible bond\npartners.\nThe prob keyword can effect whether an eligible bond is actually\nbroken.  The fraction setting must be a value between 0.0 and 1.0.\nA uniform random number between 0.0 and 1.0 is generated and the\neligible bond is only broken if the random number < fraction.\nWhen a bond is broken, data structures within LAMMPS that store bond\ntopology are updated to reflect the breakage.  Likewise, if the bond\nis part of a 3-body (angle) or 4-body (dihedral, improper)\ninteraction, that interaction is removed as well.  These changes\ntypically affect pairwise interactions between atoms that used to be\npart of bonds, angles, etc.\n\nNote\nOne data structure that is not updated when a bond breaks are\nthe molecule IDs stored by each atom.  Even though one molecule\nbecomes two molecules due to the broken bond, all atoms in both new\nmolecules retain their original molecule IDs.\n\nComputationally, each timestep this fix operates, it loops over all\nthe bonds in the system and computes distances between pairs of bonded\natoms.  It also communicates between neighboring processors to\ncoordinate which bonds are broken.  Moreover, if any bonds are broken,\nneighbor lists must be immediately updated on the same timestep.  This\nis to insure that any pairwise interactions that should be turned “on”\ndue to a bond breaking, because they are no longer excluded by the\npresence of the bond and the settings of the\nspecial_bonds command, will be immediately\nrecognized.  All of these operations increase the cost of a timestep.\nThus you should be cautious about invoking this fix too frequently.\nYou can dump out snapshots of the current bond topology via the dump local command.\n\nNote\nBreaking a bond typically alters the energy of a system.  You\nshould be careful not to choose bond breaking criteria that induce a\ndramatic change in energy.  For example, if you define a very stiff\nharmonic bond and break it when 2 atoms are separated by a distance\nfar from the equilibrium bond length, then the 2 atoms will be\ndramatically released when the bond is broken.  More generally, you\nmay need to thermostat your system to compensate for energy changes\nresulting from broken bonds (and angles, dihedrals, impropers).\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes two statistics which it stores in a global vector of\nlength 2, which can be accessed by various output commands.  The vector values calculated by this fix\nare “intensive”.\nThese are the 2 quantities:\n\n\n# of bonds broken on the most recent breakage timestep\n\n\n\ncumulative # of bonds broken\n\n\n\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID bond/break Nevery bondtype Rmax keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * bond/break = style name of this fix command\n * Nevery = attempt bond breaking every this many steps\n * bondtype = type of bonds to break\n * Rmax = bond longer than Rmax can break (distance units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = prob\n * prob values = fraction seed\n *   fraction = break a bond with this probability if otherwise eligible\n *   seed = random number seed (positive integer)",
    "examples": "fix 5 all bond/break 10 2 1.2\nfix 5 polymer bond/break 1 1 2.0 prob 0.5 49829",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info."
},
{
    "command": "fix bond/create",
    "html_filename": "fix_bond_create.html",
    "short_description": "Create bonds between pairs of atoms as a simulation runs according to specified criteria",
    "description": "Create bonds between pairs of atoms as a simulation runs according to\nspecified criteria.  This can be used to model cross-linking of\npolymers, the formation of a percolation network, etc.  In this\ncontext, a bond means an interaction between a pair of atoms computed\nby the bond_style command.  Once the bond is created\nit will be permanently in place.  Optionally, the creation of a bond\ncan also create angle, dihedral, and improper interactions that bond\nis part of.  See the discussion of the atype, dtype, and itype\nkeywords below.\nThis is different than a pairwise bond-order\npotential such as Tersoff or AIREBO which infers bonds and many-body\ninteractions based on the current geometry of a small cluster of atoms\nand effectively creates and destroys bonds and higher-order many-body\ninteractions from timestep to timestep as atoms move.\nA check for possible new bonds is performed every Nevery timesteps.\nIf two atoms I,J are within a distance Rmin of each other, if I is\nof atom type itype, if J is of atom type jtype, if both I and J\nare in the specified fix group, if a bond does not already exist\nbetween I and J, and if both I and J meet their respective maxbond\nrequirement (explained below), then I,J is labeled as a “possible”\nbond pair.\nIf several atoms are close to an atom, it may have multiple possible\nbond partners.  Every atom checks its list of possible bond partners\nand labels the closest such partner as its “sole” bond partner.  After\nthis is done, if atom I has atom J as its sole partner, and atom J has\natom I as its sole partner, then the I,J bond is “eligible” to be\nformed.\nNote that these rules mean an atom will only be part of at most one\ncreated bond on a given timestep.  It also means that if atom I\nchooses atom J as its sole partner, but atom J chooses atom K is its\nsole partner (due to Rjk < Rij), then this means atom I will not form\na bond on this timestep, even if it has other possible bond partners.\nIt is permissible to have itype = jtype.  Rmin must be <= the\npairwise cutoff distance between itype and jtype atoms, as defined\nby the pair_style command.\nThe iparam and jparam keywords can be used to limit the bonding\nfunctionality of the participating atoms.  Each atom keeps track of\nhow many bonds of bondtype it already has.  If atom I of\nitype already has maxbond bonds (as set by the iparam\nkeyword), then it will not form any more.  Likewise for atom J.  If\nmaxbond is set to 0, then there is no limit on the number of bonds\nthat can be formed with that atom.\nThe newtype value for iparam and jparam can be used to change\nthe atom type of atom I or J when it reaches maxbond number of bonds\nof type bondtype.  This means it can now interact in a pairwise\nfashion with other atoms in a different way by specifying different\npair_coeff coefficients.  If you do not wish the\natom type to change, simply specify newtype as itype or jtype.\nThe prob keyword can also effect whether an eligible bond is\nactually created.  The fraction setting must be a value between 0.0\nand 1.0.  A uniform random number between 0.0 and 1.0 is generated and\nthe eligible bond is only created if the random number < fraction.\nAny bond that is created is assigned a bond type of bondtype\nWhen a bond is created, data structures within LAMMPS that store bond\ntopology are updated to reflect the creation.  If the bond is part of\nnew 3-body (angle) or 4-body (dihedral, improper) interactions, you\ncan choose to create new angles, dihedrals, impropers as well, using\nthe atype, dtype, and itype keywords.  All of these changes\ntypically affect pairwise interactions between atoms that are now part\nof new bonds, angles, etc.\n\nNote\nOne data structure that is not updated when a bond breaks are\nthe molecule IDs stored by each atom.  Even though two molecules\nbecome one molecule due to the created bond, all atoms in the new\nmolecule retain their original molecule IDs.\n\nIf the atype keyword is used and if an angle potential is defined\nvia the angle_style command, then any new 3-body\ninteractions inferred by the creation of a bond will create new angles\nof type angletype, with parameters assigned by the corresponding\nangle_coeff command.  Likewise, the dtype and\nitype keywords will create new dihedrals and impropers of type\ndihedraltype and impropertype.\n\nNote\nTo create a new bond, the internal LAMMPS data structures that\nstore this information must have space for it.  When LAMMPS is\ninitialized from a data file, the list of bonds is scanned and the\nmaximum number of bonds per atom is tallied.  If some atom will\nacquire more bonds than this limit as this fix operates, then the\n“extra bond per atom” parameter must be set to allow for it.  Ditto\nfor “extra angle per atom”, “extra dihedral per atom”, and “extra\nimproper per atom” if angles, dihedrals, or impropers are being added\nwhen bonds are created.  See the read_data or\ncreate_box command for more details.  Note that a\ndata file with no atoms can be used if you wish to add non-bonded\natoms via the create atoms command, e.g. for a\npercolation simulation.\n\n\nNote\nLAMMPS stores and maintains a data structure with a list of the\n1st, 2nd, and 3rd neighbors of each atom (within the bond topology of\nthe system) for use in weighting pairwise interactions for bonded\natoms.  Note that adding a single bond always adds a new 1st neighbor\nbut may also induce *many* new 2nd and 3rd neighbors, depending on the\nmolecular topology of your system.  The “extra special per atom”\nparameter must typically be set to allow for the new maximum total\nsize (1st + 2nd + 3rd neighbors) of this per-atom list.  There are 2\nways to do this.  See the read_data or\ncreate_box commands for details.\n\n\nNote\nEven if you do not use the atype, dtype, or itype\nkeywords, the list of topological neighbors is updated for atoms\naffected by the new bond.  This in turn affects which neighbors are\nconsidered for pairwise interactions, using the weighting rules set by\nthe special_bonds command.  Consider a new bond\ncreated between atoms I,J.  If J has a bonded neighbor K, then K\nbecomes a 2nd neighbor of I.  Even if the atype keyword is not used\nto create angle I-J-K, the pairwise interaction between I and K will\nbe potentially turned off or weighted by the 1-3 weighting specified\nby the special_bonds command.  This is the case\neven if the “angle yes” option was used with that command.  The same\nis true for 3rd neighbors (1-4 interactions), the dtype keyword, and\nthe “dihedral yes” option used with the\nspecial_bonds command.\n\nNote that even if your simulation starts with no bonds, you must\ndefine a bond_style and use the\nbond_coeff command to specify coefficients for the\nbondtype.  Similarly, if new atom types are specified by the\niparam or jparam keywords, they must be within the range of atom\ntypes allowed by the simulation and pairwise coefficients must be\nspecified for the new types.\nComputationally, each timestep this fix operates, it loops over\nneighbor lists and computes distances between pairs of atoms in the\nlist.  It also communicates between neighboring processors to\ncoordinate which bonds are created.  Moreover, if any bonds are\ncreated, neighbor lists must be immediately updated on the same\ntimestep.  This is to insure that any pairwise interactions that\nshould be turned “off” due to a bond creation, because they are now\nexcluded by the presence of the bond and the settings of the\nspecial_bonds command, will be immediately\nrecognized.  All of these operations increase the cost of a timestep.\nThus you should be cautious about invoking this fix too frequently.\nYou can dump out snapshots of the current bond topology via the dump local command.\n\nNote\nCreating a bond typically alters the energy of a system.  You\nshould be careful not to choose bond creation criteria that induce a\ndramatic change in energy.  For example, if you define a very stiff\nharmonic bond and create it when 2 atoms are separated by a distance\nfar from the equilibrium bond length, then the 2 atoms will oscillate\ndramatically when the bond is formed.  More generally, you may need to\nthermostat your system to compensate for energy changes resulting from\ncreated bonds (and angles, dihedrals, impropers).\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes two statistics which it stores in a global vector of\nlength 2, which can be accessed by various output commands.  The vector values calculated by this fix\nare “intensive”.\nThese are the 2 quantities:\n\n\n# of bonds created on the most recent creation timestep\n\n\n\ncumulative # of bonds created\n\n\n\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID bond/create Nevery itype jtype Rmin bondtype keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * bond/create = style name of this fix command\n * Nevery = attempt bond creation every this many steps\n * itype,jtype = atoms of itype can bond to atoms of jtype\n * Rmin = 2 atoms separated by less than Rmin can bond (distance units)\n * bondtype = type of created bonds\n * zero or more keyword/value pairs may be appended to args\n * keyword = iparam or jparam or prob or atype or dtype or itype\n * iparam values = maxbond, newtype\n *   maxbond = max # of bonds of bondtype the itype atom can have\n *   newtype = change the itype atom to this type when maxbonds exist\n * jparam values = maxbond, newtype\n *   maxbond = max # of bonds of bondtype the jtype atom can have\n *   newtype = change the jtype atom to this type when maxbonds exist\n * prob values = fraction seed\n *   fraction = create a bond with this probability if otherwise eligible\n *   seed = random number seed (positive integer)\n * atype value = angletype\n *   angletype = type of created angles\n * dtype value = dihedraltype\n *   dihedraltype = type of created dihedrals\n * itype value = impropertype\n *   impropertype = type of created impropers",
    "examples": "fix 5 all bond/create 10 1 2 0.8 1\nfix 5 all bond/create 1 3 3 0.8 1 prob 0.5 85784 iparam 2 3\nfix 5 all bond/create 1 3 3 0.8 1 prob 0.5 85784 iparam 2 3 atype 1 dtype 2",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info."
},
{
    "command": "fix bond/react",
    "html_filename": "fix_bond_react.html",
    "short_description": "Initiate complex covalent bonding (topology) changes",
    "description": "Initiate complex covalent bonding (topology) changes. These topology\nchanges will be referred to as ‘reactions’ throughout this\ndocumentation. Topology changes are defined in pre- and post-reaction\nmolecule templates and can include creation and deletion of bonds,\nangles, dihedrals, impropers, bond types, angle types, dihedral types,\natom types, or atomic charges. In addition, reaction by-products or\nother molecules can be identified and deleted.\nFix bond/react does not use quantum mechanical (eg. fix qmmm) or\npairwise bond-order potential (eg. Tersoff or AIREBO) methods to\ndetermine bonding changes a priori. Rather, it uses a distance-based\nprobabilistic criteria to effect predetermined topology changes in\nsimulations using standard force fields.\nThis fix was created to facilitate the dynamic creation of polymeric,\namorphous or highly cross-linked systems. A suggested workflow for\nusing this fix is: 1) identify a reaction to be simulated 2) build a\nmolecule template of the reaction site before the reaction has\noccurred 3) build a molecule template of the reaction site after the\nreaction has occurred 4) create a map that relates the\ntemplate-atom-IDs of each atom between pre- and post-reaction molecule\ntemplates 5) fill a simulation box with molecules and run a simulation\nwith fix bond/react.\nOnly one ‘fix bond/react’ command can be used at a time. Multiple\nreactions can be simultaneously applied by specifying multiple react\narguments to a single ‘fix bond/react’ command. This syntax is\nnecessary because the ‘common keywords’ are applied to all reactions.\nThe stabilization keyword enables reaction site stabilization.\nReaction site stabilization is performed by including reacting atoms\nin an internally-created fix nve/limit time\nintegrator for a set number of timesteps given by the\nstabilize_steps keyword. While reacting atoms are being time\nintegrated by the internal nve/limit, they are prevented from being\ninvolved in any new reactions. The xmax value keyword should\ntypically be set to the maximum distance that non-reacting atoms move\nduring the simulation.\nFix bond/react creates and maintains two important dynamic groups of\natoms when using the stabilization keyword. The first group contains\nall atoms currently involved in a reaction; this group is\nautomatically thermostatted by an internally-created\nnve/limit integrator. The second group contains\nall atoms currently not involved in a reaction. This group should be\nused by a thermostat in order to time integrate the system. The name\nof this group of non-reacting atoms is created by appending ‘_REACT’\nto the group-ID argument of the stabilization keyword, as shown in\nthe second example above.\n\nNote\nWhen using reaction stabilization, you should generally not have\na separate thermostat which acts on the ‘all’ group.\n\nThe group-ID set using the stabilization keyword can be an existing\nstatic group or a previously-unused group-ID. It cannot be specified\nas ‘all’. If the group-ID is previously unused, the fix bond/react\ncommand creates a dynamic group that is initialized to\ninclude all atoms. If the group-ID is that of an existing static\ngroup, the group is used as the parent group of new,\ninternally-created dynamic group. In both cases, this new dynamic\ngroup is named by appending ‘_REACT’ to the group-ID, e.g.\nnvt_grp_REACT. By specifying an existing group, you may thermostat\nconstant-topology parts of your system separately. The dynamic group\ncontains only atoms not involved in a reaction at a given timestep,\nand therefore should be used by a subsequent system-wide time\nintegrator such as nvt, npt, or nve, as shown in the second example\nabove (full examples can be found at examples/USER/misc/bond_react).\nThe time integration command should be placed after the fix bond/react\ncommand due to the internal dynamic grouping performed by fix\nbond/react.\n\nNote\nIf the group-ID is an existing static group, react-group-IDs\nshould also be specified as this static group, or a subset.\n\nThe following comments pertain to each react argument (in other\nwords, can be customized for each reaction, or reaction step):\nA check for possible new reaction sites is performed every Nevery\ntimesteps.\nThree physical conditions must be met for a reaction to occur. First,\na bonding atom pair must be identified within the reaction distance\ncutoffs. Second, the topology surrounding the bonding atom pair must\nmatch the topology of the pre-reaction template. Finally, any reaction\nconstraints listed in the map file (see below) must be satisfied. If\nall of these conditions are met, the reaction site is eligible to be\nmodified to match the post-reaction template.\nA bonding atom pair will be identified if several conditions are met.\nFirst, a pair of atoms I,J within the specified react-group-ID of type\nitype and jtype must be separated by a distance between Rmin and\nRmax. It is possible that multiple bonding atom pairs are\nidentified: if the bonding atoms in the pre-reacted template are  1-2\nneighbors, i.e. directly bonded, the farthest bonding atom partner is\nset as its bonding partner; otherwise, the closest potential partner\nis chosen. Then, if both an atom I and atom J have each other as their\nbonding partners, these two atoms are identified as the bonding atom\npair of the reaction site. Once this unique bonding atom pair is\nidentified for each reaction, there could two or more reactions that\ninvolve a given atom on the same timestep. If this is the case, only\none such reaction is permitted to occur. This reaction is chosen\nrandomly from all potential reactions. This capability allows e.g. for\ndifferent reaction pathways to proceed from identical reaction sites\nwith user-specified probabilities.\nThe pre-reacted molecule template is specified by a molecule command.\nThis molecule template file contains a sample reaction site and its\nsurrounding topology. As described below, the bonding atom pairs of\nthe pre-reacted template are specified by atom ID in the map file. The\npre-reacted molecule template should contain as few atoms as possible\nwhile still completely describing the topology of all atoms affected\nby the reaction. For example, if the force field contains dihedrals,\nthe pre-reacted template should contain any atom within three bonds of\nreacting atoms.\nSome atoms in the pre-reacted template that are not reacting may have\nmissing topology with respect to the simulation. For example, the\npre-reacted template may contain an atom that, in the simulation, is\ncurrently connected to the rest of a long polymer chain. These are\nreferred to as edge atoms, and are also specified in the map file. All\npre-reaction template atoms should be linked to a bonding atom, via at\nleast one path that does not involve edge atoms. When the pre-reaction\ntemplate contains edge atoms, not all atoms, bonds, charges, etc.\nspecified in the reaction templates will be updated. Specifically,\ntopology that involves only atoms that are ‘too near’ to template\nedges will not be updated. The definition of ‘too near the edge’\ndepends on which interactions are defined in the simulation. If the\nsimulation has defined dihedrals, atoms within two bonds of edge atoms\nare considered ‘too near the edge.’ If the simulation defines angles,\nbut not dihedrals, atoms within one bond of edge atoms are considered\n‘too near the edge.’ If just bonds are defined, only edge atoms are\nconsidered ‘too near the edge.’\n\nNote\nSmall molecules, i.e. ones that have all their atoms contained\nwithin the reaction templates, never have edge atoms.\n\nNote that some care must be taken when a building a molecule template\nfor a given simulation. All atom types in the pre-reacted template\nmust be the same as those of a potential reaction site in the\nsimulation. A detailed discussion of matching molecule template atom\ntypes with the simulation is provided on the molecule\ncommand page.\nThe post-reacted molecule template contains a sample of the reaction\nsite and its surrounding topology after the reaction has occurred. It\nmust contain the same number of atoms as the pre-reacted template. A\none-to-one correspondence between the atom IDs in the pre- and\npost-reacted templates is specified in the map file as described\nbelow. Note that during a reaction, an atom, bond, etc. type may\nchange to one that was previously not present in the simulation. These\nnew types must also be defined during the setup of a given simulation.\nA discussion of correctly handling this is also provided on the\nmolecule command page.\n\nNote\nWhen a reaction occurs, it is possible that the resulting\ntopology/atom (e.g. special bonds, dihedrals, etc.) exceeds that of\nthe existing system and reaction templates. As when inserting\nmolecules, enough space for this increased topology/atom must be\nreserved by using the relevant “extra” keywords to the\nread_data or create_box commands.\n\nThe map file is a text document with the following format:\nA map file has a header and a body. The header of map file the\ncontains one mandatory keyword and five optional keywords. The\nmandatory keyword is ‘equivalences’:\nN equivalences = # of atoms N in the reaction molecule templates\nThe optional keywords are ‘edgeIDs’, ‘deleteIDs’, ‘customIDs’ and\n‘constraints’:\nN edgeIDs = # of edge atoms N in the pre-reacted molecule template\nN deleteIDs = # of atoms N that are specified for deletion\nN chiralIDs = # of specified chiral centers N\nN customIDs = # of atoms N that are specified for a custom update\nN constraints = # of specified reaction constraints N\nThe body of the map file contains two mandatory sections and five\noptional sections. The first mandatory section begins with the keyword\n‘BondingIDs’ and lists the atom IDs of the bonding atom pair in the\npre-reacted molecule template. The second mandatory section begins\nwith the keyword ‘Equivalences’ and lists a one-to-one correspondence\nbetween atom IDs of the pre- and post-reacted templates. The first\ncolumn is an atom ID of the pre-reacted molecule template, and the\nsecond column is the corresponding atom ID of the post-reacted\nmolecule template. The first optional section begins with the keyword\n‘EdgeIDs’ and lists the atom IDs of edge atoms in the pre-reacted\nmolecule template. The second optional section begins with the keyword\n‘DeleteIDs’ and lists the atom IDs of pre-reaction template atoms to\ndelete. The third optional section begins with the keyword ‘ChiralIDs’\nlists the atom IDs of chiral atoms whose handedness should be\nenforced. The fourth optional section begins with the keyword ‘Custom\nEdges’ and allows for forcing the update of a specific atom’s atomic\ncharge. The first column is the ID of an atom near the edge of the\npre-reacted molecule template, and the value of the second column is\neither ‘none’ or ‘charges.’ Further details are provided in the\ndiscussion of the ‘update_edges’ keyword. The fifth optional section\nbegins with the keyword ‘Constraints’ and lists additional criteria\nthat must be satisfied in order for the reaction to occur. Currently,\nthere are three types of constraints available, as discussed below.\nA sample map file is given below:\n\n# this is a map file\n\n7 equivalences\n2 edgeIDs\n\nBondingIDs\n\n3\n5\n\nEdgeIDs\n\n1\n7\n\nEquivalences\n\n1   1\n2   2\n3   3\n4   4\n5   5\n6   6\n7   7\n\n\n\nThe handedness of atoms that are chiral centers can be enforced by\nlisting their IDs in the ChiralIDs section. A chiral atom must be\nbonded to four atoms with mutually different atom types. This feature\nuses the coordinates and types of the involved atoms in the\npre-reaction template to determine handedness. Three atoms bonded to\nthe chiral center are arbitrarily chosen, to define an oriented plane,\nand the relative position of the fourth bonded atom determines the\nchiral center’s handedness.\nAny number of additional constraints may be specified in the\nConstraints section of the map file. The constraint of type ‘distance’\nhas syntax as follows:\ndistance ID1 ID2 rmin rmax\nwhere ‘distance’ is the required keyword, ID1 and ID2 are\npre-reaction atom IDs, and these two atoms must be separated by a\ndistance between rmin and rmax for the reaction to occur.\nThe constraint of type ‘angle’ has the following syntax:\nangle ID1 ID2 ID3 amin amax\nwhere ‘angle’ is the required keyword, ID1, ID2 and ID3 are\npre-reaction atom IDs, and these three atoms must form an angle\nbetween amin and amax for the reaction to occur (where ID2 is\nthe central atom). Angles must be specified in degrees. This\nconstraint can be used to enforce a certain orientation between\nreacting molecules.\nThe constraint of type ‘arrhenius’ imposes an additional reaction\nprobability according to the temperature-dependent Arrhenius equation:\n\n\\[k = AT^{n}e^{\\frac{-E_{a}}{k_{B}T}}\\]\nThe Arrhenius constraint has the following syntax:\narrhenius A n E_a seed\nwhere ‘arrhenius’ is the required keyword, A is the pre-exponential\nfactor, n is the exponent of the temperature dependence, \\(E_a\\)\nis the activation energy (units of energy), and seed is a\nrandom number seed. The temperature is defined as the instantaneous\ntemperature averaged over all atoms in the reaction site, and is\ncalculated in the same manner as for example\ncompute temp/chunk. Currently, there are no\noptions for additional temperature averaging or velocity-biased\ntemperature calculations. A uniform random number between 0 and 1 is\ngenerated using seed; if this number is less than the result of the\nArrhenius equation above, the reaction is permitted to occur.\nOnce a reaction site has been successfully identified, data structures\nwithin LAMMPS that store bond topology are updated to reflect the\npost-reacted molecule template. All force fields with fixed bonds,\nangles, dihedrals or impropers are supported.\nA few capabilities to note: 1) You may specify as many react\narguments as desired. For example, you could break down a complicated\nreaction mechanism into several reaction steps, each defined by its\nown react argument. 2) While typically a bond is formed or removed\nbetween the bonding atom pairs specified in the pre-reacted molecule\ntemplate, this is not required. 3) By reversing the order of the pre-\nand post- reacted molecule templates in another react argument, you\ncan allow for the possibility of one or more reverse reactions.\nThe optional keywords deal with the probability of a given reaction\noccurring as well as the stable equilibration of each reaction site as\nit occurs:\nThe prob keyword can affect whether or not an eligible reaction\nactually occurs. The fraction setting must be a value between 0.0 and\n1.0. A uniform random number between 0.0 and 1.0 is generated and the\neligible reaction only occurs if the random number is less than the\nfraction. Up to N reactions are permitted to occur, as optionally\nspecified by the max_rxn keyword.\nThe stabilize_steps keyword allows for the specification of how many\ntimesteps a reaction site is stabilized before being returned to the\noverall system thermostat. In order to produce the most physical\nbehavior, this ‘reaction site equilibration time’ should be tuned to\nbe as small as possible while retaining stability for a given system\nor reaction step. After a limited number of case studies, this number\nhas been set to a default of 60 timesteps. Ideally, it should be\nindividually tuned for each fix reaction step. Note that in some\nsituations, decreasing rather than increasing this parameter will\nresult in an increase in stability.\nThe update_edges keyword can increase the number of atoms whose\natomic charges are updated, when the pre-reaction template contains\nedge atoms. When the value is set to ‘charges,’ all atoms’ atomic\ncharges are updated to those specified by the post-reaction template,\nincluding atoms near the edge of reaction templates. When the value is\nset to ‘custom,’ an additional section must be included in the map\nfile that specifies whether or not to update charges, on a per-atom\nbasis. The format of this section is detailed above. Listing a\npre-reaction atom ID with a value of ‘charges’ will force the update\nof the atom’s charge, even if it is near a template edge. Atoms not\nnear a template edge are unaffected by this setting.\nA few other considerations:\nMany reactions result in one or more atoms that are considered\nunwanted by-products. Therefore, bond/react provides the option to\ndelete a user-specified set of atoms. These pre-reaction atoms are\nidentified in the map file. A deleted atom must still be included in\nthe post-reaction molecule template, in which it cannot be bonded to\nan atom that is not deleted. In addition to deleting unwanted reaction\nby-products, this feature can be used to remove specific topologies,\nsuch as small rings, that may be otherwise indistinguishable.\nOptionally, you can enforce additional behaviors on reacting atoms.\nFor example, it may be beneficial to force reacting atoms to remain at\na certain temperature. For this, you can use the internally-created\ndynamic group named “bond_react_MASTER_group”, which consists of all\natoms currently involved in a reaction. For example, adding the\nfollowing command would add an additional thermostat to the group of\nall currently-reacting atoms:\nfix 1 bond_react_MASTER_group temp/rescale 1 300 300 10 1\n\n\n\nNote\nThis command must be added after the fix bond/react command, and\nwill apply to all reactions.\n\nComputationally, each timestep this fix operates, it loops over\nneighbor lists (for bond-forming reactions) and computes distances\nbetween pairs of atoms in the list. It also communicates between\nneighboring processors to coordinate which bonds are created and/or\nremoved. All of these operations increase the cost of a timestep. Thus\nyou should be cautious about invoking this fix too frequently.\nYou can dump out snapshots of the current bond topology via the dump\nlocal command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nCumulative reaction counts for each reaction are written to binary restart files. These values are associated with the\nreaction name (react-ID). Additionally, internally-created per-atom\nproperties are stored to allow for smooth restarts. None of the\nfix_modify options are relevant to this fix.\nThis fix computes one statistic for each react argument that it\nstores in a global vector, of length ‘number of react arguments’, that\ncan be accessed by various output commands. The\nvector values calculated by this fix are “intensive”.\nThese is 1 quantity for each react argument:\n\n\ncumulative # of reactions occurred\n\n\n\nNo parameter of this fix can be used with the start/stop keywords\nof the run command.  This fix is not invoked during energy minimization.\nWhen fix bond/react is ‘unfixed,’ all internally-created groups are\ndeleted. Therefore, fix bond/react can only be unfixed after unfixing\nall other fixes that use any group created by fix bond/react.",
    "syntax": "fix ID group-ID bond/react common_keyword values ...",
    "parameters": " *   react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n *   react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n *   react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n *   ...\n * ID, group-ID are documented in fix command. Group-ID is ignored.\n * bond/react = style name of this fix command\n * the common keyword/values may be appended directly after ‘bond/react’\n * this applies to all reaction specifications (below)\n * common_keyword = stabilization\n * stabilization values = no or yes group-ID xmax\n *   no = no reaction site stabilization\n *   yes = perform reaction site stabilization\n *     group-ID = user-assigned prefix for the dynamic group of atoms not currently involved in a reaction\n *     xmax = xmax value that is used by an internally-created nve/limit integrator\n * react = mandatory argument indicating new reaction specification\n * react-ID = user-assigned name for the reaction\n * react-group-ID = only atoms in this group are considered for the reaction\n * Nevery = attempt reaction every this many steps\n * Rmin = bonding pair atoms must be separated by more than Rmin to initiate reaction (distance units)\n * Rmax = bonding pair atoms must be separated by less than Rmax to initiate reaction (distance units)\n * template-ID(pre-reacted) = ID of a molecule template containing pre-reaction topology\n * template-ID(post-reacted) = ID of a molecule template containing post-reaction topology\n * map_file = name of file specifying corresponding atom-IDs in the pre- and post-reacted templates\n * zero or more individual keyword/value pairs may be appended to each react argument\n * individual_keyword = prob or max_rxn or stabilize_steps or update_edges\n * prob values = fraction seed\n *   fraction = initiate reaction with this probability if otherwise eligible\n *   seed = random number seed (positive integer)\n * max_rxn value = N\n *   N = maximum number of reactions allowed to occur\n * stabilize_steps value = timesteps\n *   timesteps = number of timesteps to apply the internally-created nve/limit fix to reacting atoms\n * update_edges value = none or charges or custom\n *   none = do not update topology near the edges of reaction templates\n *   charges = update atomic charges of all atoms in reaction templates\n *   custom = force the update of user-specified atomic charges",
    "examples": "For unabridged example scripts and files, see examples/USER/misc/bond_react.\nmolecule mol1 pre_reacted_topology.txt\nmolecule mol2 post_reacted_topology.txt\nfix 5 all bond/react react myrxn1 all 1 0 3.25 mol1 mol2 map_file.txt\n\nmolecule mol1 pre_reacted_rxn1.txt\nmolecule mol2 post_reacted_rxn1.txt\nmolecule mol3 pre_reacted_rxn2.txt\nmolecule mol4 post_reacted_rxn2.txt\nfix 5 all bond/react stabilization yes nvt_grp .03 &\n  react myrxn1 all 1 0 3.25 mol1 mol2 map_file_rxn1.txt prob 0.50 12345 &\n  react myrxn2 all 1 0 2.75 mol3 mol4 map_file_rxn2.txt prob 0.25 12345\nfix 6 nvt_grp_REACT nvt temp 300 300 100 # set thermostat after bond/react",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the\nBuild package doc page for more info."
},
{
    "command": "fix bond/swap",
    "html_filename": "fix_bond_swap.html",
    "short_description": "In a simulation of polymer chains, this command attempts to swap bonds between two different chains, effectively grafting the end of one chain onto another chain and vice versa",
    "description": "In a simulation of polymer chains, this command attempts to swap bonds\nbetween two different chains, effectively grafting the end of one\nchain onto another chain and vice versa.  This is done via Monte Carlo\nrules using the Boltzmann acceptance criterion.  The purpose is to\nequilibrate the polymer chain conformations more rapidly than dynamics\nalone would do it, by enabling instantaneous large conformational\nchanges in a dense polymer melt.  The polymer chains should thus more\nrapidly converge to the proper end-to-end distances and radii of\ngyration.  It is designed for use with systems of\nFENE or harmonic bead-spring\npolymer chains where each polymer is a linear chain of monomers, but\nLAMMPS does not enforce this requirement, i.e. any\nbond_style can be used.\nA schematic of the kinds of bond swaps that can occur is shown here:\n\nOn the left, the red and blue chains have two monomers A1 and B1 close\nto each other, which are currently bonded to monomers A2 and B2\nrespectively within their own chains.  The bond swap operation will\nattempt to delete the A1-A2 and B1-B2 bonds and replace them with\nA1-B2 and B1-A2 bonds.  If the swap is energetically favorable, the\ntwo chains on the right are the result and each polymer chain has\nundergone a dramatic conformational change.  This reference,\n(Sides) provides more details on how the algorithm works and\nits application:\nThe bond swapping operation is invoked every Nevery timesteps.  If\nany bond is swapped, a re-build of the neighbor lists is triggered,\nsince a swap alters the list of which neighbors are considered for\npairwise interaction.  At each invocation, each processor considers a\nrandom specified fraction of its atoms as potential swapping\nmonomers for this timestep.  Choosing a small fraction value can\nreduce the likelihood of a reverse swap occurring soon after an\ninitial swap.\nFor each monomer A1, its neighbors are examined to find a possible B1\nmonomer.  Both A1 and B1 must be in the fix group, their separation\nmust be less than the specified cutoff, and the molecule IDs of A1\nand B1 must be the same (see below).  If a suitable partner is found,\nthe energy change due to swapping the 2 bonds is computed.  This\nincludes changes in pairwise, bond, and angle energies due to the\naltered connectivity of the 2 chains.  Dihedral and improper\ninteractions are not allowed to be defined when this fix is used.\nIf the energy decreases due to the swap operation, the bond swap is\naccepted.  If the energy increases it is accepted with probability\nexp(-delta/kT) where delta is the increase in energy, k is the\nBoltzmann constant, and T is the current temperature of the system.\nWhether the swap is accepted or rejected, no other swaps are attempted\nby this processor on this timestep.\nThe criterion for matching molecule IDs is how bond swaps performed by\nthis fix conserve chain length.  To use this features you must setup\nthe molecule IDs for your polymer chains in a certain way, typically\nin the data file, read by the read_data command.\nConsider a system of 6-mer chains.  You have 2 choices.  If the\nmolecule IDs for monomers on each chain are set to 1,2,3,4,5,6 then\nswaps will conserve chain length.  For a particular monomer there will\nbe only one other monomer on another chain which is a potential swap\npartner.  If the molecule IDs for monomers on each chain are set to\n1,2,3,3,2,1 then swaps will conserve chain length but swaps will be\nable to occur at either end of a chain.  Thus for a particular monomer\nthere will be 2 possible swap partners on another chain.  In this\nscenario, swaps can also occur within a single chain, i.e. the two\nends of a chain swap with each other.\n\nNote\nIf your simulation uses molecule IDs in the usual way, where all\nmonomers on a single chain are assigned the same ID (different for\neach chain), then swaps will only occur within the same chain.  If you\nassign the same molecule ID to all monomers in all chains then\ninter-chain swaps will occur, but they will not conserve chain length.\nNeither of these scenarios is probably what you want for this fix.\n\n\nNote\nWhen a bond swap occurs the image flags of monomers in the new\npolymer chains can become inconsistent.  See the dump\ncommand for a discussion of image flags.  This is not an issue for\nrunning dynamics, but can affect calculation of some diagnostic\nquantities or the printing of unwrapped coordinates to a dump file.\n\n\nThis fix computes a temperature each time it is invoked for use by the\nBoltzmann criterion.  To do this, the fix creates its own compute of\nstyle temp, as if this command had been issued:\ncompute fix-ID_temp all temp\n\n\nSee the compute temp command for details.  Note\nthat the ID of the new compute is the fix-ID with underscore + “temp”\nappended and the group for the new compute is “all”, so that the\ntemperature of the entire system is used.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\n\nRestart, fix_modify, thermo output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator\nis not saved in restart files, this means you cannot do “exact”\nrestarts with this fix, where the simulation continues on the same as\nif no restart had taken place.  However, in a statistical sense, a\nrestarted simulation should produce the same behavior.  Also note that\neach processor generates possible swaps independently of other\nprocessors.  Thus if you repeat the same simulation on a different number\nof processors, the specific swaps performed will be different.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used to compute the temperature for\nthe Boltzmann criterion.\nThis fix computes two statistical quantities as a global 2-vector of\noutput, which can be accessed by various output commands.  The first component of the vector is the\ncumulative number of swaps performed by all processors.  The second\ncomponent of the vector is the cumulative number of swaps attempted\n(whether accepted or rejected).  Note that a swap “attempt” only\noccurs when swap partners meeting the criteria described above are\nfound on a particular timestep.  The vector values calculated by this\nfix are “intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID bond/swap Nevery fraction cutoff seed",
    "parameters": " * ID, group-ID are documented in fix command\n * bond/swap = style name of this fix command\n * Nevery = attempt bond swapping every this many steps\n * fraction = fraction of group atoms to consider for swapping\n * cutoff = distance at which swapping will be considered (distance units)\n * seed = random # seed (positive integer)",
    "examples": "fix 1 all bond/swap 50 0.5 1.3 598934",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info.\nThe settings of the “special_bond” command must be 0,1,1 in order to\nuse this fix, which is typical of bead-spring chains with FENE or\nharmonic bonds.  This means that pairwise interactions between bonded\natoms are turned off, but are turned on between atoms two or three\nhops away along the chain backbone.\nCurrently, energy changes in dihedral and improper interactions due to\na bond swap are not considered.  Thus a simulation that uses this fix\ncannot use a dihedral or improper potential."
},
{
    "command": "fix box/relax",
    "html_filename": "fix_box_relax.html",
    "short_description": "Apply an external pressure or stress tensor to the simulation box during an energy minimization",
    "description": "Apply an external pressure or stress tensor to the simulation box\nduring an energy minimization.  This allows the box\nsize and shape to vary during the iterations of the minimizer so that\nthe final configuration will be both an energy minimum for the\npotential energy of the atoms, and the system pressure tensor will be\nclose to the specified external tensor.  Conceptually, specifying a\npositive pressure is like squeezing on the simulation box; a negative\npressure typically allows the box to expand.\n\nThe external pressure tensor is specified using one or more of the\niso, aniso, tri, x, y, z, xy, xz, yz, and couple\nkeywords.  These keywords give you the ability to specify all 6\ncomponents of an external stress tensor, and to couple various of\nthese components together so that the dimensions they represent are\nvaried together during the minimization.\nOrthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\nTriclinic (non-orthogonal) simulation boxes have 6 adjustable\ndimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\nspecify whether the simulation box is orthogonal or non-orthogonal\n(triclinic) and explain the meaning of the xy,xz,yz tilt factors.\nThe target pressures Ptarget for each of the 6 components of the\nstress tensor can be specified independently via the x, y, z,\nxy, xz, yz keywords, which correspond to the 6 simulation box\ndimensions.  For example, if the y keyword is used, the y-box length\nwill change during the minimization.  If the xy keyword is used, the\nxy tilt factor will change.  A box dimension will not change if that\ncomponent is not specified.\nNote that in order to use the xy, xz, or yz keywords, the\nsimulation box must be triclinic, even if its initial tilt factors are\n0.0.\nWhen the size of the simulation box changes, all atoms are re-scaled\nto new positions, unless the keyword dilate is specified with a\nvalue of partial, in which case only the atoms in the fix group are\nre-scaled.  This can be useful for leaving the coordinates of atoms in\na solid substrate unchanged and controlling the pressure of a\nsurrounding fluid.\nThe scaleyz, scalexz, and scalexy keywords control whether or\nnot the corresponding tilt factors are scaled with the associated box\ndimensions when relaxing triclinic periodic cells.  The default\nvalues yes will turn on scaling, which corresponds to adjusting the\nlinear dimensions of the cell while preserving its shape.  Choosing\nno ensures that the tilt factors are not scaled with the box\ndimensions. See below for restrictions and default values in different\nsituations. In older versions of LAMMPS, scaling of tilt factors was\nnot performed. The old behavior can be recovered by setting all three\nscale keywords to no.\nThe fixedpoint keyword specifies the fixed point for cell relaxation.\nBy default, it is the center of the box.  Whatever point is\nchosen will not move during the simulation.  For example, if the lower\nperiodic boundaries pass through (0,0,0), and this point is provided\nto fixedpoint, then the lower periodic boundaries will remain at\n(0,0,0), while the upper periodic boundaries will move twice as\nfar. In all cases, the particle positions at each iteration are\nunaffected by the chosen value, except that all particles are\ndisplaced by the same amount, different on each iteration.\n\nNote\nApplying an external pressure to tilt dimensions xy, xz, yz\ncan sometimes result in arbitrarily large values of the tilt factors,\ni.e. a dramatically deformed simulation box.  This typically indicates\nthat there is something badly wrong with how the simulation was\nconstructed.  The two most common sources of this error are applying a\nshear stress to a liquid system or specifying an external shear stress\ntensor that exceeds the yield stress of the solid.  In either case the\nminimization may converge to a bogus conformation or not converge at\nall.  Also note that if the box shape tilts to an extreme shape,\nLAMMPS will run less efficiently, due to the large volume of\ncommunication needed to acquire ghost atoms around a processor’s\nirregular-shaped sub-domain.  For extreme values of tilt, LAMMPS may\nalso lose atoms and generate an error.\n\n\nNote\nPerforming a minimization with this fix is not a mathematically\nwell-defined minimization problem.  This is because the objective\nfunction being minimized changes if the box size/shape changes.  In\npractice this means the minimizer can get “stuck” before you have\nreached the desired tolerance.  The solution to this is to restart the\nminimizer from the new adjusted box size/shape, since that creates a\nnew objective function valid for the new box size/shape.  Repeat as\nnecessary until the box size/shape has reached its new equilibrium.\n\n\nThe couple keyword allows two or three of the diagonal components of\nthe pressure tensor to be “coupled” together.  The value specified\nwith the keyword determines which are coupled.  For example, xz\nmeans the Pxx and Pzz components of the stress tensor are coupled.\nXyz means all 3 diagonal components are coupled.  Coupling means two\nthings: the instantaneous stress will be computed as an average of the\ncorresponding diagonal components, and the coupled box dimensions will\nbe changed together in lockstep, meaning coupled dimensions will be\ndilated or contracted by the same percentage every timestep.  The\nPtarget values for any coupled dimensions must be identical.\nCouple xyz can be used for a 2d simulation; the z dimension is\nsimply ignored.\n\nThe iso, aniso, and tri keywords are simply shortcuts that are\nequivalent to specifying several other keywords together.\nThe keyword iso means couple all 3 diagonal components together when\npressure is computed (hydrostatic pressure), and dilate/contract the\ndimensions together.  Using “iso Ptarget” is the same as specifying\nthese 4 keywords:\nx Ptarget\ny Ptarget\nz Ptarget\ncouple xyz\n\n\nThe keyword aniso means x, y, and z dimensions are controlled\nindependently using the Pxx, Pyy, and Pzz components of the\nstress tensor as the driving forces, and the specified scalar external\npressure.  Using “aniso Ptarget” is the same as specifying these 4\nkeywords:\nx Ptarget\ny Ptarget\nz Ptarget\ncouple none\n\n\nThe keyword tri means x, y, z, xy, xz, and yz dimensions\nare controlled independently using their individual stress components\nas the driving forces, and the specified scalar pressure as the\nexternal normal stress.  Using “tri Ptarget” is the same as specifying\nthese 7 keywords:\nx Ptarget\ny Ptarget\nz Ptarget\nxy 0.0\nyz 0.0\nxz 0.0\ncouple none\n\n\n\nThe vmax keyword can be used to limit the fractional change in the\nvolume of the simulation box that can occur in one iteration of the\nminimizer.  If the pressure is not settling down during the\nminimization this can be because the volume is fluctuating too much.\nThe specified fraction must be greater than 0.0 and should be << 1.0.\nA value of 0.001 means the volume cannot change by more than 1/10 of a\npercent in one iteration when couple xyz has been specified.  For\nany other case it means no linear dimension of the simulation box can\nchange by more than 1/10 of a percent.\n\nWith this fix, the potential energy used by the minimizer is augmented\nby an additional energy provided by the fix. The overall objective\nfunction then is:\n\n\\[E = U + P_t \\left(V-V_0 \\right) + E_{strain}\\]\nwhere U is the system potential energy, \\(P_t\\) is the desired\nhydrostatic pressure, \\(V\\) and \\(V_0\\) are the system and reference\nvolumes, respectively.  \\(E_{strain}\\) is the strain energy expression\nproposed by Parrinello and Rahman (Parrinello1981).\nTaking derivatives of E w.r.t. the box dimensions, and setting these\nto zero, we find that at the minimum of the objective function, the\nglobal system stress tensor P will satisfy the relation:\n\n\\[\\mathbf P = P_t \\mathbf I + {\\mathbf S_t} \\left( \\mathbf h_0^{-1} \\right)^t \\mathbf h_{0d}\\]\nwhere I is the identity matrix, \\(\\mathbf{h_0}\\) is the box\ndimension tensor of the reference cell, and :\\(\\mathbf{h_{0d}}\\)\nis the diagonal part of \\(\\mathbf{h_0}\\). \\(\\mathbf{S_t}\\)\nis a symmetric stress tensor that is chosen by LAMMPS\nso that the upper-triangular components of P equal the stress tensor\nspecified by the user.\nThis equation only applies when the box dimensions are equal to those\nof the reference dimensions. If this is not the case, then the\nconverged stress tensor will not equal that specified by the user.  We\ncan resolve this problem by periodically resetting the reference\ndimensions. The keyword nreset controls how often this is done.  If\nthis keyword is not used, or is given a value of zero, then the\nreference dimensions are set to those of the initial simulation domain\nand are never changed. A value of nstep means that every nstep\nminimization steps, the reference dimensions are set to those of the\ncurrent simulation domain. Note that resetting the reference\ndimensions changes the objective function and gradients, which\nsometimes causes the minimization to fail. This can be resolved by\nchanging the value of nreset, or simply continuing the minimization\nfrom a restart file.\n\nNote\nAs normally computed, pressure includes a kinetic- energy or\ntemperature-dependent component; see the compute pressure command.  However, atom velocities are\nignored during a minimization, and the applied pressure(s) specified\nwith this command are assumed to only be the virial component of the\npressure (the non-kinetic portion).  Thus if atoms have a non-zero\ntemperature and you print the usual thermodynamic pressure, it may not\nappear the system is converging to your specified pressure.  The\nsolution for this is to either (a) zero the velocities of all atoms\nbefore performing the minimization, or (b) make sure you are\nmonitoring the pressure without its kinetic component.  The latter can\nbe done by outputting the pressure from the pressure compute this\ncommand creates (see below) or a pressure compute you define yourself.\n\n\nNote\nBecause pressure is often a very sensitive function of volume,\nit can be difficult for the minimizer to equilibrate the system the\ndesired pressure with high precision, particularly for solids.  Some\ntechniques that seem to help are (a) use the “min_modify line\nquadratic” option when minimizing with box relaxations, (b) minimize\nseveral times in succession if need be, to drive the pressure closer\nto the target pressure, (c) relax the atom positions before relaxing\nthe box, and (d) relax the box to the target hydrostatic pressure\nbefore relaxing to a target shear stress state. Also note that some\nsystems (e.g. liquids) will not sustain a non-hydrostatic applied\npressure, which means the minimizer will not converge.\n\n\nThis fix computes a temperature and pressure each timestep.  The\ntemperature is used to compute the kinetic contribution to the\npressure, even though this is subsequently ignored by default.  To do\nthis, the fix creates its own computes of style “temp” and “pressure”,\nas if these commands had been issued:\ncompute fix-ID_temp group-ID temp\ncompute fix-ID_press group-ID pressure fix-ID_temp virial\n\n\nSee the compute temp and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is the same\nas the fix group.  Also note that the pressure compute does not\ninclude a kinetic component.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its temperature and pressure calculation, as described above.  Note\nthat as described above, if you assign a pressure compute to this fix\nthat includes a kinetic energy component it will affect the\nminimization, most likely in an undesirable way.\n\nNote\nIf both the temp and press keywords are used in a single\nthermo_modify command (or in two separate commands), then the order in\nwhich the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\nan argument when it is specified.  The temp keyword will override\nthis (for the pressure compute being used by fix box/relax), but only if the\ntemp keyword comes after the press keyword.  If the temp keyword\ncomes before the press keyword, then the new pressure compute\nspecified by the press keyword will be unaffected by the temp\nsetting.\n\nThis fix computes a global scalar which can be accessed by various\noutput commands. The scalar is the pressure-volume\nenergy, plus the strain energy, if it exists, as described above.  The\nenergy values reported at the end of a minimization run under\n“Minimization stats” include this energy, and so differ from what\nLAMMPS normally reports as potential energy. This fix does not support\nthe fix_modify energy option, because that would\nresult in double-counting of the fix energy in the minimization\nenergy. Instead, the fix energy can be explicitly added to the\npotential energy using one of these two variants:\nvariable emin equal pe+f_1\n\nvariable emin equal pe+f_1/atoms\n\n\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThis fix is invoked during energy minimization, but\nnot for the purpose of adding a contribution to the energy or forces\nbeing minimized.  Instead it alters the simulation box geometry as\ndescribed above.",
    "syntax": "fix ID group-ID box/relax keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * box/relax = style name of this fix command\n * one or more keyword value pairs may be appended\n * keyword = iso or aniso or tri or x or y or z or xy or yz or xz or couple or nreset or vmax or dilate or scaleyz or scalexz or scalexy or fixedpoint\n *   iso or aniso or tri value = Ptarget = desired pressure (pressure units)\n *   x or y or z or xy or yz or xz value = Ptarget = desired pressure (pressure units)\n *   couple = none or xyz or xy or yz or xz\n *   nreset value = reset reference cell every this many minimizer iterations\n *   vmax value = fraction = max allowed volume change in one iteration\n *   dilate value = all or partial\n *   scaleyz value = yes or no = scale yz with lz\n *   scalexz value = yes or no = scale xz with lz\n *   scalexy value = yes or no = scale xy with ly\n *   fixedpoint values = x y z\n *     x,y,z = perform relaxation dilation/contraction around this point (distance units)",
    "examples": "fix 1 all box/relax iso 0.0 vmax 0.001\nfix 2 water box/relax aniso 0.0 dilate partial\nfix 2 ice box/relax tri 0.0 couple xy nreset 100",
    "restrictions": "Only dimensions that are available can be adjusted by this fix.\nNon-periodic dimensions are not available.  z, xz, and yz, are\nnot available for 2D simulations. xy, xz, and yz are only\navailable if the simulation domain is non-orthogonal.  The\ncreate_box, read data, and\nread_restart commands specify whether the\nsimulation box is orthogonal or non-orthogonal (triclinic) and explain\nthe meaning of the xy,xz,yz tilt factors.\nThe scaleyz yes and scalexz yes keyword/value pairs can not be used\nfor 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\ncan only be used if the 2nd dimension in the keyword is periodic,\nand if the tilt factor is not coupled to the barostat via keywords\ntri, yz, xz, and xy."
},
{
    "command": "fix client/md",
    "html_filename": "fix_client_md.html",
    "short_description": "This fix style enables LAMMPS to run as a “client” code and communicate each timestep with a separate “server” code to perform an MD simulation together",
    "description": "This fix style enables LAMMPS to run as a “client” code and\ncommunicate each timestep with a separate “server” code to perform an\nMD simulation together.\nThe Howto client/server doc page gives an\noverview of client/server coupling of LAMMPS with another code where\none code is the “client” and sends request messages to a “server”\ncode.  The server responds to each request with a reply message.  This\nenables the two codes to work in tandem to perform a simulation.\nWhen using this fix, LAMMPS (as the client code) passes the current\ncoordinates of all particles to the server code each timestep, which\ncomputes their interaction, and returns the energy, forces, and virial\nfor the interacting particles to LAMMPS, so it can complete the\ntimestep.\nNote that the server code can be a quantum code, or another classical\nMD code which encodes a force field (pair_style in LAMMPS lingo) which\nLAMMPS does not have.  In the quantum case, this fix is a mechanism\nfor running ab initio MD with quantum forces.\nThe group associated with this fix is ignored.\nThe protocol and units for message format and content\nthat LAMMPS exchanges with the server code is defined on the server md doc page.\nNote that when using LAMMPS as an MD client, your LAMMPS input script\nshould not normally contain force field commands, like a\npair_style, bond_style, or\nkspace_style command.  However it is possible for\na server code to only compute a portion of the full force-field, while\nLAMMPS computes the remaining part.  Your LAMMPS script can also\nspecify boundary conditions or force constraints in the usual way,\nwhich will be added to the per-atom forces returned by the server\ncode.\nSee the examples/message directory for example scripts where LAMMPS is both\nthe “client” and/or “server” code for this kind of client/server MD\nsimulation.  The examples/message/README file explains how to launch\nLAMMPS and another code in tandem to perform a coupled simulation.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential energy computed by the server application to\nthe system’s potential energy as part of thermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the server application’s contribution to the system’s\nvirial as part of thermodynamic output.  The\ndefault is virial yes\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the potential\nenergy discussed above.  The scalar value calculated by this fix is\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID client/md",
    "parameters": " * ID, group-ID are documented in fix command\n * client/md = style name of this fix command",
    "examples": "fix 1 all client/md",
    "restrictions": "This fix is part of the MESSAGE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nA script that uses this command must also use the\nmessage command to setup and shut down the messaging\nprotocol with the server code."
},
{
    "command": "fix cmap",
    "html_filename": "fix_cmap.html",
    "short_description": "This command enables CMAP cross-terms to be added to simulations which use the CHARMM force field",
    "description": "This command enables CMAP cross-terms to be added to simulations which\nuse the CHARMM force field.  These are relevant for any CHARMM model\nof a peptide or protein sequences that is 3 or more amino-acid\nresidues long; see (Buck) and (Brooks) for details,\nincluding the analytic energy expressions for CMAP interactions.  The\nCMAP cross-terms add additional potential energy contributions to pairs\nof overlapping phi-psi dihedrals of amino-acids, which are important\nto properly represent their conformational behavior.\nThe examples/cmap directory has a sample input script and data file\nfor a small peptide, that illustrates use of the fix cmap command.\nAs in the example above, this fix should be used before reading a data\nfile that contains a listing of CMAP interactions.  The filename\nspecified should contain the CMAP parameters for a particular version\nof the CHARMM force field.  Two such files are including in the\nlammps/potentials directory: charmm22.cmap and charmm36.cmap.\nThe data file read by the “read_data” must contain the topology of all\nthe CMAP interactions, similar to the topology data for bonds, angles,\ndihedrals, etc.  Specially it should have a line like this\nin its header section:\nN crossterms\n\n\nwhere N is the number of CMAP cross-terms.  It should also have a section\nin the body of the data file like this with N lines:\nCMAP\n\n       1       1       8      10      12      18      20\n       2       5      18      20      22      25      27\n       [...]\n       N       3     314     315     317      318    330\n\n\nThe first column is an index from 1 to N to enumerate the CMAP terms;\nit is ignored by LAMMPS.  The 2nd column is the “type” of the\ninteraction; it is an index into the CMAP force field file.  The\nremaining 5 columns are the atom IDs of the atoms in the two 4-atom\ndihedrals that overlap to create the CMAP 5-body interaction.  Note\nthat the “crossterm” and “CMAP” keywords for the header and body\nsections match those specified in the read_data command following the\ndata file name; see the read_data doc page for\nmore details.\nA data file containing CMAP cross-terms can be generated from a PDB\nfile using the charmm2lammps.pl script in the tools/ch2lmp directory\nof the LAMMPS distribution.  The script must be invoked with the\noptional “-cmap” flag to do this; see the tools/ch2lmp/README file for\nmore information.\nThe potential energy associated with CMAP interactions can be output\nas described below.  It can also be included in the total potential\nenergy of the system, as output by the\nthermo_style command, if the fix_modify energy command is used, as in the example above.  See\nthe note below about how to include the CMAP energy when performing an\nenergy minimization.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the list of CMAP cross-terms to binary restart files.  See the read_restart command\nfor info on how to re-specify a fix in an input script that reads a\nrestart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify energy option is supported by this\nfix to add the potential “energy” of the CMAP interactions system’s\npotential energy as part of thermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the interaction between atoms to\nthe system’s virial as part of thermodynamic output.\nThe default is virial yes\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the potential\nenergy discussed above.  The scalar value calculated by this fix is\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the potential energy associated with the CMAP terms\nforces to be included in the total potential energy of the system (the\nquantity being minimized), you MUST enable the\nfix_modify energy option for this fix.",
    "syntax": "fix ID group-ID cmap filename",
    "parameters": " * ID, group-ID are documented in fix command\n * cmap = style name of this fix command\n * filename = force-field file with CMAP coefficients",
    "examples": "fix            myCMAP all cmap ../potentials/cmap36.data\nread_data      proteinX.data fix myCMAP crossterm CMAP\nfix_modify     myCMAP energy yes",
    "restrictions": "To function as expected this fix command must be issued before a\nread_data command but after a\nread_restart command.\nThis fix can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "fix colvars",
    "html_filename": "fix_colvars.html",
    "short_description": "This fix interfaces LAMMPS to the collective variables “Colvars” library, which allows to calculate potentials of mean force (PMFs) for any set of colvars, using different sampling methods: currently implemented are the Adaptive Biasing Force (ABF) method, metadynamics, Steered Molecular Dynamics (SMD) and Umbrella Sampling (US) via a flexible harmonic restraint bias",
    "description": "This fix interfaces LAMMPS to the collective variables “Colvars”\nlibrary, which allows to calculate potentials of mean force\n(PMFs) for any set of colvars, using different sampling methods:\ncurrently implemented are the Adaptive Biasing Force (ABF) method,\nmetadynamics, Steered Molecular Dynamics (SMD) and Umbrella Sampling\n(US) via a flexible harmonic restraint bias.\nThis documentation describes only the fix colvars command itself and\nLAMMPS specific parts of the code.  The full documentation of the\ncolvars library is available as this supplementary PDF document\nThe Colvars library is developed at https://github.com/colvars/colvars\nA detailed discussion of its implementation is in (Fiorin).\nThere are some example scripts for using this package with LAMMPS in the\nexamples/USER/colvars directory.\n\nThe only mandatory argument to the fix is the filename to the colvars\ninput file that contains the input that is independent from the MD\nprogram in which the colvars library has been integrated.\nThe group-ID entry is ignored. The collective variable module will\nalways apply to the entire system and there can only be one instance\nof the colvars fix at a time. The colvars fix will only communicate\nthe minimum information necessary and the colvars library supports\nmultiple, completely independent collective variables, so there is\nno restriction to functionality by limiting the number of colvars fixes.\nThe input keyword allows to specify a state file that would contain\nthe restart information required in order to continue a calculation from\na prerecorded state. Fix colvars records it state in binary restart\nfiles, so when using the read_restart command,\nthis is usually not needed.\nThe output keyword allows to specify the output prefix. All output\nfiles generated will use this prefix followed by the “.colvars.” and\na word like “state” or “traj”.\nThe seed keyword contains the seed for the random number generator\nthat will be used in the colvars module.\nThe unwrap keyword controls whether wrapped or unwrapped coordinates\nare passed to the colvars library for calculation of the collective\nvariables and the resulting forces. The default is yes, i.e. to use\nthe image flags to reconstruct the absolute atom positions.\nSetting this to no will use the current local coordinates that are\nwrapped back into the simulation cell at each re-neighboring instead.\nThe tstat keyword can be either NULL or the label of a thermostatting\nfix that thermostats all atoms in the fix colvars group. This will be\nused to provide the colvars module with the current thermostat target\ntemperature.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the current status of the colvars module into\nbinary restart files. This is in addition to the text\nmode status file that is written by the colvars module itself and the\nkind of information in both files is identical.\nThe fix_modify energy option is supported by this\nfix to add the energy change from the biasing force added by the fix\nto the system’s potential energy as part of thermodynamic output.\nThe fix_modify configfile <config file> option allows to add settings\nfrom an additional config file to the colvars module. This option can\nonly be used, after the system has been initialized with a run\ncommand.\nThe fix_modify config <quoted string> option allows to add settings\nfrom inline strings. Those have to fit on a single line when enclosed\nin a pair of double quotes (“), or can span multiple lines when bracketed\nby a pair of triple double quotes (“””, like python embedded documentation).\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.",
    "syntax": "fix ID group-ID colvars configfile keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * colvars = style name of this fix command\n * configfile = the configuration file for the colvars module\n * keyword = input or output or seed or tstat\n * input arg = colvars.state file name or prefix or NULL (default: NULL)\n * output arg = output filename prefix (default: out)\n * seed arg = seed for random number generator (default: 1966)\n * unwrap arg = yes or no\n *   use unwrapped coordinates in collective variables (default: yes)\n * tstat arg = fix id of a thermostat or NULL (default: NULL)",
    "examples": "fix mtd all colvars peptide.colvars.inp seed 2122 input peptide.colvars.state output peptide\nfix abf all colvars colvars.inp tstat 1",
    "restrictions": "This fix is part of the USER-COLVARS package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThere can only be one colvars fix active at a time. Since the interface\ncommunicates only the minimum amount of information and colvars module\nitself can handle an arbitrary number of collective variables, this is\nnot a limitation of functionality."
},
{
    "command": "fix controller",
    "html_filename": "fix_controller.html",
    "short_description": "This fix enables control of a LAMMPS simulation using a control loop feedback mechanism known as a proportional-integral-derivative (PID) controller",
    "description": "This fix enables control of a LAMMPS simulation using a control loop\nfeedback mechanism known as a proportional-integral-derivative (PID)\ncontroller.  The basic idea is to define a “process variable” which is\na quantity that can be monitored during a running simulation.  A\ndesired target value is chosen for the process variable.  A “control\nvariable” is also defined which is an adjustable attribute of the\nrunning simulation, which the process variable will respond to.  The\nPID controller continuously adjusts the control variable based on the\ndifference between the process variable and the target.\nHere are examples of ways in which this fix can be used.  The\nexamples/pid directory contains a script that implements the simple\nthermostat.\n\n\n\n\n\n\n\nGoal\nprocess variable\ncontrol variable\n\nSimple thermostat\ninstantaneous T\nthermostat target T\n\nFind melting temperature\naverage PE per atom\nthermostat target T\n\nControl pressure in non-periodic system\nforce on wall\nposition of wall\n\n\n\n\n\n\n\n\nNote\nFor this fix to work, the control variable must actually induce\na change in a running LAMMPS simulation.  Typically this will only\noccur if there is some other command (e.g. a thermostat fix) which\nuses the control variable as an input parameter.  This could be done\ndirectly or indirectly, e.g. the other command uses a variable as\ninput whose formula uses the control variable.  The other command\nshould alter its behavior dynamically as the variable changes.\n\n\nNote\nIf there is a command you think could be used in this fashion,\nbut does not currently allow a variable as an input parameter, please\nnotify the LAMMPS developers.  It is often not difficult to enable a\ncommand to use a variable as an input parameter.\n\nThe group specified with this command is ignored.  However, note that\nthe process variable may be defined by calculations performed by\ncomputes and fixes which store their own “group” definitions.\nThe PID controller is invoked once each Nevery timesteps.\nThe PID controller is implemented as a discretized version of\nthe following dynamic equation:\n\n\\[\\frac{dc}{dt}  = \\hat{E} -\\alpha (K_p e + K_i \\int_0^t e \\, dt + K_d \\frac{de}{dt} )\\]\nwhere c is the continuous time analog of the control variable,\ne =pvar-setpoint is the error in the process variable, and\n\\(\\alpha\\), \\(K_p\\), \\(K_i\\) , and \\(K_d\\) are constants\nset by the corresponding\nkeywords described above. The discretized version of this equation is:\n\n\\[c_n  = \\hat{E} c_{n-1} -\\alpha \\left( K_p \\tau e_n + K_i \\tau^2 \\sum_{i=1}^n e_i + K_d (e_n - e_{n-1}) \\right)\\]\nwhere \\(\\tau = \\mathtt{Nevery} \\cdot \\mathtt{timestep}\\) is the time\ninterval between updates,\nand the subscripted variables indicate the values of c and e at\nsuccessive updates.\nFrom the first equation, it is clear that if the three gain values\n\\(K_p\\), \\(K_i\\), \\(K_d\\) are dimensionless constants,\nthen \\(\\alpha\\) must have\nunits of [unit cvar]/[unit pvar]/[unit time] e.g. [ eV/K/ps\n]. The advantage of this unit scheme is that the value of the\nconstants should be invariant under a change of either the MD timestep\nsize or the value of Nevery. Similarly, if the LAMMPS unit style is changed, it should only be necessary to change\nthe value of \\(\\alpha\\) to reflect this, while leaving \\(K_p\\),\n\\(K_i\\), and \\(K_d\\) unaltered.\nWhen choosing the values of the four constants, it is best to first\npick a value and sign for \\(\\alpha\\) that is consistent with the\nmagnitudes and signs of pvar and cvar.  The magnitude of \\(K_p\\)\nshould then be tested over a large positive range keeping \\(K_i = K_d =0\\).\nA good value for \\(K_p\\) will produce a fast response in pvar,\nwithout overshooting the setpoint.  For many applications, proportional\nfeedback is sufficient, and so \\(K_i\\) = K_d =0` can be used. In cases\nwhere there is a substantial lag time in the response of pvar to a change\nin cvar, this can be counteracted by increasing \\(K_d\\). In situations\nwhere pvar plateaus without reaching setpoint, this can be\ncounteracted by increasing \\(K_i\\).  In the language of Charles Dickens,\n\\(K_p\\) represents the error of the present, \\(K_i\\) the error of\nthe past, and \\(K_d\\) the error yet to come.\nBecause this fix updates cvar, but does not initialize its value,\nthe initial value is that assigned by the user in the input script via\nthe internal-style variable command.  This value is\nused (by the other LAMMPS command that used the variable) until this\nfix performs its first update of cvar after Nevery timesteps.  On\nthe first update, the value of the derivative term is set to zero,\nbecause the value of \\(e_n-1\\) is not yet defined.\n\nThe process variable pvar can be specified as the output of a\ncompute or fix or the evaluation of a\nvariable.  In each case, the compute, fix, or variable\nmust produce a global quantity, not a per-atom or local quantity.\nIf pvar begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script and which generates a global\nscalar or vector.  See the individual compute doc page\nfor details.  If no bracketed integer is appended, the scalar\ncalculated by the compute is used.  If a bracketed integer is\nappended, the Ith value of the vector calculated by the compute is\nused.  Users can also write code for their own compute styles and add them to LAMMPS.\nIf pvar begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script and which generates a global\nscalar or vector.  See the individual fix doc page for\ndetails.  Note that some fixes only produce their values on certain\ntimesteps, which must be compatible with when fix controller\nreferences the values, or else an error results.  If no bracketed integer\nis appended, the scalar calculated by the fix is used.  If a bracketed\ninteger is appended, the Ith value of the vector calculated by the fix\nis used.  Users can also write code for their own fix style and add them to LAMMPS.\nIf pvar begins with “v_”, a variable name must follow which has been\npreviously defined in the input script.  Only equal-style variables\ncan be referenced.  See the variable command for\ndetails.  Note that variables of style equal define a formula which\ncan reference individual atom properties or thermodynamic keywords, or\nthey can invoke other computes, fixes, or variables when they are\nevaluated, so this is a very general means of specifying the process\nvariable.\nThe target value setpoint for the process variable must be a numeric\nvalue, in whatever units pvar is defined for.\nThe control variable cvar must be the name of an internal-style variable previously defined in the input script.  Note\nthat it is not specified with a “v_” prefix, just the name of the\nvariable.  It must be an internal-style variable, because this fix\nupdates its value directly.  Note that other commands can use an\nequal-style versus internal-style variable interchangeably.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix produces a global vector with 3 values which can be accessed\nby various output commands.  The values can be\naccessed on any timestep, though they are only updated on timesteps\nthat are a multiple of Nevery.\nThe three values are the most recent updates made to the control\nvariable by each of the 3 terms in the PID equation above.  The first\nvalue is the proportional term, the second is the integral term, the\nthird is the derivative term.\nThe units of the vector values will be whatever units the control\nvariable is in.  The vector values calculated by this fix are\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID controller Nevery alpha Kp Ki Kd pvar setpoint cvar",
    "parameters": " * ID, group-ID are documented in fix command\n * controller = style name of this fix command\n * Nevery = invoke controller every this many timesteps\n * alpha = coupling constant for PID equation (see units discussion below)\n * Kp = proportional gain in PID equation (unitless)\n * Ki = integral gain in PID equation (unitless)\n * Kd = derivative gain in PID equation (unitless)\n * pvar = process variable of form c_ID, c_ID[I], f_ID, f_ID[I], or v_name\n * c_ID = global scalar calculated by a compute with ID\n * c_ID[I] = Ith component of global vector calculated by a compute with ID\n * f_ID = global scalar calculated by a fix with ID\n * f_ID[I] = Ith component of global vector calculated by a fix with ID\n * v_name = value calculated by an equal-style variable with name\n * setpoint = desired value of process variable (same units as process variable)\n * cvar = name of control variable",
    "examples": "fix 1 all controller 100 1.0 0.5 0.0 0.0 c_thermo_temp 1.5 tcontrol\nfix 1 all controller 100 0.2 0.5 0 100.0 v_pxxwall 1.01325 xwall\nfix 1 all controller 10000 0.2 0.5 0 2000 v_avpe -3.785 tcontrol",
    "restrictions": "\nnone"
},
{
    "command": "fix deform",
    "html_filename": "fix_deform.html",
    "short_description": "Change the volume and/or shape of the simulation box during a dynamics run",
    "description": "Change the volume and/or shape of the simulation box during a dynamics\nrun.  Orthogonal simulation boxes have 3 adjustable parameters\n(x,y,z).  Triclinic (non-orthogonal) simulation boxes have 6\nadjustable parameters (x,y,z,xy,xz,yz).  Any or all of them can be\nadjusted independently and simultaneously by this command.\nThis fix can be used to perform non-equilibrium MD (NEMD) simulations\nof a continuously strained system.  See the fix nvt/sllod and compute temp/deform commands for more details.  Note\nthat simulation of a continuously extended system (extensional flow)\ncan be modeled using the USER-UEF package and its fix commands.\nFor the x, y, z parameters, the associated dimension cannot be\nshrink-wrapped.  For the xy, yz, xz parameters, the associated\n2nd dimension cannot be shrink-wrapped.  Dimensions not varied by this\ncommand can be periodic or non-periodic.  Dimensions corresponding to\nunspecified parameters can also be controlled by a fix npt or fix nph command.\nThe size and shape of the simulation box at the beginning of the\nsimulation run were either specified by the\ncreate_box or read_data or\nread_restart command used to setup the simulation\ninitially if it is the first run, or they are the values from the end\nof the previous run.  The create_box, read data, and read_restart commands\nspecify whether the simulation box is orthogonal or non-orthogonal\n(triclinic) and explain the meaning of the xy,xz,yz tilt factors.  If\nfix deform changes the xy,xz,yz tilt factors, then the simulation box\nmust be triclinic, even if its initial tilt factors are 0.0.\nAs described below, the desired simulation box size and shape at the\nend of the run are determined by the parameters of the fix deform\ncommand.  Every Nth timestep during the run, the simulation box is\nexpanded, contracted, or tilted to ramped values between the initial\nand final values.\n\nFor the x, y, and z parameters, this is the meaning of their\nstyles and values.\nThe final, delta, scale, vel, and erate styles all change\nthe specified dimension of the box via “constant displacement” which\nis effectively a “constant engineering strain rate”.  This means the\nbox dimension changes linearly with time from its initial to final\nvalue.\nFor style final, the final lo and hi box boundaries of a dimension\nare specified.  The values can be in lattice or box distance units.\nSee the discussion of the units keyword below.\nFor style delta, plus or minus changes in the lo/hi box boundaries\nof a dimension are specified.  The values can be in lattice or box\ndistance units.  See the discussion of the units keyword below.\nFor style scale, a multiplicative factor to apply to the box length\nof a dimension is specified.  For example, if the initial box length\nis 10, and the factor is 1.1, then the final box length will be 11.  A\nfactor less than 1.0 means compression.\nFor style vel, a velocity at which the box length changes is\nspecified in units of distance/time.  This is effectively a “constant\nengineering strain rate”, where rate = V/L0 and L0 is the initial box\nlength.  The distance can be in lattice or box distance units.  See\nthe discussion of the units keyword below.  For example, if the\ninitial box length is 100 Angstroms, and V is 10 Angstroms/psec, then\nafter 10 psec, the box length will have doubled.  After 20 psec, it\nwill have tripled.\nThe erate style changes a dimension of the box at a “constant\nengineering strain rate”.  The units of the specified strain rate are\n1/time.  See the units command for the time units\nassociated with different choices of simulation units,\ne.g. picoseconds for “metal” units).  Tensile strain is unitless and\nis defined as delta/L0, where L0 is the original box length and delta\nis the change relative to the original length.  The box length L as a\nfunction of time will change as\nL(t) = L0 (1 + erate*dt)\nwhere dt is the elapsed time (in time units).  Thus if erate R is\nspecified as 0.1 and time units are picoseconds, this means the box\nlength will increase by 10% of its original length every picosecond.\nI.e. strain after 1 psec = 0.1, strain after 2 psec = 0.2, etc.  R =\n-0.01 means the box length will shrink by 1% of its original length\nevery picosecond.  Note that for an “engineering” rate the change is\nbased on the original box length, so running with R = 1 for 10\npicoseconds expands the box length by a factor of 11 (strain of 10),\nwhich is different that what the trate style would induce.\nThe trate style changes a dimension of the box at a “constant true\nstrain rate”.  Note that this is not an “engineering strain rate”, as\nthe other styles are.  Rather, for a “true” rate, the rate of change\nis constant, which means the box dimension changes non-linearly with\ntime from its initial to final value.  The units of the specified\nstrain rate are 1/time.  See the units command for the\ntime units associated with different choices of simulation units,\ne.g. picoseconds for “metal” units).  Tensile strain is unitless and\nis defined as delta/L0, where L0 is the original box length and delta\nis the change relative to the original length.\nThe box length L as a function of time will change as\nL(t) = L0 exp(trate*dt)\nwhere dt is the elapsed time (in time units).  Thus if trate R is\nspecified as ln(1.1) and time units are picoseconds, this means the\nbox length will increase by 10% of its current (not original) length\nevery picosecond.  I.e. strain after 1 psec = 0.1, strain after 2 psec\n= 0.21, etc.  R = ln(2) or ln(3) means the box length will double or\ntriple every picosecond.  R = ln(0.99) means the box length will\nshrink by 1% of its current length every picosecond.  Note that for a\n“true” rate the change is continuous and based on the current length,\nso running with R = ln(2) for 10 picoseconds does not expand the box\nlength by a factor of 11 as it would with erate, but by a factor of\n1024 since the box length will double every picosecond.\nNote that to change the volume (or cross-sectional area) of the\nsimulation box at a constant rate, you can change multiple dimensions\nvia erate or trate.  E.g. to double the box volume in a picosecond\npicosecond, you could set “x erate M”, “y erate M”, “z erate M”, with\nM = pow(2,1/3) - 1 = 0.26, since if each box dimension grows by 26%,\nthe box volume doubles.  Or you could set “x trate M”, “y trate M”, “z\ntrate M”, with M = ln(1.26) = 0.231, and the box volume would double\nevery picosecond.\nThe volume style changes the specified dimension in such a way that\nthe box volume remains constant while other box dimensions are changed\nexplicitly via the styles discussed above.  For example, “x scale 1.1\ny scale 1.1 z volume” will shrink the z box length as the x,y box\nlengths increase, to keep the volume constant (product of x,y,z\nlengths).  If “x scale 1.1 z volume” is specified and parameter y is\nunspecified, then the z box length will shrink as x increases to keep\nthe product of x,z lengths constant.  If “x scale 1.1 y volume z\nvolume” is specified, then both the y,z box lengths will shrink as x\nincreases to keep the volume constant (product of x,y,z lengths).  In\nthis case, the y,z box lengths shrink so as to keep their relative\naspect ratio constant.\nFor solids or liquids, note that when one dimension of the box is\nexpanded via fix deform (i.e. tensile strain), it may be physically\nundesirable to hold the other 2 box lengths constant (unspecified by\nfix deform) since that implies a density change.  Using the volume\nstyle for those 2 dimensions to keep the box volume constant may make\nmore physical sense, but may also not be correct for materials and\npotentials whose Poisson ratio is not 0.5.  An alternative is to use\nfix npt aniso with zero applied pressure on those 2\ndimensions, so that they respond to the tensile strain dynamically.\nThe wiggle style oscillates the specified box length dimension\nsinusoidally with the specified amplitude and period.  I.e. the box\nlength L as a function of time is given by\nL(t) = L0 + A sin(2*pi t/Tp)\nwhere L0 is its initial length.  If the amplitude A is a positive\nnumber the box initially expands, then contracts, etc.  If A is\nnegative then the box initially contracts, then expands, etc.  The\namplitude can be in lattice or box distance units.  See the discussion\nof the units keyword below.\nThe variable style changes the specified box length dimension by\nevaluating a variable, which presumably is a function of time.  The\nvariable with name1 must be an equal-style variable\nand should calculate a change in box length in units of distance.\nNote that this distance is in box units, not lattice units; see the\ndiscussion of the units keyword below.  The formula associated with\nvariable name1 can reference the current timestep.  Note that it\nshould return the “change” in box length, not the absolute box length.\nThis means it should evaluate to 0.0 when invoked on the initial\ntimestep of the run following the definition of fix deform.  It should\nevaluate to a value > 0.0 to dilate the box at future times, or a\nvalue < 0.0 to compress the box.\nThe variable name2 must also be an equal-style variable and should calculate the rate of box length\nchange, in units of distance/time, i.e. the time-derivative of the\nname1 variable.  This quantity is used internally by LAMMPS to reset\natom velocities when they cross periodic boundaries.  It is computed\ninternally for the other styles, but you must provide it when using an\narbitrary variable.\nHere is an example of using the variable style to perform the same\nbox deformation as the wiggle style formula listed above, where we\nassume that the current timestep = 0.\nvariable A equal 5.0\nvariable Tp equal 10.0\nvariable displace equal \"v_A * sin(2*PI * step*dt/v_Tp)\"\nvariable rate equal \"2*PI*v_A/v_Tp * cos(2*PI * step*dt/v_Tp)\"\nfix 2 all deform 1 x variable v_displace v_rate remap v\nFor the scale, vel, erate, trate, volume, wiggle, and\nvariable styles, the box length is expanded or compressed around its\nmid point.\n\nFor the xy, xz, and yz parameters, this is the meaning of their\nstyles and values.  Note that changing the tilt factors of a triclinic\nbox does not change its volume.\nThe final, delta, vel, and erate styles all change the shear\nstrain at a “constant engineering shear strain rate”.  This means the\ntilt factor changes linearly with time from its initial to final\nvalue.\nFor style final, the final tilt factor is specified.  The value\ncan be in lattice or box distance units.  See the discussion of the\nunits keyword below.\nFor style delta, a plus or minus change in the tilt factor is\nspecified.  The value can be in lattice or box distance units.  See\nthe discussion of the units keyword below.\nFor style vel, a velocity at which the tilt factor changes is\nspecified in units of distance/time.  This is effectively an\n“engineering shear strain rate”, where rate = V/L0 and L0 is the\ninitial box length perpendicular to the direction of shear.  The\ndistance can be in lattice or box distance units.  See the discussion\nof the units keyword below.  For example, if the initial tilt factor\nis 5 Angstroms, and the V is 10 Angstroms/psec, then after 1 psec, the\ntilt factor will be 15 Angstroms.  After 2 psec, it will be 25\nAngstroms.\nThe erate style changes a tilt factor at a “constant engineering\nshear strain rate”.  The units of the specified shear strain rate are\n1/time.  See the units command for the time units\nassociated with different choices of simulation units,\ne.g. picoseconds for “metal” units).  Shear strain is unitless and is\ndefined as offset/length, where length is the box length perpendicular\nto the shear direction (e.g. y box length for xy deformation) and\noffset is the displacement distance in the shear direction (e.g. x\ndirection for xy deformation) from the unstrained orientation.\nThe tilt factor T as a function of time will change as\nT(t) = T0 + L0*erate*dt\nwhere T0 is the initial tilt factor, L0 is the original length of the\nbox perpendicular to the shear direction (e.g. y box length for xy\ndeformation), and dt is the elapsed time (in time units).  Thus if\nerate R is specified as 0.1 and time units are picoseconds, this\nmeans the shear strain will increase by 0.1 every picosecond.  I.e. if\nthe xy shear strain was initially 0.0, then strain after 1 psec = 0.1,\nstrain after 2 psec = 0.2, etc.  Thus the tilt factor would be 0.0 at\ntime 0, 0.1*ybox at 1 psec, 0.2*ybox at 2 psec, etc, where ybox is the\noriginal y box length.  R = 1 or 2 means the tilt factor will increase\nby 1 or 2 every picosecond.  R = -0.01 means a decrease in shear\nstrain by 0.01 every picosecond.\nThe trate style changes a tilt factor at a “constant true shear\nstrain rate”.  Note that this is not an “engineering shear strain\nrate”, as the other styles are.  Rather, for a “true” rate, the rate\nof change is constant, which means the tilt factor changes\nnon-linearly with time from its initial to final value.  The units of\nthe specified shear strain rate are 1/time.  See the\nunits command for the time units associated with\ndifferent choices of simulation units, e.g. picoseconds for “metal”\nunits).  Shear strain is unitless and is defined as offset/length,\nwhere length is the box length perpendicular to the shear direction\n(e.g. y box length for xy deformation) and offset is the displacement\ndistance in the shear direction (e.g. x direction for xy deformation)\nfrom the unstrained orientation.\nThe tilt factor T as a function of time will change as\nT(t) = T0 exp(trate*dt)\nwhere T0 is the initial tilt factor and dt is the elapsed time (in\ntime units).  Thus if trate R is specified as ln(1.1) and time units\nare picoseconds, this means the shear strain or tilt factor will\nincrease by 10% every picosecond.  I.e. if the xy shear strain was\ninitially 0.1, then strain after 1 psec = 0.11, strain after 2 psec =\n0.121, etc.  R = ln(2) or ln(3) means the tilt factor will double or\ntriple every picosecond.  R = ln(0.99) means the tilt factor will\nshrink by 1% every picosecond.  Note that the change is continuous, so\nrunning with R = ln(2) for 10 picoseconds does not change the tilt\nfactor by a factor of 10, but by a factor of 1024 since it doubles\nevery picosecond.  Note that the initial tilt factor must be non-zero\nto use the trate option.\nNote that shear strain is defined as the tilt factor divided by the\nperpendicular box length.  The erate and trate styles control the\ntilt factor, but assume the perpendicular box length remains constant.\nIf this is not the case (e.g. it changes due to another fix deform\nparameter), then this effect on the shear strain is ignored.\nThe wiggle style oscillates the specified tilt factor sinusoidally\nwith the specified amplitude and period.  I.e. the tilt factor T as a\nfunction of time is given by\nT(t) = T0 + A sin(2*pi t/Tp)\nwhere T0 is its initial value.  If the amplitude A is a positive\nnumber the tilt factor initially becomes more positive, then more\nnegative, etc.  If A is negative then the tilt factor initially\nbecomes more negative, then more positive, etc.  The amplitude can be\nin lattice or box distance units.  See the discussion of the units\nkeyword below.\nThe variable style changes the specified tilt factor by evaluating a\nvariable, which presumably is a function of time.  The variable with\nname1 must be an equal-style variable and should\ncalculate a change in tilt in units of distance.  Note that this\ndistance is in box units, not lattice units; see the discussion of the\nunits keyword below.  The formula associated with variable name1\ncan reference the current timestep.  Note that it should return the\n“change” in tilt factor, not the absolute tilt factor.  This means it\nshould evaluate to 0.0 when invoked on the initial timestep of the run\nfollowing the definition of fix deform.\nThe variable name2 must also be an equal-style variable and should calculate the rate of tilt change,\nin units of distance/time, i.e. the time-derivative of the name1\nvariable.  This quantity is used internally by LAMMPS to reset atom\nvelocities when they cross periodic boundaries.  It is computed\ninternally for the other styles, but you must provide it when using an\narbitrary variable.\nHere is an example of using the variable style to perform the same\nbox deformation as the wiggle style formula listed above, where we\nassume that the current timestep = 0.\nvariable A equal 5.0\nvariable Tp equal 10.0\nvariable displace equal \"v_A * sin(2*PI * step*dt/v_Tp)\"\nvariable rate equal \"2*PI*v_A/v_Tp * cos(2*PI * step*dt/v_Tp)\"\nfix 2 all deform 1 xy variable v_displace v_rate remap v\n\nAll of the tilt styles change the xy, xz, yz tilt factors during a\nsimulation.  In LAMMPS, tilt factors (xy,xz,yz) for triclinic boxes\nare normally bounded by half the distance of the parallel box length.\nSee the discussion of the flip keyword below, to allow this bound to\nbe exceeded, if desired.\nFor example, if xlo = 2 and xhi = 12, then the x box length is 10 and\nthe xy tilt factor must be between -5 and 5.  Similarly, both xz and\nyz must be between -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is\nnot a limitation, since if the maximum tilt factor is 5 (as in this\nexample), then configurations with tilt = …, -15, -5, 5, 15, 25,\n… are all equivalent.\nTo obey this constraint and allow for large shear deformations to be\napplied via the xy, xz, or yz parameters, the following\nalgorithm is used.  If prd is the associated parallel box length (10\nin the example above), then if the tilt factor exceeds the accepted\nrange of -5 to 5 during the simulation, then the box is flipped to the\nother limit (an equivalent box) and the simulation continues.  Thus\nfor this example, if the initial xy tilt factor was 0.0 and “xy final\n100.0” was specified, then during the simulation the xy tilt factor\nwould increase from 0.0 to 5.0, the box would be flipped so that the\ntilt factor becomes -5.0, the tilt factor would increase from -5.0 to\n5.0, the box would be flipped again, etc.  The flip occurs 10 times\nand the final tilt factor at the end of the simulation would be 0.0.\nDuring each flip event, atoms are remapped into the new box in the\nappropriate manner.\nThe one exception to this rule is if the 1st dimension in the tilt\nfactor (x for xy) is non-periodic.  In that case, the limits on the\ntilt factor are not enforced, since flipping the box in that dimension\ndoes not change the atom positions due to non-periodicity.  In this\nmode, if you tilt the system to extreme angles, the simulation will\nsimply become inefficient due to the highly skewed simulation box.\n\nEach time the box size or shape is changed, the remap keyword\ndetermines whether atom positions are remapped to the new box.  If\nremap is set to x (the default), atoms in the fix group are\nremapped; otherwise they are not.  Note that their velocities are not\nchanged, just their positions are altered.  If remap is set to v,\nthen any atom in the fix group that crosses a periodic boundary will\nhave a delta added to its velocity equal to the difference in\nvelocities between the lo and hi boundaries.  Note that this velocity\ndifference can include tilt components, e.g. a delta in the x velocity\nwhen an atom crosses the y periodic boundary.  If remap is set to\nnone, then neither of these remappings take place.\nConceptually, setting remap to x forces the atoms to deform via an\naffine transformation that exactly matches the box deformation.  This\nsetting is typically appropriate for solids.  Note that though the\natoms are effectively “moving” with the box over time, it is not due\nto their having a velocity that tracks the box change, but only due to\nthe remapping.  By contrast, setting remap to v is typically\nappropriate for fluids, where you want the atoms to respond to the\nchange in box size/shape on their own and acquire a velocity that\nmatches the box change, so that their motion will naturally track the\nbox without explicit remapping of their coordinates.\n\nNote\nWhen non-equilibrium MD (NEMD) simulations are performed using\nthis fix, the option “remap v” should normally be used.  This is\nbecause fix nvt/sllod adjusts the atom positions\nand velocities to induce a velocity profile that matches the changing\nbox size/shape.  Thus atom coordinates should NOT be remapped by fix\ndeform, but velocities SHOULD be when atoms cross periodic boundaries,\nsince that is consistent with maintaining the velocity profile already\ncreated by fix nvt/sllod.  LAMMPS will warn you if the remap setting\nis not consistent with fix nvt/sllod.\n\n\nNote\nFor non-equilibrium MD (NEMD) simulations using “remap v” it is\nusually desirable that the fluid (or flowing material, e.g. granular\nparticles) stream with a velocity profile consistent with the\ndeforming box.  As mentioned above, using a thermostat such as fix nvt/sllod or fix lavgevin\n(with a bias provided by compute temp/deform), will typically accomplish\nthat.  If you do not use a thermostat, then there is no driving force\npushing the atoms to flow in a manner consistent with the deforming\nbox.  E.g. for a shearing system the box deformation velocity may vary\nfrom 0 at the bottom to 10 at the top of the box.  But the stream\nvelocity profile of the atoms may vary from -5 at the bottom to +5 at\nthe top.  You can monitor these effects using the fix ave/chunk, compute temp/deform, and compute temp/profile commands.  One way to induce\natoms to stream consistent with the box deformation is to give them an\ninitial velocity profile, via the velocity ramp\ncommand, that matches the box deformation rate.  This also typically\nhelps the system come to equilibrium more quickly, even if a\nthermostat is used.\n\n\nNote\nIf a fix rigid is defined for rigid bodies, and\nremap is set to x, then the center-of-mass coordinates of rigid\nbodies will be remapped to the changing simulation box.  This will be\ndone regardless of whether atoms in the rigid bodies are in the fix\ndeform group or not.  The velocity of the centers of mass are not\nremapped even if remap is set to v, since fix nvt/sllod does not currently do anything special\nfor rigid particles.  If you wish to perform a NEMD simulation of\nrigid particles, you can either thermostat them independently or\ninclude a background fluid and thermostat the fluid via fix nvt/sllod.\n\nThe flip keyword allows the tilt factors for a triclinic box to\nexceed half the distance of the parallel box length, as discussed\nabove.  If the flip value is set to yes, the bound is enforced by\nflipping the box when it is exceeded.  If the flip value is set to\nno, the tilt will continue to change without flipping.  Note that if\nyou apply large deformations, this means the box shape can tilt\ndramatically LAMMPS will run less efficiently, due to the large volume\nof communication needed to acquire ghost atoms around a processor’s\nirregular-shaped sub-domain.  For extreme values of tilt, LAMMPS may\nalso lose atoms and generate an error.\nThe units keyword determines the meaning of the distance units used\nto define various arguments.  A box value selects standard distance\nunits as defined by the units command, e.g. Angstroms for\nunits = real or metal.  A lattice value means the distance units are\nin lattice spacings.  The lattice command must have\nbeen previously used to define the lattice spacing.  Note that the\nunits choice also affects the vel style parameters since it is\ndefined in terms of distance/time.  Also note that the units keyword\ndoes not affect the variable style.  You should use the xlat,\nylat, zlat keywords of the thermo_style\ncommand if you want to include lattice spacings in a variable formula.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix will restore the initial box settings from binary restart files, which allows the fix to be properly continue\ndeformation, when using the start/stop options of the run\ncommand.  None of the fix_modify options are\nrelevant to this fix.  No global or per-atom quantities are stored by\nthis fix for access by various output commands.\nThis fix can perform deformation over multiple runs, using the start\nand stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID deform N parameter args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * deform = style name of this fix command\n * N = perform box deformation every this many timesteps\n * one or more parameter/arg pairs may be appended\n * parameter = x or y or z or xy or xz or yz\n *   x, y, z args = style value(s)\n *     style = final or delta or scale or vel or erate or trate or volume or wiggle or variable\n *       final values = lo hi\n *         lo hi = box boundaries at end of run (distance units)\n *       delta values = dlo dhi\n *         dlo dhi = change in box boundaries at end of run (distance units)\n *       scale values = factor\n *         factor = multiplicative factor for change in box length at end of run\n *       vel value = V\n *         V = change box length at this velocity (distance/time units),\n *             effectively an engineering strain rate\n *       erate value = R\n *         R = engineering strain rate (1/time units)\n *       trate value = R\n *         R = true strain rate (1/time units)\n *       volume value = none = adjust this dim to preserve volume of system\n *       wiggle values = A Tp\n *         A = amplitude of oscillation (distance units)\n *         Tp = period of oscillation (time units)\n *       variable values = v_name1 v_name2\n *         v_name1 = variable with name1 for box length change as function of time\n *         v_name2 = variable with name2 for change rate as function of time\n *   xy, xz, yz args = style value\n *     style = final or delta or vel or erate or trate or wiggle\n *       final value = tilt\n *         tilt = tilt factor at end of run (distance units)\n *       delta value = dtilt\n *         dtilt = change in tilt factor at end of run (distance units)\n *       vel value = V\n *         V = change tilt factor at this velocity (distance/time units),\n *             effectively an engineering shear strain rate\n *       erate value = R\n *         R = engineering shear strain rate (1/time units)\n *       trate value = R\n *         R = true shear strain rate (1/time units)\n *       wiggle values = A Tp\n *         A = amplitude of oscillation (distance units)\n *         Tp = period of oscillation (time units)\n *       variable values = v_name1 v_name2\n *         v_name1 = variable with name1 for tilt change as function of time\n *         v_name2 = variable with name2 for change rate as function of time\n * zero or more keyword/value pairs may be appended\n * keyword = remap or flip or units\n * remap value = x or v or none\n *   x = remap coords of atoms in group into deforming box\n *   v = remap velocities of all atoms when they cross periodic boundaries\n *   none = no remapping of x or v\n * flip value = yes or no\n *   allow or disallow box flips when it becomes highly skewed\n * units value = lattice or box\n *   lattice = distances are defined in lattice units\n *   box = distances are defined in simulation box units",
    "examples": "fix 1 all deform 1 x final 0.0 9.0 z final 0.0 5.0 units box\nfix 1 all deform 1 x trate 0.1 y volume z volume\nfix 1 all deform 1 xy erate 0.001 remap v\nfix 1 all deform 10 y delta -0.5 0.5 xz vel 1.0",
    "restrictions": "You cannot apply x, y, or z deformations to a dimension that is\nshrink-wrapped via the boundary command.\nYou cannot apply xy, yz, or xz deformations to a 2nd dimension (y in\nxy) that is shrink-wrapped via the boundary command."
},
{
    "command": "fix deposit",
    "html_filename": "fix_deposit.html",
    "short_description": "Insert a single atom or molecule into the simulation domain every M timesteps until N atoms or molecules have been inserted",
    "description": "Insert a single atom or molecule into the simulation domain every M\ntimesteps until N atoms or molecules have been inserted.  This is\nuseful for simulating deposition onto a surface.  For the remainder of\nthis doc page, a single inserted atom or molecule is referred to as a\n“particle”.\nIf inserted particles are individual atoms, they are assigned the\nspecified atom type.  If they are molecules, the type of each atom in\nthe inserted molecule is specified in the file read by the\nmolecule command, and those values are added to the\nspecified atom type.  E.g. if the file specifies atom types 1,2,3, and\nthose are the atom types you want for inserted molecules, then specify\ntype = 0.  If you specify type = 2, the in the inserted molecule\nwill have atom types 3,4,5.\nAll atoms in the inserted particle are assigned to two groups: the\ndefault group “all” and the group specified in the fix deposit command\n(which can also be “all”).\nIf you are computing temperature values which include inserted\nparticles, you will want to use the\ncompute_modify dynamic option, which insures the\ncurrent number of atoms is used as a normalizing factor each time the\ntemperature is computed.\nCare must be taken that inserted particles are not too near existing\natoms, using the options described below.  When inserting particles\nabove a surface in a non-periodic box (see the\nboundary command), the possibility of a particle\nescaping the surface and flying upward should be considered, since the\nparticle may be lost or the box size may grow infinitely large.  A\nfix wall/reflect command can be used to\nprevent this behavior.  Note that if a shrink-wrap boundary is used,\nit is OK to insert the new particle outside the box, however the box\nwill immediately be expanded to include the new particle. When\nsimulating a sputtering experiment it is probably more realistic to\nignore those atoms using the thermo_modify\ncommand with the lost ignore option and a fixed\nboundary.\nThe fix deposit command must use the region keyword to define an\ninsertion volume.  The specified region must have been previously\ndefined with a region command.  It must be defined with\nside = in.\n\nNote\nLAMMPS checks that the specified region is wholly inside the\nsimulation box.  It can do this correctly for orthonormal simulation\nboxes.  However for triclinic boxes, it only\ntests against the larger orthonormal box that bounds the tilted\nsimulation box.  If the specified region includes volume outside the\ntilted box, then an insertion will likely fail, leading to a “lost\natoms” error.  Thus for triclinic boxes you should insure the\nspecified region is wholly inside the simulation box.\n\nThe locations of inserted particles are taken from uniform distributed\nrandom numbers, unless the gaussian keyword is used. Then the\nindividual coordinates are taken from a gaussian distribution of\nwidth sigma centered on xmid,ymid,zmid.\nIndividual atoms are inserted, unless the mol keyword is used.  It\nspecifies a template-ID previously defined using the\nmolecule command, which reads files that define one or\nmore molecules.  The coordinates, atom types, charges, etc, as well as\nany bond/angle/etc and special neighbor information for the molecule\ncan be specified in the molecule file.  See the\nmolecule command for details.  The only settings\nrequired to be in each file are the coordinates and types of atoms in\nthe molecule.\nIf the molecule template contains more than one molecule, the relative\nprobability of depositing each molecule can be specified by the\nmolfrac keyword.  N relative probabilities, each from 0.0 to 1.0, are\nspecified, where N is the number of molecules in the template.  Each\ntime a molecule is deposited, a random number is used to sample from\nthe list of relative probabilities.  The N values must sum to 1.0.\nIf you wish to insert molecules via the mol keyword, that will be\ntreated as rigid bodies, use the rigid keyword, specifying as its\nvalue the ID of a separate fix rigid/small\ncommand which also appears in your input script.\n\nNote\nIf you wish the new rigid molecules (and other rigid molecules)\nto be thermostatted correctly via fix rigid/small/nvt\nor fix rigid/small/npt, then you need to use the\n“fix_modify dynamic/dof yes” command for the rigid fix.  This is to\ninform that fix that the molecule count will vary dynamically.\n\nIf you wish to insert molecules via the mol keyword, that will have\ntheir bonds or angles constrained via SHAKE, use the shake keyword,\nspecifying as its value the ID of a separate fix shake command which also appears in your input script.\nEach timestep a particle is inserted, the coordinates for its atoms\nare chosen as follows.  For insertion of individual atoms, the\n“position” referred to in the following description is the coordinate\nof the atom.  For insertion of molecule, the “position” is the\ngeometric center of the molecule; see the molecule doc\npage for details.  A random rotation of the molecule around its center\npoint is performed, which determines the coordinates all the\nindividual atoms.\nA random position within the region insertion volume is generated.  If\nneither the global or local keyword is used, the random position\nis the trial position.  If the global keyword is used, the random\nx,y values are used, but the z position of the new particle is set\nabove the highest current atom in the simulation by a distance\nrandomly chosen between lo/hi.  (For a 2d simulation, this is done for\nthe y position.)  If the local keyword is used, the z position is\nset a distance between lo/hi above the highest current atom in the\nsimulation that is “nearby” the chosen x,y position.  In this context,\n“nearby” means the lateral distance (in x,y) between the new and old\nparticles is less than the delta setting.\nOnce a trial x,y,z position has been selected, the insertion is only\nperformed if no current atom in the simulation is within a distance R\nof any atom in the new particle, including the effect of periodic\nboundary conditions if applicable.  R is defined by the near\nkeyword.  Note that the default value for R is 0.0, which will allow\natoms to strongly overlap if you are inserting where other atoms are\npresent.  This distance test is performed independently for each atom\nin an inserted molecule, based on the randomly rotated configuration\nof the molecule.  If this test fails, a new random position within the\ninsertion volume is chosen and another trial is made.  Up to Q\nattempts are made.  If the particle is not successfully inserted,\nLAMMPS prints a warning message.\n\nNote\nIf you are inserting finite size particles or a molecule or\nrigid body consisting of finite-size particles, then you should\ntypically set R larger than the distance at which any inserted\nparticle may overlap with either a previously inserted particle or an\nexisting particle.  LAMMPS will issue a warning if R is smaller than\nthis value, based on the radii of existing and inserted particles.\n\nThe rate option moves the insertion volume in the z direction (3d)\nor y direction (2d).  This enables particles to be inserted from a\nsuccessively higher height over time.  Note that this parameter is\nignored if the global or local keywords are used, since those\noptions choose a z-coordinate for insertion independently.\nThe vx, vy, and vz components of velocity for the inserted particle\nare set using the values specified for the vx, vy, and vz\nkeywords.  Note that normally, new particles should be a assigned a\nnegative vertical velocity so that they move towards the surface.  For\nmolecules, the same velocity is given to every particle (no rotation\nor bond vibration).\nIf the target option is used, the velocity vector of the inserted\nparticle is changed so that it points from the insertion position\ntowards the specified target point.  The magnitude of the velocity is\nunchanged.  This can be useful, for example, for simulating a\nsputtering process.  E.g. the target point can be far away, so that\nall incident particles strike the surface as if they are in an\nincident beam of particles at a prescribed angle.\nThe orient keyword is only used when molecules are deposited.  By\ndefault, each molecule is inserted at a random orientation.  If this\nkeyword is specified, then (rx,ry,rz) is used as an orientation\nvector, and each inserted molecule is rotated around that vector with\na random value from zero to 2*PI.  For a 2d simulation, rx = ry = 0.0\nis required, since rotations can only be performed around the z axis.\nThe id keyword determines how atom IDs and molecule IDs are assigned\nto newly deposited particles.  Molecule IDs are only assigned if\nmolecules are being inserted.  For the max setting, the atom and\nmolecule IDs of all current atoms are checked.  Atoms in the new\nparticle are assigned IDs starting with the current maximum plus one.\nIf a molecule is inserted it is assigned an ID = current maximum plus\none.  This means that if particles leave the system, the new IDs may\nreplace the lost ones.  For the next setting, the maximum ID of any\natom and molecule is stored at the time the fix is defined.  Each time\na new particle is added, this value is incremented to assign IDs to\nthe new atom(s) or molecule.  Thus atom and molecule IDs for deposited\nparticles will be consecutive even if particles leave the system over\ntime.\nThe units keyword determines the meaning of the distance units used\nfor the other deposition parameters.  A box value selects standard\ndistance units as defined by the units command,\ne.g. Angstroms for units = real or metal.  A lattice value means the\ndistance units are in lattice spacings.  The lattice\ncommand must have been previously used to define the lattice spacing.\nNote that the units choice affects all the keyword values that have\nunits of distance or velocity.\n\nNote\nIf you are monitoring the temperature of a system where the atom\ncount is changing due to adding particles, you typically should use\nthe compute_modify dynamic yes command for the\ntemperature compute you are using.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the deposition to binary restart files.  This includes information about how many\nparticles have been deposited, the random number generator seed, the\nnext timestep for deposition, etc.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\n\nNote\nFor this to work correctly, the timestep must not be changed\nafter reading the restart with reset_timestep.\nThe fix will try to detect it and stop with an error.\n\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID deposit N type M seed keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * deposit = style name of this fix command\n * N = # of atoms or molecules to insert\n * type = atom type to assign to inserted atoms (offset for molecule insertion)\n * M = insert a single atom or molecule every M steps\n * seed = random # seed (positive integer)\n * one or more keyword/value pairs may be appended to args\n * keyword = region or id or global or local or near or gaussian or attempt or rate or vx or vy or vz or mol or rigid or shake or units\n * region value = region-ID\n *   region-ID = ID of region to use as insertion volume\n * id value = max or next\n *   max = atom ID for new atom(s) is max ID of all current atoms plus one\n *   next = atom ID for new atom(s) increments by one for every deposition\n * global values = lo hi\n *   lo,hi = put new atom/molecule a distance lo-hi above all other atoms (distance units)\n * local values = lo hi delta\n *   lo,hi = put new atom/molecule a distance lo-hi above any nearby atom beneath it (distance units)\n *   delta = lateral distance within which a neighbor is considered \"nearby\" (distance units)\n * near value = R\n *   R = only insert atom/molecule if further than R from existing particles (distance units)\n * gaussian values = xmid ymid zmid sigma\n *   xmid,ymid,zmid = center of the gaussian distribution (distance units)\n *   sigma = width of gaussian distribution (distance units)\n * attempt value = Q\n *   Q = attempt a single insertion up to Q times\n * rate value = V\n *   V = z velocity (y in 2d) at which insertion volume moves (velocity units)\n * vx values = vxlo vxhi\n *   vxlo,vxhi = range of x velocities for inserted atom/molecule (velocity units)\n * vy values = vylo vyhi\n *   vylo,vyhi = range of y velocities for inserted atom/molecule (velocity units)\n * vz values = vzlo vzhi\n *   vzlo,vzhi = range of z velocities for inserted atom/molecule (velocity units)\n * target values = tx ty tz\n *   tx,ty,tz = location of target point (distance units)\n * mol value = template-ID\n *   template-ID = ID of molecule template specified in a separate molecule command\n * molfrac values = f1 f2 ... fN\n *   f1 to fN = relative probability of creating each of N molecules in template-ID\n * rigid value = fix-ID\n *   fix-ID = ID of fix rigid/small command\n * shake value = fix-ID\n *   fix-ID = ID of fix shake command\n * orient values = rx ry rz\n *   rx,ry,rz = vector to randomly rotate an inserted molecule around\n * units value = lattice or box\n *   lattice = the geometry is defined in lattice units\n *   box = the geometry is defined in simulation box units",
    "examples": "fix 3 all deposit 1000 2 100 29494 region myblock local 1.0 1.0 1.0 units box\nfix 2 newatoms deposit 10000 1 500 12345 region disk near 2.0 vz -1.0 -0.8\nfix 4 sputter deposit 1000 2 500 12235 region sphere vz -1.0 -1.0 target 5.0 5.0 0.0 units lattice\nfix 5 insert deposit 200 2 100 777 region disk gaussian 5.0 5.0 9.0 1.0 units box",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThe specified insertion region cannot be a “dynamic” region, as\ndefined by the region command."
},
{
    "command": "fix dpd/energy",
    "html_filename": "fix_dpd_energy.html",
    "short_description": "Perform constant energy dissipative particle dynamics (DPD-E) integration",
    "description": "Perform constant energy dissipative particle dynamics (DPD-E)\nintegration.  This fix updates the internal energies for particles in\nthe group at each timestep.  It must be used in conjunction with a\ndeterministic integrator (e.g. fix nve) that updates\nthe particle positions and velocities.\nFor fix dpd/energy, the particle internal temperature is related to\nthe particle internal energy through a mesoparticle equation of state.\nAn additional fix must be specified that defines the equation of state\nfor each particle, e.g. fix eos/cv.\nThis fix must be used with the pair_style dpd/fdt/energy command.\nNote that numerous variants of DPD can be specified by choosing an\nappropriate combination of the integrator and pair_style dpd/fdt/energy command.  DPD under isoenergetic conditions\ncan be specified by using fix dpd/energy, fix nve and pair_style\ndpd/fdt/energy.  DPD under isoenthalpic conditions can\nbe specified by using fix dpd/energy, fix nph and pair_style\ndpd/fdt/energy.  Examples of each DPD variant are provided in the\nexamples/USER/dpd directory.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID dpd/energy",
    "parameters": " * ID, group-ID are documented in fix command\n * dpd/energy = style name of this fix command",
    "examples": "fix 1 all dpd/energy",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix must be used with an additional fix that specifies time\nintegration, e.g. fix nve.\nThe fix dpd/energy requires the dpd atom_style\nto be used in order to properly account for the particle internal\nenergies and temperature.\nThe fix dpd/energy must be used with an additional fix that specifies the\nmesoparticle equation of state for each particle."
},
{
    "command": "fix edpd/source",
    "html_filename": "fix_dpd_source.html",
    "short_description": "Fix edpd/source adds a heat source as an external heat flux to each atom in a spherical or cuboid domain, where the source is in units of energy/time",
    "description": "Fix edpd/source adds a heat source as an external heat flux to each\natom in a spherical or cuboid domain, where the source is in units\nof energy/time.  Fix tdpd/source adds an external concentration\nsource of the chemical species specified by index as an external\nconcentration flux for each atom in a spherical or cuboid domain,\nwhere the source is in units of mole/volume/time.\nThis command can be used to give an additional heat/concentration\nsource term to atoms in a simulation, such as for a simulation of a\nheat conduction with a source term (see Fig.12 in (Li2014))\nor diffusion with a source term (see Fig.1 in (Li2015)), as\nan analog of a periodic Poiseuille flow problem.\nIf the sphere keyword is used, the cx,cy,cz,radius defines a\nspherical domain to apply the source flux to.\nIf the cuboid keyword is used, the cx,cy,cz,dLx,dLy,dLz defines a\ncuboid domain to apply the source flux to.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID edpd/source keyword values ...",
    "parameters": " * fix ID group-ID tdpd/source cc_index keyword values ...\n * ID, group-ID are documented in fix command\n * edpd/source or tdpd/source = style name of this fix command\n * index (only specified for tdpd/source) = index of chemical species (1 to Nspecies)\n * keyword = sphere or cuboid\n * sphere values = cx,cy,cz,radius,source\n *   cx,cy,cz = x,y,z center of spherical domain (distance units)\n *   radius = radius of a spherical domain (distance units)\n *   source = heat source or concentration source (flux units, see below)\n * cuboid values = cx,cy,cz,dLx,dLy,dLz,source\n *   cx,cy,cz = x,y,z lower left corner of a cuboid domain (distance units)\n *   dLx,dLy,dLz = x,y,z side length of a cuboid domain (distance units)\n *   source = heat source or concentration source (flux units, see below)",
    "examples": "fix 1 all edpd/source sphere 0.0 0.0 0.0 5.0 0.01\nfix 1 all edpd/source cuboid 0.0 0.0 0.0 20.0 10.0 10.0 -0.01\nfix 1 all tdpd/source 1 sphere 5.0 0.0 0.0 5.0 0.01\nfix 1 all tdpd/source 2 cuboid 0.0 0.0 0.0 20.0 10.0 10.0 0.01",
    "restrictions": "This fix is part of the USER-MESO package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nFix edpd/source must be used with the pair_style edpd command.  Fix tdpd/source must be used with the\npair_style tdpd command."
},
{
    "command": "fix drag",
    "html_filename": "fix_drag.html",
    "short_description": "Apply a force to each atom in a group to drag it towards the point (x,y,z)",
    "description": "Apply a force to each atom in a group to drag it towards the point\n(x,y,z).  The magnitude of the force is specified by fmag.  If an atom\nis closer than a distance delta to the point, then the force is not\napplied.\nAny of the x,y,z values can be specified as NULL which means do not\ninclude that dimension in the distance calculation or force\napplication.\nThis command can be used to steer one or more atoms to a new location\nin the simulation.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global 3-vector of forces, which can be accessed\nby various output commands.  This is the total\nforce on the group of atoms by the drag force.  The vector values\ncalculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID drag x y z fmag delta",
    "parameters": " * ID, group-ID are documented in fix command\n * drag = style name of this fix command\n * x,y,z = coord to drag atoms towards\n * fmag = magnitude of force to apply to each atom (force units)\n * delta = cutoff distance inside of which force         is not applied (distance units)",
    "examples": "fix center small-molecule drag 0.0 10.0 0.0 5.0 2.0",
    "restrictions": "\nnone"
},
{
    "command": "fix drude",
    "html_filename": "fix_drude.html",
    "short_description": "Assign each atom type in the system to be one of 3 kinds of atoms within the Drude polarization model",
    "description": "Assign each atom type in the system to be one of 3 kinds of atoms\nwithin the Drude polarization model. This fix is designed to be used\nwith the thermalized Drude oscillator model.\nPolarizable models in LAMMPS are described on the Howto polarizable doc page.\nThe three possible types can be designated with an integer (0,1,2)\nor capital letter (N,C,D):\n\n0 or N = non-polarizable atom (not part of Drude model)\n1 or C = Drude core\n2 or D = Drude electron",
    "syntax": "fix ID group-ID drude flag1 flag2 ... flagN",
    "parameters": " * ID, group-ID are documented in fix command\n * drude = style name of this fix command\n * flag1 flag2 … flagN = Drude flag for each atom type (1 to N) in the system",
    "examples": "fix 1 all drude 1 1 0 1 0 2 2 2\nfix 1 all drude C C N C N D D D",
    "restrictions": "This fix should be invoked before any other commands that implement\nthe Drude oscillator model, such as fix langevin/drude, fix drude/transform, compute temp/drude, pair_style thole."
},
{
    "command": "fix drude/transform/direct",
    "html_filename": "fix_drude_transform.html",
    "short_description": "Transform the coordinates of Drude oscillators from real to reduced and back for thermalizing the Drude oscillators as described in (Lamoureux) using a Nose-Hoover thermostat",
    "description": "Transform the coordinates of Drude oscillators from real to reduced\nand back for thermalizing the Drude oscillators as described in\n(Lamoureux) using a Nose-Hoover thermostat.  This fix is\ndesigned to be used with the thermalized Drude oscillator model.  Polarizable models in LAMMPS are described\non the Howto polarizable doc page.\nDrude oscillators are a pair of atoms representing a single\npolarizable atom.  Ideally, the mass of Drude particles would vanish\nand their positions would be determined self-consistently by iterative\nminimization of the energy, the cores’ positions being fixed.  It is\nhowever more efficient and it yields comparable results, if the Drude\noscillators (the motion of the Drude particle relative to the core)\nare thermalized at a low temperature.  In that case, the Drude\nparticles need a small mass.\nThe thermostats act on the reduced degrees of freedom, which are\ndefined by the following equations.  Note that in these equations\nupper case denotes atomic or center of mass values and lower case\ndenotes Drude particle or dipole values. Primes denote the transformed\n(reduced) values, while bare letters denote the original values.\nMasses:\n\n\\[M' = M + m\\]\n\n\\[m' = \\frac {M\\, m } {M'}\\]\nPositions:\n\n\\[X' = \\frac {M\\, X + m\\, x} {M'}\\]\n\n\\[x' = x - X\\]\nVelocities:\n\n\\[V' = \\frac {M\\, V + m\\, v} {M'}\\]\n\n\\[v' = v - V\\]\nForces:\n\n\\[F' = F + f\\]\n\n\\[f' = \\frac { M\\, f - m\\, F} {M'}\\]\nThis transform conserves the total kinetic energy\n\n\\[ \\frac 1 2 \\, (M\\, V^2\\ + m\\, v^2)\n= \\frac 1 2 \\, (M'\\, V'^2\\ + m'\\, v'^2)\\]\nand the virial defined with absolute positions\n\n\\[X\\, F + x\\, f = X'\\, F' + x'\\, f'\\]\n\nThis fix requires each atom know whether it is a Drude particle or\nnot.  You must therefore use the fix drude command to\nspecify the Drude status of each atom type.\n\nNote\nonly the Drude core atoms need to be in the group specified for\nthis fix. A Drude electron will be transformed together with its core\neven if it is not itself in the group.  It is safe to include Drude\nelectrons or non-polarizable atoms in the group. The non-polarizable\natoms will simply not be transformed.\n\n\nThis fix does NOT perform time integration. It only transform masses,\ncoordinates, velocities and forces. Thus you must use separate time\nintegration fixes, like fix nve or fix npt to actually update the velocities and positions of\natoms.  In order to thermalize the reduced degrees of freedom at\ndifferent temperatures, two Nose-Hoover thermostats must be defined,\nacting on two distinct groups.\n\nNote\nThe fix drude/transform/direct command must appear before any\nNose-Hoover thermostatting fixes.  The fix drude/transform/inverse\ncommand must appear after any Nose-Hoover thermostatting fixes.\n\nExample:\nfix fDIRECT all drude/transform/direct\nfix fNVT gCORES nvt temp 300.0 300.0 100\nfix fNVT gDRUDES nvt temp 1.0 1.0 100\nfix fINVERSE all drude/transform/inverse\ncompute TDRUDE all temp/drude\nthermo_style custom step cpu etotal ke pe ebond ecoul elong press vol temp c_TDRUDE[1] c_TDRUDE[2]\n\n\nIn this example, gCORES is the group of the atom cores and gDRUDES\nis the group of the Drude particles (electrons). The centers of mass\nof the Drude oscillators will be thermostatted at 300.0 and the\ninternal degrees of freedom will be thermostatted at 1.0.  The\ntemperatures of cores and Drude particles, in center-of-mass and\nrelative coordinates, are calculated using compute temp/drude\nIn addition, if you want to use a barostat to simulate a system at\nconstant pressure, only one of the Nose-Hoover fixes must be npt,\nthe other one should be nvt. You must add a compute temp/com and a\nfix_modify command so that the temperature of the npt fix be just\nthat of its group (the Drude cores) but the pressure be the overall\npressure thermo_press.\nExample:\ncompute cTEMP_CORE gCORES temp/com\nfix fDIRECT all drude/transform/direct\nfix fNPT gCORES npt temp 298.0 298.0 100 iso 1.0 1.0 500\nfix_modify fNPT temp cTEMP_CORE press thermo_press\nfix fNVT gDRUDES nvt temp 5.0 5.0 100\nfix fINVERSE all drude/transform/inverse\n\n\nIn this example, gCORES is the group of the atom cores and gDRUDES\nis the group of the Drude particles. The centers of mass of the Drude\noscillators will be thermostatted at 298.0 and the internal degrees of\nfreedom will be thermostatted at 5.0. The whole system will be\nbarostatted at 1.0.\nIn order to avoid the flying ice cube problem (irreversible transfer\nof linear momentum to the center of mass of the system), you may need\nto add a fix momentum command:\nfix fMOMENTUM all momentum 100 linear 1 1 1\n\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.",
    "syntax": "fix ID group-ID style keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = drude/transform/direct or drude/transform/inverse",
    "examples": "fix 3 all drude/transform/direct\nfix 1 all drude/transform/inverse",
    "restrictions": "\nnone"
},
{
    "command": "fix dt/reset",
    "html_filename": "fix_dt_reset.html",
    "short_description": "Reset the timestep size every N steps during a run, so that no atom moves further than the specified Xmax distance, based on current atom velocities and forces",
    "description": "Reset the timestep size every N steps during a run, so that no atom\nmoves further than the specified Xmax distance, based on current\natom velocities and forces.  Optionally an additional criterion is\nimposed by the emax keyword, so that no atom’s kinetic energy\nchanges by more than the specified Emax.\nThis can be useful when starting from a configuration with overlapping\natoms, where forces will be large.  Or it can be useful when running\nan impact simulation where one or more high-energy atoms collide with\na solid, causing a damage cascade.\nThis fix overrides the timestep size setting made by the\ntimestep command.  The new timestep size dt is\ncomputed in the following manner.\nFor each atom, the timestep is computed that would cause it to\ndisplace Xmax on the next integration step, as a function of its\ncurrent velocity and force.  Since performing this calculation exactly\nwould require the solution to a quartic equation, a cheaper estimate\nis generated.  The estimate is conservative in that the atom’s\ndisplacement is guaranteed not to exceed Xmax, though it may be\nsmaller.\nIn addition if the emax keyword is used, the specified Emax value\nis enforced as a limit on how much an atom’s kinetic energy can\nchange.  If the timestep required is even smaller than for the Xmax\ndisplacement, then the smaller timestep is used.\nGiven this putative timestep for each atom, the minimum timestep value\nacross all atoms is computed.  Then the Tmin and Tmax bounds are\napplied, if specified.  If one (or both) is specified as NULL, it is\nnot applied.\nWhen the run style is respa, this fix resets the\nouter loop (largest) timestep, which is the same timestep that the\ntimestep command sets.\nNote that the cumulative simulation time (in time units), which\naccounts for changes in the timestep size as a simulation proceeds,\ncan be accessed by the thermo_style time keyword.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar stores the last\ntimestep on which the timestep was reset to a new value.\nThe scalar value calculated by this fix is “intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID dt/reset N Tmin Tmax Xmax keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * dt/reset = style name of this fix command\n * N = re-compute dt every N timesteps\n * Tmin = minimum dt allowed which can be NULL (time units)\n * Tmax = maximum dt allowed which can be NULL (time units)\n * Xmax = maximum distance for an atom to move in one timestep (distance units)\n * zero or more keyword/value pairs may be appended\n * keyword = emax or units\n * emax value = Emax\n *   Emax = maximum kinetic energy change for an atom in one timestep (energy units)\n * units value = lattice or box\n *   lattice = Xmax is defined in lattice units\n *   box = Xmax is defined in simulation box units",
    "examples": "fix 5 all dt/reset 10 1.0e-5 0.01 0.1\nfix 5 all dt/reset 10 0.01 2.0 0.2 units box\nfix 5 all dt/reset 5 NULL 0.001 0.5 emax 30 units box",
    "restrictions": "\nnone"
},
{
    "command": "fix efield",
    "html_filename": "fix_efield.html",
    "short_description": "Add a force F = qE to each charged atom in the group due to an external electric field being applied to the system",
    "description": "Add a force F = qE to each charged atom in the group due to an\nexternal electric field being applied to the system.  If the system\ncontains point-dipoles, also add a torque on the dipoles due to the\nexternal electric field.\nFor charges, any of the 3 quantities defining the E-field components\ncan be specified as an equal-style or atom-style\nvariable, namely ex, ey, ez.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value used to determine the E-field component.\nFor point-dipoles, equal-style variables can be used, but atom-style\nvariables are not currently supported, since they imply a spatial\ngradient in the electric field which means additional terms with\ngradients of the field are required for the force and torque on\ndipoles.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent E-field.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent E-field\nwith optional time-dependence as well.\nIf the region keyword is used, the atom must also be in the\nspecified geometric region in order to have force added\nto it.\n\nAdding a force or torque to atoms implies a change in their potential\nenergy as they move or rotate due to the applied E-field.\nFor dynamics via the “run” command, this energy can be optionally\nadded to the system’s potential energy for thermodynamic output (see\nbelow).  For energy minimization via the “minimize” command, this\nenergy must be added to the system’s potential energy to formulate a\nself-consistent minimization problem (see below).\nThe energy keyword is not allowed if the added field is a constant\nvector (ex,ey,ez), with all components defined as numeric constants\nand not as variables.  This is because LAMMPS can compute the energy\nfor each charged particle directly as E = -x dot qE = -q (x*ex + y*ey\n+ z*ez), so that -Grad(E) = F.  Similarly for point-dipole particles\nthe energy can be computed as E = -mu dot E = -(mux*ex + muy*ey +\nmuz*ez).\nThe energy keyword is optional if the added force is defined with\none or more variables, and if you are performing dynamics via the\nrun command.  If the keyword is not used, LAMMPS will set\nthe energy to 0.0, which is typically fine for dynamics.\nThe energy keyword is required if the added force is defined with\none or more variables, and you are performing energy minimization via\nthe “minimize” command for charged particles.  It is not required for\npoint-dipoles, but a warning is issued since the minimizer in LAMMPS\ndoes not rotate dipoles, so you should not expect to be able to\nminimize the orientation of dipoles in an applied electric field.\nThe energy keyword specifies the name of an atom-style\nvariable which is used to compute the energy of each\natom as function of its position.  Like variables used for ex, ey,\nez, the energy variable is specified as v_name, where name is the\nvariable name.\nNote that when the energy keyword is used during an energy\nminimization, you must insure that the formula defined for the\natom-style variable is consistent with the force\nvariable formulas, i.e. that -Grad(E) = F.  For example, if the force\ndue to the electric field were a spring-like F = kx, then the energy\nformula should be E = -0.5kx^2.  If you don’t do this correctly, the\nminimization will not converge properly.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential “energy” inferred by the added force due to\nthe electric field to the system’s potential energy as part of\nthermodynamic output.  This is a fictitious\nquantity but is needed so that the minimize command\ncan include the forces added by this fix in a consistent manner.\nI.e. there is a decrease in potential energy when atoms move in the\ndirection of the added force due to the electric field.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the added forces on atoms to the\nsystem’s virial as part of thermodynamic output.\nThe default is virial no\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix adding its forces. Default is the outermost level.\nThis fix computes a global scalar and a global 3-vector of forces,\nwhich can be accessed by various output commands.\nThe scalar is the potential energy discussed above.  The vector is the\ntotal force added to the group of atoms.  The scalar and vector values\ncalculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  You should not\nspecify force components with a variable that has time-dependence for\nuse with a minimizer, since the minimizer increments the timestep as\nthe iteration count during the minimization.\n\nNote\nIf you want the fictitious potential energy associated with the\nadded forces to be included in the total potential energy of the\nsystem (the quantity being minimized), you MUST enable the\nfix_modify energy option for this fix.",
    "syntax": "fix ID group-ID efield ex ey ez keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * efield = style name of this fix command\n * ex,ey,ez = E-field component values (electric field units)\n * any of ex,ey,ez can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region or energy\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to have added force\n * energy value = v_name\n *   v_name = variable with name that calculates the potential energy of each atom in the added E-field",
    "examples": "fix kick external-field efield 1.0 0.0 0.0\nfix kick external-field efield 0.0 0.0 v_oscillate",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix ehex",
    "html_filename": "fix_ehex.html",
    "short_description": "This fix implements the asymmetric version of the enhanced heat exchange algorithm (Wirnsberger)",
    "description": "This fix implements the asymmetric version of the enhanced heat\nexchange algorithm (Wirnsberger). The eHEX algorithm is\nan extension of the heat exchange algorithm (Ikeshoji) and\nadds an additional coordinate integration to account for higher-order\ntruncation terms in the operator splitting.  The original HEX\nalgorithm (implemented as fix heat) is known to\nexhibit a slight energy drift limiting the accessible simulation times\nto a few nanoseconds.  This issue is greatly improved by the new\nalgorithm decreasing the energy drift by at least a factor of a\nhundred (LJ and SPC/E water) with little computational overhead.\nIn both algorithms (non-translational) kinetic energy is constantly\nswapped between regions (reservoirs) to impose a heat flux onto the\nsystem.  The equations of motion are therefore modified if a particle\n\\(i\\) is located inside a reservoir \\(\\Gamma_k\\) where \\(k>0\\).  We\nuse \\(\\Gamma_0\\) to label those parts of the simulation box which\nare not thermostatted.)  The input parameter region-ID of this fix\ncorresponds to \\(k\\).  The energy swap is modelled by introducing an\nadditional thermostatting force to the equations of motion, such that\nthe time evolution of coordinates and momenta of particle \\(i\\)\nbecomes (Wirnsberger)\n\n\\[\\begin{split}\\dot{\\mathbf r}_i &= \\mathbf v_i,  \\\\\n\\dot{\\mathbf v}_i &= \\frac{\\mathbf f_i}{m_i} + \\frac{\\mathbf g_i}{m_i}.\\end{split}\\]\nThe thermostatting force is given by\n\n\\[\\begin{split}\\mathbf g_i = \\begin{cases}\n\\frac{m_i}{2}   \\frac{ F_{\\Gamma_{k(\\mathbf r_i)}}}{ K_{\\Gamma_{k(\\mathbf r_i)}}}\n\\left(\\mathbf v_i -  \\mathbf v_{\\Gamma_{k(\\mathbf r_i)}} \\right) &  \\mbox{$k(\\mathbf r_i)> 0$ (inside a reservoir),} \\\\\n 0                                     &  \\mbox{otherwise, }\n\\end{cases}\\end{split}\\]\nwhere \\(m_i\\) is the mass and \\(k(\\mathbf r_i)\\) maps the particle\nposition to the respective reservoir. The quantity\n\\(F_{\\Gamma_{k(\\mathbf r_i)}}\\) corresponds to the input parameter\nF, which is the energy flux into the reservoir. Furthermore,\n\\(K_{\\Gamma_{k(\\mathbf r_i)}}\\) and \\(v_{\\Gamma_{k(\\mathbf r_i)}}\\)\ndenote the non-translational kinetic energy and the center of mass\nvelocity of that reservoir. The thermostatting force does not affect\nthe center of mass velocities of the individual reservoirs and the\nentire simulation box. A derivation of the equations and details on\nthe numerical implementation with velocity Verlet in LAMMPS can be\nfound in reference “(Wirnsberger)”#_Wirnsberger.\n\nNote\nThis fix only integrates the thermostatting force and must be\ncombined with another integrator, such as fix nve, to\nsolve the full equations of motion.\n\nThis fix is different from a thermostat such as fix nvt\nor fix temp/rescale in that energy is\nadded/subtracted continually.  Thus if there isn’t another mechanism\nin place to counterbalance this effect, the entire system will heat or\ncool continuously.\n\nNote\nIf heat is subtracted from the system too aggressively so that\nthe group’s kinetic energy would go to zero, then LAMMPS will halt\nwith an error message. Increasing the value of nevery means that\nheat is added/subtracted less frequently but in larger portions.  The\nresulting temperature profile will therefore be the same.\n\nThis fix will default to fix_heat (HEX algorithm) if\nthe keyword hex is specified.\n\nCompatibility with SHAKE and RATTLE (rigid molecules):\nThis fix is compatible with fix shake and fix rattle. If either of these constraining algorithms is\nspecified in the input script and the keyword constrain is set, the\nbond distances will be corrected a second time at the end of the\nintegration step.  It is recommended to specify the keyword com in\naddition to the keyword constrain. With this option all sites of a\nconstrained cluster are rescaled, if its center of mass is located\ninside the region. Rescaling all sites of a cluster by the same factor\ndoes not introduce any velocity components along fixed bonds. No\nrescaling takes place if the center of mass lies outside the region.\n\nNote\nYou can only use the keyword com along with constrain.\n\nTo achieve the highest accuracy it is recommended to use fix rattle with the keywords constrain and com as\nshown in the second example. Only if RATTLE is employed, the velocity\nconstraints will be satisfied.\n\nNote\nEven if RATTLE is used and the keywords com and constrain\nare both set, the coordinate constraints will not necessarily be\nsatisfied up to the target precision. The velocity constraints are\nsatisfied as long as all sites of a cluster are rescaled (keyword\ncom) and the cluster does not span adjacent reservoirs. The current\nimplementation of the eHEX algorithm introduces a small error in the\nbond distances, which goes to zero with order three in the\ntimestep. For example, in a simulation of SPC/E water with a timestep\nof 2 fs the maximum relative error in the bond distances was found to\nbe on the order of \\(10^{-7}\\) for relatively large\ntemperature gradients.  A higher precision can be achieved by\ndecreasing the timestep.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID ehex nevery F keyword value",
    "parameters": " * ID, group-ID are documented in fix command\n * ehex  = style name of this fix command\n * nevery = add/subtract heat every this many timesteps\n * F = energy flux into the reservoir (energy/time units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region or constrain or com or hex\n * region value = region-ID\n *   region-ID = ID of region (reservoir) atoms must be in for added thermostatting force\n * constrain value = none\n *   apply the constraint algorithm (SHAKE or RATTLE) again at the end of the timestep\n * com value = none\n *   rescale all sites of a constrained cluster of atom if its COM is in the reservoir\n * hex value = none\n *   omit the coordinate correction to recover the HEX algorithm",
    "examples": "# Lennard-Jones, from examples/in.ehex.lj\n\nfix fnve all nve\n# specify regions rhot and rcold\n...\nfix fhot all ehex 1 0.15 region rhot\nfix fcold all ehex 1 -0.15 region rcold\n\n# SPC/E water, from examples/in.ehex.spce\nfix fnve all nve\n# specify regions rhot and rcold\n...\nfix fhot all ehex 1 0.075 region rhot constrain com\nfix fcold all ehex 1 -0.075 region rcold constrain com\nfix frattle all rattle 1e-10 400 0 b 1 a 1",
    "restrictions": "This fix is part of the RIGID package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix electron/stopping",
    "html_filename": "fix_electron_stopping.html",
    "short_description": "This fix implements inelastic energy loss for fast projectiles in solids",
    "description": "This fix implements inelastic energy loss for fast projectiles in solids. It\napplies a friction force to fast moving atoms to slow them down due to\nelectronic stopping (energy lost via electronic collisions per\nunit of distance). This fix should be used for simulation of irradiation\ndamage or ion implantation, where the ions can lose noticeable amounts of\nenergy from electron excitations. If the electronic stopping power is not\nconsidered, the simulated range of the ions can be severely overestimated\n(Nordlund98, Nordlund95).\nThe electronic stopping is implemented by applying a friction force\nto each atom as:\n\n\\[\\vec{F}_i = \\vec{F}^0_i - \\frac{\\vec{v}_i}{\\|\\vec{v}_i\\|} \\cdot S_e\\]\nwhere \\(\\vec{F}_i\\) is the resulting total force on the atom.\n\\(\\vec{F}^0_i\\) is the original force applied to the atom, \\(\\vec{v}_i\\) is\nits velocity and \\(S_e\\) is the stopping power of the ion.\n\nNote\nIn addition to electronic stopping, atomic cascades and irradiation\nsimulations require the use of an adaptive timestep (see\nfix dt/reset) and the repulsive ZBL potential (see\nZBL potential) or similar. Without these settings the\ninteraction between the ion and the target atoms will be faulty. It is also\ncommon to use in such simulations a thermostat (fix_nvt) in\nthe borders of the simulation cell.\n\n\nNote\nThis fix removes energy from fast projectiles without depositing it as a\nheat to the simulation cell. Such implementation might lead to the unphysical\nresults when the amount of energy deposited to the electronic system is large,\ne.g. simulations of Swift Heavy Ions (energy per nucleon of 100 keV/amu or\nhigher) or multiple projectiles. You could compensate energy loss by coupling\nbulk atoms with some thermostat or control heat transfer between electronic and\natomic subsystems with the two-temperature model (fix_ttm).\n\nAt low velocities the electronic stopping is negligible. The electronic\nfriction is not applied to atoms whose kinetic energy is smaller than Ecut,\nor smaller than the lowest energy value given in the table in file.\nElectronic stopping should be applied only when a projectile reaches bulk\nmaterial. This fix scans neighbor list and excludes atoms with fewer than\nminneigh neighbors (by default one). If the pair potential cutoff is large,\nminneigh should be increased, though not above the number of nearest neighbors\nin bulk material. An alternative is to disable the check for neighbors by\nsetting minneigh to zero and using the region keyword. This is necessary\nwhen running simulations of cluster bombardment.\nIf the region keyword is used, the atom must also be in the specified\ngeometric region in order to have electronic stopping applied to\nit. This is useful if the position of the bulk material is fixed. By default\nthe electronic stopping is applied everywhere in the simulation cell.\n\nThe energy ranges and stopping powers are read from the file file.\nLines starting with # and empty lines are ignored. Otherwise each\nline must contain exactly N+1 numbers, where N is the number of atom\ntypes in the simulation.\nThe first column is the energy for which the stopping powers on that\nline apply. The energies must be sorted from the smallest to the largest.\nThe other columns are the stopping powers \\(S_e\\) for each atom type,\nin ascending order, in force units. The stopping powers for\nintermediate energy values are calculated with linear interpolation between\n2 nearest points.\nFor example:\n# This is a comment\n#       atom-1    atom-2\n# eV    eV/Ang    eV/Ang  # units metal\n 10        0        0\n250       60       80\n750      100      150\n\n\nIf an atom which would have electronic stopping applied to it has a\nkinetic energy higher than the largest energy given in file, LAMMPS\nwill exit with an error message.\nThe stopping power depends on the energy of the ion and the target\nmaterial. The electronic stopping table can be obtained from\nscientific publications, experimental databases or by using\nSRIM software. Other programs such as CasP or\nPASS can calculate the energy deposited as a function\nof the impact parameter of the ion; these results can be used\nto derive the stopping power.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify options are not supported.\nThis fix computes a global scalar, which can be accessed by various\noutput commands. The scalar is the total energy\nloss from electronic stopping applied by this fix since the start of\nthe latest run. It is considered “intensive”.\nThe start/stop keywords of the run command have no effect\non this fix.",
    "syntax": "fix ID group-ID electron/stopping Ecut file keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * electron/stopping = style name of this fix command\n * Ecut = minimum kinetic energy for electronic stopping (energy units)\n * file = name of the file containing the electronic stopping power table\n * zero or more keyword/value pairs may be appended to args\n * keyword = region or minneigh\n * region value = region-ID\n *   region-ID = region, whose atoms will be affected by this fix\n * minneigh value = minneigh\n *   minneigh = minimum number of neighbors an atom to have stopping applied",
    "examples": "fix el all electron/stopping 10.0 elstop-table.txt\nfix el all electron/stopping 10.0 elstop-table.txt minneigh 3\nfix el mygroup electron/stopping 1.0 elstop-table.txt region bulk",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled if\nLAMMPS was built with that package. See the Build package\ndoc page for more info."
},
{
    "command": "fix enforce2d",
    "html_filename": "fix_enforce2d.html",
    "short_description": "Zero out the z-dimension velocity and force on each atom in the group",
    "description": "Zero out the z-dimension velocity and force on each atom in the group.\nThis is useful when running a 2d simulation to insure that atoms do\nnot move from their initial z coordinate.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.",
    "syntax": "fix ID group-ID enforce2d",
    "parameters": " * ID, group-ID are documented in fix command\n * enforce2d = style name of this fix command",
    "examples": "fix 5 all enforce2d",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "fix eos/cv",
    "html_filename": "fix_eos_cv.html",
    "short_description": "Fix eos/cv applies a mesoparticle equation of state to relate the particle internal energy (\\(u_i\\)) to the particle internal temperature (\\(\\theta_i\\))",
    "description": "Fix eos/cv applies a mesoparticle equation of state to relate the\nparticle internal energy (\\(u_i\\)) to the particle internal temperature\n(\\(\\theta_i\\)).  The eos/cv mesoparticle equation of state requires\nthe constant-volume heat capacity, and is defined as follows:\n\n\\[u_{i} = u^{mech}_{i} + u^{cond}_{i} = C_{V} \\theta_{i}\\]\nwhere \\(C_V\\) is the constant-volume heat capacity, \\(u^{cond}\\)\nis the internal conductive energy, and \\(u^{mech}\\) is the internal\nmechanical energy.  Note that alternative definitions of the mesoparticle\nequation of state are possible.",
    "syntax": "fix ID group-ID eos/cv cv",
    "parameters": " * ID, group-ID are documented in fix command\n * eos/cv = style name of this fix command\n * cv = constant-volume heat capacity (energy/temperature units)",
    "examples": "fix 1 all eos/cv 0.01",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand."
},
{
    "command": "fix eos/table",
    "html_filename": "fix_eos_table.html",
    "short_description": "Fix eos/table applies a tabulated mesoparticle equation of state to relate the particle internal energy (u_i) to the particle internal temperature (dpdTheta_i)",
    "description": "Fix eos/table applies a tabulated mesoparticle equation of state to\nrelate the particle internal energy (u_i) to the particle internal\ntemperature (dpdTheta_i).\nFix eos/table creates interpolation tables of length N from\ninternal energy values listed in a file as a function of internal\ntemperature.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy values at each of N internal\ntemperatures, and vice versa.  During a simulation, these tables are\nused to interpolate internal energy or temperature values as needed.\nThe interpolation is done with the linear style.\nFor the linear style, the internal temperature is used to find 2\nsurrounding table values from which an internal energy is computed by\nlinear interpolation, and vice versa.\nThe filename specifies a file containing tabulated internal\ntemperature and internal energy values.  The keyword specifies a\nsection of the file.  The format of this file is described below.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# EOS TABLE                (one or more comment or blank lines)\n\nKEYWORD                    (keyword is first text on line)\nN 500                      (N  parameter)\n                           (blank)\n1   1.00 0.000             (index, internal temperature, internal energy)\n2   1.02 0.001\n...\n500 10.0 0.500\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the fix command.\nThe next line lists the number of table entries.  The parameter “N” is\nrequired and its value is the number of table entries that follow.\nNote that this may be different than the N specified in the fix eos/table command.  Let Ntable = N in the fix\ncommand, and Nfile = “N” in the tabulated file.  What LAMMPS does is a\npreliminary interpolation by creating splines using the Nfile\ntabulated values as nodal points.  It uses these to interpolate as\nneeded to generate energy and temperature values at Ntable different\npoints.  The resulting tables of length Ntable are then used as\ndescribed above, when computing energy and temperature relationships.\nThis means that if you want the interpolation tables of length Ntable\nto match exactly what is in the tabulated file (with effectively no\npreliminary interpolation), you should set Ntable = Nfile.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nthe internal temperature (in temperature units), the 3rd value is the\ninternal energy (in energy units).\nNote that the internal temperature and internal energy values must\nincrease from one line to the next.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.",
    "syntax": "fix ID group-ID eos/table style file N keyword",
    "parameters": " * ID, group-ID are documented in fix command\n * eos/table = style name of this fix command\n * style = linear = method of interpolation\n * file = filename containing the tabulated equation of state\n * N = use N values in linear tables\n * keyword = name of table keyword corresponding to table file",
    "examples": "fix 1 all eos/table linear eos.table 100000 KEYWORD",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand.\nThe equation of state must be a monotonically increasing function.\nAn error will occur if the internal temperature or internal energies\nare not within the table cutoffs."
},
{
    "command": "fix eos/table/rx",
    "html_filename": "fix_eos_table_rx.html",
    "short_description": "Fix eos/table/rx applies a tabulated mesoparticle equation of state to relate the concentration-dependent particle internal energy (\\(u_i\\)) to the particle internal temperature (\\(\\theta_i\\))",
    "description": "Fix eos/table/rx applies a tabulated mesoparticle equation\nof state to relate the concentration-dependent particle internal\nenergy (\\(u_i\\)) to the particle internal temperature (\\(\\theta_i\\)).\nThe concentration-dependent particle internal energy (\\(u_i\\)) is\ncomputed according to the following relation:\n\n\\[\\begin{split}U_{i} = \\displaystyle\\sum_{j=1}^{m} c_{i,j}(u_{j} + \\Delta H_{f,j}) + \\frac{3k_{b}T}{2} + Nk_{b}T \\\\\\end{split}\\]\nwhere m is the number of species, \\(c_{i,j}\\) is the\nconcentration of species j in particle i, \\(u_j\\) is the\ninternal energy of species j, \\(\\Delta H_{f,j} is the heat of\nformation of species *j*\\ , N is the number of molecules represented\nby the coarse-grained particle, :math:\\) is the Boltzmann constant,\nand T is the temperature of the system.  Additionally, it is\npossible to modify the concentration-dependent particle internal\nenergy relation by adding an energy correction, temperature-dependent\ncorrection, and/or a molecule-dependent correction.  An energy\ncorrection can be specified as a constant (in energy units).  A\ntemperature correction can be specified by multiplying a temperature\ncorrection coefficient by the internal temperature.  A molecular\ncorrection can be specified by by multiplying a molecule correction\ncoefficient by the average number of product gas particles in the\ncoarse-grain particle.\nFix eos/table/rx creates interpolation tables of length N from m\ninternal energy values of each species \\(u_j\\) listed in a file as a\nfunction of internal temperature.  During a simulation, these tables\nare used to interpolate internal energy or temperature values as needed.\nThe interpolation is done with the linear style.  For the linear style,\nthe internal temperature is used to find 2 surrounding table values from\nwhich an internal energy is computed by linear interpolation.  A secant\nsolver is used to determine the internal temperature from the internal energy.\nThe first filename specifies a file containing tabulated internal\ntemperature and m internal energy values for each species \\(u_j\\).\nThe keyword specifies a section of the file.  The format of this\nfile is described below.\nThe second filename specifies a file containing heat of formation\n\\(\\Delta H_{f,j}\\) for each species.\nIn cases where the coarse-grain particle represents a single molecular\nspecies (i.e., no reactions occur and fix rx is not present in the\ninput file), fix eos/table/rx can be applied in a similar manner to\nfix eos/table within a non-reactive DPD simulation.  In this case,\nthe heat of formation filename is replaced with the heat of formation\nvalue for the single species.  Additionally, the energy correction and\ntemperature correction coefficients may also be specified as fix\narguments.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# EOS TABLE                (one or more comment or blank lines)\n\nKEYWORD                    (keyword is first text on line)\nN 500 h2 no2 n2 ... no     (N  parameter species1 species2 ... speciesN)\n                           (blank)\n1   1.00 0.000 ... 0.0000  (index, internal temperature, internal energy of species 1, ..., internal energy of species m)\n2   1.02 0.001 ... 0.0002\n...\n500 10.0 0.500 ... 1.0000\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the fix command.\nThe next line lists the number of table entries and the species names\nthat correspond with all the species listed in the reaction equations\nthrough the fix rx command.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Let Nfile = “N” in the tabulated file.\nWhat LAMMPS does is a preliminary interpolation by creating splines\nusing the Nfile tabulated values as nodal points.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nthe internal temperature (in temperature units), the 3rd value until\nthe m+3 value are the internal energies of the m species (in energy units).\nNote that all internal temperature and internal energy values must\nincrease from one line to the next.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nThe format of a heat of formation file is as follows (without the\nparenthesized comments):\n# HEAT OF FORMATION TABLE  (one or more comment or blank lines)\n\n                           (blank)\nh2      0.00               (species name, heat of formation)\nno2     0.34\nn2      0.00\n...\nno      0.93\n\n\nNote that the species can be listed in any order.  The tag that is\nused as the species name must correspond with the tags used to define\nthe reactions with the fix rx command.\nAlternatively, corrections to the EOS can be included by specifying\nthree additional columns that correspond to the energy correction,\nthe temperature correction coefficient and molecule correction\ncoefficient.  In this case, the format of the file is as follows:\n# HEAT OF FORMATION TABLE     (one or more comment or blank lines)\n\n                              (blank)\nh2      0.00 1.23 0.025  0.0  (species name, heat of formation, energy correction, temperature correction coefficient, molecule correction coefficient)\nno2     0.34 0.00 0.000 -1.76\nn2      0.00 0.00 0.000 -1.76\n...\nno      0.93 0.00 0.000 -1.76\n\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID eos/table/rx style file1 N keyword ...",
    "parameters": " * ID, group-ID are documented in fix command\n * eos/table/rx = style name of this fix command\n * style = linear = method of interpolation\n * file1 = filename containing the tabulated equation of state\n * N = use N values in linear tables\n * keyword = name of table keyword corresponding to table file\n * file2 = filename containing the heats of formation of each species (optional)\n * deltaHf = heat of formation for a single species in energy units (optional)\n * energyCorr = energy correction in energy units (optional)\n * tempCorrCoeff = temperature correction coefficient (optional)",
    "examples": "fix 1 all eos/table/rx linear eos.table 10000 KEYWORD thermo.table\nfix 1 all eos/table/rx linear eos.table 10000 KEYWORD 1.5\nfix 1 all eos/table/rx linear eos.table 10000 KEYWORD 1.5 0.025 0.0",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand.\nThe equation of state must be a monotonically increasing function.\nAn error will occur if the internal temperature or internal energies\nare not within the table cutoffs."
},
{
    "command": "fix evaporate",
    "html_filename": "fix_evaporate.html",
    "short_description": "Remove M atoms from the simulation every N steps",
    "description": "Remove M atoms from the simulation every N steps.  This can be used,\nfor example, to model evaporation of solvent particles or molecules\n(i.e. drying) of a system.  Every N steps, the number of atoms in the\nfix group and within the specified region are counted.  M of these are\nchosen at random and deleted.  If there are less than M eligible\nparticles, then all of them are deleted.\nIf the setting for the molecule keyword is no, then only single\natoms are deleted.  In this case, you should insure you do not delete\nonly a portion of a molecule (only some of its atoms), or LAMMPS will\nsoon generate an error when it tries to find those atoms.  LAMMPS will\nwarn you if any of the atoms eligible for deletion have a non-zero\nmolecule ID, but does not check for this at the time of deletion.\nIf the setting for the molecule keyword is yes, then when an atom\nis chosen for deletion, the entire molecule it is part of is deleted.\nThe count of deleted atoms is incremented by the number of atoms in\nthe molecule, which may make it exceed M.  If the molecule ID of the\nchosen atom is 0, then it is assumed to not be part of a molecule, and\njust the single atom is deleted.\nAs an example, if you wish to delete 10 water molecules every N\nsteps, you should set M to 30.  If only the water’s oxygen atoms\nwere in the fix group, then two hydrogen atoms would be deleted when\nan oxygen atom is selected for deletion, whether the hydrogen atoms\nare inside the evaporation region or not.\nNote that neighbor lists are re-built on timesteps that atoms are\nremoved.  Thus you should not remove atoms too frequently or you will\nincur overhead due to the cost of building neighbor lists.\n\nNote\nIf you are monitoring the temperature of a system where the atom\ncount is changing due to evaporation, you typically should use the\ncompute_modify dynamic yes command for the\ntemperature compute you are using.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar, which can be accessed by various\noutput commands.  The scalar is the cumulative\nnumber of deleted atoms.  The scalar value calculated by this fix is\n“intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID evaporate N M region-ID seed",
    "parameters": " * ID, group-ID are documented in fix command\n * evaporate = style name of this fix command\n * N = delete atoms every this many timesteps\n * M = number of atoms to delete each time\n * region-ID = ID of region within which to perform deletions\n * seed = random number seed to use for choosing atoms to delete\n * zero or more keyword/value pairs may be appended\n * keyword = molecule\n *   molecule value = no or yes",
    "examples": "fix 1 solvent evaporate 1000 10 surface 49892\nfix 1 solvent evaporate 1000 10 surface 38277 molecule yes",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix external",
    "html_filename": "fix_external.html",
    "short_description": "This fix allows external programs that are running LAMMPS through its library interface to modify certain LAMMPS properties on specific timesteps, similar to the way other fixes do",
    "description": "This fix allows external programs that are running LAMMPS through its\nlibrary interface to modify certain LAMMPS\nproperties on specific timesteps, similar to the way other fixes do.\nThe external driver can be a C/C++ or Fortran program or a Python script.\n\nIf mode is pf/callback then the fix will make a callback every\nNcall timesteps or minimization iterations to the external program.\nThe external program computes forces on atoms by setting values in an\narray owned by the fix.  The fix then adds these forces to each atom\nin the group, once every Napply steps, similar to the way the fix addforce command works.  Note that if Ncall >\nNapply, the force values produced by one callback will persist, and\nbe used multiple times to update atom forces.\nThe callback function “foo” is invoked by the fix as:\nfoo(void *ptr, bigint timestep, int nlocal, int *ids, double **x, double **fexternal);\nThe arguments are as follows:\n\nptr = pointer provided by and simply passed back to external driver\ntimestep = current LAMMPS timestep\nnlocal = # of atoms on this processor\nids = list of atom IDs on this processor\nx = coordinates of atoms on this processor\nfexternal = forces to add to atoms on this processor\n\nNote that timestep is a “bigint” which is defined in src/lmptype.h,\ntypically as a 64-bit integer.\nFexternal are the forces returned by the driver program.\nThe fix has a set_callback() method which the external driver can call\nto pass a pointer to its foo() function.  See the\ncouple/lammps_quest/lmpqst.cpp file in the LAMMPS distribution for an\nexample of how this is done.  This sample application performs\nclassical MD using quantum forces computed by a density functional\ncode Quest.\n\nIf mode is pf/array then the fix simply stores force values in an\narray.  The fix adds these forces to each atom in the group, once\nevery Napply steps, similar to the way the fix addforce command works.\nThe name of the public force array provided by the FixExternal\nclass is\ndouble **fexternal;\nIt is allocated by the FixExternal class as an (N,3) array where N is\nthe number of atoms owned by a processor.  The 3 corresponds to the\nfx, fy, fz components of force.\nIt is up to the external program to set the values in this array to\nthe desired quantities, as often as desired.  For example, the driver\nprogram might perform an MD run in stages of 1000 timesteps each.  In\nbetween calls to the LAMMPS run command, it could retrieve\natom coordinates from LAMMPS, compute forces, set values in fexternal,\netc.\n\nTo use this fix during energy minimization, the energy corresponding\nto the added forces must also be set so as to be consistent with the\nadded forces.  Otherwise the minimization will not converge correctly.\nThis can be done from the external driver by calling this public\nmethod of the FixExternal class:\nvoid set_energy(double eng);\n\n\nwhere eng is the potential energy.  Eng is an extensive quantity,\nmeaning it should be the sum over per-atom energies of all affected\natoms.  It should also be provided in energy units\nconsistent with the simulation.  See the details below for how to\ninsure this energy setting is used appropriately in a minimization.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential “energy” set by the external driver to the\nsystem’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\nneeded so that the minimize command can include the\nforces added by this fix in a consistent manner.  I.e. there is a\ndecrease in potential energy when atoms move in the direction of the\nadded force.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the interactions computed by the\nexternal program to the system’s virial as part of thermodynamic output. The default is virial yes\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the potential\nenergy discussed above.  The scalar stored by this fix is “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the fictitious potential energy associated with the\nadded forces to be included in the total potential energy of the\nsystem (the quantity being minimized), you MUST enable the\nfix_modify energy option for this fix.",
    "syntax": "fix ID group-ID external mode args",
    "parameters": " * ID, group-ID are documented in fix command\n * external = style name of this fix command\n * mode = pf/callback or pf/array\n * pf/callback args = Ncall Napply\n *   Ncall = make callback every Ncall steps\n *   Napply = apply callback forces every Napply steps\n * pf/array args = Napply\n *   Napply = apply array forces every Napply steps",
    "examples": "fix 1 all external pf/callback 1 1\nfix 1 all external pf/callback 100 1\nfix 1 all external pf/array 10",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "fix ffl",
    "html_filename": "fix_ffl.html",
    "short_description": "Apply a Fast-Forward Langevin Equation (FFL) thermostat as described in (Hijazi)",
    "description": "Apply a Fast-Forward Langevin Equation (FFL) thermostat as described\nin (Hijazi). Contrary to\nfix langevin, this fix performs both\nthermostatting and evolution of the Hamiltonian equations of motion, so it\nshould not be used together with fix nve – at least not\non the same atom groups.\nThe time-evolution of a single particle undergoing Langevin dynamics is described\nby the equations\n\n\\[\\frac {dq}{dt} = \\frac{p}{m},\\]\n\n\\[\\frac {dp}{dt} = -\\gamma p + W + F,\\]\nwhere \\(F\\) is the physical force, \\(\\gamma\\) is the friction coefficient, and \\(W\\) is a\nGaussian random force.\nThe friction coefficient is the inverse of the thermostat parameter : \\(\\gamma = 1/\\tau\\), with \\(\\tau\\) the thermostat parameter tau.\nThe thermostat parameter is given in the time units, \\(\\gamma\\) is in inverse time units.\nEquilibrium sampling a temperature T is obtained by specifying the\ntarget value as the Tstart and Tstop arguments, so that the internal\nconstants depending on the temperature are computed automatically.\nThe random number seed must be a positive integer.  A Marsaglia random\nnumber generator is used.  Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random numbers.\nThus the dynamics of the system will not be identical on two runs on\ndifferent numbers of processors.\nThe flipping type flip-type can be chosen between 4 types described in\n(Hijazi). The flipping operation occurs during the thermostatting\nstep and it flips the momenta of the atoms. If no_flip is chosen, no flip\nwill be executed and the integration will be the same as a standard\nLangevin thermostat (Bussi). The other flipping types are : rescale - hard - soft.\nRestart, fix_modify, output, run start/stop, minimize info:\nThe instantaneous values of the extended variables are written to\nbinary restart files.  Because the state of the random\nnumber generator is not saved in restart files, this means you cannot\ndo “exact” restarts with this fix, where the simulation continues on\nthe same as if no restart had taken place. However, in a statistical\nsense, a restarted simulation should produce the same behavior.\nNote however that you should use a different seed each time you\nrestart, otherwise the same sequence of random numbers will be used\neach time, which might lead to stochastic synchronization and\nsubtle artifacts in the sampling.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Langevin thermostatting to the\nsystem’s potential energy as part of thermodynamic output.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.",
    "syntax": "fix ID id-group ffl tau Tstart Tstop seed [flip-type]",
    "parameters": " * ID, group-ID are documented in fix command\n * ffl = style name of this fix command\n * tau = thermostat parameter (positive real)\n * Tstart, Tstop = temperature ramp during the run\n * seed = random number seed to use for generating noise (positive integer)\n * one more value may be appended\n * flip-type  = determines the flipping type, can be chosen between rescale - no_flip - hard - soft, if no flip type is given, rescale will be chosen by default",
    "examples": "fix 3 boundary ffl 10 300 300 31415\nfix 1 all ffl 100 500 500 9265 soft",
    "restrictions": "In order to perform constant-pressure simulations please use\nfix press/berendsen, rather than\nfix npt, to avoid duplicate integration of the\nequations of motion.\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix filter/corotate",
    "html_filename": "fix_filter_corotate.html",
    "short_description": "This fix implements a corotational filter for a mollified impulse method",
    "description": "This fix implements a corotational filter for a mollified impulse\nmethod. In biomolecular simulations, it allows the usage of larger\ntimesteps for long-range electrostatic interactions.  For details, see\n(Fath).\nWhen using run_style respa for a biomolecular\nsimulation with high-frequency covalent bonds, the outer time-step is\nrestricted to below ~ 4fs due to resonance problems. This fix filters\nthe outer stage of the respa and thus a larger (outer) time-step can\nbe used. Since in large biomolecular simulations the computation of\nthe long-range electrostatic contributions poses a major bottleneck,\nthis can significantly accelerate the simulation.\nThe filter computes a cluster decomposition of the molecular structure\nfollowing the criteria indicated by the options a, b, t and m. This\nprocess is similar to the approach in fix shake,\nhowever, the clusters are not kept constrained. Instead, the position\nis slightly modified only for the computation of long-range forces. A\ngood cluster decomposition constitutes in building clusters which\ncontain the fastest covalent bonds inside clusters.\nIf the clusters are chosen suitably, the run_style respa is stable for outer time-steps of at least 8fs.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about these fixes is written to binary restart files.  None of the fix_modify options\nare relevant to these fixes.  No global or per-atom quantities are\nstored by these fixes for access by various output commands.  No parameter of these fixes can be used\nwith the start/stop keywords of the run command.  These\nfixes are not invoked during energy minimization.",
    "syntax": "fix ID group-ID filter/corotate keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * one or more constraint/value pairs are appended\n * constraint = b or a or t or m\n * b values = one or more bond types\n * a values = one or more angle types\n * t values = one or more atom types\n * m value = one or more mass values",
    "examples": "timestep 8\nrun_style respa 3 2 8 bond 1 pair 2 kspace 3\nfix cor all filter/corotate m 1.0\n\nfix cor all filter/corotate b 4 19 a 3 5 2",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nCurrently, it does not support molecule templates."
},
{
    "command": "fix flow/gauss",
    "html_filename": "fix_flow_gauss.html",
    "short_description": "This fix implements the Gaussian dynamics (GD) method to simulate a system at constant mass flux (Strong)",
    "description": "This fix implements the Gaussian dynamics (GD) method to simulate a\nsystem at constant mass flux (Strong). GD is a\nnonequilibrium molecular dynamics simulation method that can be used\nto study fluid flows through pores, pipes, and channels. In its\noriginal implementation GD was used to compute the pressure required\nto achieve a fixed mass flux through an opening.  The flux can be\nconserved in any combination of the directions, x, y, or z, using\nxflag,yflag,zflag. This fix does not initialize a net flux through a\nsystem, it only conserves the center-of-mass momentum that is present\nwhen the fix is declared in the input script. Use the\nvelocity command to generate an initial center-of-mass\nmomentum.\nGD applies an external fluctuating gravitational field that acts as a\ndriving force to keep the system away from equilibrium. To maintain\nsteady state, a profile-unbiased thermostat must be implemented to\ndissipate the heat that is added by the driving force. Compute temp/profile can be used to implement a\nprofile-unbiased thermostat.\nA common use of this fix is to compute a pressure drop across a pipe,\npore, or membrane. The pressure profile can be computed in LAMMPS with\ncompute stress/atom and fix ave/chunk, or with the hardy method in fix atc. Note that the simple compute stress/atom method is only accurate away\nfrom inhomogeneities in the fluid, such as fixed wall atoms. Further,\nthe computed pressure profile must be corrected for the acceleration\napplied by GD before computing a pressure drop or comparing it to\nother methods, such as the pump method (Zhu). The pressure\ncorrection is discussed and described in (Strong).\nFor a complete example including the considerations discussed\nabove, see the examples/USER/flow_gauss directory.\n\nNote\nOnly the flux of the atoms in group-ID will be conserved. If the\nvelocities of the group-ID atoms are coupled to the velocities of\nother atoms in the simulation, the flux will not be conserved. For\nexample, in a simulation with fluid atoms and harmonically constrained\nwall atoms, if a single thermostat is applied to group all, the\nfluid atom velocities will be coupled to the wall atom velocities, and\nthe flux will not be conserved. This issue can be avoided by\nthermostatting the fluid and wall groups separately.\n\nAdding an acceleration to atoms does work on the system. This added\nenergy can be optionally subtracted from the potential energy for the\nthermodynamic output (see below) to check that the timestep is small\nenough to conserve energy. Since the applied acceleration is\nfluctuating in time, the work cannot be computed from a potential. As\na result, computing the work is slightly more computationally\nexpensive than usual, so it is not performed by default. To invoke the\nwork calculation, use the energy keyword. The\nfix_modify energy option also invokes the work\ncalculation, and overrides an energy no setting here. If neither\nenergy yes or fix_modify energy yes are set, the global scalar\ncomputed by the fix will return zero.\n\nNote\nIn order to check energy conservation, any other fixes that do\nwork on the system must have fix_modify energy yes set as well. This\nincludes thermostat fixes and any constraints that hold the positions\nof wall atoms fixed, such as fix spring/self.\n\nIf this fix is used in a simulation with the rRESPA\nintegrator, the applied acceleration must be computed and applied at the same\nrRESPA level as the interactions between the flowing fluid and the obstacle.\nThe rRESPA level at which the acceleration is applied can be changed using\nthe fix_modify respa option discussed below. If the\nflowing fluid and the obstacle interact through multiple interactions that are\ncomputed at different rRESPA levels, then there must be a separate flow/gauss\nfix for each level. For example, if the flowing fluid and obstacle interact\nthrough pairwise and long-range Coulomb interactions, which are computed at\nrRESPA levels 3 and 4, respectively, then there must be two separate\nflow/gauss fixes, one that specifies fix_modify respa 3 and one with\nfix_modify respa 4.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to subtract the work done from the\nsystem’s potential energy as part of thermodynamic output.\nThe fix_modify respa option is supported by this\nfix. This allows the user to set at which level of the rRESPA\nintegrator the fix computes and adds the external acceleration. Default is the\noutermost level.\nThis fix computes a global scalar and a global 3-vector of forces,\nwhich can be accessed by various output commands.\nThe scalar is the negative of the work done on the system, see above\ndiscussion.  The vector is the total force that this fix applied to\nthe group of atoms on the current timestep.  The scalar and vector\nvalues calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.",
    "syntax": "fix ID group-ID flow/gauss xflag yflag zflag keyword",
    "parameters": " * ID, group-ID are documented in fix command\n * flow/gauss = style name of this fix command\n * xflag,yflag,zflag = 0 or 1\n * 0 = do not conserve current in this dimension\n * 1 = conserve current in this dimension\n * zero or more keyword/value pairs may be appended\n * keyword = energy\n * energy value = no or yes\n *   no = do not compute work done by this fix\n *   yes = compute work done by this fix",
    "examples": "fix GD fluid flow/gauss 1 0 0\nfix GD fluid flow/gauss 1 1 1 energy yes",
    "restrictions": "\nnone"
},
{
    "command": "fix freeze",
    "html_filename": "fix_freeze.html",
    "short_description": "Zero out the force and torque on a granular particle",
    "description": "Zero out the force and torque on a granular particle.  This is useful\nfor preventing certain particles from moving in a simulation.  The\ngranular pair styles also detect if this fix has been\ndefined and compute interactions between frozen and non-frozen\nparticles appropriately, as if the frozen particle has infinite mass.\nA similar functionality for normal (point) particles can be obtained\nusing fix setforce.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global 3-vector of forces, which can be accessed\nby various output commands.  This is the total\nforce on the group of atoms before the forces on individual atoms are\nchanged by the fix.  The vector values calculated by this fix are\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID freeze",
    "parameters": " * ID, group-ID are documented in fix command\n * freeze = style name of this fix command",
    "examples": "fix 2 bottom freeze",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThere can only be a single freeze fix defined.  This is because other\nthe granular pair styles treat frozen particles\ndifferently and need to be able to reference a single group to which\nthis fix is applied."
},
{
    "command": "fix gcmc",
    "html_filename": "fix_gcmc.html",
    "short_description": "This fix performs grand canonical Monte Carlo (GCMC) exchanges of atoms or molecules with an imaginary ideal gas reservoir at the specified T and chemical potential (mu) as discussed in (Frenkel)",
    "description": "This fix performs grand canonical Monte Carlo (GCMC) exchanges of\natoms or molecules with an imaginary ideal gas\nreservoir at the specified T and chemical potential (mu) as discussed\nin (Frenkel). It also\nattempts  Monte Carlo (MC) moves (translations and molecule\nrotations) within the simulation cell or\nregion. If used with the fix nvt\ncommand, simulations in the grand canonical ensemble (muVT, constant\nchemical potential, constant volume, and constant temperature) can be\nperformed.  Specific uses include computing isotherms in microporous\nmaterials, or computing vapor-liquid coexistence curves.\nEvery N timesteps the fix attempts both GCMC exchanges\n(insertions or deletions) and MC moves of gas atoms or molecules.\nOn those timesteps, the average number of attempted GCMC exchanges is X,\nwhile the average number of attempted MC moves is M.\nFor GCMC exchanges of either molecular or atomic gasses,\nthese exchanges can be either deletions or insertions,\nwith equal probability.\nThe possible choices for MC moves are translation of an atom,\ntranslation of a molecule, and rotation of a molecule.\nThe relative amounts of each are determined by the optional\nmcmoves keyword (see below).\nThe default behavior is as follows.\nIf the mol keyword is used, only molecule translations\nand molecule rotations are performed with equal probability.\nConversely, if the mol keyword is not used, only atom\ntranslations are performed.\nM should typically be\nchosen to be approximately equal to the expected number of gas atoms\nor molecules of the given type within the simulation cell or region,\nwhich will result in roughly one MC move per atom or molecule\nper MC cycle.\nAll inserted particles are always added to two groups: the default\ngroup “all” and the fix group specified in the fix command.\nIn addition, particles are also added to any groups\nspecified by the group and grouptype keywords.  If inserted\nparticles are individual atoms, they are assigned the atom type given\nby the type argument.  If they are molecules, the type argument has no\neffect and must be set to zero. Instead, the type of each atom in the\ninserted molecule is specified in the file read by the\nmolecule command.\n\nNote\nCare should be taken to apply fix gcmc only to\na group that contains only those atoms and molecules\nthat you wish to manipulate using Monte Carlo.\nHence it is generally not a good idea to specify\nthe default group “all” in the fix command, although it is allowed.\n\nThis fix cannot be used to perform GCMC insertions of gas atoms or\nmolecules other than the exchanged type, but GCMC deletions,\nand MC translations, and rotations can be performed on any atom/molecule in\nthe fix group.  All atoms in the simulation cell can be moved using\nregular time integration translations, e.g. via fix nvt,\nresulting in a hybrid GCMC+MD simulation. A smaller-than-usual\ntimestep size may be needed when running such a hybrid simulation,\nespecially if the inserted molecules are not well equilibrated.\nThis command may optionally use the region keyword to define an\nexchange and move volume.  The specified region must have been\npreviously defined with a region command.  It must be\ndefined with side = in.  Insertion attempts occur only within the\nspecified region. For non-rectangular regions, random trial points are\ngenerated within the rectangular bounding box until a point is found\nthat lies inside the region. If no valid point is generated after 1000\ntrials, no insertion is performed, but it is counted as an attempted\ninsertion.  Move and deletion attempt candidates are selected from gas\natoms or molecules within the region. If there are no candidates, no\nmove or deletion is performed, but it is counted as an attempt move or\ndeletion. If an attempted move places the atom or molecule\ncenter-of-mass outside the specified region, a new attempted move is\ngenerated. This process is repeated until the atom or molecule\ncenter-of-mass is inside the specified region.\nIf used with fix nvt, the temperature of the imaginary\nreservoir, T, should be set to be equivalent to the target temperature\nused in fix nvt. Otherwise, the imaginary reservoir will not be in\nthermal equilibrium with the simulation cell. Also, it is important\nthat the temperature used by fix nvt be dynamic/dof, which can be\nachieved as follows:\ncompute mdtemp mdatoms temp\ncompute_modify mdtemp dynamic/dof yes\nfix mdnvt mdatoms nvt temp 300.0 300.0 10.0\nfix_modify mdnvt temp mdtemp\n\n\nNote that neighbor lists are re-built every timestep that this fix is\ninvoked, so you should not set N to be too small.  However, periodic\nrebuilds are necessary in order to avoid dangerous rebuilds and missed\ninteractions. Specifically, avoid performing so many MC translations\nper timestep that atoms can move beyond the neighbor list skin\ndistance. See the neighbor command for details.\nWhen an atom or molecule is to be inserted, its coordinates are chosen\nat a random position within the current simulation cell or region, and\nnew atom velocities are randomly chosen from the specified temperature\ndistribution given by T. The effective temperature for new atom\nvelocities can be increased or decreased using the optional keyword\ntfac_insert (see below). Relative coordinates for atoms in a\nmolecule are taken from the template molecule provided by the\nuser. The center of mass of the molecule is placed at the insertion\npoint. The orientation of the molecule is chosen at random by rotating\nabout this point.\nIndividual atoms are inserted, unless the mol keyword is used.  It\nspecifies a template-ID previously defined using the\nmolecule command, which reads a file that defines the\nmolecule.  The coordinates, atom types, charges, etc., as well as any\nbonding and special neighbor information for the molecule can\nbe specified in the molecule file.  See the molecule\ncommand for details.  The only settings required to be in this file\nare the coordinates and types of atoms in the molecule.\nWhen not using the mol keyword, you should ensure you do not delete\natoms that are bonded to other atoms, or LAMMPS will soon generate an\nerror when it tries to find bonded neighbors.  LAMMPS will warn you if\nany of the atoms eligible for deletion have a non-zero molecule ID,\nbut does not check for this at the time of deletion.\nIf you wish to insert molecules using the mol keyword that will be\ntreated as rigid bodies, use the rigid keyword, specifying as its\nvalue the ID of a separate fix rigid/small command\nwhich also appears in your input script.\n\nNote\nIf you wish the new rigid molecules (and other rigid molecules)\nto be thermostatted correctly via fix rigid/small/nvt\nor fix rigid/small/npt, then you need to use the\n“fix_modify dynamic/dof yes” command for the rigid fix.  This is to\ninform that fix that the molecule count will vary dynamically.\n\nIf you wish to insert molecules via the mol keyword, that will have\ntheir bonds or angles constrained via SHAKE, use the shake keyword,\nspecifying as its value the ID of a separate fix shake command which also appears in your input script.\nOptionally, users may specify the relative amounts of different MC\nmoves using the mcmoves keyword. The values Patomtrans,\nPmoltrans, Pmolrotate specify the average proportion of\natom translations, molecule translations, and molecule rotations,\nrespectively. The values must be non-negative integers or real\nnumbers, with at least one non-zero value. For example, (10,30,0)\nwould result in 25% of the MC moves being atomic translations, 75%\nmolecular translations, and no molecular rotations.\nOptionally, users may specify the maximum rotation angle for molecular\nrotations using the maxangle keyword and specifying the angle in\ndegrees. Rotations are performed by generating a random point on the\nunit sphere and a random rotation angle on the range\n[0,maxangle). The molecule is then rotated by that angle about an\naxis passing through the molecule center of mass. The axis is parallel\nto the unit vector defined by the point on the unit sphere.  The same\nprocedure is used for randomly rotating molecules when they are\ninserted, except that the maximum angle is 360 degrees.\nNote that fix gcmc does not use configurational bias MC or any other\nkind of sampling of intramolecular degrees of freedom.  Inserted\nmolecules can have different orientations, but they will all have the\nsame intramolecular configuration, which was specified in the molecule\ncommand input.\nFor atomic gasses, inserted atoms have the specified atom type, but\ndeleted atoms are any atoms that have been inserted or that already\nbelong to the fix group. For molecular gasses, exchanged\nmolecules use the same atom types as in the template molecule supplied\nby the user.  In both cases, exchanged atoms/molecules are assigned to\ntwo groups: the default group “all” and the fix group\n(which can also be “all”).\nThe chemical potential is a user-specified input parameter defined\nas:\n\n\\[\\mu = \\mu^{id} + \\mu^{ex}\\]\nThe second term mu_ex is the excess chemical potential due to\nenergetic interactions and is formally zero for the fictitious gas\nreservoir but is non-zero for interacting systems. So, while the\nchemical potential of the reservoir and the simulation cell are equal,\nmu_ex is not, and as a result, the densities of the two are generally\nquite different.  The first term mu_id is the ideal gas contribution\nto the chemical potential.  mu_id can be related to the density or\npressure of the fictitious gas reservoir by:\n\n\\[\\begin{split}\\mu^{id}  = & k T \\ln{\\rho \\Lambda^3} \\\\\n          = & k T \\ln{\\frac{\\phi P \\Lambda^3}{k T}}\\end{split}\\]\nwhere k is Boltzman’s constant, T is the user-specified\ntemperature, \\(\\rho\\) is the number density, P is the pressure,\nand \\(\\phi\\) is the fugacity coefficient.  The constant\n\\(\\Lambda\\) is required for dimensional consistency.  For all unit\nstyles except lj it is defined as the thermal de Broglie wavelength\n\n\\[\\Lambda = \\sqrt{ \\frac{h^2}{2 \\pi m k T}}\\]\nwhere h is Planck’s constant, and m is the mass of the exchanged atom\nor molecule.  For unit style lj, \\(\\Lambda\\) is simply set to\nunity. Note that prior to March 2017, \\(\\Lambda\\) for unit style lj\nwas calculated using the above formula with h set to the rather specific\nvalue of 0.18292026.  Chemical potential under the old definition can\nbe converted to an equivalent value under the new definition by\nsubtracting \\(3 k T \\ln(\\Lambda_{old})\\).\nAs an alternative to specifying mu directly, the ideal gas reservoir\ncan be defined by its pressure P using the pressure keyword, in\nwhich case the user-specified chemical potential is ignored. The user\nmay also specify the fugacity coefficient \\(\\phi\\) using the\nfugacity_coeff keyword, which defaults to unity.\nThe full_energy option means that the fix calculates the total\npotential energy of the entire simulated system, instead of just\nthe energy of the part that is changed. The total system\nenergy before and after the proposed GCMC exchange or MC move\nis then used in the\nMetropolis criterion to determine whether or not to accept the\nproposed change. By default, this option is off,\nin which case only\npartial energies are computed to determine the energy difference\ndue to the proposed change.\nThe full_energy option is needed for systems with complicated\npotential energy calculations, including the following:\n\nlong-range electrostatics (kspace)\nmany-body pair styles\nhybrid pair styles\neam pair styles\ntail corrections\nneed to include potential energy contributions from other fixes\n\nIn these cases, LAMMPS will automatically apply the full_energy\nkeyword and issue a warning message.\nWhen the mol keyword is used, the full_energy option also includes\nthe intramolecular energy of inserted and deleted molecules, whereas\nthis energy is not included when full_energy is not used. If this\nis not desired, the intra_energy keyword can be used to define an\namount of energy that is subtracted from the final energy when a\nmolecule is inserted, and subtracted from the initial energy when a molecule\nis deleted. For molecules that have a non-zero intramolecular energy,\nthis will ensure roughly the same behavior whether or not the\nfull_energy option is used.\nInserted atoms and molecules are assigned random velocities based on\nthe specified temperature T. Because the relative velocity of all\natoms in the molecule is zero, this may result in inserted molecules\nthat are systematically too cold. In addition, the intramolecular\npotential energy of the inserted molecule may cause the kinetic energy\nof the molecule to quickly increase or decrease after insertion.  The\ntfac_insert keyword allows the user to counteract these effects by\nchanging the temperature used to assign velocities to inserted atoms\nand molecules by a constant factor. For a particular application, some\nexperimentation may be required to find a value of tfac_insert that\nresults in inserted molecules that equilibrate quickly to the correct\ntemperature.\nSome fixes have an associated potential energy. Examples of such fixes\ninclude: efield, gravity,\naddforce, langevin,\nrestrain,\ntemp/berendsen,\ntemp/rescale, and wall fixes.\nFor that energy to be included in the total potential energy of the\nsystem (the quantity used when performing GCMC exchange and MC moves),\nyou MUST enable\nthe fix_modify energy option for that fix.  The\ndoc pages for individual fix commands specify if this\nshould be done.\nUse the charge option to insert atoms with a user-specified point\ncharge. Note that doing so will cause the system to become\nnon-neutral.  LAMMPS issues a warning when using long-range\nelectrostatics (kspace) with non-neutral systems. See the compute group/group documentation for more details\nabout simulating non-neutral systems with kspace on.\nUse of this fix typically will cause the number of atoms to fluctuate,\ntherefore, you will want to use the\ncompute_modify dynamic/dof command to insure that the\ncurrent number of atoms is used as a normalizing factor each time\ntemperature is computed. A simple example of this is:\ncompute_modify thermo_temp dynamic yes\n\n\nA more complicated example is listed earlier on this page\nin the context of NVT dynamics.\n\nNote\nIf the density of the cell is initially very small or zero, and\nincreases to a much larger density after a period of equilibration,\nthen certain quantities that are only calculated once at the start\n(kspace parameters) may no longer be accurate.  The\nsolution is to start a new simulation after the equilibrium density\nhas been reached.\n\nWith some pair_styles, such as Buckingham,\nBorn-Mayer-Huggins and ReaxFF, two\natoms placed close to each other may have an arbitrary large, negative\npotential energy due to the functional form of the potential.  While\nthese unphysical configurations are inaccessible to typical dynamical\ntrajectories, they can be generated by Monte Carlo moves. The\noverlap_cutoff keyword suppresses these moves by effectively\nassigning an infinite positive energy to all new configurations that\nplace any pair of atoms closer than the specified overlap cutoff\ndistance.\nThe max and min keywords allow for the restriction of the number\nof atoms in the simulation. They automatically reject all insertion\nor deletion moves that would take the system beyond the set boundaries.\nShould the system already be beyond the boundary, only moves that bring\nthe system closer to the bounds may be accepted.\nThe group keyword adds all inserted atoms to the\ngroup of the group-ID value. The grouptype keyword\nadds all inserted atoms of the specified type to the\ngroup of the group-ID value.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the fix to binary restart files.  This includes information about the random\nnumber generator seed, the next timestep for MC exchanges,  the number\nof MC step attempts and successes etc.  See\nthe read_restart command for info on how to\nre-specify a fix in an input script that reads a restart file, so that\nthe operation of the fix continues in an uninterrupted fashion.\n\nNote\nFor this to work correctly, the timestep must not be changed\nafter reading the restart with reset_timestep.\nThe fix will try to detect it and stop with an error.\n\nNone of the fix_modify options are relevant to this\nfix.\nThis fix computes a global vector of length 8, which can be accessed\nby various output commands.  The vector values are\nthe following global cumulative quantities:\n\n1 = translation attempts\n2 = translation successes\n3 = insertion attempts\n4 = insertion successes\n5 = deletion attempts\n6 = deletion successes\n7 = rotation attempts\n8 = rotation successes\n\nThe vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID gcmc N X M type seed T mu displace keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * gcmc = style name of this fix command\n * N = invoke this fix every N steps\n * X = average number of GCMC exchanges to attempt every N steps\n * M = average number of MC moves to attempt every N steps\n * type = atom type for inserted atoms (must be 0 if mol keyword used)\n * seed = random # seed (positive integer)\n * T = temperature of the ideal gas reservoir (temperature units)\n * mu = chemical potential of the ideal gas reservoir (energy units)\n * displace = maximum Monte Carlo translation distance (length units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = mol, region, maxangle, pressure, fugacity_coeff, full_energy, charge, group, grouptype, intra_energy, tfac_insert, or overlap_cutoff\n *   mol value = template-ID\n *     template-ID = ID of molecule template specified in a separate molecule command\n *   mcmoves values = Patomtrans Pmoltrans Pmolrotate\n *     Patomtrans = proportion of atom translation MC moves\n *     Pmoltrans = proportion of molecule translation MC moves\n *     Pmolrotate = proportion of molecule rotation MC moves\n *   rigid value = fix-ID\n *     fix-ID = ID of fix rigid/small command\n *   shake value = fix-ID\n *     fix-ID = ID of fix shake command\n *   region value = region-ID\n *     region-ID = ID of region where GCMC exchanges and MC moves are allowed\n *   maxangle value = maximum molecular rotation angle (degrees)\n *   pressure value = pressure of the gas reservoir (pressure units)\n *   fugacity_coeff value = fugacity coefficient of the gas reservoir (unitless)\n *   full_energy = compute the entire system energy when performing GCMC exchanges and MC moves\n *   charge value = charge of inserted atoms (charge units)\n *   group value = group-ID\n *     group-ID = group-ID for inserted atoms (string)\n *   grouptype values = type group-ID\n *     type = atom type (int)\n *     group-ID = group-ID for inserted atoms (string)\n *   intra_energy value = intramolecular energy (energy units)\n *   tfac_insert value = scale up/down temperature of inserted atoms (unitless)\n *   overlap_cutoff value = maximum pair distance for overlap rejection (distance units)\n *   max value = Maximum number of molecules allowed in the system\n *   min value = Minimum number of molecules allowed in the system",
    "examples": "fix 2 gas gcmc 10 1000 1000 2 29494 298.0 -0.5 0.01\nfix 3 water gcmc 10 100 100 0 3456543 3.0 -2.5 0.1 mol my_one_water maxangle 180 full_energy\nfix 4 my_gas gcmc 1 10 10 1 123456543 300.0 -12.5 1.0 region disk",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info.\nDo not set “neigh_modify once yes” or else this fix will never be\ncalled.  Reneighboring is required.\nCan be run in parallel, but aspects of the GCMC part will not scale\nwell in parallel. Only usable for 3D simulations.\nWhen using fix gcmc in combination with fix shake or fix rigid,\nonly GCMC exchange moves are supported, so the argument\nM must be zero.\nNote that very lengthy simulations involving insertions/deletions of\nbillions of gas molecules may run out of atom or molecule IDs and\ntrigger an error, so it is better to run multiple shorter-duration\nsimulations. Likewise, very large molecules have not been tested and\nmay turn out to be problematic.\nUse of multiple fix gcmc commands in the same input script can be\nproblematic if using a template molecule. The issue is that the\nuser-referenced template molecule in the second fix gcmc command may\nno longer exist since it might have been deleted by the first fix gcmc\ncommand. An existing template molecule will need to be referenced by\nthe user for each subsequent fix gcmc command."
},
{
    "command": "fix gld",
    "html_filename": "fix_gld.html",
    "short_description": "Applies Generalized Langevin Dynamics to a group of atoms, as described in (Baczewski)",
    "description": "Applies Generalized Langevin Dynamics to a group of atoms, as\ndescribed in (Baczewski).  This is intended to model the\neffect of an implicit solvent with a temporally non-local dissipative\nforce and a colored Gaussian random force, consistent with the\nFluctuation-Dissipation Theorem.  The functional form of the memory\nkernel associated with the temporally non-local force is constrained\nto be a Prony series.\n\nNote\nWhile this fix bears many similarities to fix langevin, it has one significant\ndifference. Namely, fix gld performs time integration,\nwhereas fix langevin does NOT. To this end, the\nspecification of another fix to perform time integration, such as fix nve, is NOT necessary.\n\nWith this fix active, the force on the jth atom is given as\n\n\\[\\begin{split}{\\bf F}_{j}(t) = & {\\bf F}^C_j(t)-\\int \\limits_{0}^{t} \\Gamma_j(t-s) {\\bf v}_j(s)~\\text{d}s + {\\bf F}^R_j(t) \\\\\n\\Gamma_j(t-s) = & \\sum \\limits_{k=1}^{N_k} \\frac{c_k}{\\tau_k} e^{-(t-s)/\\tau_k} \\\\\n\\langle{\\bf F}^R_j(t),{\\bf F}^R_j(s)\\rangle = & \\text{k$_\\text{B}$T} ~\\Gamma_j(t-s)\\end{split}\\]\nHere, the first term is representative of all conservative (pairwise,\nbonded, etc) forces external to this fix, the second is the temporally\nnon-local dissipative force given as a Prony series, and the third is\nthe colored Gaussian random force.\nThe Prony series form of the memory kernel is chosen to enable an\nextended variable formalism, with a number of exemplary mathematical\nfeatures discussed in (Baczewski). In particular, \\(3N_k\\)\nextended variables are added to each atom, which effect the action of\nthe memory kernel without having to explicitly evaluate the integral\nover time in the second term of the force. This also has the benefit\nof requiring the generation of uncorrelated random forces, rather than\ncorrelated random forces as specified in the third term of the force.\nPresently, the Prony series coefficients are limited to being greater\nthan or equal to zero, and the time constants are limited to being\ngreater than zero. To this end, the value of series MUST be set to\npprony, for now. Future updates will allow for negative coefficients\nand other representations of the memory kernel. It is with these\nupdates in mind that the series option was included.\nThe units of the Prony series coefficients are chosen to be mass per\ntime to ensure that the numerical integration scheme stably approaches\nthe Newtonian and Langevin limits. Details of these limits, and the\nassociated numerical concerns are discussed in\n(Baczewski).\nThe desired temperature at each timestep is ramped from Tstart to\nTstop over the course of the next run.\nThe random # seed must be a positive integer. A Marsaglia random\nnumber generator is used. Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random\nnumbers. Thus the dynamics of the system will not be identical on two\nruns on different numbers of processors.\n\nThe keyword/value option pairs are used in the following ways.\nThe keyword frozen can be used to specify how the extended variables\nassociated with the GLD memory kernel are initialized. Specifying no\n(the default), the initial values are drawn at random from an\nequilibrium distribution at Tstart, consistent with the\nFluctuation-Dissipation Theorem. Specifying yes, initializes the\nextended variables to zero.\nThe keyword zero can be used to eliminate drift due to the\nthermostat. Because the random forces on different atoms are\nindependent, they do not sum exactly to zero. As a result, this fix\napplies a small random force to the entire system, and the\ncenter-of-mass of the system undergoes a slow random walk. If the\nkeyword zero is set to yes, the total random force is set exactly\nto zero by subtracting off an equal part of it from each atom in the\ngroup. As a result, the center-of-mass of a system with zero initial\nmomentum will not drift over time.\n\nRestart, run start/stop, minimize info:\nThe instantaneous values of the extended variables are written to\nbinary restart files.  Because the state of the random\nnumber generator is not saved in restart files, this means you cannot\ndo “exact” restarts with this fix, where the simulation continues on\nthe same as if no restart had taken place. However, in a statistical\nsense, a restarted simulation should produce the same behavior.\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID gld Tstart Tstop N_k seed series c_1 tau_1 ... c_N_k tau_N_k keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * gld = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * N_k = number of terms in the Prony series representation of the memory kernel\n * seed = random number seed to use for white noise (positive integer)\n * series = pprony is presently the only available option\n * c_k = the weight of the kth term in the Prony series (mass per time units)\n * tau_k = the time constant of the kth term in the Prony series (time units)\n * zero or more keyword/value pairs may be appended\n * keyword = frozen or zero\n *   frozen value = no or yes\n *     no = initialize extended variables using values drawn from equilibrium distribution at Tstart\n *     yes = initialize extended variables to zero (i.e., from equilibrium distribution at zero temperature)\n *   zero value = no or yes\n *     no = do not set total random force to zero\n *     yes = set total random force to zero",
    "examples": "fix 1 all gld 1.0 1.0 2 82885 pprony 0.5 1.0 1.0 2.0 frozen yes zero yes\nfix 3 rouse gld 7.355 7.355 4 48823 pprony 107.1 0.02415 186.0 0.04294 428.6 0.09661 1714 0.38643",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix gle",
    "html_filename": "fix_gle.html",
    "short_description": "Apply a Generalized Langevin Equation (GLE) thermostat as described in (Ceriotti)",
    "description": "Apply a Generalized Langevin Equation (GLE) thermostat as described\nin (Ceriotti). The formalism allows one to obtain a number\nof different effects ranging from efficient sampling of all\nvibrational modes in the system to inexpensive (approximate)\nmodelling of nuclear quantum effects. Contrary to\nfix langevin, this fix performs both\nthermostatting and evolution of the Hamiltonian equations of motion, so it\nshould not be used together with fix nve – at least not\non the same atom groups.\nEach degree of freedom in the thermostatted group is supplemented\nwith Ns additional degrees of freedom s, and the equations of motion\nbecome\ndq/dt=p/m\nd(p,s)/dt=(F,0) - A(p,s) + B dW/dt\n\n\nwhere F is the physical force, A is the drift matrix (that generalizes\nthe friction in Langevin dynamics), B is the diffusion term and dW/dt\nun-correlated Gaussian random forces. The A matrix couples the physical\n(q,p) dynamics with that of the additional degrees of freedom,\nand makes it possible to obtain effectively a history-dependent\nnoise and friction kernel.\nThe drift matrix should be given as an external file Afile,\nas a (Ns+1 x Ns+1) matrix in inverse time units. Matrices that are\noptimal for a given application and the system of choice can be\nobtained from (GLE4MD).\nEquilibrium sampling a temperature T is obtained by specifying the\ntarget value as the Tstart and Tstop arguments, so that the diffusion\nmatrix that gives canonical sampling for a given A is computed automatically.\nHowever, the GLE framework also allow for non-equilibrium sampling, that\ncan be used for instance to model inexpensively zero-point energy\neffects (Ceriotti2). This is achieved specifying the noneq\nkeyword followed by the name of the file that contains the static covariance\nmatrix for the non-equilibrium dynamics.  Please note, that the covariance\nmatrix is expected to be given in temperature units.\nSince integrating GLE dynamics can be costly when used together with\nsimple potentials, one can use the every optional keyword to\napply the Langevin terms only once every several MD steps, in a\nmultiple time-step fashion. This should be used with care when doing\nnon-equilibrium sampling, but should have no effect on equilibrium\naverages when using canonical sampling.\nThe random number seed must be a positive integer.  A Marsaglia random\nnumber generator is used.  Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random numbers.\nThus the dynamics of the system will not be identical on two runs on\ndifferent numbers of processors.\nNote also that the Generalized Langevin Dynamics scheme that is\nimplemented by the fix gld scheme is closely related\nto the present one. In fact, it should be always possible to cast the\nProny series form of the memory kernel used by GLD into an appropriate\ninput matrix for fix gle. While the GLE scheme is more\ngeneral, the form used by fix gld can be more directly\nrelated to the representation of an implicit solvent environment.\nRestart, fix_modify, output, run start/stop, minimize info:\nThe instantaneous values of the extended variables are written to\nbinary restart files.  Because the state of the random\nnumber generator is not saved in restart files, this means you cannot\ndo “exact” restarts with this fix, where the simulation continues on\nthe same as if no restart had taken place. However, in a statistical\nsense, a restarted simulation should produce the same behavior.\nNote however that you should use a different seed each time you\nrestart, otherwise the same sequence of random numbers will be used\neach time, which might lead to stochastic synchronization and\nsubtle artifacts in the sampling.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Langevin thermostatting to the\nsystem’s potential energy as part of thermodynamic output.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.",
    "syntax": "fix ID id-group gle Ns Tstart Tstop seed Amatrix [noneq Cmatrix] [every stride]",
    "parameters": " * ID, group-ID are documented in fix command\n * gle = style name of this fix command\n * Ns = number of additional fictitious momenta\n * Tstart, Tstop = temperature ramp during the run\n * Amatrix = file to read the drift matrix A from\n * seed = random number seed to use for generating noise (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = noneq or every\n *   noneq Cmatrix  = file to read the non-equilibrium covariance matrix from\n *   every stride   = apply the GLE once every time steps. Reduces the accuracy\n *       of the integration of the GLE, but has *no effect* on the accuracy of equilibrium\n *       sampling. It might change sampling properties when used together with noneq.",
    "examples": "fix 3 boundary gle 6 300 300 31415 smart.A\nfix 1 all gle 6 300 300 31415 qt-300k.A noneq qt-300k.C",
    "restrictions": "The GLE thermostat in its current implementation should not be used\nwith rigid bodies, SHAKE or RATTLE. It is expected that all the\nthermostatted degrees of freedom are fully flexible, and the sampled\nensemble will not be correct otherwise.\nIn order to perform constant-pressure simulations please use\nfix press/berendsen, rather than\nfix npt, to avoid duplicate integration of the\nequations of motion.\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix gravity",
    "html_filename": "fix_gravity.html",
    "short_description": "Impose an additional acceleration on each particle in the group",
    "description": "Impose an additional acceleration on each particle in the group.  This\nfix is typically used with granular systems to include a “gravity”\nterm acting on the macroscopic particles.  More generally, it can\nrepresent any kind of driving field, e.g. a pressure gradient inducing\na Poiseuille flow in a fluid.  Note that this fix operates differently\nthan the fix addforce command.  The addforce fix\nadds the same force to each atom, independent of its mass.  This\ncommand imparts the same acceleration to each atom (force/mass).\nThe magnitude of the acceleration is specified in force/mass units.\nFor granular systems (LJ units) this is typically 1.0.  See the\nunits command for details.\nStyle chute is typically used for simulations of chute flow where\nthe specified angle is the chute angle, with flow occurring in the +x\ndirection.  For 3d systems, the tilt is away from the z axis; for 2d\nsystems, the tilt is away from the y axis.\nStyle spherical allows an arbitrary 3d direction to be specified for\nthe acceleration vector.  Phi and theta are defined in the usual\nspherical coordinates.  Thus for acceleration acting in the -z\ndirection, theta would be 180.0 (or -180.0).  Theta = 90.0 and\nphi = -90.0 would mean acceleration acts in the -y direction.  For\n2d systems, phi is ignored and theta is an angle in the xy plane\nwhere theta = 0.0 is the y-axis.\nStyle vector imposes an acceleration in the vector direction given\nby (x,y,z).  Only the direction of the vector is important; it’s\nlength is ignored.  For 2d systems, the z component is ignored.\nAny of the quantities magnitude, angle, phi, theta, x, y,\nz which define the gravitational magnitude and direction, can be\nspecified as an equal-style variable.  If the value is\na variable, it should be specified as v_name, where name is the\nvariable name.  In this case, the variable will be evaluated each\ntimestep, and its value used to determine the quantity.  You should\ninsure that the variable calculates a result in the appropriate units,\ne.g. force/mass or degrees.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent gravitational\nfield.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the gravitational potential energy of the system to the\nsystem’s potential energy as part of thermodynamic output.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  This scalar is the gravitational\npotential energy of the particles in the defined field, namely mass *\n(g dot x) for each particles, where x and mass are the particles\nposition and mass, and g is the gravitational field.  The scalar value\ncalculated by this fix is “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group gravity magnitude style args",
    "parameters": " * ID, group are documented in fix command\n * gravity = style name of this fix command\n * magnitude = size of acceleration (force/mass units)\n * magnitude can be a variable (see below)\n * style = chute or spherical or gradient or vector\n * chute args = angle\n *   angle = angle in +x away from -z or -y axis in 3d/2d (in degrees)\n *   angle can be a variable (see below)\n * spherical args = phi theta\n *   phi = azimuthal angle from +x axis (in degrees)\n *   theta = angle from +z or +y axis in 3d/2d (in degrees)\n *   phi or theta can be a variable (see below)\n * vector args = x y z\n *   x y z = vector direction to apply the acceleration\n *   x or y or z can be a variable (see below)",
    "examples": "fix 1 all gravity 1.0 chute 24.0\nfix 1 all gravity v_increase chute 24.0\nfix 1 all gravity 1.0 spherical 0.0 -180.0\nfix 1 all gravity 10.0 spherical v_phi v_theta\nfix 1 all gravity 100.0 vector 1 1 0",
    "restrictions": "\nnone"
},
{
    "command": "fix grem",
    "html_filename": "fix_grem.html",
    "short_description": "This fix implements the molecular dynamics version of the generalized replica exchange method (gREM) originally developed by (Kim), which uses non-Boltzmann ensembles to sample over first order phase transitions",
    "description": "This fix implements the molecular dynamics version of the generalized\nreplica exchange method (gREM) originally developed by (Kim),\nwhich uses non-Boltzmann ensembles to sample over first order phase\ntransitions. The is done by defining replicas with an enthalpy\ndependent effective temperature\n\n\\[T_{eff} = \\lambda + \\eta (H - H_0)\\]\nwith \\(\\eta\\) negative and steep enough to only intersect the\ncharacteristic microcanonical temperature (Ts) of the system once,\nensuring a unimodal enthalpy distribution in that replica.\n\\(\\lambda\\) is the intercept and effects the generalized ensemble\nsimilar to how temperature effects a Boltzmann ensemble. \\(H_0\\)\nis a reference enthalpy, and is typically set as the lowest desired\nsampled enthalpy.  Further explanation can be found in our recent\npapers (Malolepsza).\nThis fix requires a Nose-Hoover thermostat fix reference passed to the\ngrem as thermostat-ID. Two distinct temperatures exist in this\ngeneralized ensemble, the effective temperature defined above, and a\nkinetic temperature that controls the velocity distribution of\nparticles as usual. Either constant volume or constant pressure\nalgorithms can be used.\nThe fix enforces a generalized ensemble in a single replica\nonly. Typically, this ideology is combined with replica exchange with\nreplicas differing by \\(\\lambda\\) only for simplicity, but this is not\nrequired. A multi-replica simulation can be run within the LAMMPS\nenvironment using the temper/grem command. This\nutilizes LAMMPS partition mode and requires the number of available\nprocessors be on the order of the number of desired replicas. A\n100-replica simulation would require at least 100 processors (1 per\nworld at minimum). If many replicas are needed on a small number of\nprocessors, multi-replica runs can be run outside of LAMMPS.  An\nexample of this can be found in examples/USER/misc/grem and has no\nlimit on the number of replicas per processor. However, this is very\ninefficient and error prone and should be avoided if possible.\nIn general, defining the generalized ensembles is unique for every\nsystem. When starting a many-replica simulation without any knowledge\nof the underlying microcanonical temperature, there are several tricks\nwe have utilized to optimize the process.  Choosing a less-steep\n\\(\\eta\\) yields broader distributions, requiring fewer replicas to\nmap the microcanonical temperature.  While this likely struggles from\nthe same sampling problems gREM was built to avoid, it provides quick\ninsight to Ts.  Initially using an evenly-spaced \\(\\lambda\\)\ndistribution identifies regions where small changes in enthalpy lead\nto large temperature changes. Replicas are easily added where needed.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe thermo_modify press option is supported\nby this fix to add the rescaled kinetic pressure as part of\nthermodynamic output.",
    "syntax": "fix ID group-ID grem lambda eta H0 thermostat-ID",
    "parameters": " * ID, group-ID are documented in fix command\n * grem = style name of this fix command\n * lambda = intercept parameter of linear effective temperature function\n * eta = slope parameter of linear effective temperature function\n * H0 = shift parameter of linear effective temperature function\n * thermostat-ID = ID of Nose-Hoover thermostat or barostat used in simulation",
    "examples": "fix             fxgREM all grem 400 -0.01 -30000 fxnpt\nthermo_modify   press fxgREM_press\n\nfix             fxgREM all grem 502 -0.15 -80000 fxnvt",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "fix halt",
    "html_filename": "fix_halt.html",
    "short_description": "Check a condition every N steps during a simulation run",
    "description": "Check a condition every N steps during a simulation run.  N must be >=\n1.  If the condition is met, exit the run immediately.  In this\ncontext a “run” can be dynamics or minimization iterations, as\nspecified by the run or minimize command.\nThe specified group-ID is ignored by this fix.\nThe specified attribute can be one of the options listed above,\nnamely bondmax or tlimit, or an equal-style variable referenced as v_name, where “name” is the\nname of a variable that has been defined previously in the input\nscript.\nThe bondmax attribute will loop over all bonds in the system,\ncompute their current lengths, and set attribute to the longest bond\ndistance.\nThe tlimit attribute queries the elapsed CPU time (in seconds) since\nthe current run began, and sets attribute to that value.  This is an\nalternative way to limit the length of a simulation run, similar to\nthe timer timeout command.  There are two differences in\nusing this method versus the timer command option.  The first is that\nthe clock starts at the beginning of the current run (not when the\ntimer or fix command is specified), so that any setup time for the run\nis not included in the elapsed time.  The second is that the timer\ninvocation and syncing across all processors (via MPI_Allreduce) is\nnot performed once every N steps by this command.  Instead it is\nperformed (typically) only a small number of times and the elapsed\ntimes are used to predict when the end-of-the-run will be.  Both of\nthese attributes can be useful when performing benchmark calculations\nfor a desired length of time with minimal overhead.  For example, if\na run is performing 1000s of timesteps/sec, the overhead for syncing\nthe timer frequently across a large number of processors may be\nnon-negligible.\nEqual-style variables evaluate to a numeric value.  See the\nvariable command for a description.  They calculate\nformulas which can involve mathematical operations, atom properties,\ngroup properties, thermodynamic properties, global values calculated\nby a compute or fix, or references to other\nvariables.  Thus they are a very general means of\ncomputing some attribute of the current system.  For example, the\nfollowing “bondmax” variable will calculate the same quantity as the\nhstyle = bondmax option.\ncompute         bdist all bond/local dist\ncompute         bmax all reduce max c_bdist\nvariable        bondmax equal c_bmax\n\n\nThus these two versions of a fix halt command will do the same thing:\nfix 10 all halt 1 bondmax > 1.5\nfix 10 all halt 1 v_bondmax > 1.5\n\n\nThe version with “bondmax” will just run somewhat faster, due to less\noverhead in computing bond lengths and not storing them in a separate\ncompute.\nThe choice of operators listed above are the usual comparison\noperators.  The XOR operation (exclusive or) is also included as “|^”.\nIn this context, XOR means that if either the attribute or avalue is\n0.0 and the other is non-zero, then the result is “true”.  Otherwise\nit is “false”.\nThe specified avalue must be a numeric value.\n\nThe optional error keyword determines how the current run is halted.\nIf its value is hard, then LAMMPS will stop with an error message.\nIf its value is soft, LAMMPS will exit the current run, but continue\nto execute subsequent commands in the input script.  However,\nadditional run or minimize commands will be\nskipped.  For example, this allows a script to output the current\nstate of the system, e.g. via a write_dump or\nwrite_restart command.\nIf its value is continue, the behavior is the same as for soft,\nexcept subsequent run or minimize commands\nare executed.  This allows your script to remedy the condition that\ntriggered the halt, if necessary.  Note that you may wish use the\nunfix command on the fix halt ID, so that the same\ncondition is not immediately triggered in a subsequent run.\nThe optional message keyword determines whether a message is printed\nto the screen and logfile when the halt condition is triggered.  If\nmessage is set to yes, a one line message with the values that\ntriggered the halt is printed.  If message is set to no, no message\nis printed; the run simply exits.  The latter may be desirable for\npost-processing tools that extract thermodynamic information from log\nfiles.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.",
    "syntax": "fix ID group-ID halt N attribute operator avalue keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * halt = style name of this fix command\n * N = check halt condition every N steps\n * attribute = bondmax or tlimit or v_name\n * bondmax = length of longest bond in the system\n * tlimit = elapsed CPU time\n * v_name = name of equal-style variable\n * operator = “<” or “<=” or “>” or “>=” or “==” or “!=” or “|^”\n * avalue = numeric value to compare attribute to\n * zero or more keyword/value pairs may be appended\n * keyword = error or message\n * error value = hard or soft or continue\n * message value = yes or no",
    "examples": "fix 10 all halt 1 bondmax > 1.5\nfix 10 all print 10 v_myCheck != 0 error soft",
    "restrictions": "\nnone"
},
{
    "command": "fix heat",
    "html_filename": "fix_heat.html",
    "short_description": "Add non-translational kinetic energy (heat) to a group of atoms in a manner that conserves their aggregate momentum",
    "description": "Add non-translational kinetic energy (heat) to a group of atoms in a\nmanner that conserves their aggregate momentum.  Two of these fixes\ncan be used to establish a temperature gradient across a simulation\ndomain by adding heat (energy) to one group of atoms (hot reservoir)\nand subtracting heat from another (cold reservoir).  E.g. a simulation\nsampling from the McDLT ensemble.\nIf the region keyword is used, the atom must be in both the group\nand the specified geometric region in order to have\nenergy added or subtracted to it.  If not specified, then the atoms in\nthe group are affected wherever they may move to.\nHeat addition/subtraction is performed every N timesteps.  The eflux\nparameter can be specified as a numeric constant or as a variable (see\nbelow).  If it is a numeric constant or equal-style variable which\nevaluates to a scalar value, then the eflux determines the change in\naggregate energy of the entire group of atoms per unit time, e.g. in\neV/psec for metal units.  In this case it is an\n“extensive” quantity, meaning its magnitude should be scaled with the\nnumber of atoms in the group.  Note that since eflux has per-time\nunits (i.e. it is a flux), this means that a larger value of N will\nadd/subtract a larger amount of energy each time the fix is invoked.\n\nNote\nThe heat-exchange (HEX) algorithm implemented by this fix is\nknown to exhibit a pronounced energy drift. An improved algorithm\n(eHEX) is available as a fix ehex command and might be\npreferable if energy conservation is important.\n\nIf eflux is specified as an atom-style variable (see below), then\nthe variable computes one value per atom.  In this case, each value is\nthe energy flux for a single atom, again in units of energy per unit\ntime.  In this case, each value is an “intensive” quantity, which need\nnot be scaled with the number of atoms in the group.\nAs mentioned above, the eflux parameter can be specified as an\nequal-style or atom_style variable.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value(s) used to determine the flux.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent flux.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent flux\nwith optional time-dependence as well.\n\nNote\nIf heat is subtracted from the system too aggressively so that\nthe group’s kinetic energy would go to zero, or any individual atom’s\nkinetic energy would go to zero for the case where eflux is an\natom-style variable, then LAMMPS will halt with an error message.\n\nFix heat is different from a thermostat such as fix nvt\nor fix temp/rescale in that energy is\nadded/subtracted continually.  Thus if there isn’t another mechanism\nin place to counterbalance this effect, the entire system will heat or\ncool continuously.  You can use multiple heat fixes so that the net\nenergy change is 0.0 or use fix viscous to drain\nenergy from the system.\nThis fix does not change the coordinates of its atoms; it only scales\ntheir velocities.  Thus you must still use an integration fix\n(e.g. fix nve) on the affected atoms.  This fix should\nnot normally be used on atoms that have their temperature controlled\nby another fix - e.g. fix nvt or fix langevin fix.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  This scalar is the most recent\nvalue by which velocities were scaled.  The scalar value calculated by\nthis fix is “intensive”.  If eflux is specified as an atom-style\nvariable, this fix computes the average value by which the velocities\nwere scaled for all of the atoms that had their velocities scaled.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID heat N eflux",
    "parameters": " * ID, group-ID are documented in fix command\n * heat = style name of this fix command\n * N = add/subtract heat every this many timesteps\n * eflux = rate of heat addition or subtraction (energy/time units)\n * eflux can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to have added force",
    "examples": "fix 3 qin heat 1 1.0\nfix 3 qin heat 10 v_flux\nfix 4 qout heat 1 -1.0 region top",
    "restrictions": "\nnone"
},
{
    "command": "fix hyper/global",
    "html_filename": "fix_hyper_global.html",
    "short_description": "This fix is meant to be used with the hyper command to perform a bond-boost global hyperdynamics (GHD) simulation",
    "description": "This fix is meant to be used with the hyper command to\nperform a bond-boost global hyperdynamics (GHD) simulation.  The role\nof this fix is to a select a single pair of atoms in the system at\neach timestep to add a global bias potential to, which will alter the\ndynamics of the system in a manner that effectively accelerates time.\nThis is in contrast to the fix hyper/local\ncommand, which can be user to perform a local hyperdynamics (LHD)\nsimulation, by adding a local bias potential to multiple pairs of\natoms at each timestep.  GHD can time accelerate a small simulation\nwith up to a few 100 atoms.  For larger systems, LHD is needed to\nachieve good time acceleration.\nFor a system that undergoes rare transition events, where one or more\natoms move over an energy barrier to a new potential energy basin, the\neffect of the bias potential is to induce more rapid transitions.\nThis can lead to a dramatic speed-up in the rate at which events\noccurs, without altering their relative frequencies, thus leading to\nan overall increase in the elapsed real time of the simulation as\ncompared to running for the same number of timesteps with normal MD.\nSee the hyper doc page for a more general discussion of\nhyperdynamics and citations that explain both GHD and LHD.\nThe equations and logic used by this fix and described here to perform\nGHD follow the description given in (Voter2013).  The\nbond-boost form of a bias potential for HD is due to Miron and\nFichthorn as described in (Miron).  In LAMMPS we use a\nsimplified version of bond-boost GHD where a single bond in the system\nis biased at any one timestep.\nBonds are defined between each pair of atoms ij, whose \\(R^0_{ij}\\)\ndistance is less than cutbond, when the system is in a quenched state\n(minimum) energy.  Note that these are not “bonds” in a covalent\nsense.  A bond is simply any pair of atoms that meet the distance\ncriterion.  Cutbond is an argument to this fix; it is discussed\nbelow.  A bond is only formed if one or both of the ij atoms are in\nthe specified group.\nThe current strain of bond ij (when running dynamics) is defined as\n\n\\[E_{ij} = \\frac{R_{ij} - R^0_{ij}}{R^0_{ij}}\\]\nwhere \\(R_{ij}\\) is the current distance between atoms i and j,\nand \\(R^0_{ij}\\) is the equilibrium distance in the quenched state.\nThe bias energy \\(V_{ij}\\) of any bond between atoms i and j\nis defined as\n\n\\[V_{ij} = V^{max} \\cdot \\left( 1 - \\left(\\frac{E_{ij}}{q}\\right)^2 \\right) \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\nwhere the prefactor \\(V^{max}\\) and the cutoff qfactor are arguments to\nthis fix; they are discussed below.  This functional form is an\ninverse parabola centered at 0.0 with height \\(V^{max}\\) and\nwhich goes to 0.0 at +/- qfactor.\nLet \\(E^{max}\\) be the maximum of \\(\\left| E_{ij} \\right|\\)\nfor all ij bonds in the system on a\ngiven timestep.  On that step, \\(V_{ij}\\) is added as a bias potential\nto only the single bond with strain \\(E^{max}\\), call it\n\\(V^{max}_{ij}\\).  Note that \\(V^{max}_{ij}\\) will be 0.0\nif \\(E^{max} >= \\textrm{qfactor}\\) on that timestep.  Also note\nthat \\(V^{max}_{ij}\\) is added to the normal interatomic potential\nthat is computed between all atoms in the system at every step.\nThe derivative of \\(V^{max}_{ij}\\) with respect to the position of\neach atom in the \\(E^{max}\\) bond gives a bias force\n\\(F^{max}_{ij}\\) acting on the bond as\n\n\\[F^{max}_{ij} = - \\frac{dV^{max}_{ij}}{dE_{ij}} = \\frac{2 V^{max} E-{ij}}{\\textrm{qfactor}^2}   \\textrm{ for } \\left|E_{ij}\\right| < \\textrm{qfactor} \\textrm{ or } 0 \\textrm{ otherwise}\\]\nwhich can be decomposed into an equal and opposite force acting on\nonly the two ij atoms in the \\(E^{max}\\) bond.\nThe time boost factor for the system is given each timestep I by\n\n\\[B_i = e^{\\beta V^{max}_{ij}}\\]\nwhere \\(\\beta = \\frac{1}{kT_{equil}}\\), and \\(T_{equil}\\) is the temperature of the system\nand an argument to this fix.  Note that \\(B_i >= 1\\) at every step.\n\nNote\nTo run a GHD simulation, the input script must also use the fix langevin command to thermostat the atoms at the\nsame Tequil as specified by this fix, so that the system is running\nconstant-temperature (NVT) dynamics.  LAMMPS does not check that this\nis done.\n\nThe elapsed time \\(t_{hyper}\\) for a GHD simulation running for N\ntimesteps is simply\n\n\\[t_{hyper} = \\sum_{i=1,N} B-i \\cdot dt\\]\nwhere dt is the timestep size defined by the timestep\ncommand.  The effective time acceleration due to GHD is thus t_hyper /\nN*dt, where N*dt is elapsed time for a normal MD run of N timesteps.\nNote that in GHD, the boost factor varies from timestep to timestep.\nLikewise, which bond has \\(E^{max}\\) strain and thus which pair of\natoms the bias potential is added to, will also vary from timestep to timestep.\nThis is in contrast to local hyperdynamics (LHD) where the boost\nfactor is an input parameter; see the fix hyper/local doc page for details.\n\nHere is additional information on the input parameters for GHD.\nThe cutbond argument is the cutoff distance for defining bonds\nbetween pairs of nearby atoms.  A pair of ij atoms in their\nequilibrium, minimum-energy configuration, which are separated by a\ndistance \\(R_{ij} < cutbond\\), are flagged as a bonded pair.  Setting\ncubond to be ~25% larger than the nearest-neighbor distance in a\ncrystalline lattice is a typical choice for solids, so that bonds\nexist only between nearest neighbor pairs.\nThe qfactor argument is the limiting strain at which the bias\npotential goes to 0.0.  It is dimensionless, so a value of 0.3 means a\nbond distance can be up to 30% larger or 30% smaller than the\nequilibrium (quenched) R0ij distance and the two atoms in the bond\ncould still experience a non-zero bias force.\nIf qfactor is set too large, then transitions from one energy basin\nto another are affected because the bias potential is non-zero at the\ntransition state (e.g. saddle point).  If qfactor is set too small\nthan little boost is achieved because the \\(E_{ij}\\) strain of some bond in\nthe system will (nearly) always exceed qfactor.  A value of 0.3 for\nqfactor is typically reasonable.\nThe Vmax argument is the prefactor on the bias potential.  Ideally,\ntt should be set to a value slightly less than the smallest barrier\nheight for an event to occur.  Otherwise the applied bias potential\nmay be large enough (when added to the interatomic potential) to\nproduce a local energy basin with a maxima in the center.  This can\nproduce artificial energy minima in the same basin that trap an atom.\nOr if Vmax is even larger, it may induce an atom(s) to rapidly\ntransition to another energy basin.  Both cases are “bad dynamics”\nwhich violate the assumptions of GHD that guarantee an accelerated\ntime-accurate trajectory of the system.\nNote that if Vmax is set too small, the GHD simulation will run\ncorrectly.  There will just be fewer events because the hyper time\n(t_hyper equation above) will be shorter.\n\nNote\nIf you have no physical intuition as to the smallest barrier\nheight in your system, a reasonable strategy to determine the largest\nVmax you can use for a GHD model, is to run a sequence of\nsimulations with smaller and smaller Vmax values, until the event\nrate does not change (as a function of hyper time).\n\nThe Tequil argument is the temperature at which the system is\nsimulated; see the comment above about the fix langevin thermostatting.  It is also part of the\nbeta term in the exponential factor that determines how much boost is\nachieved as a function of the bias potential.\nIn general, the lower the value of Tequil and the higher the value\nof Vmax, the more time boost will be achievable by the GHD\nalgorithm.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy of the bias potential to the system’s\npotential energy as part of thermodynamic output.\nThis fix computes a global scalar and global vector of length 12, which\ncan be accessed by various output commands.  The\nscalar is the magnitude of the bias potential (energy units) applied on\nthe current timestep.  The vector stores the following quantities:\n\n1 = boost factor on this step (unitless)\n2 = max strain \\(E_{ij}\\) of any bond on this step (absolute value, unitless)\n3 = ID of first atom in the max-strain bond\n4 = ID of second atom in the max-strain bond\n5 = average # of bonds/atom on this step\n6 = fraction of timesteps where the biased bond has bias = 0.0 during this run\n7 = fraction of timesteps where the biased bond has negative strain during this run\n8 = max drift distance of any atom during this run (distance units)\n9 = max bond length during this run (distance units)\n10 = cumulative hyper time since fix was defined (time units)\n11 = cumulative count of event timesteps since fix was defined\n12 = cumulative count of atoms in events since fix was defined\n\nThe first 5 quantities are for the current timestep.  Quantities 6-9\nare for the current hyper run.  They are reset each time a new hyper\nrun is performed.  Quantities 19-12 are cumulative across multiple\nruns (since the point in the input script the fix was defined).\nFor value 8, drift is the distance an atom moves between two quenched\nstates when the second quench determines an event has occurred.  Atoms\ninvolved in an event will typically move the greatest distance since\nothers typically remain near their original quenched position.\nFor value 11, events are checked for by the hyper command\nonce every Nevent timesteps.  This value is the count of those\ntimesteps on which one (or more) events was detected.  It is NOT the\nnumber of distinct events, since more than one event may occur in the\nsame Nevent time window.\nFor value 12, each time the hyper command checks for an\nevent, it invokes a compute to flag zero or more atoms as\nparticipating in one or more events.  E.g. atoms that have displaced\nmore than some distance from the previous quench state.  Value 11 is\nthe cumulative count of the number of atoms participating in any of\nthe events that were found.\nThe scalar and vector values calculated by this fix are all\n“intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID hyper/global cutbond qfactor Vmax Tequil",
    "parameters": " * ID, group-ID are documented in fix command\n * hyper/global = style name of this fix command\n * cutbond = max distance at which a pair of atoms is considered bonded (distance units)\n * qfactor = max strain at which bias potential goes to 0.0 (unitless)\n * Vmax = height of bias potential (energy units)\n * Tequil = equilibration temperature (temperature units)",
    "examples": "fix 1 all hyper/global 1.0 0.3 0.8 300.0",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "fix hyper/local",
    "html_filename": "fix_hyper_local.html",
    "short_description": "This fix is meant to be used with the hyper command to perform a bond-boost local hyperdynamics (LHD) simulation",
    "description": "This fix is meant to be used with the hyper command to\nperform a bond-boost local hyperdynamics (LHD) simulation.  The role\nof this fix is to a select multiple pairs of atoms in the system at\neach timestep to add a local bias potential to, which will alter the\ndynamics of the system in a manner that effectively accelerates time.\nThis is in contrast to the fix hyper/global\ncommand, which can be user to perform a global hyperdynamics (GHD)\nsimulation, by adding a global bias potential to a single pair of\natoms at each timestep.  GHD can time accelerate a small simulation\nwith up to a few 100 atoms.  For larger systems, LHD is needed to\nachieve good time acceleration.\nFor a system that undergoes rare transition events, where one or more\natoms move over an energy barrier to a new potential energy basin, the\neffect of the bias potential is to induce more rapid transitions.\nThis can lead to a dramatic speed-up in the rate at which events\noccurs, without altering their relative frequencies, thus leading to\nan overall increase in the elapsed real time of the simulation as\ncompared to running for the same number of timesteps with normal MD.\nSee the hyper doc page for a more general discussion of\nhyperdynamics and citations that explain both GHD and LHD.\nThe equations and logic used by this fix and described here to perform\nLHD follow the description given in (Voter2013).  The\nbond-boost form of a bias potential for HD is due to Miron and\nFichthorn as described in (Miron).\nTo understand this description, you should first read the description\nof the GHD algorithm on the fix hyper/global\ndoc page.  This description of LHD builds on the GHD description.\nThe definition of bonds and \\(E_{ij}\\) are the same for GHD and LHD.\nThe formulas for \\(V^{max}_{ij}\\) and \\(F^{max}_{ij}\\) are also\nthe same except for a pre-factor \\(C_{ij}\\), explained below.\nThe bias energy \\(V_{ij}\\) applied to a bond ij with maximum strain is\n\n\\[V^{max}_{ij} = C_{ij} \\cdot V^{max} \\cdot \\left(1 - \\left(\\frac{E_{ij}}{q}\\right)^2\\right) \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\nThe derivative of \\(V^{max}_{ij}\\) with respect to the position of\neach atom in the ij bond gives a bias force \\(F^{max}_{ij}\\) acting\non the bond as\n\n\\[F^{max}_{ij} = - \\frac{dV^{max}_{ij}}{dE_{ij}} = 2 C_{ij} V^{max} \\frac{E_{ij}}{qfactor^2} \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\nwhich can be decomposed into an equal and opposite force acting on\nonly the two atoms i and j in the ij bond.\nThe key difference is that in GHD a bias energy and force is added (on\na particular timestep) to only one bond (pair of atoms) in the system,\nwhich is the bond with maximum strain \\(E^{max}\\).\nIn LHD, a bias energy and force can be added to multiple bonds\nseparated by the specified Dcut distance or more.  A bond ij is\nbiased if it is the maximum strain bond within its local\n“neighborhood”, which is defined as the bond ij plus any neighbor\nbonds within a distance Dcut from ij.  The “distance” between bond\nij and bond kl is the minimum distance between any of the ik, il,\njk, and jl pairs of atoms.\nFor a large system, multiple bonds will typically meet this\nrequirement, and thus a bias potential \\(V^{max}_{ij}\\) will be\napplied to many bonds on the same timestep.\nIn LHD, all bonds store a \\(C_{ij}\\) prefactor which appears in\nthe \\(V^{max}_{ij}\\) and \\(F^{max}_{ij}equations above.  Note\nthat the :math:\\) factor scales the strength of the bias energy\nand forces whenever bond ij is the maximum strain bond in its neighborhood.\n\\(C_{ij}\\) is initialized to 1.0 when a bond between the ij atoms\nis first defined.  The specified Btarget factor is then used to adjust the\n\\(C_{ij}\\) prefactors for each bond every timestep in the following manner.\nAn instantaneous boost factor \\(B_{ij}\\) is computed each timestep\nfor each bond, as\n\n\\[B_{ij} = e^{\\beta V^{max}_{kl}}\\]\nwhere \\(V^{max}_{kl}\\) is the bias energy of the maxstrain bond kl\nwithin bond ij’s neighborhood, \\(\\beta = \\frac{1}{kT_{equil}}\\),\nand \\(T_{equil}\\) is the temperature of the system and an argument\nto this fix.\n\nNote\nTo run an LHD simulation, the input script must also use the\nfix langevin command to thermostat the atoms at\nthe same Tequil as specified by this fix, so that the system is\nrunning constant-temperature (NVT) dynamics.  LAMMPS does not check\nthat this is done.\n\nNote that if ij== kl, then bond ij is a biased bond on that\ntimestep, otherwise it is not.  But regardless, the boost factor\n\\(B_{ij}\\) can be thought of an estimate of time boost currently\nbeing applied within a local region centered on bond ij.  For LHD,\nwe want this to be the specified Btarget value everywhere in the\nsimulation domain.\nTo accomplish this, if \\(B_{ij} < B_{target}\\), the \\(C_{ij}\\)\nprefactor for bond ij is incremented on the current timestep by an\namount proportional to the inverse of the specified \\(\\alpha\\) and\nthe difference (\\(B_{ij} - B_{target}\\)).  Conversely if\n\\(B_{ij} > B_{target}\\), \\(C_{ij}\\) is decremented by the same\namount.  This procedure is termed “boostostatting” in (Voter2013).  It drives all of the individual \\(C_{ij}\\) to\nvalues such that when \\(V^{max}_{ij}\\) is applied as a bias to bond\nij, the resulting boost factor \\(B_{ij}\\) will be close to\n\\(B_{target}\\) on average.  Thus the LHD time acceleration factor\nfor the overall system is effectively Btarget.\nNote that in LHD, the boost factor \\(B_{target}\\) is specified by the user.\nThis is in contrast to global hyperdynamics (GHD) where the boost\nfactor varies each timestep and is computed as a function of \\(V_{max}\\),\n\\(E_{max}\\), and \\(T_{equil}\\); see the\nfix hyper/global doc page for details.\n\nHere is additional information on the input parameters for LHD.\nNote that the cutbond, qfactor, and Tequil arguments have the\nsame meaning as for GHD.  The Vmax argument is slightly different.\nThe Dcut, alpha, and Btarget parameters are unique to LHD.\nThe cutbond argument is the cutoff distance for defining bonds\nbetween pairs of nearby atoms.  A pair of I,J atoms in their\nequilibrium, minimum-energy configuration, which are separated by a\ndistance \\(R_{ij} < cutbond\\), are flagged as a bonded pair.  Setting\ncubond to be ~25% larger than the nearest-neighbor distance in a\ncrystalline lattice is a typical choice for solids, so that bonds\nexist only between nearest neighbor pairs.\nThe qfactor argument is the limiting strain at which the bias\npotential goes to 0.0.  It is dimensionless, so a value of 0.3 means a\nbond distance can be up to 30% larger or 30% smaller than the\nequilibrium (quenched) \\(R^0_{ij}\\) distance and the two atoms in the bond\ncould still experience a non-zero bias force.\nIf qfactor is set too large, then transitions from one energy basin\nto another are affected because the bias potential is non-zero at the\ntransition state (e.g. saddle point).  If qfactor is set too small\nthan little boost can be achieved because the \\(E_{ij}\\) strain of\nsome bond in\nthe system will (nearly) always exceed qfactor.  A value of 0.3 for\nqfactor is typically a reasonable value.\nThe Vmax argument is a fixed prefactor on the bias potential.  There\nis a also a dynamic prefactor \\(C_{ij}\\), driven by the choice of\nBtarget as discussed above.  The product of these should be a value less than\nthe smallest barrier height for an event to occur.  Otherwise the\napplied bias potential may be large enough (when added to the\ninteratomic potential) to produce a local energy basin with a maxima\nin the center.  This can produce artificial energy minima in the same\nbasin that trap an atom.  Or if \\(C_{ij} \\cdot V^{max}\\) is even\nlarger, it may\ninduce an atom(s) to rapidly transition to another energy basin.  Both\ncases are “bad dynamics” which violate the assumptions of LHD that\nguarantee an accelerated time-accurate trajectory of the system.\n\nNote\nIt may seem that \\(V^{max}\\) can be set to any value, and\n\\(C_{ij}\\) will compensate to reduce the overall prefactor\nif necessary.  However the \\(C_{ij}\\) are initialized to 1.0\nand the boostostatting procedure typically operates slowly enough\nthat there can be a time period of bad dynamics if \\(V^{max}\\)\nis set too large.  A better strategy is to set \\(V^{max}\\) to the\nslightly smaller than the lowest barrier height for an event (the same\nas for GHD), so that the \\(C_{ij}\\) remain near unity.\n\nThe Tequil argument is the temperature at which the system is\nsimulated; see the comment above about the fix langevin thermostatting.  It is also part of the\nbeta term in the exponential factor that determines how much boost is\nachieved as a function of the bias potential.  See the discussion of\nthe Btarget argument below.\nAs discussed above, the Dcut argument is the distance required\nbetween two locally maxstrain bonds for them to both be selected as\nbiased bonds on the same timestep.  Computationally, the larger Dcut\nis, the more work (computation and communication) must be done each\ntimestep within the LHD algorithm.  And the fewer bonds can be\nsimultaneously biased, which may mean the specified Btarget time\nacceleration cannot be achieved.\nPhysically Dcut should be a long enough distance that biasing two\npairs of atoms that close together will not influence the dynamics of\neach pair.  E.g. something like 2x the cutoff of the interatomic\npotential.  In practice a Dcut value of ~10 Angstroms seems to work\nwell for many solid-state systems.\n\nNote\nYou should insure that ghost atom communication is performed for\na distance of at least Dcut + cutevent = the distance one or more\natoms move (between quenched states) to be considered an “event”.  It\nis an argument to the “compute event/displace” command used to detect\nevents.  By default the ghost communication distance is set by the\npair_style cutoff, which will typically be < Dcut.  The comm_modify cutoff command should be used to override the ghost\ncutoff explicitly, e.g.\n\ncomm_modify cutoff 12.0\n\n\nNote that this fix does not know the cutevent parameter, but uses\nhalf the cutbond parameter as an estimate to warn if the ghost\ncutoff is not long enough.\nAs described above the alpha argument is a pre-factor in the\nboostostat update equation for each bond’s \\(C_{ij}\\) prefactor.\nAlpha is specified in time units, similar to other thermostat or barostat\ndamping parameters.  It is roughly the physical time it will take the\nboostostat to adjust a \\(C_{ij}\\) value from a too high (or too low)\nvalue to a correct one.  An alpha setting of a few ps is typically good for\nsolid-state systems.  Note that the alpha argument here is the\ninverse of the alpha parameter discussed in\n(Voter2013).\nThe Btarget argument is the desired time boost factor (a value > 1)\nthat all the atoms in the system will experience.  The elapsed time\nt_hyper for an LHD simulation running for N timesteps is simply\n\n\\[t_{hyper} = B_{target} \\cdot N \\cdot dt\\]\nwhere dt is the timestep size defined by the timestep\ncommand.  The effective time acceleration due to LHD is thus\n\\(\\frac{t_{hyper}}{N\\cdot dt} = B_{target}\\), where \\(N\\cdot dt\\)\nis the elapsed time for a normal MD run of N timesteps.\nYou cannot choose an arbitrarily large setting for Btarget.  The\nmaximum value you should choose is\n\n\\[B_{target} = e^{\\beta V_{small}}\\]\nwhere \\(V_{small}\\) is the smallest event barrier height in your\nsystem, \\(\\beta = \\frac{1}{kT_{equil}}\\), and \\(T_{equil}\\)\nis the specified temperature of the system\n(both by this fix and the Langevin thermostat).\nNote that if Btarget is set smaller than this, the LHD simulation\nwill run correctly.  There will just be fewer events because the hyper\ntime (t_hyper equation above) will be shorter.\n\nNote\nIf you have no physical intuition as to the smallest barrier\nheight in your system, a reasonable strategy to determine the largest\nBtarget you can use for an LHD model, is to run a sequence of\nsimulations with smaller and smaller Btarget values, until the event\nrate does not change (as a function of hyper time).\n\n\nHere is additional information on the optional keywords for this fix.\nThe bound keyword turns on min/max bounds for bias coefficients\n\\(C_{ij}\\) for all bonds.  \\(C_{ij}\\) is a prefactor for each bond on\nthe bias potential of maximum strength \\(V^{max}\\).  Depending on the\nchoice of alpha and Btarget and Vmax, the boostostatting can cause\nindividual \\(C_{ij}\\) values to fluctuate.  If the fluctuations are too\nlarge \\(C_{ij} \\cdot V^{max}\\) can exceed low barrier heights and induce\nbad event dynamics.  Bounding the \\(C_{ij}\\) values is a way to prevent\nthis.  If Bfrac is set to -1 or any negative value (the default) then no\nbounds are enforced on \\(C_{ij}\\) values (except they must always\nbe >= 0.0).  A Bfrac setting >= 0.0\nsets a lower bound of 1.0 - Bfrac and upper bound of 1.0 + Bfrac on each\n\\(C_{ij}\\) value.  Note that all \\(C_{ij}\\) values are initialized\nto 1.0 when a bond is created for the first time.  Thus Bfrac limits the\nbias potential height to Vmax +/- Bfrac*Vmax.\nThe reset keyword allow Vmax to be adjusted dynamically depending on the\naverage value of all \\(C_{ij}\\) prefactors.  This can be useful if you\nare unsure what value of Vmax will match the Btarget boost for the\nsystem.  The \\(C_{ij}\\) values will then adjust in aggregate (up or down)\nso that \\(C_{ij} \\cdot V^{max}\\) produces a boost of Btarget, but this\nmay conflict with the bound keyword settings.  By using bound and reset\ntogether, \\(V^{max}\\) itself can be reset, and desired bounds still applied\nto the \\(C_{ij}\\) values.\nA setting for Rfreq of -1 (the default) means Vmax never changes.\nA setting of 0 means \\(V^{max}\\) is adjusted every time an event occurs and\nbond pairs are recalculated.  A setting of N > 0 timesteps means\n\\(V^{max}\\) is adjusted on the first time an event occurs on a timestep >=\nN steps after the previous adjustment.  The adjustment to \\(V^{max}\\) is\ncomputed as follows.  The current average of all \\(C_{ij} \\cdot V^{max}\\)\nvalues is computed and the \\(V^{max}\\) is reset to that value.  All\n\\(C_{ij}\\) values are changed to new prefactors such the new\n\\(C_{ij} \\cdot V^{max}\\) is the same as it was previously.  If the\nbound keyword was used, those bounds are enforced on the new \\(C_{ij}\\)\nvalues.  Henceforth, new bonds are assigned a \\(C_{ij} = 1.0\\), which\nmeans their bias potential magnitude is the new \\(V^{max}\\).\nThe check/ghost keyword turns on extra computation each timestep to\ncompute statistics about ghost atoms used to determine which bonds to\nbias.  The output of these stats are the vector values 14 and 15,\ndescribed below.  If this keyword is not enabled, the output\nof the stats will be zero.\nThe check/bias keyword turns on extra computation and communication\nto check if any biased bonds are closer than Dcut to each other,\nwhich should not be the case if LHD is operating correctly.  Thus it\nis a debugging check.  The Nevery setting determines how often the\ncheck is made.  The error, warn, or ignore setting determines\nwhat is done if the count of too-close bonds is not zero.  Either the\ncode will exit, or issue a warning, or silently tally the count.  The\ncount can be output as vector value 17, as described below.  If this\nkeyword is not enabled, the output of that statistic will be 0.\nNote that both of these computations are costly, hence they are only\nenabled by these keywords.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy of the bias potential to the system’s potential\nenergy as part of thermodynamic output.\nThis fix computes a global scalar and global vector of length 28,\nwhich can be accessed by various output commands.\nThe scalar is the magnitude of the bias potential (energy units)\napplied on the current timestep, summed over all biased bonds.  The\nvector stores the following quantities:\n\n1 = average boost for all bonds on this step (unitless)\n2 = # of biased bonds on this step\n3 = max strain \\(E_{ij}\\) of any bond on this step (absolute value, unitless)\n4 = value of \\(V^{max}\\) on this step (energy units)\n5 = average bias coeff for all bonds on this step (unitless)\n6 = min bias coeff for all bonds on this step (unitless)\n7 = max bias coeff for all bonds on this step (unitless)\n8 = average # of bonds/atom on this step\n9 = average neighbor bonds/bond on this step within Dcut\n10 = average boost for all bonds during this run (unitless)\n11 = average # of biased bonds/step during this run\n12 = fraction of biased bonds with no bias during this run\n13 = fraction of biased bonds with negative strain during this run\n14 = max bond length during this run (distance units)\n15 = average bias coeff for all bonds during this run (unitless)\n16 = min bias coeff for any bond during this run (unitless)\n17 = max bias coeff for any bond during this run (unitless)\n18 = max drift distance of any bond atom during this run (distance units)\n19 = max distance from proc subbox of any ghost atom with maxstrain < qfactor during this run (distance units)\n20 = max distance outside my box of any ghost atom with any maxstrain during this run (distance units)\n21 = count of ghost atoms that could not be found on reneighbor steps during this run\n22 = count of bias overlaps (< Dcut) found during this run\n23 = cumulative hyper time since fix created (time units)\n24 = cumulative count of event timesteps since fix created\n25 = cumulative count of atoms in events since fix created\n26 = cumulative # of new bonds formed since fix created\n\n27 = average boost for biased bonds on this step (unitless)\n28 = # of bonds with absolute strain >= q on this step\nThe first quantities 1-9 are for the current timestep.  Quantities\n10-22 are for the current hyper run.  They are reset each time a new\nhyper run is performed.  Quantities 23-26 are cumulative across\nmultiple runs (since the point in the input script the fix was\ndefined).\nFor value 10, each bond instantaneous boost factor is given by the\nequation for \\(B_{ij}\\) above.  The total system boost (average across all\nbonds) fluctuates, but should average to a value close to the\nspecified \\(B_{target}\\).\nFor value 12, the numerator is a count of all biased bonds on each\ntimestep whose bias energy = 0.0 due to \\(E_{ij} >= qfactor\\).  The\ndenominator is the count of all biased bonds on all timesteps.\nFor value 13, the numerator is a count of all biased bonds on each\ntimestep with negative strain.  The denominator is the count of all\nbiased bonds on all timesteps.\nValues 18-22 are mostly useful for debugging and diagnostic purposes.\nFor value 18, drift is the distance an atom moves between two quenched\nstates when the second quench determines an event has occurred.  Atoms\ninvolved in an event will typically move the greatest distance since\nothers typically remain near their original quenched position.\nFor values 19-21, neighbor atoms in the full neighbor list with cutoff\nDcut may be ghost atoms outside a processor’s sub-box.  Before the\nnext event occurs they may move further than Dcut away from the\nsub-box boundary.  Value 19 is the furthest (from the sub-box) any\nghost atom in the neighbor list with maxstrain < qfactor was\naccessed during the run.  Value 20 is the same except that the ghost\natom’s maxstrain may be >= qfactor, which may mean it is about to\nparticipate in an event.  Value 21 is a count of how many ghost atoms\ncould not be found on reneighbor steps, presumably because they moved\ntoo far away due to their participation in an event (which will likely\nbe detected at the next quench).\nTypical values for 19 and 20 should be slightly larger than Dcut,\nwhich accounts for ghost atoms initially at a Dcut distance moving\nthermally before the next event takes place.\nNote that for values 19 and 20 to be computed, the optional keyword\ncheck/ghost must be specified.  Otherwise these values will be zero.\nThis is because computing them incurs overhead, so the values are only\ncomputed if requested.\nValue 21 should be zero or small.  As explained above a small count\nlikely means some ghost atoms were participating in their own events\nand moved a longer distance.  If the value is large, it likely means\nthe communication cutoff for ghosts is too close to Dcut leading to\nmany not-found ghost atoms before the next event.  This may lead to a\nreduced number of bonds being selected for biasing, since the code\nassumes those atoms are part of highly strained bonds.  As explained\nabove, the comm_modify cutoff command can be used\nto set a longer cutoff.\nFor value 22, no two bonds should be biased if they are within a\nDcut distance of each other.  This value should be zero, indicating\nthat no pair of biased bonds are closer than Dcut from each other.\nNote that for value 22 to be computed, the optional keyword\ncheck/bias must be specified and it determines how often this check\nis performed.  This is because performing the check incurs overhead,\nso if only computed as often as requested.\nThe result at the end of the run is the cumulative total from every\ntimestep the check was made.  Note that the value is a count of atoms\nin bonds which found other atoms in bonds too close, so it is almost\nalways an over-count of the number of too-close bonds.\nValue 23 is simply the specified boost factor times the number of\ntimesteps times the timestep size.\nFor value 24, events are checked for by the hyper command\nonce every Nevent timesteps.  This value is the count of those\ntimesteps on which one (or more) events was detected.  It is NOT the\nnumber of distinct events, since more than one event may occur in the\nsame Nevent time window.\nFor value 25, each time the hyper command checks for an\nevent, it invokes a compute to flag zero or more atoms as\nparticipating in one or more events.  E.g. atoms that have displaced\nmore than some distance from the previous quench state.  Value 25 is\nthe cumulative count of the number of atoms participating in any of\nthe events that were found.\nValue 26 tallies the number of new bonds created by the bond reset\noperation.  Bonds between a specific I,J pair of atoms may persist for\nthe entire hyperdynamics simulation if neither I or J are involved in\nan event.\nValue 27 computes the average boost for biased bonds only on this step.\nValue 28 is the count of bonds with an absolute value of strain >= q\non this step.\nThe scalar and vector values calculated by this fix are all\n“intensive”.\nThis fix also computes a local vector of length the number of bonds\ncurrently in the system.  The value for each bond is its \\(C_{ij}\\)\nprefactor (bias coefficient).  These values can be can be accessed by various\noutput commands.  A particularly useful one is the\nfix ave/histo command which can be used to\nhistogram the Cij values to see if they are distributed reasonably\nclose to 1.0, which indicates a good choice of \\(V^{max}\\).\nThe local values calculated by this fix are unitless.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID hyper/local cutbond qfactor Vmax Tequil Dcut alpha Btarget",
    "parameters": " * ID, group-ID are documented in fix command\n * hyper/local = style name of this fix command\n * cutbond = max distance at which a pair of atoms is considered bonded (distance units)\n * qfactor = max strain at which bias potential goes to 0.0 (unitless)\n * Vmax = estimated height of bias potential (energy units)\n * Tequil = equilibration temperature (temperature units)\n * Dcut = minimum distance between boosted bonds (distance units)\n * alpha = boostostat relaxation time (time units)\n * Btarget = desired time boost factor (unitless)\n * zero or more keyword/value pairs may be appended\n * keyword = bound or reset or check/ghost or check/bias\n * bound value = Bfrac\n *   Bfrac =  -1 or a value >= 0.0\n * reset value = Rfreq\n *   Rfreq = -1 or 0 or timestep value > 0\n * check/ghost values = none\n * check/bias values = Nevery error/warn/ignore",
    "examples": "fix 1 all hyper/local 1.0 0.3 0.8 300.0\nfix 1 all hyper/local 1.0 0.3 0.8 300.0 bound 0.1 reset 0",
    "restrictions": "This fix is part of the REPLICA package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package\ndoc page for more info."
},
{
    "command": "fix imd",
    "html_filename": "fix_imd.html",
    "short_description": "This fix implements the “Interactive MD” (IMD) protocol which allows realtime visualization and manipulation of MD simulations through the IMD protocol, as initially implemented in VMD and NAMD",
    "description": "This fix implements the “Interactive MD” (IMD) protocol which allows\nrealtime visualization and manipulation of MD simulations through the\nIMD protocol, as initially implemented in VMD and NAMD.  Specifically\nit allows LAMMPS to connect an IMD client, for example the VMD visualization program, so that it can monitor the progress of the\nsimulation and interactively apply forces to selected atoms.\nIf LAMMPS is compiled with the pre-processor flag -DLAMMPS_ASYNC_IMD\nthen fix imd will use POSIX threads to spawn a IMD communication\nthread on MPI rank 0 in order to offload data reading and writing\nfrom the main execution thread and potentially lower the inferred\nlatencies for slow communication links. This feature has only been\ntested under linux.\nThere are example scripts for using this package with LAMMPS in\nexamples/USER/imd. Additional examples and a driver for use with the\nNovint Falcon game controller as haptic device can be found at:\nhttp://sites.google.com/site/akohlmey/software/vrpn-icms.\nThe source code for this fix includes code developed by the\nTheoretical and Computational Biophysics Group in the Beckman\nInstitute for Advanced Science and Technology at the University of\nIllinois at Urbana-Champaign.  We thank them for providing a software\ninterface that allows codes like LAMMPS to hook to VMD.\nUpon initialization of the fix, it will open a communication port on\nthe node with MPI task 0 and wait for an incoming connection.  As soon\nas an IMD client is connected, the simulation will continue and the\nfix will send the current coordinates of the fix’s group to the IMD\nclient at every trate MD step. When using r-RESPA, trate applies to\nthe steps of the outmost RESPA level.  During a run with an active IMD\nconnection also the IMD client can request to apply forces to selected\natoms of the fix group.\nThe port number selected must be an available network port number.  On\nmany machines, port numbers < 1024 are reserved for accounts with\nsystem manager privilege and specific applications. If multiple imd\nfixes would be active at the same time, each needs to use a different\nport number.\nThe nowait keyword controls the behavior of the fix when no IMD\nclient is connected. With the default setting of off, LAMMPS will\nwait until a connection is made before continuing with the\nexecution. Setting nowait to on will have the LAMMPS code be ready\nto connect to a client, but continue with the simulation. This can for\nexample be used to monitor the progress of an ongoing calculation\nwithout the need to be permanently connected or having to download a\ntrajectory file.\nThe trate keyword allows to select how often the coordinate data is\nsent to the IMD client. It can also be changed on request of the IMD\nclient through an IMD protocol message.  The unwrap keyword allows\nto send “unwrapped” coordinates to the IMD client that undo the\nwrapping back of coordinates into the principle unit cell, as done by\ndefault in LAMMPS.  The fscale keyword allows to apply a scaling\nfactor to forces transmitted by the IMD client. The IMD protocols\nstipulates that forces are transferred in kcal/mol/angstrom under the\nassumption that coordinates are given in angstrom. For LAMMPS runs\nwith different units or as a measure to tweak the forces generated by\nthe manipulation of the IMD client, this option allows to make\nadjustments.\nTo connect VMD to a listening LAMMPS simulation on the same machine\nwith fix imd enabled, one needs to start VMD and load a coordinate or\ntopology file that matches the fix group.  When the VMD command\nprompts appears, one types the command line:\nimd connect localhost 5678\n\n\nThis assumes that fix imd was started with 5678 as a port\nnumber for the IMD protocol.\nThe steps to do interactive manipulation of a running simulation in\nVMD are the following:\nIn the Mouse menu of the VMD Main window, select “Mouse -> Force ->\nAtom”.  You may alternately select “Residue”, or “Fragment” to apply\nforces to whole residues or fragments. Your mouse can now be used to\napply forces to your simulation. Click on an atom, residue, or\nfragment and drag to apply a force. Click quickly without moving the\nmouse to turn the force off. You can also use a variety of 3D position\ntrackers to apply forces to your simulation. Game controllers or haptic\ndevices with force-feedback such as the Novint Falcon or Sensable\nPHANTOM allow you to feel the resistance due to inertia or interactions\nwith neighbors that the atoms experience you are trying to move, as if\nthey were real objects. See the VMD IMD Homepage and the\nVRPN-ICMS Homepage for more details.\nIf IMD control messages are received, a line of text describing the\nmessage and its effect will be printed to the LAMMPS output screen, if\nscreen output is active.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global scalar or vector or per-atom\nquantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\nwith the start/stop keywords of the run command.  This\nfix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID imd trate port keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * imd = style name of this fix command\n * port = port number on which the fix listens for an IMD client\n * keyword = unwrap or fscale or trate\n * unwrap arg = on or off\n *   off = coordinates are wrapped back into the principal unit cell (default)\n *   on = \"unwrapped\" coordinates using the image flags used\n * fscale arg = factor\n *   factor = floating point number to scale IMD forces (default: 1.0)\n * trate arg = transmission rate of coordinate data sets (default: 1)\n * nowait arg = on or off\n *   off = LAMMPS waits to be connected to an IMD client before continuing (default)\n *   on = LAMMPS listens for an IMD client, but continues with the run",
    "examples": "fix vmd all imd 5678\nfix comm all imd 8888 trate 5 unwrap on fscale 10.0",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nWhen used in combination with VMD, a topology or coordinate file has\nto be loaded, which matches (in number and ordering of atoms) the\ngroup the fix is applied to. The fix internally sorts atom IDs by\nascending integer value; in VMD (and thus the IMD protocol) those will\nbe assigned 0-based consecutive index numbers.\nWhen using multiple active IMD connections at the same time, each\nneeds to use a different port number.\nRelated commands: none\nDefault: none"
},
{
    "command": "fix indent",
    "html_filename": "fix_indent.html",
    "short_description": "Insert an indenter within a simulation box",
    "description": "Insert an indenter within a simulation box.  The indenter repels all\natoms in the group that touch it, so it can be used to push into a\nmaterial or as an obstacle in a flow.  Or it can be used as a\nconstraining wall around a simulation; see the discussion of the\nside keyword below.\nThe indenter can either be spherical or cylindrical or planar.  You\nmust set one of those 3 keywords.\nA spherical indenter exerts a force of magnitude\nF(r) = - K (r - R)^2\non each atom where K is the specified force constant, r is the\ndistance from the atom to the center of the indenter, and R is the\nradius of the indenter.  The force is repulsive and F(r) = 0 for r >\nR.\nA cylindrical indenter exerts the same force, except that r is the\ndistance from the atom to the center axis of the cylinder.  The\ncylinder extends infinitely along its axis.\nSpherical and cylindrical indenters account for periodic boundaries in\ntwo ways.  First, the center point of a spherical indenter (x,y,z) or\naxis of a cylindrical indenter (c1,c2) is remapped back into the\nsimulation box, if the box is periodic in a particular dimension.\nThis occurs every timestep if the indenter geometry is specified with\na variable (see below), e.g. it is moving over time.  Second, the\ncalculation of distance to the indenter center or axis accounts for\nperiodic boundaries.  Both of these mean that an indenter can\neffectively move through and straddle one or more periodic boundaries.\nA planar indenter is really an axis-aligned infinite-extent wall\nexerting the same force on atoms in the system, where R is the\nposition of the plane and r-R is the distance from the plane.  If\nthe side parameter of the plane is specified as lo then it will\nindent from the lo end of the simulation box, meaning that atoms with\na coordinate less than the plane’s current position will be pushed\ntowards the hi end of the box and atoms with a coordinate higher than\nthe plane’s current position will feel no force.  Vice versa if side\nis specified as hi.\nAny of the 4 quantities defining a spherical indenter’s geometry can\nbe specified as an equal-style variable, namely x,\ny, z, or R.  Similarly, for a cylindrical indenter, any of c1,\nc2, or R, can be a variable.  For a planar indenter, pos can be\na variable.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value used to define the\nindenter geometry.\nNote that equal-style variables can specify formulas with various\nmathematical functions, and include thermo_style\ncommand keywords for the simulation box parameters and timestep and\nelapsed time.  Thus it is easy to specify indenter properties that\nchange as a function of time or span consecutive runs in a continuous\nfashion.  For the latter, see the start and stop keywords of the\nrun command and the elaplong keyword of thermo_style custom for details.\nFor example, if a spherical indenter’s x-position is specified as v_x,\nthen this variable definition will keep it’s center at a relative\nposition in the simulation box, 1/4 of the way from the left edge to\nthe right edge, even if the box size changes:\nvariable x equal \"xlo + 0.25*lx\"\nSimilarly, either of these variable definitions will move the indenter\nfrom an initial position at 2.5 at a constant velocity of 5:\nvariable x equal \"2.5 + 5*elaplong*dt\"\nvariable x equal vdisplace(2.5,5)\nIf a spherical indenter’s radius is specified as v_r, then these\nvariable definitions will grow the size of the indenter at a specified\nrate.\nvariable r0 equal 0.0\nvariable rate equal 1.0\nvariable r equal \"v_r0 + step*dt*v_rate\"\nIf the side keyword is specified as out, which is the default,\nthen particles outside the indenter are pushed away from its outer\nsurface, as described above.  This only applies to spherical or\ncylindrical indenters.  If the side keyword is specified as in,\nthe action of the indenter is reversed.  Particles inside the indenter\nare pushed away from its inner surface.  In other words, the indenter\nis now a containing wall that traps the particles inside it.  If the\nradius shrinks over time, it will squeeze the particles.\nThe units keyword determines the meaning of the distance units used\nto define the indenter geometry.  A box value selects standard\ndistance units as defined by the units command,\ne.g. Angstroms for units = real or metal.  A lattice value means the\ndistance units are in lattice spacings.  The lattice\ncommand must have been previously used to define the lattice spacing.\nThe (x,y,z) coords of the indenter position are scaled by the x,y,z\nlattice spacings respectively.  The radius of a spherical or\ncylindrical indenter is scaled by the x lattice spacing.\nNote that the units keyword only affects indenter geometry parameters\nspecified directly with numbers, not those specified as variables.  In\nthe latter case, you should use the xlat, ylat, zlat keywords of\nthe thermo_style command if you want to include\nlattice spacings in a variable formula.\nThe force constant K is not affected by the units keyword.  It is\nalways in force/distance^2 units where force and distance are defined\nby the units command.  If you wish K to be scaled by the\nlattice spacing, you can define K with a variable whose formula\ncontains xlat, ylat, zlat keywords of the\nthermo_style command, e.g.\nvariable k equal 100.0/xlat/xlat\nfix 1 all indent $k sphere ...\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy of interaction between atoms and the indenter to\nthe system’s potential energy as part of thermodynamic output.  The energy of each particle interacting\nwith the indenter is K/3 (r - R)^3.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar energy and a global 3-vector of\nforces (on the indenter), which can be accessed by various output commands.  The scalar and vector values calculated\nby this fix are “extensive”.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  Note that if you\ndefine the indenter geometry with a variable using a time-dependent\nformula, LAMMPS uses the iteration count in the minimizer as the\ntimestep.  But it is almost certainly a bad idea to have the indenter\nchange its position or size during a minimization.  LAMMPS does not\ncheck if you have done this.\n\nNote\nIf you want the atom/indenter interaction energy to be included\nin the total potential energy of the system (the quantity being\nminimized), you must enable the fix_modify energy\noption for this fix.",
    "syntax": "fix ID group-ID indent K keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * indent = style name of this fix command\n * K = force constant for indenter surface (force/distance^2 units)\n * one or more keyword/value pairs may be appended\n * keyword = sphere or cylinder or plane or side or units\n * sphere args = x y z R\n *   x,y,z = initial position of center of indenter (distance units)\n *   R = sphere radius of indenter (distance units)\n *   any of x,y,z,R can be a variable (see below)\n * cylinder args = dim c1 c2 R\n *   dim = x or y or z = axis of cylinder\n *   c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n *   R = cylinder radius of indenter (distance units)\n *   any of c1,c2,R can be a variable (see below)\n * plane args = dim pos side\n *   dim = x or y or z = plane perpendicular to this dimension\n *   pos = position of plane in dimension x, y, or z (distance units)\n *   pos can be a variable (see below)\n *   side = lo or hi\n * side value = in or out\n *   in = the indenter acts on particles inside the sphere or cylinder\n *   out = the indenter acts on particles outside the sphere or cylinder\n * units value = lattice or box\n *   lattice = the geometry is defined in lattice units\n *   box = the geometry is defined in simulation box units",
    "examples": "fix 1 all indent 10.0 sphere 0.0 0.0 15.0 3.0\nfix 1 all indent 10.0 sphere v_x v_y 0.0 v_radius side in\nfix 2 flow indent 10.0 cylinder z 0.0 0.0 10.0 units box",
    "restrictions": "\nnone\n\nRelated commands: none"
},
{
    "command": "fix ipi",
    "html_filename": "fix_ipi.html",
    "short_description": "This fix enables LAMMPS to be run as a client for the i-PI Python wrapper (IPI) for performing a path integral molecular dynamics (PIMD) simulation",
    "description": "This fix enables LAMMPS to be run as a client for the i-PI Python\nwrapper (IPI) for performing a path integral molecular dynamics\n(PIMD) simulation.  The philosophy behind i-PI is described in the\nfollowing publication (IPI-CPC).\nA version of the i-PI package, containing only files needed for use\nwith LAMMPS, is provided in the tools/i-pi directory.  See the\ntools/i-pi/manual.pdf for an introduction to i-PI.  The\nexamples/USER/i-pi directory contains example scripts for using i-PI\nwith LAMMPS.\nIn brief, the path integral molecular dynamics is performed by the\nPython wrapper, while the client (LAMMPS in this case) simply computes\nforces and energy for each configuration. The communication between\nthe two components takes place using sockets, and is reduced to the\nbare minimum. All the parameters of the dynamics are specified in the\ninput of i-PI, and all the parameters of the force field must be\nspecified as LAMMPS inputs, preceding the fix ipi command.\nThe server address must be specified by the address argument, and\ncan be either the IP address, the fully-qualified name of the server,\nor the name of a UNIX socket for local, faster communication. In the\ncase of internet sockets, the port argument specifies the port\nnumber on which i-PI is listening, while the unix optional switch\nspecifies that the socket is a UNIX socket.\nNote that there is no check of data integrity, or that the atomic\nconfigurations make sense. It is assumed that the species in the i-PI\ninput are listed in the same order as in the data file of LAMMPS. The\ninitial configuration is ignored, as it will be substituted with the\ncoordinates received from i-PI before forces are ever evaluated.\nA note of caution when using potentials that contain long-range\nelectrostatics, or that contain parameters that depend on box size:\nall of these options will be initialized based on the cell size in the\nLAMMPS-side initial configuration and kept constant during the run.\nThis is required to e.g. obtain reproducible and conserved forces.\nIf the cell varies too wildly, it may be advisable to re-initialize\nthese interactions at each call. This behavior can be requested by\nsetting the reset switch.\nRestart, fix_modify, output, run start/stop, minimize info:\nThere is no restart information associated with this fix, since all\nthe dynamical parameters are dealt with by i-PI.",
    "syntax": "fix ID group-ID ipi address port [unix] [reset]",
    "parameters": " * ID, group-ID are documented in fix command\n * ipi = style name of this fix command\n * address = internet address (FQDN or IP), or UNIX socket name\n * port = port number (ignored for UNIX sockets)\n * optional keyword = unix, if present uses a unix socket\n * optional keyword = reset, if present reset electrostatics at each call",
    "examples": "fix 1 all ipi my.server.com 12345\nfix 1 all ipi mysocket 666 unix reset",
    "restrictions": "Using this fix on anything other than all atoms requires particular\ncare, since i-PI will know nothing on atoms that are not those whose\ncoordinates are transferred. However, one could use this strategy to\ndefine an external potential acting on the atoms that are moved by\ni-PI.\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.  Because of the\nuse of UNIX domain sockets, this fix will only work in a UNIX\nenvironment."
},
{
    "command": "fix langevin",
    "html_filename": "fix_langevin.html",
    "short_description": "Apply a Langevin thermostat as described in (Schneider) to a group of atoms which models an interaction with a background implicit solvent",
    "description": "Apply a Langevin thermostat as described in (Schneider)\nto a group of atoms which models an interaction with a background\nimplicit solvent.  Used with fix nve, this command\nperforms Brownian dynamics (BD), since the total force on each atom\nwill have the form:\n\n\\[\\begin{split}F = & F_c + F_f + F_r \\\\\nF_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\nF_r \\propto & \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n\\(F_c\\) is the conservative force computed via the usual\ninter-particle interactions (pair_style,\nbond_style, etc).  The \\(F_f\\) and \\(F_r\\)\nterms are added by this fix on a per-particle basis.  See the\npair_style dpd/tstat command for a thermostatting\noption that adds similar terms on a pairwise basis to pairs of\ninteracting particles.\n\\(F_f\\) is a frictional drag or viscous damping term proportional to\nthe particle’s velocity.  The proportionality constant for each atom is\ncomputed as \\(\\frac{m}{\\mathrm{damp}}\\), where m is the mass of the\nparticle and damp is the damping factor specified by the user.\n\\(F_r\\) is a force due to solvent atoms at a temperature T\nrandomly bumping into the particle.  As derived from the\nfluctuation/dissipation theorem, its magnitude as shown above is\nproportional to \\(\\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\), where\n\\(k_B\\) is the Boltzmann constant, T is the desired temperature,\nm is the mass of the particle, dt is the timestep size, and damp is\nthe damping factor.  Random numbers are used to randomize the direction\nand magnitude of this force as described in (Dunweg),\nwhere a uniform random number is used (instead of a Gaussian random\nnumber) for speed.\nNote that unless you use the omega or angmom keywords, the\nthermostat effect of this fix is applied to only the translational\ndegrees of freedom for the particles, which is an important\nconsideration for finite-size particles, which have rotational degrees\nof freedom, are being thermostatted.  The translational degrees of\nfreedom can also have a bias velocity removed from them before\nthermostatting takes place; see the description below.\n\nNote\nUnlike the fix nvt command which performs Nose/Hoover\nthermostatting AND time integration, this fix does NOT perform time\nintegration.  It only modifies forces to effect thermostatting.  Thus\nyou must use a separate time integration fix, like fix nve to actually update the velocities and positions of atoms\nusing the modified forces.  Likewise, this fix should not normally be\nused on atoms that also have their temperature controlled by another\nfix - e.g. by fix nvt or fix temp/rescale commands.\n\nSee the Howto thermostat doc page for\na discussion of different ways to compute temperature and perform\nthermostatting.\nThe desired temperature at each timestep is a ramped value during the\nrun from Tstart to Tstop.\nTstart can be specified as an equal-style or atom-style\nvariable.  In this case, the Tstop setting is\nignored.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value used to determine the\ntarget temperature.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent temperature.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent\ntemperature with optional time-dependence as well.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that remove a “bias” from the\natom velocities.  E.g. removing the center-of-mass velocity from a\ngroup of atoms or removing the x-component of velocity from the\ncalculation.  This is not done by default, but only if the\nfix_modify command is used to assign a temperature\ncompute to this fix that includes such a bias term.  See the doc pages\nfor individual compute commands to determine which ones\ninclude a bias.  In this case, the thermostat works in the following\nmanner: bias is removed from each atom, thermostatting is performed on\nthe remaining thermal degrees of freedom, and the bias is added back\nin.\nThe damp parameter is specified in time units and determines how\nrapidly the temperature is relaxed.  For example, a value of 100.0 means\nto relax the temperature in a timespan of (roughly) 100 time units\n(\\(\\tau\\) or fs or ps - see the units command).  The\ndamp factor can be thought of as inversely related to the viscosity of\nthe solvent.  I.e. a small relaxation time implies a high-viscosity\nsolvent and vice versa.  See the discussion about \\(\\gamma\\) and\nviscosity in the documentation for the fix viscous\ncommand for more details.\nThe random # seed must be a positive integer.  A Marsaglia random\nnumber generator is used.  Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random numbers.\nThus the dynamics of the system will not be identical on two runs on\ndifferent numbers of processors.\n\nThe keyword/value option pairs are used in the following ways.\nThe keyword angmom and omega keywords enable thermostatting of\nrotational degrees of freedom in addition to the usual translational\ndegrees of freedom.  This can only be done for finite-size particles.\nA simulation using atom_style sphere defines an omega for finite-size\nspheres.  A simulation using atom_style ellipsoid defines a finite\nsize and shape for aspherical particles and an angular momentum.\nThe Langevin formulas for thermostatting the rotational degrees of\nfreedom are the same as those above, where force is replaced by\ntorque, m is replaced by the moment of inertia I, and v is replaced by\nomega (which is derived from the angular momentum in the case of\naspherical particles).\nThe rotational temperature of the particles can be monitored by the\ncompute temp/sphere and compute temp/asphere commands with their rotate\noptions.\nFor the omega keyword there is also a scale factor of\n\\(\\frac{10.0}{3.0}\\) that is applied as a multiplier on the\n\\(F_f\\) (damping) term in the equation above and of\n\\(\\sqrt{\\frac{10.0}{3.0}}\\) as a multiplier on the \\(F_r\\) term.\nThis does not affect the thermostatting behavior of the Langevin\nformalism but insures that the randomized rotational diffusivity of\nspherical particles is correct.\nFor the angmom keyword a similar scale factor is needed which is\n\\(\\frac{10.0}{3.0}\\) for spherical particles, but is anisotropic for\naspherical particles (e.g. ellipsoids).  Currently LAMMPS only applies\nan isotropic scale factor, and you can choose its magnitude as the\nspecified value of the angmom keyword.  If your aspherical particles\nare (nearly) spherical than a value of \\(\\frac{10.0}{3.0} =\n3.\\overline{3}\\) is a good choice.  If they are highly aspherical, a\nvalue of 1.0 is as good a choice as any, since the effects on rotational\ndiffusivity of the particles will be incorrect regardless.  Note that\nfor any reasonable scale factor, the thermostatting effect of the\nangmom keyword on the rotational temperature of the aspherical\nparticles should still be valid.\nThe keyword scale allows the damp factor to be scaled up or down by\nthe specified factor for atoms of that type.  This can be useful when\ndifferent atom types have different sizes or masses.  It can be used\nmultiple times to adjust damp for several atom types.  Note that\nspecifying a ratio of 2 increases the relaxation time which is\nequivalent to the solvent’s viscosity acting on particles with\n\\(\\frac{1}{2}\\) the diameter.  This is the opposite effect of scale\nfactors used by the fix viscous command, since the\ndamp factor in fix langevin is inversely related to the \\(\\gamma\\)\nfactor in fix viscous.  Also note that the damping factor in fix\nlangevin includes the particle mass in Ff, unlike fix viscous.\nThus the mass and size of different atom types should be accounted for\nin the choice of ratio values.\nThe keyword tally enables the calculation of the cumulative energy\nadded/subtracted to the atoms as they are thermostatted.  Effectively\nit is the energy exchanged between the infinite thermal reservoir and\nthe particles.  As described below, this energy can then be printed\nout or added to the potential energy of the system to monitor energy\nconservation.\n\nNote\nthis accumulated energy does NOT include kinetic energy removed\nby the zero flag. LAMMPS will print a warning when both options are\nactive.\n\nThe keyword zero can be used to eliminate drift due to the\nthermostat. Because the random forces on different atoms are\nindependent, they do not sum exactly to zero.  As a result, this fix\napplies a small random force to the entire system, and the\ncenter-of-mass of the system undergoes a slow random walk.  If the\nkeyword zero is set to yes, the total random force is set exactly\nto zero by subtracting off an equal part of it from each atom in the\ngroup.  As a result, the center-of-mass of a system with zero initial\nmomentum will not drift over time.\nThe keyword gjf can be used to run the Gronbech-Jensen/Farago time-discretization of the Langevin model.  As\ndescribed in the papers cited below, the purpose of this method is to\nenable longer timesteps to be used (up to the numerical stability\nlimit of the integrator), while still producing the correct Boltzmann\ndistribution of atom positions.\nThe current implementation provides the user with the option to output\nthe velocity in one of two forms: vfull or vhalf, which replaces\nthe outdated option yes. The gjf option vfull outputs the on-site\nvelocity given in Gronbech-Jensen/Farago; this velocity\nis shown to be systematically lower than the target temperature by a small\namount, which grows quadratically with the timestep.\nThe gjf option vhalf outputs the 2GJ half-step velocity given in\nGronbech Jensen/Gronbech-Jensen; for linear systems,\nthis velocity is shown to not have any statistical errors for any stable time step.\nAn overview of statistically correct Boltzmann and Maxwell-Boltzmann\nsampling of true on-site and true half-step velocities is given in\nGronbech-Jensen.\nRegardless of the choice of output velocity, the sampling of the configurational\ndistribution of atom positions is the same, and linearly consistent with the\ntarget temperature.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator\nis not saved in restart files, this means you cannot do “exact”\nrestarts with this fix, where the simulation continues on the same as\nif no restart had taken place.  However, in a statistical sense, a\nrestarted simulation should produce the same behavior.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthis fix and by the compute should be the same.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Langevin thermostatting to the\nsystem’s potential energy as part of thermodynamic output.  Note that use of this option requires\nsetting the tally keyword to yes.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.  Note that calculation of this quantity requires\nsetting the tally keyword to yes.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID langevin Tstart Tstop damp seed keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * langevin = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * Tstart can be a variable (see below)\n * damp = damping parameter (time units)\n * seed = random number seed to use for white noise (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = angmom or omega or scale or tally or zero\n * angmom value = no or factor\n *   no = do not thermostat rotational degrees of freedom via the angular momentum\n *   factor = do thermostat rotational degrees of freedom via the angular momentum and apply numeric scale factor as discussed below\n * gjf value = no or vfull or vhalf\n *   no = use standard formulation\n *   vfull = use Gronbech-Jensen/Farago formulation\n *   vhalf = use 2GJ formulation\n * omega value = no or yes\n *   no = do not thermostat rotational degrees of freedom via the angular velocity\n *   yes = do thermostat rotational degrees of freedom via the angular velocity\n * scale values = type ratio\n *   type = atom type (1-N)\n *   ratio = factor by which to scale the damping coefficient\n * tally value = no or yes\n *   no = do not tally the energy added/subtracted to atoms\n *   yes = do tally the energy added/subtracted to atoms\n * zero value = no or yes\n *   no = do not set total random force to zero\n *   yes = set total random force to zero",
    "examples": "fix 3 boundary langevin 1.0 1.0 1000.0 699483\nfix 1 all langevin 1.0 1.1 100.0 48279 scale 3 1.5\nfix 1 all langevin 1.0 1.1 100.0 48279 angmom 3.333",
    "restrictions": "For gjf do not choose damp=dt/2. gjf is not compatible\nwith run_style respa."
},
{
    "command": "fix langevin/drude",
    "html_filename": "fix_langevin_drude.html",
    "short_description": "Apply two Langevin thermostats as described in (Jiang) for thermalizing the reduced degrees of freedom of Drude oscillators",
    "description": "Apply two Langevin thermostats as described in (Jiang) for\nthermalizing the reduced degrees of freedom of Drude oscillators.\nThis link describes how to use the thermalized Drude oscillator model in LAMMPS and polarizable models in LAMMPS\nare discussed on the Howto polarizable doc\npage.\nDrude oscillators are a way to simulate polarizables atoms, by\nsplitting them into a core and a Drude particle bound by a harmonic\nbond.  The thermalization works by transforming the particles degrees\nof freedom by these equations.  In these equations upper case denotes\natomic or center of mass values and lower case denotes Drude particle\nor dipole values. Primes denote the transformed (reduced) values,\nwhile bare letters denote the original values.\nVelocities:\n\n\\[V' = \\frac {M\\, V + m\\, v} {M'}\\]\n\n\\[v' = v - V\\]\nMasses:\n\n\\[M' = M + m\\]\n\n\\[m' = \\frac {M\\, m } {M'}\\]\nThe Langevin forces are computed as\n\n\\[F' = - \\frac {M'} {\\mathtt{damp\\_com}}\\, V' + F_r'\\]\n\n\\[f' = - \\frac {m'} {\\mathtt{damp\\_drude}}\\, v' + f_r'\\]\n\\(F_r'\\) is a random force proportional to\n\\(\\sqrt { \\frac {2\\, k_B \\mathtt{Tcom}\\, m'}                  {\\mathrm dt\\, \\mathtt{damp\\_com} }         }\\).\n\\(f_r'\\) is a random force proportional to\n\\(\\sqrt { \\frac {2\\, k_B \\mathtt{Tdrude}\\, m'}                  {\\mathrm dt\\, \\mathtt{damp\\_drude} }         }\\).\nThen the real forces acting on the particles are computed from the inverse\ntransform:\n\n\\[F = \\frac M {M'}\\, F' - f'\\]\n\n\\[f = \\frac m {M'}\\, F' + f'\\]\nThis fix also thermostats non-polarizable atoms in the group at\ntemperature Tcom, as if they had a massless Drude partner.  The\nDrude particles themselves need not be in the group. The center of\nmass and the dipole are thermostatted iff the core atom is in the\ngroup.\nNote that the thermostat effect of this fix is applied to only the\ntranslational degrees of freedom of the particles, which is an\nimportant consideration if finite-size particles, which have\nrotational degrees of freedom, are being thermostatted. The\ntranslational degrees of freedom can also have a bias velocity removed\nfrom them before thermostatting takes place; see the description below.\n\nNote\nLike the fix langevin command, this fix does\nNOT perform time integration. It only modifies forces to effect\nthermostatting. Thus you must use a separate time integration fix, like\nfix nve or fix nph to actually update the\nvelocities and positions of atoms using the modified forces.\nLikewise, this fix should not normally be used on atoms that also have\ntheir temperature controlled by another fix - e.g. by fix nvt or fix temp/rescale commands.\n\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nThis fix requires each atom know whether it is a Drude particle or\nnot.  You must therefore use the fix drude command to\nspecify the Drude status of each atom type.\n\nNote\nonly the Drude core atoms need to be in the group specified for\nthis fix. A Drude electron will be transformed together with its cores\neven if it is not itself in the group.  It is safe to include Drude\nelectrons or non-polarizable atoms in the group. The non-polarizable\natoms will simply be thermostatted as if they had a massless Drude\npartner (electron).\n\n\nNote\nGhost atoms need to know their velocity for this fix to act\ncorrectly.  You must use the comm_modify command to\nenable this, e.g.\n\ncomm_modify vel yes\n\n\n\nTcom is the target temperature of the centers of mass, which would\nbe used to thermostat the non-polarizable atoms.  Tdrude is the\n(normally low) target temperature of the core-Drude particle pairs\n(dipoles).  Tcom and Tdrude can be specified as an equal-style\nvariable.  If the value is a variable, it should be\nspecified as v_name, where name is the variable name. In this case,\nthe variable will be evaluated each timestep, and its value used to\ndetermine the target temperature.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent temperature.\nLike other fixes that perform thermostatting, this fix can be used with\ncompute commands that remove a “bias” from the atom\nvelocities.  E.g. removing the center-of-mass velocity from a group of\natoms.  This is not done by default, but only if the\nfix_modify command is used to assign a temperature\ncompute to this fix that includes such a bias term.  See the doc pages\nfor individual compute commands to determine which ones\ninclude a bias.  In this case, the thermostat works in the following\nmanner: bias is removed from each atom, thermostatting is performed on\nthe remaining thermal degrees of freedom, and the bias is added back\nin.  NOTE: this feature has not been tested.\nNote: The temperature thermostatting the core-Drude particle pairs\nshould be chosen low enough, so as to mimic as closely as possible the\nself-consistent minimization. It must however be high enough, so that\nthe dipoles can follow the local electric field exerted by the\nneighboring atoms. The optimal value probably depends on the\ntemperature of the centers of mass and on the mass of the Drude\nparticles.\ndamp_com is the characteristic time for reaching thermal equilibrium\nof the centers of mass.  For example, a value of 100.0 means to relax\nthe temperature of the centers of mass in a timespan of (roughly) 100\ntime units (tau or fmsec or psec - see the units\ncommand).  damp_drude is the characteristic time for reaching\nthermal equilibrium of the dipoles. It is typically a few timesteps.\nThe number seed_com and seed_drude are positive integers. They set\nthe seeds of the Marsaglia random number generators used for\ngenerating the random forces on centers of mass and on the\ndipoles. Each processor uses the input seed to generate its own unique\nseed and its own stream of random numbers.  Thus the dynamics of the\nsystem will not be identical on two runs on different numbers of\nprocessors.\nThe keyword zero can be used to eliminate drift due to the\nthermostat on centers of mass. Because the random forces on different\ncenters of mass are independent, they do not sum exactly to zero.  As\na result, this fix applies a small random force to the entire system,\nand the momentum of the total center of mass of the system undergoes a\nslow random walk.  If the keyword zero is set to yes, the total\nrandom force on the centers of mass is set exactly to zero by\nsubtracting off an equal part of it from each center of mass in the\ngroup. As a result, the total center of mass of a system with zero\ninitial momentum will not drift over time.\nThe actual temperatures of cores and Drude particles, in\ncenter-of-mass and relative coordinates, respectively, can be\ncalculated using the compute temp/drude\ncommand.\n\nUsage example for rigid bodies in the NPT ensemble:\ncomm_modify vel yes\nfix TEMP all langevin/drude 300. 100. 1256 1. 20. 13977 zero yes\nfix NPH ATOMS rigid/nph/small molecule iso 1. 1. 500.\nfix NVE DRUDES nve\ncompute TDRUDE all temp/drude\nthermo_style custom step cpu etotal ke pe ebond ecoul elong press vol temp c_TDRUDE[1] c_TDRUDE[2]\n\n\nComments:\n\nDrude particles should not be in the rigid group, otherwise the Drude\noscillators will be frozen and the system will lose its\npolarizability.\nzero yes avoids a drift of the center of mass of\nthe system, but is a bit slower.\nUse two different random seeds to avoid unphysical correlations.\nTemperature is controlled by the fix langevin/drude, so the\ntime-integration fixes do not thermostat.  Don’t forget to\ntime-integrate both cores and Drude particles.\nPressure is time-integrated only once by using nve for Drude\nparticles and nph for atoms/cores (or vice versa). Do not use nph\nfor both.\nThe temperatures of cores and Drude particles are calculated by\ncompute temp/drude\nContrary to the alternative thermostatting using Nose-Hoover thermostat\nfix npt and fix drude/transform, the\nfix_modify command is not required here, because the fix nph\ncomputes the global pressure even if its group is ATOMS. This is\nwhat we want. If we thermostatted ATOMS using npt, the pressure\nshould be the global one, but the temperature should be only that of\nthe cores. That’s why the command fix_modify should be called in\nthat case.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator\nis not saved in restart files, this means you cannot do “exact”\nrestarts with this fix, where the simulation continues on the same as\nif no restart had taken place.  However, in a statistical sense, a\nrestarted simulation should produce the same behavior.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above. For consistency, the group used by the\ncompute should include the group of this fix and the Drude particles.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID langevin/drude Tcom damp_com seed_com Tdrude damp_drude seed_drude keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * langevin/drude = style name of this fix command\n * Tcom = desired temperature of the centers of mass (temperature units)\n * damp_com = damping parameter for the thermostat on centers of mass (time units)\n * seed_com = random number seed to use for white noise of the thermostat on centers of mass (positive integer)\n * Tdrude = desired temperature of the Drude oscillators (temperature units)\n * damp_drude = damping parameter for the thermostat on Drude oscillators (time units)\n * seed_drude = random number seed to use for white noise of the thermostat on Drude oscillators (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = zero\n * zero value = no or yes\n *   no = do not set total random force on centers of mass to zero\n *   yes = set total random force on centers of mass to zero",
    "examples": "fix 3 all langevin/drude 300.0 100.0 19377 1.0 20.0 83451\nfix 1 all langevin/drude 298.15 100.0 19377 5.0 10.0 83451 zero yes",
    "restrictions": "\nnone"
},
{
    "command": "fix langevin/eff",
    "html_filename": "fix_langevin_eff.html",
    "short_description": "Apply a Langevin thermostat as described in (Schneider) to a group of nuclei and electrons in the electron force field model",
    "description": "Apply a Langevin thermostat as described in (Schneider)\nto a group of nuclei and electrons in the electron force field model.  Used with fix nve/eff,\nthis command performs Brownian dynamics (BD), since the total force on\neach atom will have the form:\n\n\\[\\begin{split}F   = & F_c + F_f + F_r \\\\\nF_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\nF_r \\propto &  \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n\\(F_c\\) is the conservative force computed via the usual\ninter-particle interactions (pair_style).\nThe \\(F_f\\) and \\(F_r\\) terms are added by this fix on a\nper-particle basis.\nThe operation of this fix is exactly like that described by the\nfix langevin command, except that the\nthermostatting is also applied to the radial electron velocity for\nelectron particles.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator is not\nsaved in restart files, this means you cannot do “exact” restarts with\nthis fix, where the simulation continues on the same as if no restart\nhad taken place.  However, in a statistical sense, a restarted\nsimulation should produce the same behavior.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthis fix and by the compute should be the same.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Langevin thermostatting to the\nsystem’s potential energy as part of thermodynamic output.  Note that use of this option requires\nsetting the tally keyword to yes.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.  Note that calculation of this quantity requires\nsetting the tally keyword to yes.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID langevin/eff Tstart Tstop damp seed keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * langevin/eff = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * damp = damping parameter (time units)\n * seed = random number seed to use for white noise (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = scale or tally or zero\n *   scale values = type ratio\n *     type = atom type (1-N)\n *     ratio = factor by which to scale the damping coefficient\n *   tally values = no or yes\n *     no = do not tally the energy added/subtracted to atoms\n *     yes = do tally the energy added/subtracted to atoms\n * zero value = no or yes\n *   no = do not set total random force to zero\n *   yes = set total random force to zero",
    "examples": "fix 3 boundary langevin/eff 1.0 1.0 10.0 699483\nfix 1 all langevin/eff 1.0 1.1 10.0 48279 scale 3 1.5",
    "restrictions": "\nnone\n\nThis fix is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix langevin/spin",
    "html_filename": "fix_langevin_spin.html",
    "short_description": "Apply a Langevin thermostat as described in (Mayergoyz) to the magnetic spins associated to the atoms",
    "description": "Apply a Langevin thermostat as described in (Mayergoyz) to the\nmagnetic spins associated to the atoms.\nUsed with fix nve/spin, this command performs\nBrownian dynamics (BD).\nA random torque and a transverse dissipation are applied to each spin i according to\nthe following stochastic differential equation:\n\n\\[ \\frac{d \\vec{s}_{i}}{dt} = \\frac{1}{\\left(1+\\lambda^2 \\right)} \\left( \\left(\n \\vec{\\omega}_{i} +\\vec{\\eta} \\right) \\times \\vec{s}_{i} + \\lambda\\, \\vec{s}_{i}\n\\times\\left( \\vec{\\omega}_{i} \\times\\vec{s}_{i} \\right) \\right)\\]\nwith \\(\\lambda\\) the transverse damping, and \\(\\eta\\) a random vector.\nThis equation is referred to as the stochastic Landau-Lifshitz-Gilbert (sLLG)\nequation.\nThe components of \\(\\eta\\) are drawn from a Gaussian probability\nlaw. Their amplitude is defined as a proportion of the temperature of\nthe external thermostat T (in K in metal units).\nMore details about this implementation are reported in (Tranchida).\nNote: due to the form of the sLLG equation, this fix has to be defined just\nbefore the nve/spin fix (and after all other magnetic fixes).\nAs an example:\nfix 1 all precession/spin zeeman 0.01 0.0 0.0 1.0\nfix 2 all langevin/spin 300.0 0.01 21\nfix 3 all nve/spin lattice moving\n\n\nis correct, but defining a force/spin command after the langevin/spin command\nwould give an error message.\nNote: The random # seed must be a positive integer.  A Marsaglia random\nnumber generator is used.  Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random numbers.\nThus the dynamics of the system will not be identical on two runs on\ndifferent numbers of processors.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator\nis not saved in restart files, this means you cannot do “exact”\nrestarts with this fix, where the simulation continues on the same as\nif no restart had taken place.  However, in a statistical sense, a\nrestarted simulation should produce the same behavior.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID langevin/spin T Tdamp seed",
    "parameters": " * ID, group-ID are documented in fix command\n * langevin/spin = style name of this fix command\n * T = desired temperature of the bath (temperature units, K in metal units)\n * Tdamp = transverse magnetic damping parameter (adim)\n * seed = random number seed to use for white noise (positive integer)",
    "examples": "fix 2 all langevin/spin 300.0 0.01 21",
    "restrictions": "The langevin/spin fix is part of the SPIN package.  This style is\nonly enabled if LAMMPS was built with this package.  See the Build package doc page for more info.\nThe numerical integration has to be performed with fix nve/spin\nwhen fix langevin/spin is enabled.\nThis fix has to be the last defined magnetic fix before the time\nintegration fix (e.g. fix nve/spin)."
},
{
    "command": "fix latte",
    "html_filename": "fix_latte.html",
    "short_description": "This fix style is a wrapper on the self-consistent charge transfer density functional based tight binding (DFTB) code LATTE",
    "description": "This fix style is a wrapper on the self-consistent charge transfer\ndensity functional based tight binding (DFTB) code LATTE. If you\ndownload and build LATTE, it can be called as a library by LAMMPS via\nthis fix to run dynamics or perform energy minimization using DFTB\nforces and energies computed by LATTE.\nLATTE is principally developed and supported by Marc Cawkwell and\nco-workers at Los Alamos National Laboratory (LANL).  See the full\nlist of contributors in the src/LATTE/README file.\nTo use this fix, the LATTE program needs to be compiled as a library\nand linked with LAMMPS.  LATTE can be downloaded (or cloned) from\nhttps://github.com/lanl/LATTE.\nInstructions on how to download and build LATTE on your system can be\nfound in the lib/latte/README.  Note that you can also use the “make\nlib-latte” command from the LAMMPS src directory to automate this\nprocess.\nOnce LAMMPS is built with the LATTE package, you can run the example\ninput scripts for molecular dynamics or energy minimization that are\nfound in examples/latte.\nA step-by-step tutorial can be followed at: LAMMPS-LATTE tutorial\nThe peID argument is not yet supported by fix latte, so it must be\nspecified as NULL.  Eventually it will be used to enable LAMMPS to\ncalculate a Coulomb potential as an alternative to LATTE performing\nthe calculation.\n\nLATTE is a code for performing self-consistent charge transfer\ntight-binding (SC-TB) calculations of total energies and the forces\nacting on atoms in molecules and solids. This tight-binding method is\nbecoming more and more popular and widely used in chemistry,\nbiochemistry, material science, etc.\nThe SC-TB formalism is derived from an expansion of the Kohn-Sham\ndensity functional to second order in charge fluctuations about a\nreference charge of overlapping atom-centered densities and bond\nintegrals are parameterized using a Slater-Koster tight-binding\napproach. This procedure, which usually is referred to as the DFTB\nmethod has been described in detail by (Elstner) and\n(Finnis) and coworkers.\nThe work of the LATTE developers follows that of Elstner closely with\nrespect to the physical model.  However, the development of LATTE is\ngeared principally toward large-scale, long duration, microcanonical\nquantum-based Born-Oppenheimer molecular dynamics (QMD) simulations.\nOne of the main bottlenecks of an electronic structure calculation is\nthe solution of the generalized eigenvalue problem which scales with\nthe cube of the system size O(N^3).\nThe Theoretical and Computer sciences divisions at Los Alamos National\nLaboratory have accumulated large experience addressing this issue by\ncalculating the density matrix directly instead of using\ndiagonalization. We typically use a recursive sparse Fermi-operator\nexpansion using second-order spectral projection functions\n(SP2-algorithm), which was introduced by Niklasson in 2002\n(Niklasson2002), (Rubensson),\n(Mniszewski).  When the matrices involved in the\nrecursive expansion are sufficiently sparse, the calculation of the\ndensity matrix scales linearly as a function of the system size O(N).\nAnother important feature is the extended Lagrangian framework for\nBorn-Oppenheimer molecular dynamics (XL-BOMD)\n(Niklasson2008) (Niklasson2014),\n(Niklasson2017) that allows for a drastic reduction\nor even a complete removal of the iterative self-consistent field\noptimization.  Often only a single density matrix calculation per\nmolecular dynamics time step is required, yet total energy stability\nis well maintained.  The SP2 and XL-BOMD techniques enables stable\nlinear scaling MD simulations with a very small computational\noverhead.  This opens a number of opportunities in many different\nareas of chemistry and materials science, as we now can simulate\nlarger system sizes and longer time scales\n(Cawkwell2012), (Negre2016).\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential energy computed by LATTE to the system’s\npotential energy as part of thermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the LATTE DFTB contribution to the system’s virial as part\nof thermodynamic output.  The default is virial\nyes\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the potential\nenergy discussed above.  The scalar value calculated by this fix is\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe DFTB forces computed by LATTE via this fix are imposed during an\nenergy minimization, invoked by the minimize command.\n\nNote\nIf you want the potential energy associated with the DFTB\nforces to be included in the total potential energy of the system (the\nquantity being minimized), you MUST enable the\nfix_modify energy option for this fix.",
    "syntax": "fix ID group-ID latte peID",
    "parameters": " * ID, group-ID are documented in fix command\n * latte = style name of this fix command\n * peID = NULL or ID of compute used to calculate per-atom energy",
    "examples": "fix dftb all latte NULL",
    "restrictions": "This fix is part of the LATTE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nYou must use metal units, as set by the units command to\nuse this fix.\nLATTE does not currently compute per-atom energy or per-atom virial\ncontributions.  So they will not show up as part of the calculations\nperformed by the compute pe/atom or compute stress/atom commands.\nCurrently, LAMMPS must be run in serial or as a single MPI task, to\nuse this fix.  This is typically not a bottleneck, since LATTE will be\ndoing 99% or more of the work to compute quantum-accurate forces.\n\nNote\nNEB calculations can be done using this fix using multiple\nreplicas and running LAMMPS in parallel.  However, each replica must\nbe run on a single MPI task.  For details, see the neb\ncommand doc page and the -partition command-line switch\n\nRelated commands: none\nDefault: none\n\n(Elstner) M. Elstner, D. Poresag, G. Jungnickel, J. Elsner,\nM. Haugk, T. Frauenheim, S. Suhai, and G. Seifert, Phys. Rev. B, 58,\n7260 (1998).\n(Elstner) M. Elstner, D. Poresag, G. Jungnickel, J. Elsner,\nM. Haugk, T. Frauenheim, S. Suhai, and G. Seifert, Phys. Rev. B, 58,\n7260 (1998).\n(Finnis) M. W. Finnis, A. T. Paxton, M. Methfessel, and M. van\nSchilfgarde, Phys. Rev. Lett., 81, 5149 (1998).\n(Mniszewski) S. M. Mniszewski, M. J. Cawkwell, M. E. Wall,\nJ. Mohd-Yusof, N. Bock, T. C.  Germann, and A. M. N. Niklasson,\nJ. Chem. Theory Comput., 11, 4644 (2015).\n(Niklasson2002) A. M. N. Niklasson, Phys. Rev. B, 66, 155115 (2002).\n(Rubensson) E. H. Rubensson, A. M. N. Niklasson, SIAM\nJ. Sci. Comput. 36 (2), 147-170, (2014).\n(Niklasson2008) A. M. N. Niklasson, Phys. Rev. Lett., 100, 123004\n(2008).\n(Niklasson2014) A. M. N. Niklasson and M. Cawkwell, J. Chem. Phys.,\n141, 164123, (2014).\n(Niklasson2017) A. M. N. Niklasson, J. Chem. Phys., 147, 054103 (2017).\n(Cawkwell2012) A. M. N. Niklasson, M. J. Cawkwell, Phys. Rev. B, 86\n(17), 174308 (2012).\n(Negre2016) C. F. A. Negre, S. M. Mniszewski, M. J. Cawkwell,\nN. Bock, M. E. Wall, and A. M. N. Niklasson, J. Chem. Theory Comp.,\n12, 3063 (2016)."
},
{
    "command": "fix lb/fluid",
    "html_filename": "fix_lb_fluid.html",
    "short_description": "Implement a lattice-Boltzmann fluid on a uniform mesh covering the LAMMPS simulation domain",
    "description": "Implement a lattice-Boltzmann fluid on a uniform mesh covering the LAMMPS\nsimulation domain.  The MD particles described by group-ID apply a velocity\ndependent force to the fluid.\nThe lattice-Boltzmann algorithm solves for the fluid motion governed by\nthe Navier Stokes equations,\n\n\\[\\begin{split}\\partial_t \\rho + \\partial_{\\beta}\\left(\\rho u_{\\beta}\\right)= & 0 \\\\\n\\partial_t\\left(\\rho u_{\\alpha}\\right) + \\partial_{\\beta}\\left(\\rho u_{\\alpha} u_{\\beta}\\right) = & \\partial_{\\beta}\\sigma_{\\alpha \\beta} + F_{\\alpha} + \\partial_{\\beta}\\left(\\eta_{\\alpha \\beta \\gamma \\nu}\\partial_{\\gamma} u_{\\nu}\\right)\\end{split}\\]\nwith,\n\n\\[\\eta_{\\alpha \\beta \\gamma \\nu} = \\eta\\left[\\delta_{\\alpha \\gamma}\\delta_{\\beta \\nu} + \\delta_{\\alpha \\nu}\\delta_{\\beta \\gamma} - \\frac{2}{3}\\delta_{\\alpha \\beta}\\delta_{\\gamma \\nu}\\right] + \\Lambda \\delta_{\\alpha \\beta}\\delta_{\\gamma \\nu}\\]\nwhere \\(\\rho\\) is the fluid density, u is the local\nfluid velocity, \\(\\sigma\\) is the stress tensor, F is a local external\nforce, and \\(\\eta\\) and \\(\\Lambda\\) are the shear and bulk viscosities\nrespectively.  Here, we have implemented\n\n\\[\\sigma_{\\alpha \\beta} = -P_{\\alpha \\beta} = -\\rho a_0 \\delta_{\\alpha \\beta}\\]\nwith \\(a_0\\) set to \\(\\frac{1}{3} \\frac{dx}{dt}^2\\) by default.\nThe algorithm involves tracking the time evolution of a set of partial\ndistribution functions which evolve according to a velocity\ndiscretized version of the Boltzmann equation,\n\n\\[\\left(\\partial_t + e_{i\\alpha}\\partial_{\\alpha}\\right)f_i = -\\frac{1}{\\tau}\\left(f_i - f_i^{eq}\\right) + W_i\\]\nwhere the first term on the right hand side represents a single time\nrelaxation towards the equilibrium distribution function, and \\(\\tau\\) is a\nparameter physically related to the viscosity.  On a technical note,\nwe have implemented a 15 velocity model (D3Q15) as default; however,\nthe user can switch to a 19 velocity model (D3Q19) through the use of\nthe D3Q19 keyword.  This fix provides the user with the choice of\ntwo algorithms to solve this equation, through the specification of\nthe keyword LBtype.  If LBtype is set equal to 1, the standard\nfinite difference LB integrator is used.  If LBtype is set equal to\n2, the algorithm of Ollila et al. is used.\nPhysical variables are then defined in terms of moments of the distribution\nfunctions,\n\n\\[\\begin{split}\\rho = & \\displaystyle\\sum\\limits_{i} f_i \\\\\n\\rho u_{\\alpha} = & \\displaystyle\\sum\\limits_{i} f_i e_{i\\alpha}\\end{split}\\]\nFull details of the lattice-Boltzmann algorithm used can be found in\nMackay et al..\nThe fluid is coupled to the MD particles described by group-ID through\na velocity dependent force.  The contribution to the fluid force on a\ngiven lattice mesh site j due to MD particle \\(\\alpha\\) is\ncalculated as:\n\n\\[{\\bf F}_{j \\alpha} = \\gamma \\left({\\bf v}_n - {\\bf u}_f \\right) \\zeta_{j\\alpha}\\]\nwhere \\(\\mathbf{v}_n\\) is the velocity of the MD particle,\n\\(\\mathbf{u}_f\\) is the fluid\nvelocity interpolated to the particle location, and \\(\\gamma\\) is the force\ncoupling constant.  \\(\\zeta\\) is a weight assigned to the grid point,\nobtained by distributing the particle to the nearest lattice sites.\nFor this, the user has the choice between a trilinear stencil, which\nprovides a support of 8 lattice sites, or the immersed boundary method\nPeskin stencil, which provides a support of 64 lattice sites.  While\nthe Peskin stencil is seen to provide more stable results, the\ntrilinear stencil may be better suited for simulation of objects close\nto walls, due to its smaller support.  Therefore, by default, the\nPeskin stencil is used; however the user may switch to the trilinear\nstencil by specifying the keyword, trilinear.\nBy default, the force coupling constant, \\(\\gamma\\), is calculated\naccording to\n\n\\[\\gamma = \\frac{2m_um_v}{m_u+m_v}\\left(\\frac{1}{\\Delta t_{collision}}\\right)\\]\nHere, \\(m_v\\) is the mass of the MD particle, \\(m_u\\) is a\nrepresentative fluid mass at the particle location, and \\(\\Delta\nt_{collision}\\) is a collision time, chosen such that\n\\(\\frac{\\tau}{\\Delta t_{collision}} = 1\\) (see Mackay and\nDenniston for full details).  In order to calculate \\(m_u\\),\nthe fluid density is interpolated to the MD particle location, and\nmultiplied by a volume, node_area * \\(dx_{LB}\\), where node_area\nrepresents the portion of the surface area of the composite object\nassociated with a given MD particle.  By default, node_area is set\nequal to \\(dx_{LB}^2\\); however specific values for given atom types\ncan be set using the setArea keyword.\nThe user also has the option of specifying their own value for the\nforce coupling constant, for all the MD particles associated with the\nfix, through the use of the setGamma keyword.  This may be useful\nwhen modelling porous particles.  See Mackay et al. for a\ndetailed description of the method by which the user can choose an\nappropriate \\(\\gamma\\) value.\n\nNote\nwhile this fix applies the force of the particles on the fluid,\nit does not apply the force of the fluid to the particles.  When the\nforce coupling constant is set using the default method, there is only\none option to include this hydrodynamic force on the particles, and\nthat is through the use of the lb/viscous fix.\nThis fix adds the hydrodynamic force to the total force acting on the\nparticles, after which any of the built-in LAMMPS integrators can be\nused to integrate the particle motion.  However, if the user specifies\ntheir own value for the force coupling constant, as mentioned in\nMackay et al., the built-in LAMMPS integrators may prove to\nbe unstable.  Therefore, we have included our own integrators\nfix lb/rigid/pc/sphere, and\nfix lb/pc, to solve for the particle motion in these\ncases.  These integrators should not be used with the\nlb/viscous fix, as they add hydrodynamic forces\nto the particles directly.  In addition, they can not be used if the\nforce coupling constant has been set the default way.\n\n\nNote\nif the force coupling constant is set using the default method,\nand the lb/viscous fix is NOT used to add the\nhydrodynamic force to the total force acting on the particles, this\nphysically corresponds to a situation in which an infinitely massive\nparticle is moving through the fluid (since collisions between the\nparticle and the fluid do not act to change the particle’s velocity).\nTherefore, the user should set the mass of the particle to be\nsignificantly larger than the mass of the fluid at the particle\nlocation, in order to approximate an infinitely massive particle (see\nthe dragforce test run for an example).\n\n\nInside the fix, parameters are scaled by the lattice-Boltzmann\ntimestep, \\(dt_{LB}\\), grid spacing, \\(dx_{LB}\\), and mass unit,\n\\(dm_{LB}\\).  \\(dt_{LB}\\) is set equal to\n\\(\\mathrm{nevery}\\cdot dt_{MD}\\), where \\(dt_{MD}\\) is the MD timestep.\nBy default,\n\\(dm_{LB}\\) is set equal to 1.0, and \\(dx_{LB}\\) is chosen so that\n\\(\\frac{\\tau}{dt} = \\frac{3\\eta dt}{\\rho dx^2}\\) is approximately equal to 1.\nHowever, the user has the option of specifying their own values for\n\\(dm_{LB}\\), and \\(dx_{LB}\\), by using\nthe optional keywords dm, and dx respectively.\n\nNote\nCare must be taken when choosing both a value for \\(dx_{LB}\\),\nand a simulation domain size.  This fix uses the same subdivision of\nthe simulation domain among processors as the main LAMMPS program.  In\norder to uniformly cover the simulation domain with lattice sites, the\nlengths of the individual LAMMPS sub-domains must all be evenly\ndivisible by \\(dx_{LB}\\).  If the simulation domain size is cubic,\nwith equal lengths in all dimensions, and the default value for\n\\(dx_{LB}\\) is used, this will automatically be satisfied.\n\nPhysical parameters describing the fluid are specified through\nviscosity, density, and a0. If the force coupling constant is\nset the default way, the surface area associated with the MD particles\nis specified using the setArea keyword.  If the user chooses to\nspecify a value for the force coupling constant, this is set using the\nsetGamma keyword.  These parameters should all be given in terms of\nthe mass, distance, and time units chosen for the main LAMMPS run, as\nthey are scaled by the LB timestep, lattice spacing, and mass unit,\ninside the fix.\n\nThe setArea keyword allows the user to associate a surface area with\na given atom type.  For example if a spherical composite object of\nradius R is represented as a spherical shell of N evenly distributed\nMD particles, all of the same type, the surface area per particle\nassociated with that atom type should be set equal to \\(\\frac{4\\pi R^2}{N}\\).\nThis keyword should only be used if the force coupling constant,\n\\(\\gamma\\), is set the default way.\nThe setGamma keyword allows the user to specify their own value for\nthe force coupling constant, \\(\\gamma\\), instead of using the default\nvalue.\nThe scaleGamma keyword should be used in conjunction with the\nsetGamma keyword, when the user wishes to specify different \\(\\gamma\\)\nvalues for different atom types.  This keyword allows the user to\nscale the setGamma \\(\\gamma\\) value by a factor, gammaFactor,\nfor a given atom type.\nThe dx keyword allows the user to specify a value for the LB grid\nspacing.\nThe dm keyword allows the user to specify the LB mass unit.\nIf the a0 keyword is used, the value specified is used for the\nsquare of the speed of sound in the fluid.  If this keyword is not\npresent, the speed of sound squared is set equal to\n\\(\\frac{1}{3}\\left(\\frac{dx_{LB}}{dt_{LB}}\\right)^2\\).\nSetting \\(a0 > (\\frac{dx_{LB}}{dt_{LB}})^2\\) is not allowed,\nas this may lead to instabilities.\nIf the noise keyword is used, followed by a positive temperature\nvalue, and a positive integer random number seed, a thermal\nlattice-Boltzmann algorithm is used.  If LBtype is set equal to 1\n(i.e. the standard LB integrator is chosen), the thermal LB algorithm\nof Adhikari et al. is used; however if LBtype is set\nequal to 2 both the LB integrator, and thermal LB algorithm described\nin Ollila et al. are used.\nIf the calcforce keyword is used, both the fluid force and torque\nacting on the specified particle group are printed to the screen every\nN timesteps.\nIf the keyword trilinear is used, the trilinear stencil is used to\ninterpolate the particle nodes onto the fluid mesh.  By default, the\nimmersed boundary method, Peskin stencil is used.  Both of these\ninterpolation methods are described in Mackay et al..\nIf the keyword D3Q19 is used, the 19 velocity (D3Q19) lattice is\nused by the lattice-Boltzmann algorithm.  By default, the 15 velocity\n(D3Q15) lattice is used.\nIf the keyword write_restart is used, followed by a positive\ninteger, N, a binary restart file is printed every N LB timesteps.\nThis restart file only contains information about the fluid.\nTherefore, a LAMMPS restart file should also be written in order to\nprint out full details of the simulation.\n\nNote\nWhen a large number of lattice grid points are used, the restart\nfiles may become quite large.\n\nIn order to restart the fluid portion of the simulation, the keyword\nread_restart is specified, followed by the name of the binary\nlb_fluid restart file to be used.\nIf the zwall_velocity keyword is used y-velocities are assigned to\nthe lower and upper walls.  This keyword requires the presence of\nwalls in the z-direction.  This is set by assigning fixed boundary\nconditions in the z-direction.  If fixed boundary conditions are\npresent in the z-direction, and this keyword is not used, the walls\nare assumed to be stationary.\nIf the bodyforce keyword is used, a constant body force is added to\nthe fluid, defined by it’s x, y and z components.\nIf the printfluid keyword is used, followed by a positive integer, N,\nthe fluid densities and velocities at each lattice site are printed to the\nscreen every N timesteps.\n\nFor further details, as well as descriptions and results of several\ntest runs, see Mackay et al..  Please include a citation to\nthis paper if the lb_fluid fix is used in work contributing to\npublished research.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nDue to the large size of the fluid data, this fix writes it’s own\nbinary restart files, if requested, independent of the main LAMMPS\nbinary restart files; no information about lb_fluid\nis written to the main LAMMPS binary restart files.\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID lb/fluid nevery LBtype viscosity density keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * lb/fluid = style name of this fix command\n * nevery = update the lattice-Boltzmann fluid every this many timesteps\n * LBtype = 1 to use the standard finite difference LB integrator,\n * 2 to use the LB integrator of Ollila et al.\n * viscosity = the fluid viscosity (units of mass/(time*length)).\n * density = the fluid density.\n * zero or more keyword/value pairs may be appended\n * keyword = setArea or setGamma or scaleGamma or dx or dm or a0 or noise or calcforce or trilinear or D3Q19 or read_restart or write_restart or zwall_velocity or bodyforce or printfluid\n * setArea values = type node_area\n *     type = atom type (1-N)\n *     node_area = portion of the surface area of the composite object associated with the particular atom type (used when the force coupling constant is set by default).\n * setGamma values = gamma\n *     gamma = user set value for the force coupling constant.\n * scaleGamma values = type gammaFactor\n *     type = atom type (1-N)\n *     gammaFactor = factor to scale the setGamma gamma value by, for the specified atom type.\n * dx values = dx_LB = the lattice spacing.\n * dm values = dm_LB = the lattice-Boltzmann mass unit.\n * a0 values = a_0_real = the square of the speed of sound in the fluid.\n * noise values = Temperature seed\n *     Temperature = fluid temperature.\n *     seed = random number generator seed (positive integer)\n * calcforce values = N forcegroup-ID\n *     N = output the force and torque every N timesteps\n *     forcegroup-ID = ID of the particle group to calculate the force and torque of\n * trilinear values = none (used to switch from the default Peskin interpolation stencil to the trilinear stencil).\n * D3Q19 values = none (used to switch from the default D3Q15, 15 velocity lattice, to the D3Q19, 19 velocity lattice).\n * read_restart values = restart file = name of the restart file to use to restart a fluid run.\n * write_restart values = N = write a restart file every N MD timesteps.\n * zwall_velocity values = velocity_bottom velocity_top = velocities along the y-direction of the bottom and top walls (located at z=zmin and z=zmax).\n * bodyforce values = bodyforcex bodyforcey bodyforcez = the x,y and z components of a constant body force added to the fluid.\n * printfluid values = N = print the fluid density and velocity at each grid point every N timesteps.",
    "examples": "fix 1 all lb/fluid 1 2 1.0 1.0 setGamma 13.0 dx 4.0 dm 10.0 calcforce sphere1\nfix 1 all lb/fluid 1 1 1.0 0.0009982071 setArea 1 1.144592082 dx 2.0 dm 0.3 trilinear noise 300.0 8979873",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix can only be used with an orthogonal simulation domain.\nWalls have only been implemented in the z-direction.  Therefore, the\nboundary conditions, as specified via the main LAMMPS boundary command\nmust be periodic for x and y, and either fixed or periodic for z.\nShrink-wrapped boundary conditions are not permitted with this fix.\nThis fix must be used before any of fix lb/viscous, fix lb/momentum, fix lb/rigid/pc/sphere, and/ or fix lb/pc , as the fluid needs to be initialized before\nany of these routines try to access its properties.  In addition, in\norder for the hydrodynamic forces to be added to the particles, this\nfix must be used in conjunction with the\nlb/viscous fix if the force coupling constant is\nset by default, or either the lb/viscous fix or\none of the lb/rigid/pc/sphere or\nlb/pc integrators, if the user chooses to specify\ntheir own value for the force coupling constant."
},
{
    "command": "fix lb/momentum",
    "html_filename": "fix_lb_momentum.html",
    "short_description": "This fix is based on the fix momentum command, and was created to be used in place of that command, when a lattice-Boltzmann fluid is present",
    "description": "This fix is based on the fix momentum command, and\nwas created to be used in place of that command, when a\nlattice-Boltzmann fluid is present.\nZero the total linear momentum of the system, including both the atoms\nspecified by group-ID and the lattice-Boltzmann fluid every nevery\ntimesteps.  This is accomplished by adjusting the particle velocities\nand the fluid velocities at each lattice site.\n\nNote\nThis fix only considers the linear momentum of the system.\n\nBy default, the subtraction is performed for each dimension.  This can\nbe changed by specifying the keyword linear, along with a set of\nthree flags set to 0/1 in order to exclude/ include the corresponding\ndimension.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID lb/momentum nevery keyword values ...",
    "parameters": " * ID, group-ID are documented in the fix command\n * lb/momentum = style name of this fix command\n * nevery = adjust the momentum every this many timesteps\n * zero or more keyword/value pairs may be appended\n * keyword = linear\n * linear values = xflag yflag zflag\n *   xflag,yflag,zflag = 0/1 to exclude/include each dimension.",
    "examples": "fix 1 sphere lb/momentum\nfix 1 all lb/momentum linear 1 1 0",
    "restrictions": "Can only be used if a lattice-Boltzmann fluid has been created via the\nfix lb/fluid command, and must come after this\ncommand.\nThis fix is part of the USER-LB package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix lb/pc",
    "html_filename": "fix_lb_pc.html",
    "short_description": "Update the positions and velocities of the individual particles described by group-ID, experiencing velocity-dependent hydrodynamic forces, using the integration algorithm described in Mackay et al",
    "description": "Update the positions and velocities of the individual particles\ndescribed by group-ID, experiencing velocity-dependent hydrodynamic\nforces, using the integration algorithm described in Mackay et al..  This integration algorithm should only be used if a\nuser-specified value for the force-coupling constant used in fix lb/fluid has been set; do not use this integration\nalgorithm if the force coupling constant has been set by default.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID lb/pc",
    "parameters": " * ID, group-ID are documented in the fix command\n * lb/pc = style name of this fix command",
    "examples": "fix 1 all lb/pc",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nCan only be used if a lattice-Boltzmann fluid has been created via the\nfix lb/fluid command, and must come after this\ncommand."
},
{
    "command": "fix lb/rigid/pc/sphere",
    "html_filename": "fix_lb_rigid_pc_sphere.html",
    "short_description": "This fix is based on the fix rigid command, and was created to be used in place of that fix, to integrate the equations of motion of spherical rigid bodies when a lattice-Boltzmann fluid is present with a user-specified value of the force-coupling constant",
    "description": "This fix is based on the fix rigid command, and was\ncreated to be used in place of that fix, to integrate the equations of\nmotion of spherical rigid bodies when a lattice-Boltzmann fluid is\npresent with a user-specified value of the force-coupling constant.\nThe fix uses the integration algorithm described in Mackay et al. to update the positions, velocities, and orientations of\na set of spherical rigid bodies experiencing velocity dependent\nhydrodynamic forces.  The spherical bodies are assumed to rotate as\nsolid, uniform density spheres, with moments of inertia calculated\nusing the combined sum of the masses of all the constituent particles\n(which are assumed to be point particles).\n\nBy default, all of the atoms that this fix acts on experience a\nhydrodynamic force due to the presence of the lattice-Boltzmann fluid.\nHowever, the innerNodes keyword allows the user to specify atoms\nbelonging to a rigid object which do not interact with the\nlattice-Boltzmann fluid (i.e. these atoms do not feel a hydrodynamic\nforce from the lattice-Boltzmann fluid).  This can be used to\ndistinguish between atoms on the surface of a non-porous object, and\nthose on the inside.\nThis feature can be used, for example, when implementing a hard sphere\ninteraction between two spherical objects.  Instead of interactions\noccurring between the particles on the surfaces of the two spheres, it\nis desirable simply to place an atom at the center of each sphere,\nwhich does not contribute to the hydrodynamic force, and have these\ncentral atoms interact with one another.\n\nApart from the features described above, this fix is very similar to\nthe rigid fix (although it includes fewer optional arguments, and\nassumes the constituent atoms are point particles); see\nfix rigid for a complete documentation.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about the rigid and rigid/nve fixes are written to\nbinary restart files.\nSimilar to the fix rigid command: The rigid fix\ncomputes a global scalar which can be accessed by various output commands.  The scalar value calculated by these\nfixes is “intensive”.  The scalar is the current temperature of the\ncollection of rigid bodies.  This is averaged over all rigid bodies\nand their translational and rotational degrees of freedom.  The\ntranslational energy of a rigid body is 1/2 m v^2, where m = total\nmass of the body and v = the velocity of its center of mass.  The\nrotational energy of a rigid body is 1/2 I w^2, where I = the moment\nof inertia tensor of the body and w = its angular velocity.  Degrees\nof freedom constrained by the force and torque keywords are\nremoved from this calculation.\nAll of these fixes compute a global array of values which can be\naccessed by various output commands.  The number\nof rows in the array is equal to the number of rigid bodies.  The\nnumber of columns is 15.  Thus for each rigid body, 15 values are\nstored: the xyz coords of the center of mass (COM), the xyz components\nof the COM velocity, the xyz components of the force acting on the\nCOM, the xyz components of the torque acting on the COM, and the xyz\nimage flags of the COM, which have the same meaning as image flags for\natom positions (see the “dump” command).  The force and torque values\nin the array are not affected by the force and torque keywords in\nthe fix rigid command; they reflect values before any changes are made\nby those keywords.\nThe ordering of the rigid bodies (by row in the array) is as follows.\nFor the single keyword there is just one rigid body.  For the\nmolecule keyword, the bodies are ordered by ascending molecule ID.\nFor the group keyword, the list of group IDs determines the ordering\nof bodies.\nThe array values calculated by these fixes are “intensive”, meaning\nthey are independent of the number of atoms in the simulation.\nNo parameter of these fixes can be used with the start/stop keywords\nof the run command.  These fixes are not invoked during\nenergy minimization.",
    "syntax": "fix ID group-ID lb/rigid/pc/sphere bodystyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * lb/rigid/pc/sphere = style name of this fix command\n * bodystyle = single or molecule or group\n * single args = none\n * molecule args = none\n * group args = N groupID1 groupID2 ...\n *   N = # of groups\n * zero or more keyword/value pairs may be appended\n * keyword = force or torque or innerNodes\n * force values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass force is active\n * torque values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n * innerNodes values = innergroup-ID\n *   innergroup-ID = ID of the atom group which does not experience a hydrodynamic force from the lattice-Boltzmann fluid",
    "examples": "fix 1 spheres lb/rigid/pc/sphere\nfix 1 all lb/rigid/pc/sphere force 1 0 0 innerNodes ForceAtoms",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nCan only be used if a lattice-Boltzmann fluid has been created via the\nfix lb/fluid command, and must come after this\ncommand.  Should only be used if the force coupling constant used in\nfix lb/fluid has been set by the user; this\nintegration fix cannot be used if the force coupling constant is set\nby default."
},
{
    "command": "fix lb/viscous",
    "html_filename": "fix_lb_viscous.html",
    "short_description": "This fix is similar to the fix viscous command, and is to be used in place of that command when a lattice-Boltzmann fluid is present, and the user wishes to integrate the particle motion using one of the built in LAMMPS integrators",
    "description": "This fix is similar to the fix viscous command, and\nis to be used in place of that command when a lattice-Boltzmann fluid\nis present, and the user wishes to integrate the particle motion using\none of the built in LAMMPS integrators.\nThis fix adds a force, F = - Gamma*(velocity-fluid_velocity), to each\natom, where Gamma is the force coupling constant described in the fix lb/fluid command (which applies an equal and\nopposite force to the fluid).\n\nNote\nThis fix should only be used in conjunction with one of the\nbuilt in LAMMPS integrators; it should not be used with the fix lb/pc or fix lb/rigid/pc/sphere integrators, which\nalready include the hydrodynamic forces.  These latter fixes should\nonly be used if the force coupling constant has been set by the user\n(instead of using the default value); if the default force coupling\nvalue is used, then this fix provides the only method for adding the\nhydrodynamic forces to the particles.\n\n\nFor further details, as well as descriptions and results of several\ntest runs, see Mackay et al..  Please include a citation to\nthis paper if this fix is used in work contributing to published\nresearch.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nAs described in the fix viscous documentation:\n“No information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  This fix should only\nbe used with damped dynamics minimizers that allow for\nnon-conservative forces.  See the min_style command\nfor details.”",
    "syntax": "fix ID group-ID lb/viscous",
    "parameters": " * ID, group-ID are documented in fix command\n * lb/viscous = style name of this fix command",
    "examples": "fix 1 flow lb/viscous",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nCan only be used if a lattice-Boltzmann fluid has been created via the\nfix lb/fluid command, and must come after this\ncommand.\nThis fix should not be used if either the fix lb/pc\nor fix lb/rigid/pc/sphere integrator is\nused."
},
{
    "command": "fix lineforce",
    "html_filename": "fix_lineforce.html",
    "short_description": "Adjust the forces on each atom in the group so that only the component of force along the linear direction specified by the vector (x,y,z) remains",
    "description": "Adjust the forces on each atom in the group so that only the component\nof force along the linear direction specified by the vector (x,y,z)\nremains.  This is done by subtracting out components of force in the\nplane perpendicular to the line.\nIf the initial velocity of the atom is 0.0 (or along the line), then\nit should continue to move along the line thereafter.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.",
    "syntax": "fix ID group-ID lineforce x y z",
    "parameters": " * ID, group-ID are documented in fix command\n * lineforce = style name of this fix command\n * x y z = direction of line as a 3-vector",
    "examples": "fix hold boundary lineforce 0.0 1.0 1.0",
    "restrictions": "\nnone"
},
{
    "command": "fix manifoldforce",
    "html_filename": "fix_manifoldforce.html",
    "short_description": "This fix subtracts each time step from the force the component along the normal of the specified manifold",
    "description": "This fix subtracts each time step from the force the component along\nthe normal of the specified manifold.  This can be\nused in combination with minimize to remove overlap\nbetween particles while keeping them (roughly) constrained to the\ngiven manifold, e.g. to set up a run with fix nve/manifold/rattle.  I have found that\nonly hftn and quickmin with a very small time step perform\nadequately though.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is invoked during energy minimization.",
    "syntax": "fix ID group-ID manifoldforce manifold manifold-args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * manifold = name of the manifold\n * manifold-args = parameters for the manifold",
    "examples": "fix constrain all manifoldforce sphere 5.0",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nOnly use this with min_style hftn or min_style quickmin. If not,\nthe constraints will not be satisfied very well at all. A warning is\ngenerated if the min_style is incompatible but no error."
},
{
    "command": "fix meso",
    "html_filename": "fix_meso.html",
    "short_description": "Perform time integration to update position, velocity, internal energy and local density for atoms in the group each timestep",
    "description": "Perform time integration to update position, velocity, internal energy\nand local density for atoms in the group each timestep. This fix is\nneeded to time-integrate mesoscopic systems where particles carry\ninternal variables such as SPH or DPDE.\nSee this PDF guide to using SPH in\nLAMMPS.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID meso",
    "parameters": " * ID, group-ID are documented in fix command\n * meso = style name of this fix command",
    "examples": "fix 1 all meso",
    "restrictions": "This fix is part of the USER-SPH package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix meso/move",
    "html_filename": "fix_meso_move.html",
    "short_description": "Perform updates of position, velocity, internal energy and local density for mesoscopic particles in the group each timestep using the specified settings or formulas, without regard to forces on the particles",
    "description": "Perform updates of position, velocity, internal energy and local\ndensity for mesoscopic particles in the group each timestep using the\nspecified settings or formulas, without regard to forces on the\nparticles. This can be useful for boundary, solid bodies or other\nparticles, whose movement can influence nearby particles.\nThe operation of this fix is exactly like that described by the\nfix move command, except that particles’ density,\ninternal energy and extrapolated velocity are also updated.\n\nNote\nThe particles affected by this fix should not be time integrated\nby other fixes (e.g. fix meso, fix meso/stationary), since that will change their\npositions and velocities twice.\n\n\nNote\nAs particles move due to this fix, they will pass through periodic\nboundaries and be remapped to the other side of the simulation box,\njust as they would during normal time integration (e.g. via the fix meso command).  It is up to you to decide whether periodic\nboundaries are appropriate with the kind of particle motion you are\nprescribing with this fix.\n\n\nNote\nAs discussed below, particles are moved relative to their initial\nposition at the time the fix is specified.  These initial coordinates\nare stored by the fix in “unwrapped” form, by using the image flags\nassociated with each particle.  See the dump custom command\nfor a discussion of “unwrapped” coordinates.  See the Atoms section of\nthe read_data command for a discussion of image flags\nand how they are set for each particle.  You can reset the image flags\n(e.g. to 0) before invoking this fix by using the set image\ncommand.\n\n\nThe linear style moves particles at a constant velocity, so that their\nposition X = (x,y,z) as a function of time is given in vector\nnotation as\nX(t) = X0 + V * delta\nwhere X0 = (x0,y0,z0) is their position at the time the fix is\nspecified, V is the specified velocity vector with components\n(Vx,Vy,Vz), and delta is the time elapsed since the fix was\nspecified.  This style also sets the velocity of each particle to V =\n(Vx,Vy,Vz).  If any of the velocity components is specified as NULL,\nthen the position and velocity of that component is time integrated\nthe same as the fix meso command would perform, using\nthe corresponding force component on the particle.\nNote that the linear style is identical to using the variable\nstyle with an equal-style variable that uses the\nvdisplace() function.  E.g.\nvariable V equal 10.0\nvariable x equal vdisplace(0.0,$V)\nfix 1 boundary move variable v_x NULL NULL v_V NULL NULL\n\n\nThe wiggle style moves particles in an oscillatory fashion, so that\ntheir position X = (x,y,z) as a function of time is given in vector\nnotation as\nX(t) = X0 + A sin(omega*delta)\nwhere X0 = (x0,y0,z0) is their position at the time the fix is\nspecified, A is the specified amplitude vector with components\n(Ax,Ay,Az), omega is 2 PI / period, and delta is the time\nelapsed since the fix was specified.  This style also sets the\nvelocity of each particle to the time derivative of this expression.\nIf any of the amplitude components is specified as NULL, then the\nposition and velocity of that component is time integrated the same as\nthe fix meso command would perform, using the\ncorresponding force component on the particle.\nNote that the wiggle style is identical to using the variable\nstyle with equal-style variables that use the\nswiggle() and cwiggle() functions.  E.g.\nvariable A equal 10.0\nvariable T equal 5.0\nvariable omega equal 2.0*PI/$T\nvariable x equal swiggle(0.0,$A,$T)\nvariable v equal v_omega*($A-cwiggle(0.0,$A,$T))\nfix 1 boundary move variable v_x NULL NULL v_v NULL NULL\nThe rotate style rotates particles around a rotation axis R =\n(Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The period of\nthe rotation is also specified.  The direction of rotation for the\nparticles around the rotation axis is consistent with the right-hand\nrule: if your right-hand thumb points along R, then your fingers wrap\naround the axis in the direction of rotation.\nThis style also sets the velocity of each particle to (omega cross\nRperp) where omega is its angular velocity around the rotation axis and\nRperp is a perpendicular vector from the rotation axis to the particle.\nThe variable style allows the position and velocity components of\neach particle to be set by formulas specified via the\nvariable command.  Each of the 6 variables is\nspecified as an argument to the fix as v_name, where name is the\nvariable name that is defined elsewhere in the input script.\nEach variable must be of either the equal or atom style.\nEqual-style variables compute a single numeric quantity, that can be\na function of the timestep as well as of other simulation values.\nAtom-style variables compute a numeric quantity for each particle, that\ncan be a function per-atom quantities, such as the particle’s position, as\nwell as of the timestep and other simulation values.  Note that this\nfix stores the original coordinates of each particle (see note below) so\nthat per-atom quantity can be used in an atom-style variable formula.\nSee the variable command for details.\nThe first 3 variables (v_dx,v_dy,v_dz) specified for the variable\nstyle are used to calculate a displacement from the particle’s original\nposition at the time the fix was specified.  The second 3 variables\n(v_vx,v_vy,v_vz) specified are used to compute a velocity for each\nparticle.\nAny of the 6 variables can be specified as NULL.  If both the\ndisplacement and velocity variables for a particular x,y,z component\nare specified as NULL, then the position and velocity of that\ncomponent is time integrated the same as the fix meso\ncommand would perform, using the corresponding force component on the\nparticle.  If only the velocity variable for a component is specified as\nNULL, then the displacement variable will be used to set the position\nof the particle, and its velocity component will not be changed. If only\nthe displacement variable for a component is specified as NULL, then\nthe velocity variable will be used to set the velocity of the particle,\nand the position of the particle will be time integrated using that\nvelocity.\nThe units keyword determines the meaning of the distance units used\nto define the linear velocity and wiggle amplitude and rotate\norigin.  This setting is ignored for the variable style.  A box\nvalue selects standard units as defined by the units\ncommand, e.g. velocity in Angstroms/fmsec and amplitude and position\nin Angstroms for units = real.  A lattice value means the velocity\nunits are in lattice spacings per time and the amplitude and position\nare in lattice spacings.  The lattice command must have\nbeen previously used to define the lattice spacing.  Each of these 3\nquantities may be dependent on the x,y,z dimension, since the lattice\nspacings can be different in x,y,z.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the original coordinates of moving particles to binary restart files, as well as the initial timestep, so that\nthe motion can be continuous in a restarted simulation.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\n\nNote\nBecause the move positions are a function of the current\ntimestep and the initial timestep, you cannot reset the timestep to a\ndifferent value after reading a restart file, if you expect a fix move\ncommand to work in an uninterrupted fashion.\n\nNone of the fix_modify options are relevant to this\nfix.\nThis fix produces a per-atom array which can be accessed by various\noutput commands.  The number of columns for each\natom is 3, and the columns store the original unwrapped x,y,z coords\nof each particle.  The per-atom values can be accessed on any timestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID meso/move style args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * meso/move = style name of this fix command\n * style = linear or wiggle or rotate or variable\n * linear args = Vx Vy Vz\n *   Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n * wiggle args = Ax Ay Az period\n *   Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n *   period = period of oscillation (time units)\n * rotate args = Px Py Pz Rx Ry Rz period\n *   Px,Py,Pz = origin point of axis of rotation (distance units)\n *   Rx,Ry,Rz = axis of rotation vector\n *   period = period of rotation (time units)\n * variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n *   v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n *   v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = box or lattice",
    "examples": "fix 1 boundary meso/move wiggle 3.0 0.0 0.0 1.0 units box\nfix 2 boundary meso/move rotate 0.0 0.0 0.0 0.0 0.0 1.0 5.0\nfix 2 boundary meso/move variable v_myx v_myy NULL v_VX v_VY NULL",
    "restrictions": "This fix is part of the USER-SDPD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nThis fix requires that atoms store density and internal energy as\ndefined by the atom_style meso command.\nAll particles in the group must be mesoscopic SPH/SDPD particles."
},
{
    "command": "fix meso/stationary",
    "html_filename": "fix_meso_stationary.html",
    "short_description": "Perform time integration to update internal energy and local density, but not position or velocity for atoms in the group each timestep",
    "description": "Perform time integration to update internal energy and local density,\nbut not position or velocity for atoms in the group each timestep.\nThis fix is needed for SPH simulations to correctly time-integrate\nfixed boundary particles which constrain a fluid to a given region in\nspace.\nSee this PDF guide to using SPH in\nLAMMPS.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID meso/stationary",
    "parameters": " * ID, group-ID are documented in fix command\n * meso = style name of this fix command",
    "examples": "fix 1 boundary meso/stationary",
    "restrictions": "This fix is part of the USER-SPH package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix_modify",
    "html_filename": "fix_modify.html",
    "short_description": "Modify one or more parameters of a previously defined fix",
    "description": "Modify one or more parameters of a previously defined fix.  Only\nspecific fix styles support specific parameters.  See the doc pages\nfor individual fix commands for info on which ones support which\nfix_modify parameters.\nThe temp keyword is used to determine how a fix computes\ntemperature.  The specified compute ID must have been previously\ndefined by the user via the compute command and it must\nbe a style of compute that calculates a temperature.  All fixes that\ncompute temperatures define their own compute by default, as described\nin their documentation.  Thus this option allows the user to override\nthe default method for computing T.\nThe press keyword is used to determine how a fix computes pressure.\nThe specified compute ID must have been previously defined by the user\nvia the compute command and it must be a style of\ncompute that calculates a pressure.  All fixes that compute pressures\ndefine their own compute by default, as described in their\ndocumentation.  Thus this option allows the user to override the\ndefault method for computing P.\nThe energy keyword can be used with fixes that support it.\nenergy yes adds a contribution to the potential energy of the\nsystem. The fix’s global and per-atom\nenergy is included in the calculation performed by the compute pe or compute pe/atom\ncommands.  See the thermo_style command for info\non how potential energy is output.  For fixes that tally a global\nenergy, it can be printed by using the keyword f_ID in the\nthermo_style custom command, where ID is the fix-ID of the appropriate\nfix.\n\nNote\nYou must also specify the energy yes setting for a fix if you\nare using it when performing an energy minimization\nand if you want the energy and forces it produces to be part of the\noptimization criteria.\n\nThe virial keyword can be used with fixes that support it.\nvirial yes adds a contribution to the virial of the\nsystem. The fix’s global and per-atom\nvirial is included in the calculation performed by the compute pressure or\ncompute stress/atom\ncommands.  See the thermo_style command for info\non how pressure is output.\n\nNote\nYou must specify the virial yes setting for a fix if you\nare doing box relaxation and\nif you want virial contribution of the fix to be part of the\nrelaxation criteria, although this seems unlikely.\n\n\nNote\nThis option is only supported by fixes that explicitly say\nso. For some of these (e.g. the fix shake command)\nthe default setting is virial yes, for others it is virial no.\n\nFor fixes that set or modify forces, it may be possible to select at\nwhich r-RESPA level the fix operates via the respa\nkeyword. The RESPA level at which the fix is active can be selected.\nThis is a number ranging from 1 to the number of levels. If the RESPA\nlevel is larger than the current maximum, the outermost level will be\nused, which is also the default setting. This default can be restored\nusing a value of 0 for the RESPA level. The affected fix has to be\nenabled to support this feature; if not, fix_modify will report an\nerror. Active fixes with a custom RESPA level setting are reported\nwith their specified level at the beginning of a r-RESPA run.\nThe dynamic/dof keyword determines whether the number of atoms N in\nthe fix group and their associated degrees of freedom are re-computed\neach time a temperature is computed.  Only fix styles that calculate\ntheir own internal temperature use this option.  Currently this is\nonly the fix rigid/nvt/small and fix rigid/npt/small commands for the purpose of\nthermostatting rigid body translation and rotation.  By default, N and\ntheir DOF are assumed to be constant.  If you are adding atoms or\nmolecules to the system (see the fix pour, fix deposit, and fix gcmc commands) or\nexpect atoms or molecules to be lost (e.g. due to exiting the\nsimulation box or via fix evaporate), then\nthis option should be used to insure the temperature is correctly\nnormalized.\n\nNote\nOther thermostatting fixes, such as fix nvt, do\nnot use the dynamic/dof keyword because they use a temperature\ncompute to calculate temperature.  See the compute_modify dynamic/dof command for a similar way to insure\ncorrect temperature normalization for those thermostats.\n\nThe bodyforces keyword determines whether the forces and torques\nacting on rigid bodies are computed early at the post-force stage of\neach timestep (right after per-atom forces have been computed and\ncommunicated among processors), or late at the final-integrate stage\nof each timestep (after any other fixes have finished their post-force\ntasks).  Only the rigid-body integration fixes use this option, which\nincludes fix rigid and fix rigid/small, and their variants, and also fix poems.\nThe default is late.  If there are other fixes that add forces to\nindividual atoms, then the rigid-body constraints will include these\nforces when time-integrating the rigid bodies.  If early is\nspecified, then new fixes can be written that use or modify the\nper-body force and torque, before time-integration of the rigid bodies\noccurs.  Note however this has the side effect, that fixes such as\nfix addforce, fix setforce,\nfix spring, which add forces to individual atoms\nwill have no effect on the motion of the rigid bodies if they are\nspecified in the input script after the fix rigid command.  LAMMPS\nwill give a warning if that is the case.",
    "syntax": "fix_modify fix-ID keyword value ...",
    "parameters": " * fix-ID = ID of the fix to modify\n * one or more keyword/value pairs may be appended\n * keyword = temp or press or energy or virial or respa or dynamic/dof or bodyforces\n * temp value = compute ID that calculates a temperature\n * press value = compute ID that calculates a pressure\n * energy value = yes or no\n * virial value = yes or no\n * respa value = 1 to max respa level or 0 (for outermost level)\n * dynamic/dof value = yes or no\n *   yes/no = do or do not re-compute the number of degrees of freedom (DOF) contributing to the temperature\n * bodyforces value = early or late\n *   early/late = compute rigid-body forces/torques early or late in the timestep",
    "examples": "fix_modify 3 temp myTemp press myPress\nfix_modify 1 energy yes\nfix_modify tether respa 2",
    "restrictions": "none"
},
{
    "command": "fix momentum",
    "html_filename": "fix_momentum.html",
    "short_description": "Zero the linear and/or angular momentum of the group of atoms every N timesteps by adjusting the velocities of the atoms",
    "description": "Zero the linear and/or angular momentum of the group of atoms every N\ntimesteps by adjusting the velocities of the atoms.  One (or both) of\nthe linear or angular keywords must be specified.\nIf the linear keyword is used, the linear momentum is zeroed by\nsubtracting the center-of-mass velocity of the group from each atom.\nThis does not change the relative velocity of any pair of atoms.  One\nor more dimensions can be excluded from this operation by setting the\ncorresponding flag to 0.\nIf the angular keyword is used, the angular momentum is zeroed by\nsubtracting a rotational component from each atom.\nThis command can be used to insure the entire collection of atoms (or\na subset of them) does not drift or rotate during the simulation due\nto random perturbations (e.g. fix langevin\nthermostatting).\nThe rescale keyword enables conserving the kinetic energy of the group\nof atoms by rescaling the velocities after the momentum was removed.\nNote that the velocity command can be used to create\ninitial velocities with zero aggregate linear and/or angular momentum.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID momentum N keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * momentum = style name of this fix command\n * N = adjust the momentum every this many timesteps\n * one or more keyword/value pairs may be appended\n * keyword = linear or angular or rescale\n * linear values = xflag yflag zflag\n *   xflag,yflag,zflag = 0/1 to exclude/include each dimension\n * angular values = none\n * rescale values = none",
    "examples": "fix 1 all momentum 1 linear 1 1 0\nfix 1 all momentum 1 linear 1 1 1 rescale\nfix 1 all momentum 100 linear 1 1 1 angular",
    "restrictions": "\nnone"
},
{
    "command": "fix move",
    "html_filename": "fix_move.html",
    "short_description": "Perform updates of position and velocity for atoms in the group each timestep using the specified settings or formulas, without regard to forces on the atoms",
    "description": "Perform updates of position and velocity for atoms in the group each\ntimestep using the specified settings or formulas, without regard to\nforces on the atoms.  This can be useful for boundary or other atoms,\nwhose movement can influence nearby atoms.\n\nNote\nThe atoms affected by this fix should not normally be time\nintegrated by other fixes (e.g. fix nve, fix nvt), since that will change their positions and\nvelocities twice.\n\n\nNote\nAs atoms move due to this fix, they will pass through periodic\nboundaries and be remapped to the other side of the simulation box,\njust as they would during normal time integration (e.g. via the fix nve command).  It is up to you to decide whether\nperiodic boundaries are appropriate with the kind of atom motion you\nare prescribing with this fix.\n\n\nNote\nAs discussed below, atoms are moved relative to their initial\nposition at the time the fix is specified.  These initial coordinates\nare stored by the fix in “unwrapped” form, by using the image flags\nassociated with each atom.  See the dump custom command\nfor a discussion of “unwrapped” coordinates.  See the Atoms section of\nthe read_data command for a discussion of image flags\nand how they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this fix by using the set image\ncommand.\n\n\nThe linear style moves atoms at a constant velocity, so that their\nposition X = (x,y,z) as a function of time is given in vector\nnotation as\nX(t) = X0 + V * delta\nwhere X0 = (x0,y0,z0) is their position at the time the fix is\nspecified, V is the specified velocity vector with components\n(Vx,Vy,Vz), and delta is the time elapsed since the fix was\nspecified.  This style also sets the velocity of each atom to V =\n(Vx,Vy,Vz).  If any of the velocity components is specified as NULL,\nthen the position and velocity of that component is time integrated\nthe same as the fix nve command would perform, using\nthe corresponding force component on the atom.\nNote that the linear style is identical to using the variable\nstyle with an equal-style variable that uses the\nvdisplace() function.  E.g.\nvariable V equal 10.0\nvariable x equal vdisplace(0.0,$V)\nfix 1 boundary move variable v_x NULL NULL v_V NULL NULL\n\n\nThe wiggle style moves atoms in an oscillatory fashion, so that\ntheir position X = (x,y,z) as a function of time is given in vector\nnotation as\nX(t) = X0 + A sin(omega*delta)\nwhere X0 = (x0,y0,z0) is their position at the time the fix is\nspecified, A is the specified amplitude vector with components\n(Ax,Ay,Az), omega is 2 PI / period, and delta is the time\nelapsed since the fix was specified.  This style also sets the\nvelocity of each atom to the time derivative of this expression.  If\nany of the amplitude components is specified as NULL, then the\nposition and velocity of that component is time integrated the same as\nthe fix nve command would perform, using the\ncorresponding force component on the atom.\nNote that the wiggle style is identical to using the variable\nstyle with equal-style variables that use the\nswiggle() and cwiggle() functions.  E.g.\nvariable A equal 10.0\nvariable T equal 5.0\nvariable omega equal 2.0*PI/$T\nvariable x equal swiggle(0.0,$A,$T)\nvariable v equal v_omega*($A-cwiggle(0.0,$A,$T))\nfix 1 boundary move variable v_x NULL NULL v_v NULL NULL\nThe rotate style rotates atoms around a rotation axis R =\n(Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The period of\nthe rotation is also specified.  The direction of rotation for the\natoms around the rotation axis is consistent with the right-hand rule:\nif your right-hand thumb points along R, then your fingers wrap\naround the axis in the direction of rotation.\nThis style also sets the velocity of each atom to (omega cross Rperp)\nwhere omega is its angular velocity around the rotation axis and Rperp\nis a perpendicular vector from the rotation axis to the atom.  If the\ndefined atom_style assigns an angular velocity or\nangular momentum or orientation to each atom (atom styles sphere, ellipsoid, line, tri, body), then\nthose properties are also updated appropriately to correspond to the\natom’s motion and rotation over time.\nThe variable style allows the position and velocity components of\neach atom to be set by formulas specified via the\nvariable command.  Each of the 6 variables is\nspecified as an argument to the fix as v_name, where name is the\nvariable name that is defined elsewhere in the input script.\nEach variable must be of either the equal or atom style.\nEqual-style variables compute a single numeric quantity, that can be\na function of the timestep as well as of other simulation values.\nAtom-style variables compute a numeric quantity for each atom, that\ncan be a function per-atom quantities, such as the atom’s position, as\nwell as of the timestep and other simulation values.  Note that this\nfix stores the original coordinates of each atom (see note below) so\nthat per-atom quantity can be used in an atom-style variable formula.\nSee the variable command for details.\nThe first 3 variables (v_dx,v_dy,v_dz) specified for the variable\nstyle are used to calculate a displacement from the atom’s original\nposition at the time the fix was specified.  The second 3 variables\n(v_vx,v_vy,v_vz) specified are used to compute a velocity for each\natom.\nAny of the 6 variables can be specified as NULL.  If both the\ndisplacement and velocity variables for a particular x,y,z component\nare specified as NULL, then the position and velocity of that\ncomponent is time integrated the same as the fix nve\ncommand would perform, using the corresponding force component on the\natom.  If only the velocity variable for a component is specified as\nNULL, then the displacement variable will be used to set the position\nof the atom, and its velocity component will not be changed.  If only\nthe displacement variable for a component is specified as NULL, then\nthe velocity variable will be used to set the velocity of the atom,\nand the position of the atom will be time integrated using that\nvelocity.\nThe units keyword determines the meaning of the distance units used\nto define the linear velocity and wiggle amplitude and rotate\norigin.  This setting is ignored for the variable style.  A box\nvalue selects standard units as defined by the units\ncommand, e.g. velocity in Angstroms/fmsec and amplitude and position\nin Angstroms for units = real.  A lattice value means the velocity\nunits are in lattice spacings per time and the amplitude and position\nare in lattice spacings.  The lattice command must have\nbeen previously used to define the lattice spacing.  Each of these 3\nquantities may be dependent on the x,y,z dimension, since the lattice\nspacings can be different in x,y,z.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the original coordinates of moving atoms to binary restart files, as well as the initial timestep, so that\nthe motion can be continuous in a restarted simulation.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\n\nNote\nBecause the move positions are a function of the current\ntimestep and the initial timestep, you cannot reset the timestep to a\ndifferent value after reading a restart file, if you expect a fix move\ncommand to work in an uninterrupted fashion.\n\nNone of the fix_modify options are relevant to this\nfix.\nThis fix produces a per-atom array which can be accessed by various\noutput commands.  The number of columns for each\natom is 3, and the columns store the original unwrapped x,y,z coords\nof each atom.  The per-atom values can be accessed on any timestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\nFor rRESPA time integration, this fix adjusts the\nposition and velocity of atoms on the outermost rRESPA level.",
    "syntax": "fix ID group-ID move style args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * move = style name of this fix command\n * style = linear or wiggle or rotate or variable\n * linear args = Vx Vy Vz\n *   Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n * wiggle args = Ax Ay Az period\n *   Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n *   period = period of oscillation (time units)\n * rotate args = Px Py Pz Rx Ry Rz period\n *   Px,Py,Pz = origin point of axis of rotation (distance units)\n *   Rx,Ry,Rz = axis of rotation vector\n *   period = period of rotation (time units)\n * variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n *   v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n *   v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = box or lattice",
    "examples": "fix 1 boundary move wiggle 3.0 0.0 0.0 1.0 units box\nfix 2 boundary move rotate 0.0 0.0 0.0 0.0 0.0 1.0 5.0\nfix 2 boundary move variable v_myx v_myy NULL v_VX v_VY NULL",
    "restrictions": "\nnone"
},
{
    "command": "fix mscg",
    "html_filename": "fix_mscg.html",
    "short_description": "This fix applies the Multi-Scale Coarse-Graining (MSCG) method to snapshots from a dump file to generate potentials for coarse-grained simulations from all-atom simulations, using a force-matching technique (Izvekov, Noid)",
    "description": "This fix applies the Multi-Scale Coarse-Graining (MSCG) method to\nsnapshots from a dump file to generate potentials for coarse-grained\nsimulations from all-atom simulations, using a force-matching\ntechnique (Izvekov, Noid).\nIt makes use of the MS-CG library, written and maintained by Greg\nVoth’s group at the University of Chicago, which is freely available\non their MS-CG GitHub site.  See instructions\non obtaining and installing the MS-CG library in the src/MSCG/README\nfile, which must be done before you build LAMMPS with this fix command\nand use the command in a LAMMPS input script.\nAn example script using this fix is provided the examples/mscg\ndirectory.\nThe general workflow for using LAMMPS in conjunction with the MS-CG\nlibrary to create a coarse-grained model and run coarse-grained\nsimulations is as follows:\n\nPerform all-atom simulations on the system to be coarse grained.\nGenerate a trajectory mapped to the coarse-grained model.\nCreate input files for the MS-CG library.\nRun the range finder functionality of the MS-CG library.\nRun the force matching functionality of the MS-CG library.\nCheck the results of the force matching.\nRun coarse-grained simulations using the new coarse-grained potentials.\n\nThis fix can perform the range finding and force matching steps 4 and\n5 of the above workflow when used in conjunction with the\nrerun command.  It does not perform steps 1-3 and 6-7.\nStep 2 can be performed using a Python script (what is the name?)\nprovided with the MS-CG library which defines the coarse-grained model\nand converts a standard LAMMPS dump file for an all-atom simulation\n(step 1) into a LAMMPS dump file which has the positions of and forces\non the coarse-grained beads.\nIn step 3, an input file named “control.in” is needed by the MS-CG\nlibrary which sets parameters for the range finding and force matching\nfunctionalities.  See the examples/mscg/control.in file as an example.\nAnd see the documentation provided with the MS-CG library for more\ninfo on this file.\nWhen this fix is used to perform steps 4 and 5, the MS-CG library also\nproduces additional output files.  The range finder functionality\n(step 4) outputs files defining pair and bonded interaction ranges.\nThe force matching functionality (step 5) outputs tabulated force\nfiles for every interaction in the system. Other diagnostic files can\nalso be output depending on the parameters in the MS-CG library input\nscript.  Again, see the documentation provided with the MS-CG library\nfor more info.\n\nThe range keyword specifies which MS-CG library functionality should\nbe invoked. If on, the step 4 range finder functionality is invoked.\noff, the step 5 force matching functionality is invoked.\nIf the name keyword is used, string names are defined to associate\nwith the integer atom types in LAMMPS.  Ntype names must be\nprovided, one for each atom type (1-Ntype).\nThe max keyword specifies the maximum number of bonds, angles, and\ndihedrals a bead can have in the coarse-grained model.",
    "syntax": "fix ID group-ID mscg N keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * mscg = style name of this fix command\n * N = envoke this fix every this many timesteps\n * zero or more keyword/value pairs may be appended\n * keyword = range or name or max\n * range arg = on or off\n *   on = range finding functionality is performed\n *   off = force matching functionality is performed\n * name args = name1 ... nameN\n *   name1,...,nameN = string names for each atom type (1-Ntype)\n * max args = maxb maxa maxd\n *   maxb,maxa,maxd = maximum bonds/angles/dihedrals per atom",
    "examples": "fix 1 all mscg 1\nfix 1 all mscg 1 range name A B\nfix 1 all mscg 1 max 4 8 20",
    "restrictions": "This fix is part of the MSCG package. It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info.\nThe MS-CG library uses C++11, which may not be supported by older\ncompilers. The MS-CG library also has some additional numeric library\ndependencies, which are described in its documentation.\nCurrently, the MS-CG library is not setup to run in parallel with MPI,\nso this fix can only be used in a serial LAMMPS build and run\non a single processor.\nRelated commands: none"
},
{
    "command": "fix msst",
    "html_filename": "fix_msst.html",
    "short_description": "This command performs the Multi-Scale Shock Technique (MSST) integration to update positions and velocities each timestep to mimic a compressive shock wave passing over the system",
    "description": "This command performs the Multi-Scale Shock Technique (MSST)\nintegration to update positions and velocities each timestep to mimic\na compressive shock wave passing over the system. See (Reed)\nfor a detailed description of this method.  The MSST varies the cell\nvolume and temperature in such a way as to restrain the system to the\nshock Hugoniot and the Rayleigh line. These restraints correspond to\nthe macroscopic conservation laws dictated by a shock\nfront. shockvel determines the steady shock velocity that will be\nsimulated.\nTo perform a simulation, choose a value of q that provides volume\ncompression on the timescale of 100 fs to 1 ps.  If the volume is not\ncompressing, either the shock speed is chosen to be below the material\nsound speed or p0 has been chosen inaccurately.  Volume compression\nat the start can be sped up by using a non-zero value of tscale. Use\nthe smallest value of tscale that results in compression.\nUnder some special high-symmetry conditions, the pressure (volume)\nand/or temperature of the system may oscillate for many cycles even\nwith an appropriate choice of mass-like parameter q. Such\noscillations have physical significance in some cases.  The optional\nmu keyword adds an artificial viscosity that helps break the system\nsymmetry to equilibrate to the shock Hugoniot and Rayleigh line more\nrapidly in such cases.\nThe keyword tscale is a factor between 0 and 1 that determines what\nfraction of thermal kinetic energy is converted to compressive strain\nkinetic energy at the start of the simulation.  Setting this parameter\nto a non-zero value may assist in compression at the start of\nsimulations where it is slow to occur.\nIf keywords e0, p0,or v0 are not supplied, these quantities will\nbe calculated on the first step, after the energy specified by\ntscale is removed.  The value of e0 is not used in the dynamical\nequations, but is used in calculating the deviation from the Hugoniot.\nThe keyword beta is a scaling term that can be added to the MSST\nionic equations of motion to account for drift in the conserved\nquantity during long timescale simulations, similar to a Berendsen\nthermostat. See (Reed) and (Goldman) for more\ndetails.  The value of beta must be between 0.0 and 1.0 inclusive.\nA value of 0.0 means no contribution, a value of 1.0 means a full\ncontribution.\nValues of shockvel less than a critical value determined by the\nmaterial response will not have compressive solutions. This will be\nreflected in lack of significant change of the volume in the MSST.\nFor all pressure styles, the simulation box stays orthogonal in shape.\nParrinello-Rahman boundary conditions (tilted box) are supported by\nLAMMPS, but are not implemented for MSST.\nThis fix computes a temperature and pressure and potential energy each\ntimestep. To do this, the fix creates its own computes of style “temp”\n“pressure”, and “pe”, as if these commands had been issued:\ncompute fix-ID_MSST_temp all temp\ncompute fix-ID_MSST_press all pressure fix-ID_MSST_temp\n\ncompute fix-ID_MSST_pe all pe\n\n\nSee the compute temp and compute pressure commands for details.  Note that the IDs of the\nnew computes are the fix-ID + “_MSST_temp” or “MSST_press” or\n“_MSST_pe”.  The group for the new computes is “all”.\n\nThe dftb keyword is to allow this fix to be used when LAMMPS is\nbeing driven by DFTB+, a density-functional tight-binding code. If the\nkeyword dftb is used with a value of yes, then the MSST equations\nare altered to account for the electron entropy contribution to the\nHugonio relations and total energy.  See (Reed2) and\n(Goldman) for details on this contribution.  In this case,\nyou must define a fix external command in your\ninput script, which is used to callback to DFTB+ during the LAMMPS\ntimestepping.  DFTB+ will communicate its info to LAMMPS via that fix.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of all internal variables to binary\nrestart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe progress of the MSST can be monitored by printing the global\nscalar and global vector quantities computed by the fix.\nThe scalar is the cumulative energy change due to the fix. This is\nalso the energy added to the potential energy by the\nfix_modify energy command.  With this command, the\nthermo keyword etotal prints the conserved quantity of the MSST\ndynamic equations. This can be used to test if the MD timestep is\nsufficiently small for accurate integration of the dynamic\nequations. See also thermo_style command.\nThe global vector contains four values in this order:\n[dhugoniot, drayleigh, lagrangian_speed, lagrangian_position]\n\ndhugoniot is the departure from the Hugoniot (temperature units).\ndrayleigh is the departure from the Rayleigh line (pressure units).\nlagrangian_speed is the laboratory-frame Lagrangian speed (particle velocity) of the computational cell (velocity units).\nlagrangian_position is the computational cell position in the reference frame moving at the shock speed. This is usually a good estimate of distance of the computational cell behind the shock front.\n\nTo print these quantities to the log file with descriptive column\nheaders, the following LAMMPS commands are suggested:\nfix              msst all msst z\nfix_modify       msst energy yes\nvariable dhug    equal f_msst[1]\nvariable dray    equal f_msst[2]\nvariable lgr_vel equal f_msst[3]\nvariable lgr_pos equal f_msst[4]\nthermo_style     custom step temp ke pe lz pzz etotal v_dhug v_dray v_lgr_vel v_lgr_pos f_msst\n\n\nThese fixes compute a global scalar and a global vector of 4\nquantities, which can be accessed by various output commands.  The scalar values calculated by this fix are\n“extensive”; the vector values are “intensive”.",
    "syntax": "fix ID group-ID msst dir shockvel keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * msst = style name of this fix\n * dir = x or y or z\n * shockvel = shock velocity (strictly positive, distance/time units)\n * zero or more keyword value pairs may be appended\n * keyword = q or mu or p0 or v0 or e0 or tscale or beta or dftb\n * q value = cell mass-like parameter (mass^2/distance^4 units)\n * mu value = artificial viscosity (mass/length/time units)\n * p0 value = initial pressure in the shock equations (pressure units)\n * v0 value = initial simulation cell volume in the shock equations (distance^3 units)\n * e0 value = initial total energy (energy units)\n * tscale value = reduction in initial temperature (unitless fraction between 0.0 and 1.0)\n * dftb value = yes or no for whether using MSST in conjunction with DFTB+\n * beta value = scale factor for improved energy conservation",
    "examples": "fix 1 all msst y 100.0 q 1.0e5 mu 1.0e5\nfix 2 all msst z 50.0 q 1.0e4 mu 1.0e4  v0 4.3419e+03 p0 3.7797e+03 e0 -9.72360e+02 tscale 0.01\nfix 1 all msst y 100.0 q 1.0e5 mu 1.0e5 dftb yes beta 0.5",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nAll cell dimensions must be periodic. This fix can not be used with a\ntriclinic cell.  The MSST fix has been tested only for the group-ID\nall."
},
{
    "command": "fix mvv/dpd",
    "html_filename": "fix_mvv_dpd.html",
    "short_description": "Perform time integration using the modified velocity-Verlet (MVV) algorithm to update position and velocity (fix mvv/dpd), or position, velocity and temperature (fix mvv/edpd), or position, velocity and concentration (fix mvv/tdpd) for particles in the group each timestep",
    "description": "Perform time integration using the modified velocity-Verlet (MVV)\nalgorithm to update position and velocity (fix mvv/dpd), or position,\nvelocity and temperature (fix mvv/edpd), or position, velocity and\nconcentration (fix mvv/tdpd) for particles in the group each timestep.\nThe modified velocity-Verlet (MVV) algorithm aims to improve the\nstability of the time integrator by using an extrapolated version of\nthe velocity for the force evaluation:\n\n\\[\\begin{split}v(t+\\frac{\\Delta t}{2}) = & v(t) + \\frac{\\Delta t}{2}\\cdot a(t) \\\\\nr(t+\\Delta t) = & r(t) + \\Delta t\\cdot v(t+\\frac{\\Delta t}{2}) \\\\\na(t+\\Delta t) = & \\frac{1}{m}\\cdot F\\left[ r(t+\\Delta t), v(t) +\\lambda \\cdot \\Delta t\\cdot a(t)\\right] \\\\\nv(t+\\Delta t) = & v(t+\\frac{\\Delta t}{2}) + \\frac{\\Delta t}{2}\\cdot a(t+\\Delta t)\\end{split}\\]\nwhere the parameter \\(\\lambda\\) depends on the\nspecific choice of DPD parameters, and needs to be tuned on a\ncase-by-case basis.  Specification of a lambda value is optional.\nIf specified, the setting must be from 0.0 to 1.0.  If not specified,\na default value of 0.5 is used, which effectively reproduces the\nstandard velocity-Verlet (VV) scheme.  For more details, see\nGroot.\nFix mvv/dpd updates the position and velocity of each atom.  It can\nbe used with the pair_style mdpd command or other\npair styles such as pair dpd.\nFix mvv/edpd updates the per-atom temperature, in addition to\nposition and velocity, and must be used with the pair_style edpd command.\nFix mvv/tdpd updates the per-atom chemical concentration, in\naddition to position and velocity, and must be used with the\npair_style tdpd command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID mvv/dpd lambda",
    "parameters": " * fix ID group-ID mvv/edpd lambda\n * fix ID group-ID mvv/tdpd lambda\n * ID, group-ID are documented in fix command\n * mvv/dpd, mvv/edpd, mvv/tdpd = style name of this fix command\n * lambda = (optional) relaxation parameter (unitless)",
    "examples": "fix 1 all mvv/dpd\nfix 1 all mvv/dpd 0.5\nfix 1 all mvv/edpd\nfix 1 all mvv/edpd 0.5\nfix 1 all mvv/tdpd\nfix 1 all mvv/tdpd 0.5",
    "restrictions": "This fix is part of the USER-MESO package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "fix neb",
    "html_filename": "fix_neb.html",
    "short_description": "Add nudging forces to atoms in the group for a multi-replica simulation run via the neb command to perform a nudged elastic band (NEB) calculation for finding the transition state",
    "description": "Add nudging forces to atoms in the group for a multi-replica\nsimulation run via the neb command to perform a nudged\nelastic band (NEB) calculation for finding the transition state.\nHi-level explanations of NEB are given with the neb command\nand on the Howto replica doc page.  The fix neb\ncommand must be used with the “neb” command and defines how\ninter-replica nudging forces are computed.  A NEB calculation is\ndivided in two stages. In the first stage n replicas are relaxed\ntoward a MEP until convergence.  In the second stage, the climbing\nimage scheme (see (Henkelman2)) is enabled, so that the\nreplica having the highest energy relaxes toward the saddle point\n(i.e. the point of highest energy along the MEP), and a second\nrelaxation is performed.\nA key purpose of the nudging forces is to keep the replicas equally\nspaced.  During the NEB calculation, the 3N-length vector of\ninteratomic force Fi = -Grad(V) for each replica I is altered.  For\nall intermediate replicas (i.e. for 1 < I < N, except the climbing\nreplica) the force vector becomes:\nFi = -Grad(V) + (Grad(V) dot T') T' + Fnudge_parallel + Fnudge_perp\n\n\nT’ is the unit “tangent” vector for replica I and is a function of Ri,\nRi-1, Ri+1, and the potential energy of the 3 replicas; it points\nroughly in the direction of (Ri+i - Ri-1); see the\n(Henkelman1) paper for details.  Ri are the atomic\ncoordinates of replica I; Ri-1 and Ri+1 are the coordinates of its\nneighbor replicas.  The term (Grad(V) dot T’) is used to remove the\ncomponent of the gradient parallel to the path which would tend to\ndistribute the replica unevenly along the path.  Fnudge_parallel is an\nartificial nudging force which is applied only in the tangent\ndirection and which maintains the equal spacing between replicas (see\nbelow for more information).  Fnudge_perp is an optional artificial\nspring which is applied in a direction perpendicular to the tangent\ndirection and which prevent the paths from forming acute kinks (see\nbelow for more information).\nIn the second stage of the NEB calculation, the interatomic force Fi\nfor the climbing replica (the replica of highest energy after the\nfirst stage) is changed to:\nFi = -Grad(V) + 2 (Grad(V) dot T') T'\n\n\nand the relaxation procedure is continued to a new converged MEP.\n\nThe keyword parallel specifies how the parallel nudging force is\ncomputed.  With a value of neigh, the parallel nudging force is\ncomputed as in (Henkelman1) by connecting each\nintermediate replica with the previous and the next image:\nFnudge_parallel = Kspring * (|Ri+1 - Ri| - |Ri - Ri-1|)\nNote that in this case the specified Kspring is in force/distance\nunits.\nWith a value of ideal, the spring force is computed as suggested in\nref`(WeinanE) <WeinanE>`\nFnudge_parallel = -Kspring * (RD-RDideal) / (2 * meanDist)\nwhere RD is the “reaction coordinate” see neb section, and\nRDideal is the ideal RD for which all the images are equally spaced.\nI.e. RDideal = (I-1)*meanDist when the climbing replica is off, where\nI is the replica number).  The meanDist is the average distance\nbetween replicas.  Note that in this case the specified Kspring is\nin force units.\nNote that the ideal form of nudging can often be more effective at\nkeeping the replicas equally spaced.\n\nThe keyword perp specifies if and how a perpendicular nudging force\nis computed.  It adds a spring force perpendicular to the path in\norder to prevent the path from becoming too strongly kinked.  It can\nsignificantly improve the convergence of the NEB calculation when the\nresolution is poor.  I.e. when few replicas are used; see\n(Maras) for details.\nThe perpendicular spring force is given by\nFnudge_perp = Kspring2 * F(Ri-1,Ri,Ri+1) (Ri+1 + Ri-1 - 2 Ri)\nwhere Kspring2 is the specified value.  F(Ri-1 Ri R+1) is a smooth\nscalar function of the angle Ri-1 Ri Ri+1.  It is equal to 0.0 when\nthe path is straight and is equal to 1 when the angle Ri-1 Ri Ri+1 is\nacute.  F(Ri-1 Ri R+1) is defined in (Jonsson).\nIf Kspring2 is set to 0.0 (the default) then no perpendicular spring\nforce is added.\n\nBy default, no additional forces act on the first and last replicas\nduring the NEB relaxation, so these replicas simply relax toward their\nrespective local minima.  By using the key word end, additional\nforces can be applied to the first and/or last replicas, to enable\nthem to relax toward a MEP while constraining their energy E to the\ntarget energy ETarget.\nIf ETarget>E, the interatomic force Fi for the specified replica becomes:\nFi = -Grad(V) + (Grad(V) dot T' + (E-ETarget)*Kspring3) T',  when Grad(V) dot T' < 0\nFi = -Grad(V) + (Grad(V) dot T' + (ETarget- E)*Kspring3) T', when Grad(V) dot T' > 0\nThe “spring” constant on the difference in energies is the specified\nKspring3 value.\nWhen estyle is specified as first, the force is applied to the\nfirst replica.  When estyle is specified as last, the force is\napplied to the last replica.  Note that the end keyword can be used\ntwice to add forces to both the first and last replicas.\nFor both these estyle settings, the target energy ETarget is set\nto the initial energy of the replica (at the start of the NEB\ncalculation).\nIf the estyle is specified as last/efirst or last/efirst/middle,\nforce is applied to the last replica, but the target energy ETarget\nis continuously set to the energy of the first replica, as it evolves\nduring the NEB relaxation.\nThe difference between these two estyle options is as follows.  When\nestyle is specified as last/efirst, no change is made to the\ninter-replica force applied to the intermediate replicas (neither\nfirst or last).  If the initial path is too far from the MEP, an\nintermediate replica may relax “faster” and reach a lower energy than\nthe last replica.  In this case the intermediate replica will be\nrelaxing toward its own local minima.  This behavior can be prevented\nby specifying estyle as last/efirst/middle which will alter the\ninter-replica force applied to intermediate replicas by removing the\ncontribution of the gradient to the inter-replica force.  This will\nonly be done if a particular intermediate replica has a lower energy\nthan the first replica.  This should effectively prevent the\nintermediate replicas from over-relaxing.\nAfter converging a NEB calculation using an estyle of\nlast/efirst/middle, you should check that all intermediate replicas\nhave a larger energy than the first replica. If this is not the case,\nthe path is probably not a MEP.\nFinally, note that the last replica may never reach the target energy\nif it is stuck in a local minima which has a larger energy than the\ntarget energy.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\nas invoked by the minimize command via the\nneb command.",
    "syntax": "fix ID group-ID neb Kspring keyword value",
    "parameters": " * ID, group-ID are documented in fix command\n * neb = style name of this fix command\n * Kspring = spring constant for parallel nudging force (force/distance units or force units, see parallel keyword)\n * zero or more keyword/value pairs may be appended\n * keyword = parallel or perp or end\n * parallel value = neigh or ideal\n *   neigh = parallel nudging force based on distance to neighbor replicas (Kspring = force/distance units)\n *   ideal = parallel nudging force based on interpolated ideal position (Kspring = force units)\n * perp value = Kspring2\n *   Kspring2 = spring constant for perpendicular nudging force (force/distance units)\n * end values = estyle Kspring3\n *   estyle = first or last or last/efirst or last/efirst/middle\n *     first = apply force to first replica\n *     last = apply force to last replica\n *     last/efirst = apply force to last replica and set its target energy to that of first replica\n *     last/efirst/middle = same as last/efirst plus prevent middle replicas having lower energy than first replica\n *   Kspring3 = spring constant for target energy term (1/distance units)",
    "examples": "fix 1 active neb 10.0\nfix 2 all neb 1.0 perp 1.0 end last\nfix 2 all neb 1.0 perp 1.0 end first 1.0 end last 1.0\nfix 1 all neb 1.0 parallel ideal end last/efirst 1",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "fix neb/spin",
    "html_filename": "fix_neb_spin.html",
    "short_description": "Add nudging forces to spins in the group for a multi-replica simulation run via the neb/spin command to perform a geodesic nudged elastic band (GNEB) calculation for finding the transition state",
    "description": "Add nudging forces to spins in the group for a multi-replica\nsimulation run via the neb/spin command to perform a\ngeodesic nudged elastic band (GNEB) calculation for finding the\ntransition state.\nHi-level explanations of GNEB are given with the\nneb/spin command and on the\nHowto replica doc page.\nThe fix neb/spin command must be used with the “neb/spin” command and\ndefines how inter-replica nudging forces are computed.  A GNEB\ncalculation is divided in two stages. In the first stage n replicas\nare relaxed toward a MEP until convergence.  In the second stage, the\nclimbing image scheme is enabled, so that the replica having the highest\nenergy relaxes toward the saddle point (i.e. the point of highest energy\nalong the MEP), and a second relaxation is performed.\nThe nudging forces are calculated as explained in\n(BessarabB)).\nSee this reference for more explanation about their expression.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\nas invoked by the minimize command via the\nneb/spin command.",
    "syntax": "fix ID group-ID neb/spin Kspring",
    "parameters": " * ID, group-ID are documented in fix command\n * neb/spin = style name of this fix command\n * Kspring = spring constant for parallel nudging force\n * (force/distance units or force units, see parallel keyword)",
    "examples": "fix 1 active neb/spin 1.0",
    "restrictions": "This command can only be used if LAMMPS was built with the SPIN\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "fix nvt",
    "html_filename": "fix_nh.html",
    "short_description": "These commands perform time integration on Nose-Hoover style non-Hamiltonian equations of motion which are designed to generate positions and velocities sampled from the canonical (nvt), isothermal-isobaric (npt), and isenthalpic (nph) ensembles",
    "description": "These commands perform time integration on Nose-Hoover style\nnon-Hamiltonian equations of motion which are designed to generate\npositions and velocities sampled from the canonical (nvt),\nisothermal-isobaric (npt), and isenthalpic (nph) ensembles.  This\nupdates the position and velocity for atoms in the group each\ntimestep.\nThe thermostatting and barostatting is achieved by adding some dynamic\nvariables which are coupled to the particle velocities\n(thermostatting) and simulation domain dimensions (barostatting).  In\naddition to basic thermostatting and barostatting, these fixes can\nalso create a chain of thermostats coupled to the particle thermostat,\nand another chain of thermostats coupled to the barostat\nvariables. The barostat can be coupled to the overall box volume, or\nto individual dimensions, including the xy, xz and yz tilt\ndimensions. The external pressure of the barostat can be specified as\neither a scalar pressure (isobaric ensemble) or as components of a\nsymmetric stress tensor (constant stress ensemble).  When used\ncorrectly, the time-averaged temperature and stress tensor of the\nparticles will match the target values specified by Tstart/Tstop and\nPstart/Pstop.\nThe equations of motion used are those of Shinoda et al in\n(Shinoda), which combine the hydrostatic equations of\nMartyna, Tobias and Klein in (Martyna) with the strain\nenergy proposed by Parrinello and Rahman in\n(Parrinello).  The time integration schemes closely\nfollow the time-reversible measure-preserving Verlet and rRESPA\nintegrators derived by Tuckerman et al in (Tuckerman).\n\nThe thermostat parameters for fix styles nvt and npt are specified\nusing the temp keyword.  Other thermostat-related keywords are\ntchain, tloop and drag, which are discussed below.\nThe thermostat is applied to only the translational degrees of freedom\nfor the particles.  The translational degrees of freedom can also have\na bias velocity removed before thermostatting takes place; see the\ndescription below.  The desired temperature at each timestep is a\nramped value during the run from Tstart to Tstop.  The Tdamp\nparameter is specified in time units and determines how rapidly the\ntemperature is relaxed.  For example, a value of 10.0 means to relax\nthe temperature in a timespan of (roughly) 10 time units (e.g. tau or\nfmsec or psec - see the units command).  The atoms in the\nfix group are the only ones whose velocities and positions are updated\nby the velocity/position update portion of the integration.\n\nNote\nA Nose-Hoover thermostat will not work well for arbitrary values\nof Tdamp.  If Tdamp is too small, the temperature can fluctuate\nwildly; if it is too large, the temperature will take a very long time\nto equilibrate.  A good choice for many models is a Tdamp of around\n100 timesteps.  Note that this is NOT the same as 100 time units for\nmost units settings. A simple way to ensure this, is\nvia using an immediate variable expression accessing\nthe thermo property ‘dt’, which is the length of the time step. Example:\n\nfix 1 all nvt temp 300.0 300.0 $(100.0*dt)\n\nThe barostat parameters for fix styles npt and nph is specified\nusing one or more of the iso, aniso, tri, x, y, z, xy,\nxz, yz, and couple keywords.  These keywords give you the\nability to specify all 6 components of an external stress tensor, and\nto couple various of these components together so that the dimensions\nthey represent are varied together during a constant-pressure\nsimulation.\nOther barostat-related keywords are pchain, mtk, ploop,\nnreset, drag, and dilate, which are discussed below.\nOrthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\nTriclinic (non-orthogonal) simulation boxes have 6 adjustable\ndimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\nspecify whether the simulation box is orthogonal or non-orthogonal\n(triclinic) and explain the meaning of the xy,xz,yz tilt factors.\nThe target pressures for each of the 6 components of the stress tensor\ncan be specified independently via the x, y, z, xy, xz, yz\nkeywords, which correspond to the 6 simulation box dimensions.  For\neach component, the external pressure or tensor component at each\ntimestep is a ramped value during the run from Pstart to Pstop.\nIf a target pressure is specified for a component, then the\ncorresponding box dimension will change during a simulation.  For\nexample, if the y keyword is used, the y-box length will change.  If\nthe xy keyword is used, the xy tilt factor will change.  A box\ndimension will not change if that component is not specified, although\nyou have the option to change that dimension via the fix deform command.\nNote that in order to use the xy, xz, or yz keywords, the\nsimulation box must be triclinic, even if its initial tilt factors are\n0.0.\nFor all barostat keywords, the Pdamp parameter operates like the\nTdamp parameter, determining the time scale on which pressure is\nrelaxed.  For example, a value of 10.0 means to relax the pressure in\na timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\nthe units command).\n\nNote\nA Nose-Hoover barostat will not work well for arbitrary values\nof Pdamp.  If Pdamp is too small, the pressure and volume can\nfluctuate wildly; if it is too large, the pressure will take a very\nlong time to equilibrate.  A good choice for many models is a Pdamp\nof around 1000 timesteps.  However, note that Pdamp is specified in\ntime units, and that timesteps are NOT the same as time units for most\nunits settings.\n\nRegardless of what atoms are in the fix group (the only atoms which\nare time integrated), a global pressure or stress tensor is computed\nfor all atoms.  Similarly, when the size of the simulation box is\nchanged, all atoms are re-scaled to new positions, unless the keyword\ndilate is specified with a dilate-group-ID for a group that\nrepresents a subset of the atoms.  This can be useful, for example, to\nleave the coordinates of atoms in a solid substrate unchanged and\ncontrolling the pressure of a surrounding fluid.  This option should\nbe used with care, since it can be unphysical to dilate some atoms and\nnot others, because it can introduce large, instantaneous\ndisplacements between a pair of atoms (one dilated, one not) that are\nfar from the dilation origin.  Also note that for atoms not in the fix\ngroup, a separate time integration fix like fix nve or\nfix nvt can be used on them, independent of whether they\nare dilated or not.\n\nThe couple keyword allows two or three of the diagonal components of\nthe pressure tensor to be “coupled” together.  The value specified\nwith the keyword determines which are coupled.  For example, xz\nmeans the Pxx and Pzz components of the stress tensor are coupled.\nXyz means all 3 diagonal components are coupled.  Coupling means two\nthings: the instantaneous stress will be computed as an average of the\ncorresponding diagonal components, and the coupled box dimensions will\nbe changed together in lockstep, meaning coupled dimensions will be\ndilated or contracted by the same percentage every timestep.  The\nPstart, Pstop, Pdamp parameters for any coupled dimensions must\nbe identical.  Couple xyz can be used for a 2d simulation; the z\ndimension is simply ignored.\n\nThe iso, aniso, and tri keywords are simply shortcuts that are\nequivalent to specifying several other keywords together.\nThe keyword iso means couple all 3 diagonal components together when\npressure is computed (hydrostatic pressure), and dilate/contract the\ndimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\nspecifying these 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple xyz\n\n\nThe keyword aniso means x, y, and z dimensions are controlled\nindependently using the Pxx, Pyy, and Pzz components of the\nstress tensor as the driving forces, and the specified scalar external\npressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\nthese 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple none\n\n\nThe keyword tri means x, y, z, xy, xz, and yz dimensions\nare controlled independently using their individual stress components\nas the driving forces, and the specified scalar pressure as the\nexternal normal stress.  Using “tri Pstart Pstop Pdamp” is the same as\nspecifying these 7 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\nxy 0.0 0.0 Pdamp\nyz 0.0 0.0 Pdamp\nxz 0.0 0.0 Pdamp\ncouple none\n\n\n\nIn some cases (e.g. for solids) the pressure (volume) and/or\ntemperature of the system can oscillate undesirably when a Nose/Hoover\nbarostat and thermostat is applied.  The optional drag keyword will\ndamp these oscillations, although it alters the Nose/Hoover equations.\nA value of 0.0 (no drag) leaves the Nose/Hoover formalism unchanged.\nA non-zero value adds a drag term; the larger the value specified, the\ngreater the damping effect.  Performing a short run and monitoring the\npressure and temperature is the best way to determine if the drag term\nis working.  Typically a value between 0.2 to 2.0 is sufficient to\ndamp oscillations after a few periods. Note that use of the drag\nkeyword will interfere with energy conservation and will also change\nthe distribution of positions and velocities so that they do not\ncorrespond to the nominal NVT, NPT, or NPH ensembles.\nAn alternative way to control initial oscillations is to use chain\nthermostats. The keyword tchain determines the number of thermostats\nin the particle thermostat. A value of 1 corresponds to the original\nNose-Hoover thermostat. The keyword pchain specifies the number of\nthermostats in the chain thermostatting the barostat degrees of\nfreedom. A value of 0 corresponds to no thermostatting of the\nbarostat variables.\nThe mtk keyword controls whether or not the correction terms due to\nMartyna, Tuckerman, and Klein are included in the equations of motion\n(Martyna).  Specifying no reproduces the original\nHoover barostat, whose volume probability distribution function\ndiffers from the true NPT and NPH ensembles by a factor of 1/V.  Hence\nusing yes is more correct, but in many cases the difference is\nnegligible.\nThe keyword tloop can be used to improve the accuracy of integration\nscheme at little extra cost.  The initial and final updates of the\nthermostat variables are broken up into tloop sub-steps, each of\nlength dt/tloop. This corresponds to using a first-order\nSuzuki-Yoshida scheme (Tuckerman).  The keyword ploop\ndoes the same thing for the barostat thermostat.\nThe keyword nreset controls how often the reference dimensions used\nto define the strain energy are reset.  If this keyword is not used,\nor is given a value of zero, then the reference dimensions are set to\nthose of the initial simulation domain and are never changed. If the\nsimulation domain changes significantly during the simulation, then\nthe final average pressure tensor will differ significantly from the\nspecified values of the external stress tensor.  A value of nstep\nmeans that every nstep timesteps, the reference dimensions are set\nto those of the current simulation domain.\nThe scaleyz, scalexz, and scalexy keywords control whether or\nnot the corresponding tilt factors are scaled with the associated box\ndimensions when barostatting triclinic periodic cells.  The default\nvalues yes will turn on scaling, which corresponds to adjusting the\nlinear dimensions of the cell while preserving its shape.  Choosing\nno ensures that the tilt factors are not scaled with the box\ndimensions. See below for restrictions and default values in different\nsituations. In older versions of LAMMPS, scaling of tilt factors was\nnot performed. The old behavior can be recovered by setting all three\nscale keywords to no.\nThe flip keyword allows the tilt factors for a triclinic box to\nexceed half the distance of the parallel box length, as discussed\nbelow.  If the flip value is set to yes, the bound is enforced by\nflipping the box when it is exceeded.  If the flip value is set to\nno, the tilt will continue to change without flipping.  Note that if\napplied stress induces large deformations (e.g. in a liquid), this\nmeans the box shape can tilt dramatically and LAMMPS will run less\nefficiently, due to the large volume of communication needed to\nacquire ghost atoms around a processor’s irregular-shaped sub-domain.\nFor extreme values of tilt, LAMMPS may also lose atoms and generate an\nerror.\nThe fixedpoint keyword specifies the fixed point for barostat volume\nchanges. By default, it is the center of the box.  Whatever point is\nchosen will not move during the simulation.  For example, if the lower\nperiodic boundaries pass through (0,0,0), and this point is provided\nto fixedpoint, then the lower periodic boundaries will remain at\n(0,0,0), while the upper periodic boundaries will move twice as\nfar. In all cases, the particle trajectories are unaffected by the\nchosen value, except for a time-dependent constant translation of\npositions.\nIf the update keyword is used with the dipole value, then the\norientation of the dipole moment of each particle is also updated\nduring the time integration.  This option should be used for models\nwhere a dipole moment is assigned to finite-size particles,\ne.g. spheroids via use of the atom_style hybrid sphere dipole command.\nThe default dipole orientation integrator can be changed to the\nDullweber-Leimkuhler-McLachlan integration scheme\n(Dullweber) when using update with the value\ndipole/dlm. This integrator is symplectic and time-reversible,\ngiving better energy conservation and allows slightly longer timesteps\nat only a small additional computational cost.\n\n\nNote\nUsing a barostat coupled to tilt dimensions xy, xz, yz can\nsometimes result in arbitrarily large values of the tilt dimensions,\ni.e. a dramatically deformed simulation box.  LAMMPS allows the tilt\nfactors to grow a small amount beyond the normal limit of half the box\nlength (0.6 times the box length), and then performs a box “flip” to\nan equivalent periodic cell.  See the discussion of the flip keyword\nabove, to allow this bound to be exceeded, if desired.\n\nThe flip operation is described in more detail in the doc page for\nfix deform.  Both the barostat dynamics and the atom\ntrajectories are unaffected by this operation.  However, if a tilt\nfactor is incremented by a large amount (1.5 times the box length) on\na single timestep, LAMMPS can not accommodate this event and will\nterminate the simulation with an error. This error typically indicates\nthat there is something badly wrong with how the simulation was\nconstructed, such as specifying values of Pstart that are too far\nfrom the current stress value, or specifying a timestep that is too\nlarge. Triclinic barostatting should be used with care. This also is\ntrue for other barostat styles, although they tend to be more\nforgiving of insults. In particular, it is important to recognize that\nequilibrium liquids can not support a shear stress and that\nequilibrium solids can not support shear stresses that exceed the\nyield stress.\nOne exception to this rule is if the 1st dimension in the tilt factor\n(x for xy) is non-periodic.  In that case, the limits on the tilt\nfactor are not enforced, since flipping the box in that dimension does\nnot change the atom positions due to non-periodicity.  In this mode,\nif you tilt the system to extreme angles, the simulation will simply\nbecome inefficient due to the highly skewed simulation box.\n\nNote\nUnlike the fix temp/berendsen command\nwhich performs thermostatting but NO time integration, these fixes\nperform thermostatting/barostatting AND time integration.  Thus you\nshould not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\nfix nvt and fix npt should not normally be used on atoms that also\nhave their temperature controlled by another fix - e.g. by fix langevin or fix temp/rescale\ncommands.\n\nSee the Howto thermostat and Howto barostat doc pages for a discussion of different\nways to compute temperature and perform thermostatting and\nbarostatting.\n\nThese fixes compute a temperature and pressure each timestep.  To do\nthis, the thermostat and barostat fixes create their own computes of\nstyle “temp” and “pressure”, as if one of these sets of commands had\nbeen issued:\nFor fix nvt:\ncompute fix-ID_temp group-ID temp\nFor fix npt and fix nph:\ncompute fix-ID_temp all temp\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nFor fix nvt, the group for the new temperature compute is the same as\nthe fix group.  For fix npt and fix nph, the group for both the new\ntemperature and pressure compute is “all” since pressure is computed\nfor the entire system.  In the case of fix nph, the temperature\ncompute is not used for thermostatting, but just for a kinetic-energy\ncontribution to the pressure.  See the compute temp and compute pressure\ncommands for details.  Note that the IDs of the new computes are the\nfix-ID + underscore + “temp” or fix_ID + underscore + “press”.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of these\nfix’s temperature or pressure via the\ncompute_modify command.  Or you can print this\ntemperature or pressure during thermodynamic output via the\nthermo_style custom command using the appropriate\ncompute-ID.  It also means that changing attributes of thermo_temp\nor thermo_press will have no effect on this fix.\nLike other fixes that perform thermostatting, fix nvt and fix npt can\nbe used with compute commands that calculate a\ntemperature after removing a “bias” from the atom velocities.\nE.g. removing the center-of-mass velocity from a group of atoms or\nonly calculating temperature on the x-component of velocity or only\ncalculating temperature for atoms in a geometric region.  This is not\ndone by default, but only if the fix_modify command\nis used to assign a temperature compute to this fix that includes such\na bias term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nThese fixes can be used with either the verlet or respa\nintegrators. When using one of the barostat fixes\nwith respa, LAMMPS uses an integrator constructed\naccording to the following factorization of the Liouville propagator\n(for two rRESPA levels):\n\n\\[\\begin{split}\\exp \\left(\\mathrm{i} L \\Delta t \\right) = & \\hat{E}\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right) \\\\\n&\\times \\left[\n\\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_1 \\frac{\\Delta t}{n} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n\\right]^n \\\\\n&\\times\n\\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right) \\\\\n&+ \\mathcal{O} \\left(\\Delta t^3 \\right)\\end{split}\\]\nThis factorization differs somewhat from that of Tuckerman et al, in\nthat the barostat is only updated at the outermost rRESPA level,\nwhereas Tuckerman’s factorization requires splitting the pressure into\npieces corresponding to the forces computed at each rRESPA level. In\ntheory, the latter method will exhibit better numerical stability. In\npractice, because Pdamp is normally chosen to be a large multiple of\nthe outermost rRESPA timestep, the barostat dynamics are not the\nlimiting factor for numerical stability. Both factorizations are\ntime-reversible and can be shown to preserve the phase space measure\nof the underlying non-Hamiltonian equations of motion.\n\nNote\nThis implementation has been shown to conserve linear momentum\nup to machine precision under NVT dynamics. Under NPT dynamics,\nfor a system with zero initial total linear momentum, the total\nmomentum fluctuates close to zero. It may occasionally undergo brief\nexcursions to non-negligible values, before returning close to zero.\nOver long simulations, this has the effect of causing the center-of-mass\nto undergo a slow random walk. This can be mitigated by resetting\nthe momentum at infrequent intervals using the\nfix momentum command.\n\n\nThe fix npt and fix nph commands can be used with rigid bodies or\nmixtures of rigid bodies and non-rigid particles (e.g. solvent).  But\nthere are also fix rigid/npt and fix rigid/nph commands, which are typically a more natural\nchoice.  See the doc page for those commands for more discussion of\nthe various ways to do this.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThese fixes writes the state of all the thermostat and barostat\nvariables to binary restart files.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by these fixes.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure, as described above.\nIf you do this, note that the kinetic energy derived from the compute\ntemperature should be consistent with the virial term computed using\nall atoms for the pressure.  LAMMPS will warn you if you choose to\ncompute temperature on a subset of atoms.\n\nNote\nIf both the temp and press keywords are used in a single\nthermo_modify command (or in two separate commands), then the order in\nwhich the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\nan argument when it is specified.  The temp keyword will override\nthis (for the pressure compute being used by fix npt), but only if the\ntemp keyword comes after the press keyword.  If the temp keyword\ncomes before the press keyword, then the new pressure compute\nspecified by the press keyword will be unaffected by the temp\nsetting.\n\nThe fix_modify energy option is supported by these\nfixes to add the energy change induced by Nose/Hoover thermostatting\nand barostatting to the system’s potential energy as part of\nthermodynamic output.\nThese fixes compute a global scalar and a global vector of quantities,\nwhich can be accessed by various output commands.\nThe scalar value calculated by these fixes is “extensive”; the vector\nvalues are “intensive”.\nThe scalar is the cumulative energy change due to the fix.\nThe vector stores internal Nose/Hoover thermostat and barostat\nvariables.  The number and meaning of the vector values depends on\nwhich fix is used and the settings for keywords tchain and pchain,\nwhich specify the number of Nose/Hoover chains for the thermostat and\nbarostat.  If no thermostatting is done, then tchain is 0.  If no\nbarostatting is done, then pchain is 0.  In the following list,\n“ndof” is 0, 1, 3, or 6, and is the number of degrees of freedom in\nthe barostat.  Its value is 0 if no barostat is used, else its value\nis 6 if any off-diagonal stress tensor component is barostatted, else\nits value is 1 if couple xyz is used or couple xy for a 2d\nsimulation, otherwise its value is 3.\nThe order of values in the global vector and their meaning is as\nfollows.  The notation means there are tchain values for eta, followed\nby tchain for eta_dot, followed by ndof for omega, etc:\n\neta[tchain] = particle thermostat displacements (unitless)\neta_dot[tchain] = particle thermostat velocities (1/time units)\nomega[ndof] = barostat displacements (unitless)\nomega_dot[ndof] = barostat velocities (1/time units)\netap[pchain] = barostat thermostat displacements (unitless)\netap_dot[pchain] = barostat thermostat velocities (1/time units)\nPE_eta[tchain] = potential energy of each particle thermostat displacement (energy units)\nKE_eta_dot[tchain] = kinetic energy of each particle thermostat velocity (energy units)\nPE_omega[ndof] = potential energy of each barostat displacement (energy units)\nKE_omega_dot[ndof] = kinetic energy of each barostat velocity (energy units)\nPE_etap[pchain] = potential energy of each barostat thermostat displacement (energy units)\nKE_etap_dot[pchain] = kinetic energy of each barostat thermostat velocity (energy units)\nPE_strain[1] = scalar strain energy (energy units)\n\nThese fixes can ramp their external temperature and pressure over\nmultiple runs, using the start and stop keywords of the\nrun command.  See the run command for details of\nhow to do this.\nThese fixes are not invoked during energy minimization.",
    "syntax": "fix ID group-ID style_name keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style_name = nvt or npt or nph\n * one or more keyword/value pairs may be appended\n * keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scalexy or scaleyz or scalexz or flip or fixedpoint or update\n *   temp values = Tstart Tstop Tdamp\n *     Tstart,Tstop = external temperature at start/end of run\n *     Tdamp = temperature damping parameter (time units)\n *   iso or aniso or tri values = Pstart Pstop Pdamp\n *     Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n *     Pdamp = pressure damping parameter (time units)\n *   x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n *     Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n *     Pdamp = stress damping parameter (time units)\n *   couple = none or xyz or xy or yz or xz\n *   tchain value = N\n *     N = length of thermostat chain (1 = single thermostat)\n *   pchain values = N\n *     N length of thermostat chain on barostat (0 = no thermostat)\n *   mtk value = yes or no = add in MTK adjustment term or not\n *   tloop value = M\n *     M = number of sub-cycles to perform on thermostat\n *   ploop value = M\n *     M = number of sub-cycles to perform on barostat thermostat\n *   nreset value = reset reference cell every this many timesteps\n *   drag value = Df\n *     Df = drag factor added to barostat/thermostat (0.0 = no drag)\n *   dilate value = dilate-group-ID\n *     dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n *   scalexy value = yes or no = scale xy with ly\n *   scaleyz value = yes or no = scale yz with lz\n *   scalexz value = yes or no = scale xz with lz\n *   flip value = yes or no = allow or disallow box flips when it becomes highly skewed\n *   fixedpoint values = x y z\n *     x,y,z = perform barostat dilation/contraction around this point (distance units)\n *   update value = dipole or dipole/dlm\n *     dipole = update dipole orientation (only for sphere variants)\n *     dipole/dlm = use DLM integrator to update dipole orientation (only for sphere variants)",
    "examples": "fix 1 all nvt temp 300.0 300.0 100.0\nfix 1 water npt temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\nfix 2 jello npt temp 300.0 300.0 100.0 tri 5.0 5.0 1000.0\nfix 2 ice nph x 1.0 1.0 0.5 y 2.0 2.0 0.5 z 3.0 3.0 0.5 yz 0.1 0.1 0.5 xz 0.2 0.2 0.5 xy 0.3 0.3 0.5 nreset 1000",
    "restrictions": "X, y, z cannot be barostatted if the associated dimension is not\nperiodic.  Xy, xz, and yz can only be barostatted if the\nsimulation domain is triclinic and the 2nd dimension in the keyword\n(y dimension in xy) is periodic.  Z, xz, and yz, cannot be\nbarostatted for 2D simulations.  The create_box,\nread data, and read_restart\ncommands specify whether the simulation box is orthogonal or\nnon-orthogonal (triclinic) and explain the meaning of the xy,xz,yz\ntilt factors.\nFor the temp keyword, the final Tstop cannot be 0.0 since it would\nmake the external T = 0.0 at some timestep during the simulation which\nis not allowed in the Nose/Hoover formulation.\nThe scaleyz yes and scalexz yes keyword/value pairs can not be used\nfor 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\ncan only be used if the 2nd dimension in the keyword is periodic,\nand if the tilt factor is not coupled to the barostat via keywords\ntri, yz, xz, and xy.\nThese fixes can be used with dynamic groups as defined by the\ngroup command.  Likewise they can be used with groups to\nwhich atoms are added or deleted over time, e.g. a deposition\nsimulation.  However, the conservation properties of the thermostat\nand barostat are defined for systems with a static set of atoms.  You\nmay observe odd behavior if the atoms in a group vary dramatically\nover time or the atom count becomes very small."
},
{
    "command": "fix nvt/eff",
    "html_filename": "fix_nh_eff.html",
    "short_description": "These commands perform time integration on Nose-Hoover style non-Hamiltonian equations of motion for nuclei and electrons in the group for the electron force field model",
    "description": "These commands perform time integration on Nose-Hoover style\nnon-Hamiltonian equations of motion for nuclei and electrons in the\ngroup for the electron force field model.  The fixes\nare designed to generate positions and velocities sampled from the\ncanonical (nvt), isothermal-isobaric (npt), and isenthalpic (nph)\nensembles.  This is achieved by adding some dynamic variables which\nare coupled to the particle velocities (thermostatting) and simulation\ndomain dimensions (barostatting).  In addition to basic thermostatting\nand barostatting, these fixes can also create a chain of thermostats\ncoupled to the particle thermostat, and another chain of thermostats\ncoupled to the barostat variables. The barostat can be coupled to the\noverall box volume, or to individual dimensions, including the xy,\nxz and yz tilt dimensions. The external pressure of the barostat\ncan be specified as either a scalar pressure (isobaric ensemble) or as\ncomponents of a symmetric stress tensor (constant stress ensemble).\nWhen used correctly, the time-averaged temperature and stress tensor\nof the particles will match the target values specified by\nTstart/Tstop and Pstart/Pstop.\nThe operation of these fixes is exactly like that described by the\nfix nvt, npt, and nph commands, except that the radius\nand radial velocity of electrons are also updated.  Likewise the\ntemperature and pressure calculated by the fix, using the computes it\ncreates (as discussed in the fix nvt, npt, and nph\ndoc page), are performed with computes that include the eFF contribution\nto the temperature or kinetic energy from the electron radial velocity.\n\nNote\nthere are two different pressures that can be reported for eFF\nwhen defining the pair_style (see pair eff/cut to\nunderstand these settings), one (default) that considers electrons do\nnot contribute radial virial components (i.e. electrons treated as\nincompressible ‘rigid’ spheres) and one that does.  The radial\nelectronic contributions to the virials are only tallied if the\nflexible pressure option is set, and this will affect both global and\nper-atom quantities.  In principle, the true pressure of a system is\nsomewhere in between the rigid and the flexible eFF pressures, but,\nfor most cases, the difference between these two pressures will not be\nsignificant over long-term averaged runs (i.e. even though the energy\npartitioning changes, the total energy remains similar).\n\n\nNote\ncurrently, there is no available option for the user to set or\ncreate temperature distributions that include the radial electronic\ndegrees of freedom with the velocity command, so the\nthe user must allow for these degrees of freedom to equilibrate\n(i.e. equi-partitioning of energy) through time integration.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nSee the doc page for the fix nvt, npt, and nph commands\nfor details.",
    "syntax": "fix ID group-ID style_name keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style_name = nvt/eff or npt/eff or nph/eff\n * one or more keyword value pairs may be appended\n * keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate\n *   temp values = Tstart Tstop Tdamp\n *     Tstart,Tstop = external temperature at start/end of run\n *     Tdamp = temperature damping parameter (time units)\n *   iso or aniso or tri values = Pstart Pstop Pdamp\n *     Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n *     Pdamp = pressure damping parameter (time units)\n *   x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n *     Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n *     Pdamp = stress damping parameter (time units)\n *   couple = none or xyz or xy or yz or xz\n *   tchain value = length of thermostat chain (1 = single thermostat)\n *   pchain values = length of thermostat chain on barostat (0 = no thermostat)\n *   mtk value = yes or no = add in MTK adjustment term or not\n *   tloop value = number of sub-cycles to perform on thermostat\n *   ploop value = number of sub-cycles to perform on barostat thermostat\n *   nreset value = reset reference cell every this many timesteps\n *   drag value = drag factor added to barostat/thermostat (0.0 = no drag)\n *   dilate value = all or partial",
    "examples": "fix 1 all nvt/eff temp 300.0 300.0 0.1\nfix 1 part npt/eff temp 300.0 300.0 0.1 iso 0.0 0.0 1.0\nfix 2 part npt/eff temp 300.0 300.0 0.1 tri 5.0 5.0 1.0\nfix 2 ice nph/eff x 1.0 1.0 0.5 y 2.0 2.0 0.5 z 3.0 3.0 0.5 yz 0.1 0.1 0.5 xz 0.2 0.2 0.5 xy 0.3 0.3 0.5 nreset 1000",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nOther restriction discussed on the doc page for the fix nvt, npt, and nph commands also apply.\n\nNote\nThe temperature for systems (regions or groups) with only\nelectrons and no nuclei is 0.0 (i.e. not defined) in the current\ntemperature calculations, a practical example would be a uniform\nelectron gas or a very hot plasma, where electrons remain delocalized\nfrom the nuclei.  This is because, even though electron virials are\nincluded in the temperature calculation, these are averaged over the\nnuclear degrees of freedom only.  In such cases a corrective term must\nbe added to the pressure to get the correct kinetic contribution."
},
{
    "command": "fix nvt/uef",
    "html_filename": "fix_nh_uef.html",
    "short_description": "This fix can be used to simulate non-equilibrium molecular dynamics (NEMD) under diagonal flow fields, including uniaxial and bi-axial flow",
    "description": "This fix can be used to simulate non-equilibrium molecular dynamics\n(NEMD) under diagonal flow fields, including uniaxial and bi-axial\nflow.  Simulations under continuous extensional flow may be carried\nout for an indefinite amount of time.  It is an implementation of the\nboundary conditions from (Dobson), and also uses numerical\nlattice reduction as was proposed by (Hunt). The lattice\nreduction algorithm is from (Semaev). The fix is intended for\nsimulations of homogeneous flows, and integrates the SLLOD equations\nof motion, originally proposed by Hoover and Ladd (see (Evans and Morriss)).  Additional detail about this implementation can be\nfound in (Nicholson and Rutledge).\nNote that NEMD simulations of a continuously strained system can be\nperformed using the fix deform, fix nvt/sllod, and compute temp/deform commands.\nThe applied flow field is set by the eps keyword. The values\nedot_x and edot_y correspond to the strain rates in the xx and yy\ndirections.  It is implicitly assumed that the flow field is\ntraceless, and therefore the strain rate in the zz direction is eqal\nto -(edot_x + edot_y).\n\nNote\nDue to an instability in the SLLOD equations under extension,\nfix momentum should be used to regularly reset the\nlinear momentum.\n\nThe boundary conditions require a simulation box that does not have a\nconsistent alignment relative to the applied flow field. Since LAMMPS\nutilizes an upper-triangular simulation box, it is not possible to\nexpress the evolving simulation box in the same coordinate system as\nthe flow field.  This fix keeps track of two coordinate systems: the\nflow frame, and the upper triangular LAMMPS frame. The coordinate\nsystems are related to each other through the QR decomposition, as is\nillustrated in the image below.\n\nDuring most molecular dynamics operations, the system is represented\nin the LAMMPS frame. Only when the positions and velocities are\nupdated is the system rotated to the flow frame, and it is rotated\nback to the LAMMPS frame immediately afterwards. For this reason, all\nvector-valued quantities (except for the tensors from\ncompute pressure/uef and\ncompute temp/uef) will be computed in the\nLAMMPS frame. Rotationally invariant scalar quantities like the\ntemperature and hydrostatic pressure are frame-invariant and will be\ncomputed correctly. Additionally, the system is in the LAMMPS frame\nduring all of the output steps, and therefore trajectory files made\nusing the dump command will be in the LAMMPS frame unless the\ndump cfg/uef command is used.\n\nTemperature control is achieved with the default Nose-Hoover style\nthermostat documented in fix npt. When this fix is\nactive, only the peculiar velocity of each atom is stored, defined as\nthe velocity relative to the streaming velocity. This is in contrast\nto fix nvt/sllod, which uses a lab-frame\nvelocity, and removes the contribution from the streaming velocity in\norder to compute the temperature.\nPressure control is achieved using the default Nose-Hoover barostat\ndocumented in fix npt. There are two ways to control the\npressure using this fix. The first method involves using the ext\nkeyword along with the iso pressure style. With this method, the\npressure is controlled by scaling the simulation box isotropically to\nachieve the average pressure only in the directions specified by\next.  For example, if the ext value is set to xy, the average\npressure (Pxx+Pyy)/2 will be controlled.\nThis example command will control the total hydrostatic pressure under\nuniaxial tension:\nfix f1 all npt/uef temp 0.7 0.7 0.5 iso 1 1 5 erate -0.5 -0.5 ext xyz\n\n\nThis example command will control the average stress in compression\ndirections, which would typically correspond to free surfaces under\ndrawing with uniaxial tension:\nfix f2 all npt/uef temp 0.7 0.7 0.5 iso 1 1 5 erate -0.5 -0.5 ext xy\n\n\nThe second method for pressure control involves setting the normal\nstresses using the x, y , and/or z keywords. When using this\nmethod, the same pressure must be specified via Pstart and Pstop\nfor all dimensions controlled. Any choice of pressure conditions that\nwould cause LAMMPS to compute a deviatoric stress are not permissible\nand will result in an error. Additionally, all dimensions with\ncontrolled stress must have the same applied strain rate. The ext\nkeyword must be set to the default value (xyz) when using this\nmethod.\nFor example, the following commands will work:\nfix f3 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 y 1 1 5 erate -0.5 -0.5\nfix f4 all npt/uef temp 0.7 0.7 0.5 z 1 1 5 erate 0.5 0.5\n\n\nThe following commands will not work:\nfix f5 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 z 1 1 5 erate -0.5 -0.5\nfix f6 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 z 2 2 5 erate 0.5 0.5\n\n\n\nThese fix computes a temperature and pressure each timestep.  To do\nthis, it creates its own computes of style “temp/uef” and\n“pressure/uef”, as if one of these two sets of commands had been\nissued:\ncompute fix-ID_temp group-ID temp/uef\ncompute fix-ID_press group-ID pressure/uef fix-ID_temp\n\ncompute fix-ID_temp all temp/uef\ncompute fix-ID_press all pressure/uef fix-ID_temp\n\n\nSee the compute temp/uef and compute pressure/uef commands for details.  Note\nthat the IDs of the new computes are the fix-ID + underscore + “temp”\nor fix_ID + underscore + “press”.\nRestart, fix_modify, output, run start/stop, minimize info:\nThe fix writes the state of all the thermostat and barostat variables,\nas well as the cumulative strain applied, to binary restart files.  See the read_restart command\nfor info on how to re-specify a fix in an input script that reads a\nrestart file, so that the operation of the fix continues in an\nuninterrupted fashion.\n\nNote\nIt is not necessary to set the strain keyword when resuming a\nrun from a restart file. Only for resuming from data files, which do\nnot contain the cumulative applied strain, will this keyword be\nnecessary.\n\nThis fix can be used with the fix_modify temp and\npress options. The temperature and pressure computes used must be of\ntype temp/uef and pressure/uef.\nThis fix computes the same global scalar and vector quantities as fix npt.\nThe fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID style_name erate edot_x edot_y temp Tstart Tstop Tdamp keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style_name = nvt/uef or npt/uef\n * Tstart, Tstop, and Tdamp are documented in the fix npt command\n * edot_x and edot_y are the strain rates in the x and y directions (1/(time units))\n * one or more keyword/value pairs may be appended\n * keyword = ext or strain or iso or x or y or z or tchain or pchain or tloop or ploop or mtk\n *   ext value = x or y or z or xy or yz or xz = external dimensions\n *     sets the external dimensions used to calculate the scalar pressure\n *   strain values = e_x e_y = initial strain\n *     usually not needed, but may be needed to resume a run with a data file.\n *   iso, x, y, z, tchain, pchain, tloop, ploop, mtk keywords\n *     documented by the fix npt command",
    "examples": "fix uniax_nvt all nvt/uef temp 400 400 100 erate 0.00001 -0.000005\nfix biax_nvt all nvt/uef temp 400 400 100 erate 0.000005 0.000005\nfix uniax_npt all npt/uef temp 400 400 300 iso 1 1 3000 erate 0.00001 -0.000005 ext yz\nfix biax_npt all npt/uef temp 400 400 100 erate -0.00001 0.000005 x 1 1 3000",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\nwas built with that package. See the Build package doc page for more info.\nDue to requirements of the boundary conditions, when the strain\nkeyword is set to zero (or unset), the initial simulation box must be\ncubic and have style triclinic. If the box is initially of type ortho,\nuse change_box before invoking the fix.\n\nNote\nWhen resuming from restart files, you may need to use box tilt large since lammps has internal criteria from lattice\nreduction that are not the same as the criteria in the numerical\nlattice reduction algorithm."
},
{
    "command": "fix nph/asphere",
    "html_filename": "fix_nph_asphere.html",
    "short_description": "Perform constant NPH integration to update position, velocity, orientation, and angular velocity each timestep for aspherical or ellipsoidal particles in the group using a Nose/Hoover pressure barostat",
    "description": "Perform constant NPH integration to update position, velocity,\norientation, and angular velocity each timestep for aspherical or\nellipsoidal particles in the group using a Nose/Hoover pressure\nbarostat.  P is pressure; H is enthalpy.  This creates a system\ntrajectory consistent with the isenthalpic ensemble.\nThis fix differs from the fix nph command, which assumes\npoint particles and only updates their position and velocity.\nAdditional parameters affecting the barostat are specified by keywords\nand values documented with the fix nph command.  See,\nfor example, discussion of the aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPH integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/asphere” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/asphere\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/asphere and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover barostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nph command.\nThis fix can ramp its target pressure over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nph/asphere args keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nph/asphere = style name of this fix command\n * additional barostat related keyword/value pairs from the fix nph command can be appended",
    "examples": "fix 1 all nph/asphere iso 0.0 0.0 1000.0\nfix 2 all nph/asphere x 5.0 5.0 1000.0\nfix 2 all nph/asphere x 5.0 5.0 1000.0 drag 0.2\nfix 2 water nph/asphere aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "fix nph/body",
    "html_filename": "fix_nph_body.html",
    "short_description": "Perform constant NPH integration to update position, velocity, orientation, and angular velocity each timestep for body particles in the group using a Nose/Hoover pressure barostat",
    "description": "Perform constant NPH integration to update position, velocity,\norientation, and angular velocity each timestep for body\nparticles in the group using a Nose/Hoover pressure\nbarostat.  P is pressure; H is enthalpy.  This creates a system\ntrajectory consistent with the isenthalpic ensemble.\nThis fix differs from the fix nph command, which assumes\npoint particles and only updates their position and velocity.\nAdditional parameters affecting the barostat are specified by keywords\nand values documented with the fix nph command.  See,\nfor example, discussion of the aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPH integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/body” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/body\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/body and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover barostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nph command.\nThis fix can ramp its target pressure over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nph/body args keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nph/body = style name of this fix command\n * additional barostat related keyword/value pairs from the fix nph command can be appended",
    "examples": "fix 1 all nph/body iso 0.0 0.0 1000.0\nfix 2 all nph/body x 5.0 5.0 1000.0\nfix 2 all nph/body x 5.0 5.0 1000.0 drag 0.2\nfix 2 water nph/body aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style body\ncommand."
},
{
    "command": "fix nph/sphere",
    "html_filename": "fix_nph_sphere.html",
    "short_description": "Perform constant NPH integration to update position, velocity, and angular velocity each timestep for finite-size spherical particles in the group using a Nose/Hoover pressure barostat",
    "description": "Perform constant NPH integration to update position, velocity, and\nangular velocity each timestep for finite-size spherical particles in\nthe group using a Nose/Hoover pressure barostat.  P is pressure; H is\nenthalpy.  This creates a system trajectory consistent with the\nisenthalpic ensemble.\nThis fix differs from the fix nph command, which assumes\npoint particles and only updates their position and velocity.\nIf the disc keyword is used, then each particle is treated as a 2d\ndisc (circle) instead of as a sphere.  This is only possible for 2d\nsimulations, as defined by the dimension keyword.\nThe only difference between discs and spheres in this context is their\nmoment of inertia, as used in the time integration.\nAdditional parameters affecting the barostat are specified by keywords\nand values documented with the fix nph command.  See,\nfor example, discussion of the aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPH integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/sphere” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/sphere\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/sphere and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover barostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nph command.\nThis fix can ramp its target pressure over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nph/sphere args keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nph/sphere = style name of this fix command\n * keyword = disc\n * disc value = none = treat particles as 2d discs, not spheres\n * additional barostat related keyword/value pairs from the fix nph command can be appended",
    "examples": "fix 1 all nph/sphere iso 0.0 0.0 1000.0\nfix 2 all nph/sphere x 5.0 5.0 1000.0\nfix 2 all nph/sphere x 5.0 5.0 1000.0 disc\nfix 2 all nph/sphere x 5.0 5.0 1000.0 drag 0.2\nfix 2 water nph/sphere aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\nand a radius as defined by the atom_style sphere\ncommand.\nAll particles in the group must be finite-size spheres.  They cannot\nbe point particles.\nUse of the disc keyword is only allowed for 2d simulations, as\ndefined by the dimension keyword."
},
{
    "command": "fix nphug",
    "html_filename": "fix_nphug.html",
    "short_description": "This command is a variant of the Nose-Hoover fix npt fix style",
    "description": "This command is a variant of the Nose-Hoover\nfix npt fix style.\nIt performs time integration of the Hugoniostat equations\nof motion developed by Ravelo et al. (Ravelo).\nThese equations compress the system to a state with average\naxial stress or pressure equal to the specified target value\nand that satisfies the Rankine-Hugoniot (RH)\njump conditions for steady shocks.\nThe compression can be performed\neither\nhydrostatically (using keyword iso, aniso, or tri) or uniaxially\n(using keywords x, y, or z).  In the hydrostatic case,\nthe cell dimensions change dynamically so that the average axial stress\nin all three directions converges towards the specified target value.\nIn the uniaxial case, the chosen cell dimension changes dynamically\nso that the average\naxial stress in that direction converges towards the target value. The\nother two cell dimensions are kept fixed (zero lateral strain).\nThis leads to the following additional restrictions on the keywords:\n\nOne and only one of the following keywords should be used: iso, aniso, tri, x, y, z\nThe specified initial and final target pressures must be the same.\nThe keywords xy, xz, yz may not be used.\nThe only admissible value for the couple keyword is xyz, which has the same effect as keyword iso\nThe temp keyword must be used to specify the time constant for kinetic energy relaxation, but initial and final target temperature values are ignored.\n\nEssentially, a Hugoniostat simulation is an NPT simulation in which the\nuser-specified target temperature is replaced with a time-dependent\ntarget temperature Tt obtained from the following equation:\n\n\\[T_t - T = \\frac{\\left(\\frac{1}{2}\\left(P + P_0\\right)\\left(V_0 - V\\right) + E_0 - E\\right)}{N_{dof} k_B } = \\Delta\\]\nwhere T and \\(T_t\\) are the instantaneous and target temperatures,\nP and \\(P_0\\) are the instantaneous and reference pressures or axial stresses,\ndepending on whether hydrostatic or uniaxial compression is being\nperformed, V and \\(V_0\\) are the instantaneous and reference volumes,\nE and \\(E_0\\) are the instantaneous and reference internal energy (potential\nplus kinetic), \\(N_{dof}\\) is the number of degrees of freedom used in the\ndefinition of temperature, and \\(k_B\\) is the Boltzmann constant. \\(\\Delta\\) is the\nnegative deviation of the instantaneous temperature from the target temperature.\nWhen the system reaches a stable equilibrium, the value of \\(\\Delta\\) should\nfluctuate about zero.\nThe values of \\(E_0\\), \\(V_0\\), and \\(P_0\\) are the instantaneous values at the start of\nthe simulation. These can be overridden using the fix_modify keywords e0,\nv0, and p0 described below.\n\n\nNote\nUnlike the fix temp/berendsen command\nwhich performs thermostatting but NO time integration, this fix\nperforms thermostatting/barostatting AND time integration.  Thus you\nshould not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\nthis fix should not be used on atoms that have their temperature\ncontrolled by another fix - e.g. by fix langevin or fix temp/rescale commands.\n\n\nThis fix computes a temperature and pressure at each timestep.  To do\nthis, the fix creates its own computes of style “temp” and “pressure”,\nas if one of these two sets of commands had been issued:\ncompute fix-ID_temp group-ID temp\ncompute fix-ID_press group-ID pressure fix-ID_temp\n\ncompute fix-ID_temp all temp\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”.  The group for\nthe new computes is “all” since pressure is computed for the entire\nsystem.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the values of \\(E_0\\), \\(V_0\\), and \\(P_0\\),\nas well as the state of all the thermostat and barostat variables to\nbinary restart files.  See the read_restart command for info on how to re-specify a fix in an input\nscript that reads a restart file, so that the operation of the fix\ncontinues in an uninterrupted fashion.\nThe fix_modify e0, v0 and p0 keywords can be\nused to define the values of \\(E_0\\), \\(V_0\\), and\n\\(P_0\\). Note the the values for e0 and v0 are extensive, and so\nmust correspond to the total energy and volume of the entire system, not\nenergy and volume per atom. If any of these quantities are not\nspecified, then the instantaneous value in the system at the start of\nthe simulation is used.\nThe fix_modify temp and press options are\nsupported by these fixes.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure, as described above.\nIf you do this, note that the kinetic energy derived from the compute\ntemperature should be consistent with the virial term computed using\nall atoms for the pressure.  LAMMPS will warn you if you choose to\ncompute temperature on a subset of atoms.\nThe fix_modify energy option is supported by these\nfixes to add the energy change induced by Nose/Hoover thermostatting\nand barostatting to the system’s potential energy as part of\nthermodynamic output. Either way, this energy is *not*\nincluded in the definition of internal energy E when calculating the value\nof Delta in the above equation.\nThese fixes compute a global scalar and a global vector of quantities,\nwhich can be accessed by various output commands.\nThe scalar value calculated by these fixes is “extensive”; the vector\nvalues are “intensive”.\nThe scalar is the cumulative energy change due to the fix.\nThe vector stores three quantities unique to this fix (\\(\\Delta\\), Us, and up),\nfollowed by all the internal Nose/Hoover thermostat and barostat\nvariables defined for fix npt. Delta is the deviation\nof the temperature from the target temperature, given by the above equation.\nUs and up are the shock and particle velocity corresponding to a steady\nshock calculated from the RH conditions. They have units of distance/time.",
    "syntax": "fix ID group-ID nphug keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * one or more keyword value pairs may be appended\n * keyword = temp or iso or aniso or tri or x or y or z or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scaleyz or scalexz or scalexy\n *   temp values = Value1 Value2 Tdamp\n *     Value1, Value2 = Nose-Hoover target temperatures, ignored by Hugoniostat\n *     Tdamp = temperature damping parameter (time units)\n *   iso or aniso or tri values = Pstart Pstop Pdamp\n *     Pstart,Pstop = scalar external pressures, must be equal (pressure units)\n *     Pdamp = pressure damping parameter (time units)\n *   x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n *     Pstart,Pstop = external stress tensor components, must be equal (pressure units)\n *     Pdamp = stress damping parameter (time units)\n *   couple = none or xyz or xy or yz or xz\n *   tchain value = length of thermostat chain (1 = single thermostat)\n *   pchain values = length of thermostat chain on barostat (0 = no thermostat)\n *   mtk value = yes or no = add in MTK adjustment term or not\n *   tloop value = number of sub-cycles to perform on thermostat\n *   ploop value = number of sub-cycles to perform on barostat thermostat\n *   nreset value = reset reference cell every this many timesteps\n *   drag value = drag factor added to barostat/thermostat (0.0 = no drag)\n *   dilate value = all or partial\n *   scaleyz value = yes or no = scale yz with lz\n *   scalexz value = yes or no = scale xz with lz\n *   scalexy value = yes or no = scale xy with ly",
    "examples": "fix myhug all nphug temp 1.0 1.0 10.0 z 40.0 40.0 70.0\nfix myhug all nphug temp 1.0 1.0 10.0 iso 40.0 40.0 70.0 drag 200.0 tchain 1 pchain 0",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nAll the usual restrictions for fix npt apply,\nplus the additional ones mentioned above."
},
{
    "command": "fix npt/asphere",
    "html_filename": "fix_npt_asphere.html",
    "short_description": "Perform constant NPT integration to update position, velocity, orientation, and angular velocity each timestep for aspherical or ellipsoidal particles in the group using a Nose/Hoover temperature thermostat and Nose/Hoover pressure barostat",
    "description": "Perform constant NPT integration to update position, velocity,\norientation, and angular velocity each timestep for aspherical or\nellipsoidal particles in the group using a Nose/Hoover temperature\nthermostat and Nose/Hoover pressure barostat.  P is pressure; T is\ntemperature.  This creates a system trajectory consistent with the\nisothermal-isobaric ensemble.\nThis fix differs from the fix npt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the aspherical particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nAdditional parameters affecting the thermostat and barostat are\nspecified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\niso, aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPT integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/asphere” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/asphere\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/asphere and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat and barostat\nto binary restart files.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting and\nbarostatting to the system’s potential energy as part of\nthermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix npt command.\nThis fix can ramp its target temperature and pressure over multiple\nruns, using the start and stop keywords of the run\ncommand.  See the run command for details of how to do\nthis.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID npt/asphere keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * npt/asphere = style name of this fix command\n * additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended",
    "examples": "fix 1 all npt/asphere temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\nfix 2 all npt/asphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\nfix 2 all npt/asphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\nfix 2 water npt/asphere temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "fix npt/body",
    "html_filename": "fix_npt_body.html",
    "short_description": "Perform constant NPT integration to update position, velocity, orientation, and angular velocity each timestep for body particles in the group using a Nose/Hoover temperature thermostat and Nose/Hoover pressure barostat",
    "description": "Perform constant NPT integration to update position, velocity,\norientation, and angular velocity each timestep for body\nparticles in the group using a Nose/Hoover temperature\nthermostat and Nose/Hoover pressure barostat.  P is pressure; T is\ntemperature.  This creates a system trajectory consistent with the\nisothermal-isobaric ensemble.\nThis fix differs from the fix npt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the body particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nAdditional parameters affecting the thermostat and barostat are\nspecified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\niso, aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPT integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/body” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/body\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/body and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat and barostat\nto binary restart files.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting and\nbarostatting to the system’s potential energy as part of\nthermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix npt command.\nThis fix can ramp its target temperature and pressure over multiple\nruns, using the start and stop keywords of the run\ncommand.  See the run command for details of how to do\nthis.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID npt/body keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * npt/body = style name of this fix command\n * additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended",
    "examples": "fix 1 all npt/body temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\nfix 2 all npt/body temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\nfix 2 all npt/body temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\nfix 2 water npt/body temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style body\ncommand."
},
{
    "command": "fix npt/cauchy",
    "html_filename": "fix_npt_cauchy.html",
    "short_description": "This command performs time integration on Nose-Hoover style non-Hamiltonian equations of motion which are designed to generate positions and velocities sampled from the isothermal-isobaric (npt) ensembles",
    "description": "This command performs time integration on Nose-Hoover style\nnon-Hamiltonian equations of motion which are designed to generate\npositions and velocities sampled from the isothermal-isobaric (npt)\nensembles.  This updates the position and velocity for atoms in the\ngroup each timestep and the box dimensions.\nThe thermostatting and barostatting is achieved by adding some dynamic\nvariables which are coupled to the particle velocities\n(thermostatting) and simulation domain dimensions (barostatting).  In\naddition to basic thermostatting and barostatting, this fix can\nalso create a chain of thermostats coupled to the particle thermostat,\nand another chain of thermostats coupled to the barostat\nvariables. The barostat can be coupled to the overall box volume, or\nto individual dimensions, including the xy, xz and yz tilt\ndimensions. The external pressure of the barostat can be specified as\neither a scalar pressure (isobaric ensemble) or as components of a\nsymmetric stress tensor (constant stress ensemble).  When used\ncorrectly, the time-averaged temperature and stress tensor of the\nparticles will match the target values specified by Tstart/Tstop and\nPstart/Pstop.\nThe equations of motion used are those of Shinoda et al in\n(Shinoda), which combine the hydrostatic equations of\nMartyna, Tobias and Klein in (Martyna) with the strain\nenergy proposed by Parrinello and Rahman in\n(Parrinello).  The time integration schemes closely\nfollow the time-reversible measure-preserving Verlet and rRESPA\nintegrators derived by Tuckerman et al in (Tuckerman).\n\nThe thermostat parameters are specified using the temp keyword.\nOther thermostat-related keywords are tchain, tloop and drag,\nwhich are discussed below.\nThe thermostat is applied to only the translational degrees of freedom\nfor the particles.  The translational degrees of freedom can also have\na bias velocity removed before thermostatting takes place; see the\ndescription below.  The desired temperature at each timestep is a\nramped value during the run from Tstart to Tstop.  The Tdamp\nparameter is specified in time units and determines how rapidly the\ntemperature is relaxed.  For example, a value of 10.0 means to relax\nthe temperature in a timespan of (roughly) 10 time units (e.g. tau or\nfmsec or psec - see the units command).  The atoms in the\nfix group are the only ones whose velocities and positions are updated\nby the velocity/position update portion of the integration.\n\nNote\nA Nose-Hoover thermostat will not work well for arbitrary values\nof Tdamp.  If Tdamp is too small, the temperature can fluctuate\nwildly; if it is too large, the temperature will take a very long time\nto equilibrate.  A good choice for many models is a Tdamp of around\n100 timesteps.  Note that this is NOT the same as 100 time units for\nmost units settings.\n\n\nThe barostat parameters are specified using one or more of the iso,\naniso, tri, x, y, z, xy, xz, yz, and couple keywords.\nThese keywords give you the ability to specify all 6 components of an\nexternal stress tensor, and to couple various of these components\ntogether so that the dimensions they represent are varied together\nduring a constant-pressure simulation.\nOther barostat-related keywords are pchain, mtk, ploop,\nnreset, drag, and dilate, which are discussed below.\nOrthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\nTriclinic (non-orthogonal) simulation boxes have 6 adjustable\ndimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\nspecify whether the simulation box is orthogonal or non-orthogonal\n(triclinic) and explain the meaning of the xy,xz,yz tilt factors.\nThe target pressures for each of the 6 components of the stress tensor\ncan be specified independently via the x, y, z, xy, xz, yz\nkeywords, which correspond to the 6 simulation box dimensions.  For\neach component, the external pressure or tensor component at each\ntimestep is a ramped value during the run from Pstart to Pstop.\nIf a target pressure is specified for a component, then the\ncorresponding box dimension will change during a simulation.  For\nexample, if the y keyword is used, the y-box length will change.  If\nthe xy keyword is used, the xy tilt factor will change.  A box\ndimension will not change if that component is not specified, although\nyou have the option to change that dimension via the fix deform command.\nNote that in order to use the xy, xz, or yz keywords, the\nsimulation box must be triclinic, even if its initial tilt factors are\n0.0.\nFor all barostat keywords, the Pdamp parameter operates like the\nTdamp parameter, determining the time scale on which pressure is\nrelaxed.  For example, a value of 10.0 means to relax the pressure in\na timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\nthe units command).\n\nNote\nA Nose-Hoover barostat will not work well for arbitrary values\nof Pdamp.  If Pdamp is too small, the pressure and volume can\nfluctuate wildly; if it is too large, the pressure will take a very\nlong time to equilibrate.  A good choice for many models is a Pdamp\nof around 1000 timesteps.  However, note that Pdamp is specified in\ntime units, and that timesteps are NOT the same as time units for most\nunits settings.\n\nRegardless of what atoms are in the fix group (the only atoms which\nare time integrated), a global pressure or stress tensor is computed\nfor all atoms.  Similarly, when the size of the simulation box is\nchanged, all atoms are re-scaled to new positions, unless the keyword\ndilate is specified with a dilate-group-ID for a group that\nrepresents a subset of the atoms.  This can be useful, for example, to\nleave the coordinates of atoms in a solid substrate unchanged and\ncontrolling the pressure of a surrounding fluid.  This option should\nbe used with care, since it can be unphysical to dilate some atoms and\nnot others, because it can introduce large, instantaneous\ndisplacements between a pair of atoms (one dilated, one not) that are\nfar from the dilation origin.  Also note that for atoms not in the fix\ngroup, a separate time integration fix like fix nve or\nfix nvt can be used on them, independent of whether they\nare dilated or not.\n\nThe couple keyword allows two or three of the diagonal components of\nthe pressure tensor to be “coupled” together.  The value specified\nwith the keyword determines which are coupled.  For example, xz\nmeans the Pxx and Pzz components of the stress tensor are coupled.\nXyz means all 3 diagonal components are coupled.  Coupling means two\nthings: the instantaneous stress will be computed as an average of the\ncorresponding diagonal components, and the coupled box dimensions will\nbe changed together in lockstep, meaning coupled dimensions will be\ndilated or contracted by the same percentage every timestep.  The\nPstart, Pstop, Pdamp parameters for any coupled dimensions must\nbe identical.  Couple xyz can be used for a 2d simulation; the z\ndimension is simply ignored.\n\nThe iso, aniso, and tri keywords are simply shortcuts that are\nequivalent to specifying several other keywords together.\nThe keyword iso means couple all 3 diagonal components together when\npressure is computed (hydrostatic pressure), and dilate/contract the\ndimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\nspecifying these 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple xyz\n\n\nThe keyword aniso means x, y, and z dimensions are controlled\nindependently using the Pxx, Pyy, and Pzz components of the\nstress tensor as the driving forces, and the specified scalar external\npressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\nthese 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple none\n\n\nThe keyword tri means x, y, z, xy, xz, and yz dimensions\nare controlled independently using their individual stress components\nas the driving forces, and the specified scalar pressure as the\nexternal normal stress.  Using “tri Pstart Pstop Pdamp” is the same as\nspecifying these 7 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\nxy 0.0 0.0 Pdamp\nyz 0.0 0.0 Pdamp\nxz 0.0 0.0 Pdamp\ncouple none\n\n\n\nIn some cases (e.g. for solids) the pressure (volume) and/or\ntemperature of the system can oscillate undesirably when a Nose/Hoover\nbarostat and thermostat is applied.  The optional drag keyword will\ndamp these oscillations, although it alters the Nose/Hoover equations.\nA value of 0.0 (no drag) leaves the Nose/Hoover formalism unchanged.\nA non-zero value adds a drag term; the larger the value specified, the\ngreater the damping effect.  Performing a short run and monitoring the\npressure and temperature is the best way to determine if the drag term\nis working.  Typically a value between 0.2 to 2.0 is sufficient to\ndamp oscillations after a few periods. Note that use of the drag\nkeyword will interfere with energy conservation and will also change\nthe distribution of positions and velocities so that they do not\ncorrespond to the nominal NVT, NPT, or NPH ensembles.\nAn alternative way to control initial oscillations is to use chain\nthermostats. The keyword tchain determines the number of thermostats\nin the particle thermostat. A value of 1 corresponds to the original\nNose-Hoover thermostat. The keyword pchain specifies the number of\nthermostats in the chain thermostatting the barostat degrees of\nfreedom. A value of 0 corresponds to no thermostatting of the\nbarostat variables.\nThe mtk keyword controls whether or not the correction terms due to\nMartyna, Tuckerman, and Klein are included in the equations of motion\n(Martyna).  Specifying no reproduces the original\nHoover barostat, whose volume probability distribution function\ndiffers from the true NPT and NPH ensembles by a factor of 1/V.  Hence\nusing yes is more correct, but in many cases the difference is\nnegligible.\nThe keyword tloop can be used to improve the accuracy of integration\nscheme at little extra cost.  The initial and final updates of the\nthermostat variables are broken up into tloop sub-steps, each of\nlength dt/tloop. This corresponds to using a first-order\nSuzuki-Yoshida scheme (Tuckerman).  The keyword ploop\ndoes the same thing for the barostat thermostat.\nThe keyword nreset controls how often the reference dimensions used\nto define the strain energy are reset.  If this keyword is not used,\nor is given a value of zero, then the reference dimensions are set to\nthose of the initial simulation domain and are never changed. If the\nsimulation domain changes significantly during the simulation, then\nthe final average pressure tensor will differ significantly from the\nspecified values of the external stress tensor.  A value of nstep\nmeans that every nstep timesteps, the reference dimensions are set\nto those of the current simulation domain.\nThe scaleyz, scalexz, and scalexy keywords control whether or\nnot the corresponding tilt factors are scaled with the associated box\ndimensions when barostatting triclinic periodic cells.  The default\nvalues yes will turn on scaling, which corresponds to adjusting the\nlinear dimensions of the cell while preserving its shape.  Choosing\nno ensures that the tilt factors are not scaled with the box\ndimensions. See below for restrictions and default values in different\nsituations. In older versions of LAMMPS, scaling of tilt factors was\nnot performed. The old behavior can be recovered by setting all three\nscale keywords to no.\nThe flip keyword allows the tilt factors for a triclinic box to\nexceed half the distance of the parallel box length, as discussed\nbelow.  If the flip value is set to yes, the bound is enforced by\nflipping the box when it is exceeded.  If the flip value is set to\nno, the tilt will continue to change without flipping.  Note that if\napplied stress induces large deformations (e.g. in a liquid), this\nmeans the box shape can tilt dramatically and LAMMPS will run less\nefficiently, due to the large volume of communication needed to\nacquire ghost atoms around a processor’s irregular-shaped sub-domain.\nFor extreme values of tilt, LAMMPS may also lose atoms and generate an\nerror.\nThe fixedpoint keyword specifies the fixed point for barostat volume\nchanges. By default, it is the center of the box.  Whatever point is\nchosen will not move during the simulation.  For example, if the lower\nperiodic boundaries pass through (0,0,0), and this point is provided\nto fixedpoint, then the lower periodic boundaries will remain at\n(0,0,0), while the upper periodic boundaries will move twice as\nfar. In all cases, the particle trajectories are unaffected by the\nchosen value, except for a time-dependent constant translation of\npositions.\n\n\nNote\nUsing a barostat coupled to tilt dimensions xy, xz, yz can\nsometimes result in arbitrarily large values of the tilt dimensions,\ni.e. a dramatically deformed simulation box.  LAMMPS allows the tilt\nfactors to grow a small amount beyond the normal limit of half the box\nlength (0.6 times the box length), and then performs a box “flip” to\nan equivalent periodic cell.  See the discussion of the flip keyword\nabove, to allow this bound to be exceeded, if desired.\n\nThe flip operation is described in more detail in the doc page for\nfix deform.  Both the barostat dynamics and the atom\ntrajectories are unaffected by this operation.  However, if a tilt\nfactor is incremented by a large amount (1.5 times the box length) on\na single timestep, LAMMPS can not accommodate this event and will\nterminate the simulation with an error. This error typically indicates\nthat there is something badly wrong with how the simulation was\nconstructed, such as specifying values of Pstart that are too far\nfrom the current stress value, or specifying a timestep that is too\nlarge. Triclinic barostatting should be used with care. This also is\ntrue for other barostat styles, although they tend to be more\nforgiving of insults. In particular, it is important to recognize that\nequilibrium liquids can not support a shear stress and that\nequilibrium solids can not support shear stresses that exceed the\nyield stress.\nOne exception to this rule is if the 1st dimension in the tilt factor\n(x for xy) is non-periodic.  In that case, the limits on the tilt\nfactor are not enforced, since flipping the box in that dimension does\nnot change the atom positions due to non-periodicity.  In this mode,\nif you tilt the system to extreme angles, the simulation will simply\nbecome inefficient due to the highly skewed simulation box.\n\nNote\nUnlike the fix temp/berendsen command\nwhich performs thermostatting but NO time integration, this fix\nperforms thermostatting/barostatting AND time integration.  Thus you\nshould not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\nfix npt/cauchy should not normally be used on atoms that also\nhave their temperature controlled by another fix - e.g. by fix langevin or fix temp/rescale\ncommands.\n\nSee the Howto thermostat and Howto barostat doc pages for a discussion of different\nways to compute temperature and perform thermostatting and\nbarostatting.\n\nThis fix compute a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp” and “pressure”,\nas if one of these sets of commands had been issued:\ncompute fix-ID_temp all temp\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nThe group for both the new temperature and pressure compute is “all”\nsince pressure is computed for the entire system.  See the compute temp and compute pressure\ncommands for details.  Note that the IDs of the new computes are the\nfix-ID + underscore + “temp” or fix_ID + underscore + “press”.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of these\nfix’s temperature or pressure via the\ncompute_modify command.  Or you can print this\ntemperature or pressure during thermodynamic output via the\nthermo_style custom command using the appropriate\ncompute-ID.  It also means that changing attributes of thermo_temp\nor thermo_press will have no effect on this fix.\nLike other fixes that perform thermostatting, fix npt/cauchy can\nbe used with compute commands that calculate a\ntemperature after removing a “bias” from the atom velocities.\nE.g. removing the center-of-mass velocity from a group of atoms or\nonly calculating temperature on the x-component of velocity or only\ncalculating temperature for atoms in a geometric region.  This is not\ndone by default, but only if the fix_modify command\nis used to assign a temperature compute to this fix that includes such\na bias term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nThis fix can be used with either the verlet or respa\nintegrators. When using this fix\nwith respa, LAMMPS uses an integrator constructed\naccording to the following factorization of the Liouville propagator\n(for two rRESPA levels):\n\n\\[\\begin{split}\\exp \\left(\\mathrm{i} L \\Delta t \\right) = & \\hat{E}\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right) \\\\\n&\\times \\left[\n\\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_1 \\frac{\\Delta t}{n} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n\\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n\\right]^n \\\\\n&\\times\n\\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n\\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right) \\\\\n&+ \\mathcal{O} \\left(\\Delta t^3 \\right)\\end{split}\\]\nThis factorization differs somewhat from that of Tuckerman et al, in\nthat the barostat is only updated at the outermost rRESPA level,\nwhereas Tuckerman’s factorization requires splitting the pressure into\npieces corresponding to the forces computed at each rRESPA level. In\ntheory, the latter method will exhibit better numerical stability. In\npractice, because Pdamp is normally chosen to be a large multiple of\nthe outermost rRESPA timestep, the barostat dynamics are not the\nlimiting factor for numerical stability. Both factorizations are\ntime-reversible and can be shown to preserve the phase space measure\nof the underlying non-Hamiltonian equations of motion.\n\nNote\nUnder NPT dynamics, for a system with zero initial total linear\nmomentum, the total momentum fluctuates close to zero.  It may occasionally\nundergo brief excursions to non-negligible values, before returning close\nto zero.  Over long simulations, this has the effect of causing the\ncenter-of-mass to undergo a slow random walk. This can be mitigated by\nresetting the momentum at infrequent intervals using the\nfix momentum command.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of all the thermostat and barostat\nvariables to binary restart files.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure, as described above.\nIf you do this, note that the kinetic energy derived from the compute\ntemperature should be consistent with the virial term computed using\nall atoms for the pressure.  LAMMPS will warn you if you choose to\ncompute temperature on a subset of atoms.\n\nNote\nIf both the temp and press keywords are used in a single\nthermo_modify command (or in two separate commands), then the order in\nwhich the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\nan argument when it is specified.  The temp keyword will override\nthis (for the pressure compute being used by fix npt), but only if the\ntemp keyword comes after the press keyword.  If the temp keyword\ncomes before the press keyword, then the new pressure compute\nspecified by the press keyword will be unaffected by the temp\nsetting.\n\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting\nand barostatting to the system’s potential energy as part of\nthermodynamic output.\nThis fix computes a global scalar and a global vector of quantities,\nwhich can be accessed by various output commands.\nThe scalar value calculated by this fix is “extensive”; the vector\nvalues are “intensive”.\nThe scalar is the cumulative energy change due to the fix.\nThe vector stores internal Nose/Hoover thermostat and barostat\nvariables.  The number and meaning of the vector values depends on\nwhich fix is used and the settings for keywords tchain and pchain,\nwhich specify the number of Nose/Hoover chains for the thermostat and\nbarostat.  If no thermostatting is done, then tchain is 0.  If no\nbarostatting is done, then pchain is 0.  In the following list,\n“ndof” is 0, 1, 3, or 6, and is the number of degrees of freedom in\nthe barostat.  Its value is 0 if no barostat is used, else its value\nis 6 if any off-diagonal stress tensor component is barostatted, else\nits value is 1 if couple xyz is used or couple xy for a 2d\nsimulation, otherwise its value is 3.\nThe order of values in the global vector and their meaning is as\nfollows.  The notation means there are tchain values for eta, followed\nby tchain for eta_dot, followed by ndof for omega, etc:\n\neta[tchain] = particle thermostat displacements (unitless)\neta_dot[tchain] = particle thermostat velocities (1/time units)\nomega[ndof] = barostat displacements (unitless)\nomega_dot[ndof] = barostat velocities (1/time units)\netap[pchain] = barostat thermostat displacements (unitless)\netap_dot[pchain] = barostat thermostat velocities (1/time units)\nPE_eta[tchain] = potential energy of each particle thermostat displacement (energy units)\nKE_eta_dot[tchain] = kinetic energy of each particle thermostat velocity (energy units)\nPE_omega[ndof] = potential energy of each barostat displacement (energy units)\nKE_omega_dot[ndof] = kinetic energy of each barostat velocity (energy units)\nPE_etap[pchain] = potential energy of each barostat thermostat displacement (energy units)\nKE_etap_dot[pchain] = kinetic energy of each barostat thermostat velocity (energy units)\nPE_strain[1] = scalar strain energy (energy units)\n\nThis fix can ramp its external temperature and pressure over\nmultiple runs, using the start and stop keywords of the\nrun command.  See the run command for details of\nhow to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID style_name keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style_name = npt/cauchy\n * one or more keyword/value pairs may be appended\n * keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scalexy or scaleyz or scalexz or flip or fixedpoint or update\n * temp values = Tstart Tstop Tdamp\n *   Tstart,Tstop = external temperature at start/end of run\n *   Tdamp = temperature damping parameter (time units)\n * iso or aniso or tri values = Pstart Pstop Pdamp\n *   Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n *   Pdamp = pressure damping parameter (time units)\n * x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n *   Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n *   Pdamp = stress damping parameter (time units)\n * couple = none or xyz or xy or yz or xz\n * tchain value = N\n *   N = length of thermostat chain (1 = single thermostat)\n * pchain values = N\n *   N length of thermostat chain on barostat (0 = no thermostat)\n * mtk value = yes or no = add in MTK adjustment term or not\n * tloop value = M\n *   M = number of sub-cycles to perform on thermostat\n * ploop value = M\n *   M = number of sub-cycles to perform on barostat thermostat\n * nreset value = reset reference cell every this many timesteps\n * drag value = Df\n *   Df = drag factor added to barostat/thermostat (0.0 = no drag)\n * dilate value = dilate-group-ID\n *   dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n * scalexy value = yes or no = scale xy with ly\n * scaleyz value = yes or no = scale yz with lz\n * scalexz value = yes or no = scale xz with lz\n * flip value = yes or no = allow or disallow box flips when it becomes highly skewed\n * cauchystat cauchystat values = alpha continue\n *   alpha = strength of Cauchy stress control parameter\n *   continue = yes or no = whether of not to continue from a previous run\n * fixedpoint values = x y z\n *   x,y,z = perform barostat dilation/contraction around this point (distance units)",
    "examples": "fix 1 water npt/cauchy temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nX, y, z cannot be barostatted if the associated dimension is not\nperiodic.  Xy, xz, and yz can only be barostatted if the\nsimulation domain is triclinic and the 2nd dimension in the keyword\n(y dimension in xy) is periodic.  Z, xz, and yz, cannot be\nbarostatted for 2D simulations.  The create_box,\nread data, and read_restart\ncommands specify whether the simulation box is orthogonal or\nnon-orthogonal (triclinic) and explain the meaning of the xy,xz,yz\ntilt factors.\nFor the temp keyword, the final Tstop cannot be 0.0 since it would\nmake the external T = 0.0 at some timestep during the simulation which\nis not allowed in the Nose/Hoover formulation.\nThe scaleyz yes and scalexz yes keyword/value pairs can not be used\nfor 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\ncan only be used if the 2nd dimension in the keyword is periodic,\nand if the tilt factor is not coupled to the barostat via keywords\ntri, yz, xz, and xy.\nWithout the cauchystat keyword, the barostat algorithm\ncontrols the Second-Piola Kirchhoff stress, which is a stress measure\nreferred to the unmodified (initial) simulation box.  If the box\ndeforms substantially during the equilibration, the difference between\nthe set values and the final true (Cauchy) stresses can be\nconsiderable.\nThe cauchystat keyword modifies the barostat as per Miller et\nal. (Miller)_”#nc-Miller” so that the Cauchy stress is controlled.\nalpha is the non-dimensional parameter, typically set to 0.001 or\n0.01 that determines how aggressively the algorithm drives the system\ntowards the set Cauchy stresses.  Larger values of alpha will modify\nthe system more quickly, but can lead to instabilities.  Smaller\nvalues will lead to longer convergence time.  Since alpha also\ninfluences how much the stress fluctuations deviate from the\nequilibrium fluctuations, it should be set as small as possible.\nA continue value of yes indicates that the fix is subsequent to a\nprevious run with the npt/cauchy fix, and the intention is to continue\nfrom the converged stress state at the end of the previous run.  This\nmay be required, for example, when implementing a multi-step loading/unloading\nsequence over several fixes.\nSetting alpha to zero is not permitted.  To “turn off” the\ncauchystat control and thus restore the equilibrium stress\nfluctuations, two subsequent fixes should be used.  In the first, the\ncauchystat flag is used and the simulation box equilibrates to the\ncorrect shape for the desired stresses.  In the second, the fix\nstatement is identical except that the cauchystat keyword is removed\n(along with related alpha and continue values). This restores the\noriginal Parrinello-Rahman algorithm, but now with the correct simulation\nbox shape from the first fix.\nThis fix can be used with dynamic groups as defined by the\ngroup command.  Likewise it can be used with groups to\nwhich atoms are added or deleted over time, e.g. a deposition\nsimulation.  However, the conservation properties of the thermostat\nand barostat are defined for systems with a static set of atoms.  You\nmay observe odd behavior if the atoms in a group vary dramatically\nover time or the atom count becomes very small."
},
{
    "command": "fix npt/sphere",
    "html_filename": "fix_npt_sphere.html",
    "short_description": "Perform constant NPT integration to update position, velocity, and angular velocity each timestep for finite-sizex spherical particles in the group using a Nose/Hoover temperature thermostat and Nose/Hoover pressure barostat",
    "description": "Perform constant NPT integration to update position, velocity, and\nangular velocity each timestep for finite-sizex spherical particles in\nthe group using a Nose/Hoover temperature thermostat and Nose/Hoover\npressure barostat.  P is pressure; T is temperature.  This creates a\nsystem trajectory consistent with the isothermal-isobaric ensemble.\nThis fix differs from the fix npt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the spherical particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nIf the disc keyword is used, then each particle is treated as a 2d\ndisc (circle) instead of as a sphere.  This is only possible for 2d\nsimulations, as defined by the dimension keyword.\nThe only difference between discs and spheres in this context is their\nmoment of inertia, as used in the time integration.\nAdditional parameters affecting the thermostat and barostat are\nspecified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\niso, aniso, and dilate keywords.\nThe particles in the fix group are the only ones whose velocities and\npositions are updated by the velocity/position update portion of the\nNPT integration.\nRegardless of what particles are in the fix group, a global pressure is\ncomputed for all particles.  Similarly, when the size of the simulation\nbox is changed, all particles are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the particles in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of particles in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp/sphere” and\n“pressure”, as if these commands had been issued:\ncompute fix-ID_temp all temp/sphere\ncompute fix-ID_press all pressure fix-ID_temp\n\n\nSee the compute temp/sphere and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is “all”\nsince pressure is computed for the entire system.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat and barostat\nto binary restart files.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its thermostatting or barostatting procedure.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting and\nbarostatting to the system’s potential energy as part of\nthermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix npt command.\nThis fix can ramp its target temperature and pressure over multiple\nruns, using the start and stop keywords of the run\ncommand.  See the run command for details of how to do\nthis.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID npt/sphere keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * npt/sphere = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = disc\n * disc value = none = treat particles as 2d discs, not spheres\n * additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended",
    "examples": "fix 1 all npt/sphere temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\nfix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\nfix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 disc\nfix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\nfix 2 water npt/sphere temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\nand a radius as defined by the atom_style sphere\ncommand.\nAll particles in the group must be finite-size spheres.  They cannot\nbe point particles.\nUse of the disc keyword is only allowed for 2d simulations, as\ndefined by the dimension keyword."
},
{
    "command": "fix nve",
    "html_filename": "fix_nve.html",
    "short_description": "Perform constant NVE integration to update position and velocity for atoms in the group each timestep",
    "description": "Perform constant NVE integration to update position and velocity for\natoms in the group each timestep.  V is volume; E is energy.  This\ncreates a system trajectory consistent with the microcanonical\nensemble.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve",
    "parameters": " * ID, group-ID are documented in fix command\n * nve = style name of this fix command",
    "examples": "fix 1 all nve",
    "restrictions": "\nnone"
},
{
    "command": "fix nve/asphere",
    "html_filename": "fix_nve_asphere.html",
    "short_description": "Perform constant NVE integration to update position, velocity, orientation, and angular velocity for aspherical particles in the group each timestep",
    "description": "Perform constant NVE integration to update position, velocity,\norientation, and angular velocity for aspherical particles in the\ngroup each timestep.  V is volume; E is energy.  This creates a system\ntrajectory consistent with the microcanonical ensemble.\nThis fix differs from the fix nve command, which\nassumes point particles and only updates their position and velocity.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID nve/asphere",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/asphere = style name of this fix command",
    "examples": "fix 1 all nve/asphere",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "fix nve/asphere/noforce",
    "html_filename": "fix_nve_asphere_noforce.html",
    "short_description": "Perform updates of position and orientation, but not velocity or angular momentum for atoms in the group each timestep",
    "description": "Perform updates of position and orientation, but not velocity or\nangular momentum for atoms in the group each timestep.  In other\nwords, the force and torque on the atoms is ignored and their velocity\nand angular momentum are not updated.  The atom velocities and\nangular momenta are used to update their positions and orientation.\nThis is useful as an implicit time integrator for Fast Lubrication\nDynamics, since the velocity and angular momentum are updated by the\npair_style lubricuteU command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/asphere/noforce",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/asphere/noforce = style name of this fix command",
    "examples": "fix 1 all nve/asphere/noforce",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "fix nve/awpmd",
    "html_filename": "fix_nve_awpmd.html",
    "short_description": "Perform constant NVE integration to update position and velocity for nuclei and electrons in the group for the Antisymmetrized Wave Packet Molecular Dynamics model",
    "description": "Perform constant NVE integration to update position and velocity for\nnuclei and electrons in the group for the Antisymmetrized Wave Packet Molecular Dynamics model.  V is volume; E is energy.\nThis creates a system trajectory consistent with the microcanonical\nensemble.\nThe operation of this fix is exactly like that described by the fix nve command, except that the width and width-velocity of\nthe electron wave functions are also updated.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/awpmd",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/awpmd = style name of this fix command",
    "examples": "fix 1 all nve/awpmd",
    "restrictions": "This fix is part of the USER-AWPMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix nve/body",
    "html_filename": "fix_nve_body.html",
    "short_description": "Perform constant NVE integration to update position, velocity, orientation, and angular velocity for body particles in the group each timestep",
    "description": "Perform constant NVE integration to update position, velocity,\norientation, and angular velocity for body particles in the group each\ntimestep.  V is volume; E is energy.  This creates a system trajectory\nconsistent with the microcanonical ensemble.  See the Howto body doc page for more details on using body\nparticles.\nThis fix differs from the fix nve command, which\nassumes point particles and only updates their position and velocity.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/body",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/body = style name of this fix command",
    "examples": "fix 1 all nve/body",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style body\ncommand.\nAll particles in the group must be body particles.  They cannot be\npoint particles."
},
{
    "command": "fix nve/dot",
    "html_filename": "fix_nve_dot.html",
    "short_description": "Apply a rigid-body integrator as described in (Davidchack) to a group of atoms, but without Langevin dynamics",
    "description": "Apply a rigid-body integrator as described in (Davidchack)\nto a group of atoms, but without Langevin dynamics.\nThis command performs Molecular dynamics (MD)\nvia a velocity-Verlet algorithm and an evolution operator that rotates\nthe quaternion degrees of freedom, similar to the scheme outlined in (Miller).\nThis command is the equivalent of the fix nve/dotc/langevin\nwithout damping and noise and can be used to determine the stability range\nin a NVE ensemble prior to using the Langevin-type DOTC-integrator\n(see also fix nve/dotc/langevin).\nThe command is equivalent to the fix nve.\nThe particles are always considered to have a finite size.\nAn example input file can be found in /examples/USER/cgdna/examples/duplex1/.\nFurther details of the implementation and stability of the integrator are contained in (Henrich).\nThe preprint version of the article can be found here.",
    "syntax": "fix ID group-ID nve/dot",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/dot = style name of this fix command",
    "examples": "fix 1 all nve/dot",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.\nSee the Build package doc page for more info."
},
{
    "command": "fix nve/dotc/langevin",
    "html_filename": "fix_nve_dotc_langevin.html",
    "short_description": "Apply a rigid-body Langevin-type integrator of the kind “Langevin C” as described in (Davidchack) to a group of atoms, which models an interaction with an implicit background solvent",
    "description": "Apply a rigid-body Langevin-type integrator of the kind “Langevin C”\nas described in (Davidchack)\nto a group of atoms, which models an interaction with an implicit background\nsolvent.  This command performs Brownian dynamics (BD)\nvia a technique that splits the integration into a deterministic Hamiltonian\npart and the Ornstein-Uhlenbeck process for noise and damping.\nThe quaternion degrees of freedom are updated though an evolution\noperator which performs a rotation in quaternion space, preserves\nthe quaternion norm and is akin to (Miller).\nIn terms of syntax this command has been closely modelled on the\nfix langevin and its angmom option. But it combines\nthe fix nve and the fix langevin in\none single command. The main feature is improved stability\nover the standard integrator, permitting slightly larger timestep sizes.\n\nNote\nUnlike the fix langevin this command performs\nalso time integration of the translational and quaternion degrees of freedom.\n\nThe total force on each atom will have the form:\n\n\\[\\begin{split}F =   & F_c + F_f + F_r \\\\\nF_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\nF_r \\propto & \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n\\(F_c\\) is the conservative force computed via the usual\ninter-particle interactions (pair_style,\nbond_style, etc). The \\(F_f\\) and \\(F_r\\)\nterms are implicitly taken into account by this fix on a per-particle\nbasis.\n\\(F_f\\) is a frictional drag or viscous damping term proportional to\nthe particle’s velocity.  The proportionality constant for each atom is\ncomputed as \\(\\frac{m}{\\mathrm{damp}}\\), where m is the mass of\nthe particle and damp is the damping factor specified by the user.\n\\(F_r\\) is a force due to solvent atoms at a temperature T\nrandomly bumping into the particle.  As derived from the\nfluctuation/dissipation theorem, its magnitude as shown above is\nproportional to \\(\\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\), where\n\\(k_B\\) is the Boltzmann constant, T is the desired temperature,\nm is the mass of the particle, dt is the timestep size, and damp is\nthe damping factor.  Random numbers are used to randomize the direction\nand magnitude of this force as described in (Dunweg),\nwhere a uniform random number is used (instead of a Gaussian random\nnumber) for speed.\n\nTstart and Tstop have to be constant values, i.e. they cannot\nbe variables. If used together with the oxDNA force field for\ncoarse-grained simulation of DNA please note that T = 0.1 in oxDNA units\ncorresponds to T = 300 K.\nThe damp parameter is specified in time units and determines how\nrapidly the temperature is relaxed.  For example, a value of 0.03\nmeans to relax the temperature in a timespan of (roughly) 0.03 time\nunits tau (see the units command).\nThe damp factor can be thought of as inversely related to the\nviscosity of the solvent, i.e. a small relaxation time implies a\nhigh-viscosity solvent and vice versa.  See the discussion about gamma\nand viscosity in the documentation for the fix viscous command for more details.\nNote that the value 78.9375 in the second example above corresponds\nto a diffusion constant, which is about an order of magnitude larger\nthan realistic ones. This has been used to sample configurations faster\nin Brownian dynamics simulations.\nThe random # seed must be a positive integer. A Marsaglia random\nnumber generator is used.  Each processor uses the input seed to\ngenerate its own unique seed and its own stream of random numbers.\nThus the dynamics of the system will not be identical on two runs on\ndifferent numbers of processors.\nThe keyword/value option has to be used in the following way:\nThis fix has to be used together with the angmom keyword. The\nparticles are always considered to have a finite size.\nThe keyword angmom enables thermostatting of the rotational degrees of\nfreedom in addition to the usual translational degrees of freedom.\nThe scale factor after the angmom keyword gives the ratio of the\nrotational to the translational friction coefficient.\nAn example input file can be found in examples/USER/cgdna/examples/duplex2/.\nFurther details of the implementation and stability of the integrators are contained in (Henrich).\nThe preprint version of the article can be found here.",
    "syntax": "fix ID group-ID nve/dotc/langevin Tstart Tstop damp seed keyword value",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/dotc/langevin = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * damp = damping parameter (time units)\n * seed = random number seed to use for white noise (positive integer)\n * keyword = angmom\n * angmom value = factor\n *   factor = do thermostat rotational degrees of freedom via the angular momentum and apply numeric scale factor as discussed below",
    "examples": "fix 1 all nve/dotc/langevin 1.0 1.0 0.03 457145 angmom 10\nfix 1 all nve/dotc/langevin 0.1 0.1 78.9375 457145 angmom 10",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.\nSee the Build package doc page for more info."
},
{
    "command": "fix nve/eff",
    "html_filename": "fix_nve_eff.html",
    "short_description": "Perform constant NVE integration to update position and velocity for nuclei and electrons in the group for the electron force field model",
    "description": "Perform constant NVE integration to update position and velocity for\nnuclei and electrons in the group for the electron force field model.  V is volume; E is energy.  This creates a\nsystem trajectory consistent with the microcanonical ensemble.\nThe operation of this fix is exactly like that described by the fix nve command, except that the radius and radial velocity\nof electrons are also updated.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/eff",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/eff = style name of this fix command",
    "examples": "fix 1 all nve/eff",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix nve/limit",
    "html_filename": "fix_nve_limit.html",
    "short_description": "Perform constant NVE updates of position and velocity for atoms in the group each timestep",
    "description": "Perform constant NVE updates of position and velocity for atoms in the\ngroup each timestep.  A limit is imposed on the maximum distance an\natom can move in one timestep.  This is useful when starting a\nsimulation with a configuration containing highly overlapped atoms.\nNormally this would generate huge forces which would blow atoms out of\nthe simulation box, causing LAMMPS to stop with an error.\nUsing this fix can overcome that problem.  Forces on atoms must still\nbe computable (which typically means 2 atoms must have a separation\ndistance > 0.0).  But large velocities generated by large forces are\nreset to a value that corresponds to a displacement of length xmax\nin a single timestep.  Xmax is specified in distance units; see the\nunits command for details.  The value of xmax should be\nconsistent with the neighbor skin distance and the frequency of\nneighbor list re-building, so that pairwise interactions are not\nmissed on successive timesteps as atoms move.  See the\nneighbor and neigh_modify commands\nfor details.\nNote that if a velocity reset occurs the integrator will not conserve\nenergy.  On steps where no velocity resets occur, this integrator is\nexactly like the fix nve command.  Since forces are\nunaltered, pressures computed by thermodynamic output will still be\nvery large for overlapped configurations.\n\nNote\nYou should not use fix shake in conjunction\nwith this fix.  That is because fix shake applies constraint forces\nbased on the predicted positions of atoms after the next timestep.\nIt has no way of knowing the timestep may change due to this fix,\nwhich will cause the constraint forces to be invalid.  A better\nstrategy is to turn off fix shake when performing initial dynamics\nthat need this fix, then turn fix shake on when doing normal dynamics\nwith a fixed-size timestep.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the count of how\nmany updates of atom’s velocity/position were limited by the maximum\ndistance criterion.  This should be roughly the number of atoms so\naffected, except that updates occur at both the beginning and end of a\ntimestep in a velocity Verlet timestepping algorithm.  This is a\ncumulative quantity for the current run, but is re-initialized to zero\neach time a run is performed.  The scalar value calculated by this fix\nis “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/limit xmax",
    "parameters": " * ID, group-ID are documented in fix command\n * nve = style name of this fix command\n * xmax = maximum distance an atom can move in one timestep (distance units)",
    "examples": "fix 1 all nve/limit 0.1",
    "restrictions": "\nnone"
},
{
    "command": "fix nve/line",
    "html_filename": "fix_nve_line.html",
    "short_description": "Perform constant NVE integration to update position, velocity, orientation, and angular velocity for line segment particles in the group each timestep",
    "description": "Perform constant NVE integration to update position, velocity,\norientation, and angular velocity for line segment particles in the\ngroup each timestep.  V is volume; E is energy.  This creates a system\ntrajectory consistent with the microcanonical ensemble.  See Howto spherical doc page for an overview of using line\nsegment particles.\nThis fix differs from the fix nve command, which\nassumes point particles and only updates their position and velocity.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/line",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/line = style name of this fix command",
    "examples": "fix 1 all nve/line",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that particles be line segments as defined by the\natom_style line command."
},
{
    "command": "fix nve/manifold/rattle",
    "html_filename": "fix_nve_manifold_rattle.html",
    "short_description": "Perform constant NVE integration to update position and velocity for atoms constrained to a curved surface (manifold) in the group each timestep",
    "description": "Perform constant NVE integration to update position and velocity for\natoms constrained to a curved surface (manifold) in the group each\ntimestep. The constraint is handled by RATTLE (Andersen)\nwritten out for the special case of single-particle constraints as\nexplained in (Paquay).  V is volume; E is energy. This way,\nthe dynamics of particles constrained to curved surfaces can be\nstudied. If combined with fix langevin, this\ngenerates Brownian motion of particles constrained to a curved\nsurface. For a list of currently supported manifolds and their\nparameters, see the Howto manifold doc page.\nNote that the particles must initially be close to the manifold in\nquestion. If not, RATTLE will not be able to iterate until the\nconstraint is satisfied, and an error is generated. For simple\nmanifolds this can be achieved with region and create_atoms\ncommands, but for more complex surfaces it might be more useful to\nwrite a script.\nThe manifold args may be equal-style variables, like so:\nvariable R equal \"ramp(5.0,3.0)\"\nfix shrink_sphere all nve/manifold/rattle 1e-4 10 sphere v_R\n\n\nIn this case, the manifold parameter will change in time according to\nthe variable.  This is not a problem for the time integrator as long\nas the change of the manifold is slow with respect to the dynamics of\nthe particles.  Note that if the manifold has to exert work on the\nparticles because of these changes, the total energy might not be\nconserved.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/manifold/rattle tol maxit manifold manifold-args keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/manifold/rattle = style name of this fix command\n * tol = tolerance to which Newton iteration must converge\n * maxit = maximum number of iterations to perform\n * manifold = name of the manifold\n * manifold-args = parameters for the manifold\n * one or more keyword/value pairs may be appended\n * keyword = every\n *   every values = N\n *     N = print info about iteration every N steps. N = 0 means no output",
    "examples": "fix 1 all nve/manifold/rattle 1e-4 10 sphere 5.0\nfix step all nve/manifold/rattle 1e-8 100 ellipsoid 2.5 2.5 5.0 every 25",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "fix nve/noforce",
    "html_filename": "fix_nve_noforce.html",
    "short_description": "Perform updates of position, but not velocity for atoms in the group each timestep",
    "description": "Perform updates of position, but not velocity for atoms in the group\neach timestep.  In other words, the force on the atoms is ignored and\ntheir velocity is not updated.  The atom velocities are used to update\ntheir positions.\nThis can be useful for wall atoms, when you set their velocities, and\nwant the wall to move (or stay stationary) in a prescribed fashion.\nThis can also be accomplished via the fix setforce\ncommand, but with fix nve/noforce, the forces on the wall atoms are\nunchanged, and can thus be printed by the dump command or\nqueried with an equal-style variable that uses the\nfcm() group function to compute the total force on the group of atoms.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/noforce = style name of this fix command",
    "examples": "fix 3 wall nve/noforce",
    "restrictions": "\nnone"
},
{
    "command": "fix nve/sphere",
    "html_filename": "fix_nve_sphere.html",
    "short_description": "Perform constant NVE integration to update position, velocity, and angular velocity for finite-size spherical particles in the group each timestep",
    "description": "Perform constant NVE integration to update position, velocity, and\nangular velocity for finite-size spherical particles in the group each\ntimestep.  V is volume; E is energy.  This creates a system trajectory\nconsistent with the microcanonical ensemble.\nThis fix differs from the fix nve command, which\nassumes point particles and only updates their position and velocity.\nIf the update keyword is used with the dipole value, then the\norientation of the dipole moment of each particle is also updated\nduring the time integration.  This option should be used for models\nwhere a dipole moment is assigned to finite-size particles,\ne.g. spheroids via use of the atom_style hybrid sphere dipole command.\nThe default dipole orientation integrator can be changed to the\nDullweber-Leimkuhler-McLachlan integration scheme\n(Dullweber) when using update with the value\ndipole/dlm. This integrator is symplectic and time-reversible,\ngiving better energy conservation and allows slightly longer timesteps\nat only a small additional computational cost.\nIf the disc keyword is used, then each particle is treated as a 2d\ndisc (circle) instead of as a sphere.  This is only possible for 2d\nsimulations, as defined by the dimension keyword.\nThe only difference between discs and spheres in this context is their\nmoment of inertia, as used in the time integration.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/sphere",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/sphere = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = update or disc\n * update value = dipole or dipole/dlm\n *   dipole = update orientation of dipole moment during integration\n *   dipole/dlm = use DLM integrator to update dipole orientation\n * disc value = none = treat particles as 2d discs, not spheres",
    "examples": "fix 1 all nve/sphere\nfix 1 all nve/sphere update dipole\nfix 1 all nve/sphere disc\nfix 1 all nve/sphere update dipole/dlm",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\nand a radius as defined by the atom_style sphere\ncommand.  If the dipole keyword is used, then they must also store a\ndipole moment as defined by the atom_style dipole\ncommand.\nAll particles in the group must be finite-size spheres.  They cannot\nbe point particles.\nUse of the disc keyword is only allowed for 2d simulations, as\ndefined by the dimension keyword."
},
{
    "command": "fix nve/spin",
    "html_filename": "fix_nve_spin.html",
    "short_description": "Perform a symplectic integration for the spin or spin-lattice system",
    "description": "Perform a symplectic integration for the spin or spin-lattice system.\nThe lattice keyword defines if the spins are integrated on a lattice\nof fixed atoms (lattice = frozen), or if atoms are moving\n(lattice = moving).\nThe first case corresponds to a spin dynamics calculation, and\nthe second to a spin-lattice calculation.\nBy default a spin-lattice integration is performed (lattice = moving).\nThe nve/spin fix applies a Suzuki-Trotter decomposition to\nthe equations of motion of the spin lattice system, following the scheme:\n\naccording to the implementation reported in (Omelyan).\nA sectoring method enables this scheme for parallel calculations.\nThe implementation of this sectoring algorithm is reported\nin (Tranchida).",
    "syntax": "fix ID group-ID nve/spin keyword values",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/spin = style name of this fix command\n * keyword = lattice\n * lattice value = moving or frozen\n *   moving = integrate both spin and atomic degress of freedom\n *   frozen = integrate spins on a fixed lattice",
    "examples": "fix 3 all nve/spin lattice moving\nfix 1 all nve/spin lattice frozen",
    "restrictions": "This fix style can only be used if LAMMPS was built with the SPIN\npackage.  See the Build package doc page for more\ninfo.\nTo use the spin algorithm, it is necessary to define a map with\nthe atom_modify command. Typically, by adding the command:\natom_modify map array\n\n\nbefore you create the simulation box. Note that the keyword “hash”\ninstead of “array” is also valid."
},
{
    "command": "fix nve/tri",
    "html_filename": "fix_nve_tri.html",
    "short_description": "Perform constant NVE integration to update position, velocity, orientation, and angular momentum for triangular particles in the group each timestep",
    "description": "Perform constant NVE integration to update position, velocity,\norientation, and angular momentum for triangular particles in the\ngroup each timestep.  V is volume; E is energy.  This creates a system\ntrajectory consistent with the microcanonical ensemble.  See the\nHowto spherical doc page for an overview of\nusing triangular particles.\nThis fix differs from the fix nve command, which\nassumes point particles and only updates their position and velocity.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nve/tri",
    "parameters": " * ID, group-ID are documented in fix command\n * nve/tri = style name of this fix command",
    "examples": "fix 1 all nve/tri",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that particles be triangles as defined by the\natom_style tri command."
},
{
    "command": "fix nvk",
    "html_filename": "fix_nvk.html",
    "short_description": "Perform constant kinetic energy integration using the Gaussian thermostat to update position and velocity for atoms in the group each timestep",
    "description": "Perform constant kinetic energy integration using the Gaussian\nthermostat to update position and velocity for atoms in the group each\ntimestep.  V is volume; K is kinetic energy. This creates a system\ntrajectory consistent with the isokinetic ensemble.\nThe equations of motion used are those of Minary et al in\n(Minary), a variant of those initially given by Zhang in\n(Zhang).\nThe kinetic energy will be held constant at its value given when fix\nnvk is initiated. If a different kinetic energy is desired, the\nvelocity command should be used to change the kinetic\nenergy prior to this fix.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvk",
    "parameters": " * ID, group-ID are documented in fix command\n * nvk = style name of this fix command",
    "examples": "fix 1 all nvk",
    "restrictions": "The Gaussian thermostat only works when it is applied to all atoms in\nthe simulation box. Therefore, the group must be set to all.\nThis fix has not yet been implemented to work with the RESPA integrator.\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nRelated commands: none\nDefault: none\n\n(Minary) Minary, Martyna, and Tuckerman, J Chem Phys, 18, 2510 (2003).\n(Zhang) Zhang, J Chem Phys, 106, 6102 (1997)."
},
{
    "command": "fix nvt/asphere",
    "html_filename": "fix_nvt_asphere.html",
    "short_description": "Perform constant NVT integration to update position, velocity, orientation, and angular velocity each timestep for aspherical or ellipsoidal particles in the group using a Nose/Hoover temperature thermostat",
    "description": "Perform constant NVT integration to update position, velocity,\norientation, and angular velocity each timestep for aspherical or\nellipsoidal particles in the group using a Nose/Hoover temperature\nthermostat.  V is volume; T is temperature.  This creates a system\ntrajectory consistent with the canonical ensemble.\nThis fix differs from the fix nvt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the aspherical particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nAdditional parameters affecting the thermostat are specified by\nkeywords and values documented with the fix nvt\ncommand.  See, for example, discussion of the temp and drag\nkeywords.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp/asphere”, as if this command\nhad been issued:\ncompute fix-ID_temp group-ID temp/asphere\n\n\nSee the compute temp/asphere command for\ndetails.  Note that the ID of the new compute is the fix-ID +\nunderscore + “temp”, and the group for the new compute is the same as\nthe fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used in its thermostatting\nprocedure.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nvt command.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/asphere keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/asphere = style name of this fix command\n * additional thermostat related keyword/value pairs from the fix nvt command can be appended",
    "examples": "fix 1 all nvt/asphere temp 300.0 300.0 100.0\nfix 1 all nvt/asphere temp 300.0 300.0 100.0 drag 0.2",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "fix nvt/body",
    "html_filename": "fix_nvt_body.html",
    "short_description": "Perform constant NVT integration to update position, velocity, orientation, and angular velocity each timestep for body particles in the group using a Nose/Hoover temperature thermostat",
    "description": "Perform constant NVT integration to update position, velocity,\norientation, and angular velocity each timestep for body\nparticles in the group using a Nose/Hoover temperature\nthermostat.  V is volume; T is temperature.  This creates a system\ntrajectory consistent with the canonical ensemble.\nThis fix differs from the fix nvt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the body particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nAdditional parameters affecting the thermostat are specified by\nkeywords and values documented with the fix nvt\ncommand.  See, for example, discussion of the temp and drag\nkeywords.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp/body”, as if this command\nhad been issued:\ncompute fix-ID_temp group-ID temp/body\n\n\nSee the compute temp/body command for\ndetails.  Note that the ID of the new compute is the fix-ID +\nunderscore + “temp”, and the group for the new compute is the same as\nthe fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used in its thermostatting\nprocedure.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nvt command.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/body keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/body = style name of this fix command\n * additional thermostat related keyword/value pairs from the fix nvt command can be appended",
    "examples": "fix 1 all nvt/body temp 300.0 300.0 100.0\nfix 1 all nvt/body temp 300.0 300.0 100.0 drag 0.2",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms store torque and angular momentum and a\nquaternion as defined by the atom_style body\ncommand."
},
{
    "command": "fix nvt/manifold/rattle",
    "html_filename": "fix_nvt_manifold_rattle.html",
    "short_description": "This fix combines the RATTLE-based (Andersen) time integrator of fix nve/manifold/rattle (Paquay) with a Nose-Hoover-chain thermostat to sample the canonical ensemble of particles constrained to a curved surface (manifold)",
    "description": "This fix combines the RATTLE-based (Andersen) time\nintegrator of fix nve/manifold/rattle\n(Paquay) with a Nose-Hoover-chain thermostat to sample the\ncanonical ensemble of particles constrained to a curved surface\n(manifold). This sampling does suffer from discretization bias of\nO(dt).  For a list of currently supported manifolds and their\nparameters, see the Howto manifold doc page.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/manifold/rattle tol maxit manifold manifold-args keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/manifold/rattle = style name of this fix command\n * tol = tolerance to which Newton iteration must converge\n * maxit = maximum number of iterations to perform\n * manifold = name of the manifold\n * manifold-args = parameters for the manifold\n * one or more keyword/value pairs may be appended\n * keyword = temp or tchain or every\n *   temp values = Tstart Tstop Tdamp\n *     Tstart, Tstop = external temperature at start/end of run\n *     Tdamp = temperature damping parameter (time units)\n *   tchain value = N\n *     N = length of thermostat chain (1 = single thermostat)\n *   every value = N\n *     N = print info about iteration every N steps. N = 0 means no output",
    "examples": "fix 1 all nvt/manifold/rattle 1e-4 10 cylinder 3.0 temp 1.0 1.0 10.0",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix nvt/sllod",
    "html_filename": "fix_nvt_sllod.html",
    "short_description": "Perform constant NVT integration to update positions and velocities each timestep for atoms in the group using a Nose/Hoover temperature thermostat",
    "description": "Perform constant NVT integration to update positions and velocities\neach timestep for atoms in the group using a Nose/Hoover temperature\nthermostat.  V is volume; T is temperature.  This creates a system\ntrajectory consistent with the canonical ensemble.\nThis thermostat is used for a simulation box that is changing size\nand/or shape, for example in a non-equilibrium MD (NEMD) simulation.\nThe size/shape change is induced by use of the fix deform command, so each point in the simulation box\ncan be thought of as having a “streaming” velocity.  This\nposition-dependent streaming velocity is subtracted from each atom’s\nactual velocity to yield a thermal velocity which is used for\ntemperature computation and thermostatting.  For example, if the box\nis being sheared in x, relative to y, then points at the bottom of the\nbox (low y) have a small x velocity, while points at the top of the\nbox (hi y) have a large x velocity.  These velocities do not\ncontribute to the thermal “temperature” of the atom.\n\nNote\nFix deform has an option for remapping either\natom coordinates or velocities to the changing simulation box.  To use\nfix nvt/sllod, fix deform should NOT remap atom positions, because fix\nnvt/sllod adjusts the atom positions and velocities to create a\nvelocity profile that matches the changing box size/shape.  Fix deform\nSHOULD remap atom velocities when atoms cross periodic boundaries\nsince that is consistent with maintaining the velocity profile created\nby fix nvt/sllod.  LAMMPS will give an error if this setting is not\nconsistent.\n\nThe SLLOD equations of motion, originally proposed by Hoover and Ladd\n(see (Evans and Morriss)), were proven to be equivalent to\nNewton’s equations of motion for shear flow by (Evans and Morriss). They were later shown to generate the desired\nvelocity gradient and the correct production of work by stresses for\nall forms of homogeneous flow by (Daivis and Todd).  As\nimplemented in LAMMPS, they are coupled to a Nose/Hoover chain\nthermostat in a velocity Verlet formulation, closely following the\nimplementation used for the fix nvt command.\n\nNote\nA recent (2017) book by (Daivis and Todd)\ndiscusses use of the SLLOD method and non-equilibrium MD (NEMD)\nthermostatting generally, for both simple and complex fluids,\ne.g. molecular systems.  The latter can be tricky to do correctly.\n\nAdditional parameters affecting the thermostat are specified by\nkeywords and values documented with the fix nvt\ncommand.  See, for example, discussion of the temp and drag\nkeywords.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp/deform”, as if this command had\nbeen issued:\ncompute fix-ID_temp group-ID temp/deform\n\n\nSee the compute temp/deform command for\ndetails.  Note that the ID of the new compute is the fix-ID +\nunderscore + “temp”, and the group for the new compute is the same as\nthe fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used in its thermostatting\nprocedure.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nvt command.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/sllod keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/sllod = style name of this fix command\n * additional thermostat related keyword/value pairs from the fix nvt command can be appended",
    "examples": "fix 1 all nvt/sllod temp 300.0 300.0 100.0\nfix 1 all nvt/sllod temp 300.0 300.0 100.0 drag 0.2",
    "restrictions": "This fix works best without Nose-Hoover chain thermostats, i.e. using\ntchain = 1.  Setting tchain to larger values can result in poor\nequilibration."
},
{
    "command": "fix nvt/sllod/eff",
    "html_filename": "fix_nvt_sllod_eff.html",
    "short_description": "Perform constant NVT integration to update positions and velocities each timestep for nuclei and electrons in the group for the electron force field model, using a Nose/Hoover temperature thermostat",
    "description": "Perform constant NVT integration to update positions and velocities\neach timestep for nuclei and electrons in the group for the electron force field model, using a Nose/Hoover temperature\nthermostat.  V is volume; T is temperature.  This creates a system\ntrajectory consistent with the canonical ensemble.\nThe operation of this fix is exactly like that described by the fix nvt/sllod command, except that the radius and\nradial velocity of electrons are also updated and thermostatted.\nLikewise the temperature calculated by the fix, using the compute it\ncreates (as discussed in the fix nvt, npt, and nph doc\npage), is performed with a compute temp/deform/eff command that includes\nthe eFF contribution to the temperature from the electron radial\nvelocity.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used in its thermostatting\nprocedure.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nvt/eff command.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/sllod/eff keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/sllod/eff = style name of this fix command\n * additional thermostat related keyword/value pairs from the fix nvt/eff command can be appended",
    "examples": "fix 1 all nvt/sllod/eff temp 300.0 300.0 0.1\nfix 1 all nvt/sllod/eff temp 300.0 300.0 0.1 drag 0.2",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix works best without Nose-Hoover chain thermostats, i.e. using\ntchain = 1.  Setting tchain to larger values can result in poor\nequilibration."
},
{
    "command": "fix nvt/sphere",
    "html_filename": "fix_nvt_sphere.html",
    "short_description": "Perform constant NVT integration to update position, velocity, and angular velocity each timestep for finite-size spherical particles in the group using a Nose/Hoover temperature thermostat",
    "description": "Perform constant NVT integration to update position, velocity, and\nangular velocity each timestep for finite-size spherical particles in\nthe group using a Nose/Hoover temperature thermostat.  V is volume; T\nis temperature.  This creates a system trajectory consistent with the\ncanonical ensemble.\nThis fix differs from the fix nvt command, which\nassumes point particles and only updates their position and velocity.\nThe thermostat is applied to both the translational and rotational\ndegrees of freedom for the spherical particles, assuming a compute is\nused which calculates a temperature that includes the rotational\ndegrees of freedom (see below).  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nIf the disc keyword is used, then each particle is treated as a 2d\ndisc (circle) instead of as a sphere.  This is only possible for 2d\nsimulations, as defined by the dimension keyword.\nThe only difference between discs and spheres in this context is their\nmoment of inertia, as used in the time integration.\nAdditional parameters affecting the thermostat are specified by\nkeywords and values documented with the fix nvt\ncommand.  See, for example, discussion of the temp and drag\nkeywords.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp/sphere”, as if this command\nhad been issued:\ncompute fix-ID_temp group-ID temp/sphere\n\n\nSee the compute temp/sphere command for\ndetails.  Note that the ID of the new compute is the fix-ID +\nunderscore + “temp”, and the group for the new compute is the same as\nthe fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a compute you have\ndefined to this fix which will be used in its thermostatting\nprocedure.\nThe fix_modify energy option is supported by this\nfix to add the energy change induced by Nose/Hoover thermostatting to\nthe system’s potential energy as part of thermodynamic output.\nThis fix computes the same global scalar and global vector of\nquantities as does the fix nvt command.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID nvt/sphere keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * nvt/sphere = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = disc\n * disc value = none = treat particles as 2d discs, not spheres\n * additional thermostat related keyword/value pairs from the fix nvt command can be appended",
    "examples": "fix 1 all nvt/sphere temp 300.0 300.0 100.0\nfix 1 all nvt/sphere temp 300.0 300.0 100.0 disc\nfix 1 all nvt/sphere temp 300.0 300.0 100.0 drag 0.2",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\nand a radius as defined by the atom_style sphere\ncommand.\nAll particles in the group must be finite-size spheres.  They cannot\nbe point particles.\nUse of the disc keyword is only allowed for 2d simulations, as\ndefined by the dimension keyword."
},
{
    "command": "fix oneway",
    "html_filename": "fix_oneway.html",
    "short_description": "Enforce that particles in the group and in a given region can only move in one direction",
    "description": "Enforce that particles in the group and in a given region can only\nmove in one direction.  This is done by reversing a particle’s\nvelocity component, if it has the wrong sign in the specified\ndimension.  The effect is that the particle moves in one direction\nonly.\nThis can be used, for example, as a simple model of a semi-permeable\nmembrane, or as an implementation of Maxwell’s demon.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID oneway N region-ID direction",
    "parameters": " * ID, group-ID are documented in fix command\n * oneway = style name of this fix command\n * N = apply this fix every this many timesteps\n * region-ID = ID of region where fix is active\n * direction = x or -x or y or -y or z or -z = coordinate and direction of the oneway constraint",
    "examples": "fix ions oneway 10 semi -x\nfix all oneway 1 left -z\nfix all oneway 1 right z",
    "restrictions": "\nnone"
},
{
    "command": "fix orient/fcc",
    "html_filename": "fix_orient.html",
    "short_description": "The fix applies an orientation-dependent force to atoms near a planar grain boundary which can be used to induce grain boundary migration (in the direction perpendicular to the grain boundary plane)",
    "description": "The fix applies an orientation-dependent force to atoms near a planar\ngrain boundary which can be used to induce grain boundary migration\n(in the direction perpendicular to the grain boundary plane).  The\nmotivation and explanation of this force and its application are\ndescribed in (Janssens). The adaptation to bcc crystals\nis described in (Wicaksono1). The computed force is only\napplied to atoms in the fix group.\nThe basic idea is that atoms in one grain (on one side of the\nboundary) have a potential energy dE added to them.  Atoms in the\nother grain have 0.0 potential energy added.  Atoms near the boundary\n(whose neighbor environment is intermediate between the two grain\norientations) have an energy between 0.0 and dE added.  This creates\nan effective driving force to reduce the potential energy of atoms\nnear the boundary by pushing them towards one of the grain\norientations.  For dir = 1 and dE > 0, the boundary will thus move so\nthat the grain described by file0 grows and the grain described by\nfile1 shrinks.  Thus this fix is designed for simulations of two-grain\nsystems, either with one grain boundary and free surfaces parallel to\nthe boundary, or a system with periodic boundary conditions and two\nequal and opposite grain boundaries.  In either case, the entire\nsystem can displace during the simulation, and such motion should be\naccounted for in measuring the grain boundary velocity.\nThe potential energy added to atom I is given by these formulas\n\n\\[\\begin{split} \\xi_{i} = & \\sum_{j=1}^{12} \\left| \\mathbf{r}_{j} - \\mathbf{r}_{j}^{\\rm I} \\right| \\qquad\\qquad\\left(1\\right) \\\\\n \\\\\n\\xi_{\\rm IJ} = & \\sum_{j=1}^{12} \\left| \\mathbf{r}_{j}^{\\rm J} - \\mathbf{r}_{j}^{\\rm I} \\right| \\qquad\\qquad\\left(2\\right)\\\\\n\\\\\n\\xi_{\\rm low}  = & {\\rm cutlo} \\, \\xi_{\\rm IJ}  \\qquad\\qquad\\qquad\\left(3\\right)\\\\\n\\xi_{\\rm high}  = & {\\rm cuthi} \\, \\xi_{\\rm IJ} \\qquad\\qquad\\qquad\\left(4\\right) \\\\\n\\\\\n\\omega_{i} = & \\frac{\\pi}{2} \\frac{\\xi_{i} - \\xi_{\\rm low}}{\\xi_{\\rm high} - \\xi_{\\rm low}} \\qquad\\qquad\\left(5\\right)\\\\\n\\\\\nu_{i}  = & 0 \\quad\\quad\\qquad\\qquad\\qquad \\textrm{ for } \\qquad \\xi_{i} < \\xi_{\\rm low}\\\\\n       = & {\\rm dE}\\,\\frac{1 - \\cos(2 \\omega_{i})}{2}\n \\qquad \\mathrm{ for }\\qquad \\xi_{\\rm low} < \\xi_{i} < \\xi_{\\rm high}  \\quad \\left(6\\right) \\\\\n       = & {\\rm dE} \\quad\\qquad\\qquad\\qquad\\textrm{ for } \\qquad \\xi_{\\rm high} < \\xi_{i}\\end{split}\\]\nwhich are fully explained in (Janssens).  For fcc crystals\nthis order parameter Xi for atom I in equation (1) is a sum over the\n12 nearest neighbors of atom I. For bcc crystals it is the\ncorresponding sum of the 8 nearest neighbors. Rj is the vector from\natom I to its neighbor J, and RIj is a vector in the reference\n(perfect) crystal.  That is, if dir = 0/1, then RIj is a vector to an\natom coord from file 0/1.  Equation (2) gives the expected value of\nthe order parameter XiIJ in the other grain.  Hi and lo cutoffs are\ndefined in equations (3) and (4), using the input parameters cutlo\nand cuthi as thresholds to avoid adding grain boundary energy when\nthe deviation in the order parameter from 0 or 1 is small (e.g. due to\nthermal fluctuations in a perfect crystal).  The added potential\nenergy Ui for atom I is given in equation (6) where it is interpolated\nbetween 0 and dE using the two threshold Xi values and the Wi value of\nequation (5).\nThe derivative of this energy expression gives the force on each atom\nwhich thus depends on the orientation of its neighbors relative to the\n2 grain orientations.  Only atoms near the grain boundary feel a net\nforce which tends to drive them to one of the two grain orientations.\nIn equation (1), the reference vector used for each neighbor is the\nreference vector closest to the actual neighbor position.  This means\nit is possible two different neighbors will use the same reference\nvector.  In such cases, the atom in question is far from a perfect\norientation and will likely receive the full dE addition, so the\neffect of duplicate reference vector usage is small.\nThe dir parameter determines which grain wants to grow at the\nexpense of the other.  A value of 0 means the first grain will shrink;\na value of 1 means it will grow.  This assumes that dE is positive.\nThe reverse will be true if dE is negative.\nThe alat parameter is the cubic lattice constant for the fcc or bcc\nmaterial and is only used to compute a cutoff distance of 1.57 * alat\n/ sqrt(2) for finding the 12 or 8 nearest neighbors of each atom\n(which should be valid for an fcc or bcc crystal).  A longer/shorter\ncutoff can be imposed by adjusting alat.  If a particular atom has\nless than 12 or 8 neighbors within the cutoff, the order parameter of\nequation (1) is effectively multiplied by 12 or 8 divided by the\nactual number of neighbors within the cutoff.\nThe dE parameter is the maximum amount of additional energy added to\neach atom in the grain which wants to shrink.\nThe cutlo and cuthi parameters are used to reduce the force added\nto bulk atoms in each grain far away from the boundary.  An atom in\nthe bulk surrounded by neighbors at the ideal grain orientation would\ncompute an order parameter of 0 or 1 and have no force added.\nHowever, thermal vibrations in the solid will cause the order\nparameters to be greater than 0 or less than 1.  The cutoff parameters\nmask this effect, allowing forces to only be added to atoms with\norder-parameters between the cutoff values.\nFile0 and file1 are filenames for the two grains which each\ncontain 6 vectors (6 lines with 3 values per line) which specify the\ngrain orientations.  Each vector is a displacement from a central atom\n(0,0,0) to a nearest neighbor atom in an fcc lattice at the proper\norientation.  The vector lengths should all be identical since an fcc\nlattice has a coordination number of 12.  Only 6 are listed due to\nsymmetry, so the list must include one from each pair of\nequal-and-opposite neighbors.  A pair of orientation files for a\nSigma=5 tilt boundary are shown below. A tutorial that can help for\nwriting the orientation files is given in (Wicaksono2)\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential energy of atom interactions with the grain\nboundary driving force to the system’s potential energy as part of\nthermodynamic output.\nThe fix_modify respa option is supported by these\nfixes. This allows to set at which level of the r-RESPA\nintegrator a fix is adding its forces. Default is the outermost level.\nThis fix calculates a global scalar which can be accessed by various\noutput commands.  The scalar is the potential\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.\nThis fix also calculates a per-atom array which can be accessed by\nvarious output commands.  The array stores the\norder parameter Xi and normalized order parameter (0 to 1) for each\natom.  The per-atom values can be accessed on any timestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID oneway N region-ID direction",
    "parameters": " * ID, group-ID are documented in fix command\n * oneway = style name of this fix command\n * N = apply this fix every this many timesteps\n * region-ID = ID of region where fix is active\n * direction = x or -x or y or -y or z or -z = coordinate and direction of the oneway constraint",
    "examples": "fix gb all orient/fcc 0 1 4.032008 0.001 0.25 0.75 xi.vec chi.vec\nfix gb all orient/bcc 0 1 2.882 0.001 0.25 0.75 ngb.left ngb.right",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nThis fix should only be used with fcc or bcc lattices."
},
{
    "command": "fix phonon",
    "html_filename": "fix_phonon.html",
    "short_description": "Calculate the dynamical matrix from molecular dynamics simulations based on fluctuation-dissipation theory for a group of atoms",
    "description": "Calculate the dynamical matrix from molecular dynamics simulations\nbased on fluctuation-dissipation theory for a group of atoms.\nConsider a crystal with \\(N\\) unit cells in three dimensions labeled\n\\(l = (l_1, l_2, l_3)\\) where \\(l_i\\) are integers.  Each unit cell is\ndefined by three linearly independent vectors \\(\\mathbf{a}_1\\),\n\\(\\mathbf{a}_2\\), \\(\\mathbf{a}_3\\) forming a parallelepiped,\ncontaining \\(K\\) basis atoms labeled \\(k\\).\nBased on fluctuation-dissipation theory, the force constant\ncoefficients of the system in reciprocal space are given by\n(Campana , Kong)\n\n\\[\\mathbf{\\Phi}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) = k_B T \\mathbf{G}^{-1}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q})\\]\nwhere \\(\\mathbf{G}\\) is the Green’s functions coefficients given by\n\n\\[\\mathbf{G}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) = \\left< \\mathbf{u}_{k\\alpha}(\\mathbf{q}) \\bullet \\mathbf{u}_{k^\\prime \\beta}^*(\\mathbf{q}) \\right>\\]\nwhere \\(\\left< \\ldots \\right>\\) denotes the ensemble average, and\n\n\\[\\mathbf{u}_{k\\alpha}(\\mathbf{q}) = \\sum_l \\mathbf{u}_{l k \\alpha} \\exp{(i\\mathbf{qr}_l)}\\]\nis the \\(\\alpha\\) component of the atomic displacement for the \\(k\\)\nth atom in the unit cell in reciprocal space at \\(\\mathbf{q}\\). In\npractice, the Green’s functions coefficients can also be measured\naccording to the following formula,\n\n\\[\\mathbf{G}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) =\n\\left< \\mathbf{R}_{k \\alpha}(\\mathbf{q}) \\bullet \\mathbf{R}^*_{k^\\prime \\beta}(\\mathbf{q}) \\right>\n- \\left<\\mathbf{R}\\right>_{k \\alpha}(\\mathbf{q}) \\bullet \\left<\\mathbf{R}\\right>^*_{k^\\prime \\beta}(\\mathbf{q})\\]\nwhere \\(\\mathbf{R}\\) is the instantaneous positions of atoms, and\n\\(\\left<\\mathbf{R}\\right>\\) is the averaged atomic positions. It\ngives essentially the same results as the displacement method and is\neasier to implement in an MD code.\nOnce the force constant matrix is known, the dynamical matrix\n\\(\\mathbf{D}\\) can then be obtained by\n\n\\[\\mathbf{D}_{k\\alpha, k^\\prime\\beta}(\\mathbf{q}) =\n(m_k m_{k^\\prime})^{-\\frac{1}{2}} \\mathbf{\\Phi}_{k \\alpha, k^\\prime \\beta}(\\mathbf{q})\\]\nwhose eigenvalues are exactly the phonon frequencies at \\(\\mathbf{q}\\).\nThis fix uses positions of atoms in the specified group and calculates\ntwo-point correlations.  To achieve this. the positions of the atoms\nare examined every Nevery steps and are Fourier-transformed into\nreciprocal space, where the averaging process and correlation\ncomputation is then done.  After every Noutput measurements, the\nmatrix \\(\\mathbf{G}(\\mathbf{q})\\) is calculated and inverted to\nobtain the elastic stiffness coefficients.  The dynamical matrices are\nthen constructed and written to prefix.bin.timestep files in binary\nformat and to the file prefix.log for each wave-vector\n\\(\\mathbf{q}\\).\nA detailed description of this method can be found in\n(Kong2011).\nThe sysdim keyword is optional.  If specified with a value smaller\nthan the dimensionality of the LAMMPS simulation, its value is used\nfor the dynamical matrix calculation.  For example, using LAMMPS ot\nmodel a 2D or 3D system, the phonon dispersion of a 1D atomic chain\ncan be computed using sysdim = 1.\nThe nasr keyword is optional.  An iterative procedure is employed to\nenforce the acoustic sum rule on \\(\\Phi\\) at \\(\\Gamma\\), and the number\nprovided by keyword nasr gives the total number of iterations. For a\nsystem whose unit cell has only one atom, nasr = 1 is sufficient;\nfor other systems, nasr = 10 is typically sufficient.\nThe map_file contains the mapping information between the lattice\nindices and the atom IDs, which tells the code which atom sits at\nwhich lattice point; the lattice indices start from 0. An auxiliary\ncode, latgen, can be employed to\ngenerate the compatible map file for various crystals.\nIn case one simulates a non-periodic system, where the whole simulation\nbox is treated as a unit cell, one can set map_file as GAMMA, so\nthat the mapping info will be generated internally and a file is not\nneeded. In this case, the dynamical matrix at only the gamma-point\nwill/can be evaluated. Please keep in mind that fix-phonon is designed\nfor cyrstals, it will be inefficient and even degrade the performance\nof lammps in case the unit cell is too large.\nThe calculated dynamical matrix elements are written out in\nenergy/distance^2/mass units.  The coordinates for q\npoints in the log file is in the units of the basis vectors of the\ncorresponding reciprocal lattice.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp option is supported by this\nfix. You can use it to change the temperature compute from thermo_temp\nto the one that reflects the true temperature of atoms in the group.\nNo global scalar or vector or per-atom quantities are stored by this\nfix for access by various output commands.\nInstead, this fix outputs its initialization information (including\nmapping information) and the calculated dynamical matrices to the file\nprefix.log, with the specified prefix.  The dynamical matrices are\nalso written to files prefix.bin.timestep in binary format.  These\ncan be read by the post-processing tool in tools/phonon to compute the\nphonon density of states and/or phonon dispersion curves.\nNo parameter of this fix can be used with the start/stop keywords\nof the run command.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID phonon N Noutput Nwait map_file prefix keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * phonon = style name of this fix command\n * N = measure the Green’s function every this many timesteps\n * Noutput = output the dynamical matrix every this many measurements\n * Nwait = wait this many timesteps before measuring\n * map_file = file or GAMMA\n * file is the file that contains the mapping info between atom ID and the lattice indices.\n * GAMMA flags to treate the whole simulation box as a unit cell, so that the mapping\n * info can be generated internally. In this case, dynamical matrix at only the gamma-point\n * will/can be evaluated.\n * prefix = prefix for output files\n * one or none keyword/value pairs may be appended\n * keyword = sysdim or nasr\n * sysdim value = d\n *   d = dimension of the system, usually the same as the MD model dimension\n * nasr value = n\n *   n = number of iterations to enforce the acoustic sum rule",
    "examples": "fix 1 all phonon 20 5000 200000 map.in LJ1D sysdim 1\nfix 1 all phonon 20 5000 200000 map.in EAM3D\nfix 1 all phonon 10 5000 500000 GAMMA EAM0D nasr 100",
    "restrictions": "This fix assumes a crystalline system with periodical lattice. The\ntemperature of the system should not exceed the melting temperature to\nkeep the system in its solid state.\nThis fix is part of the USER-PHONON package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix requires LAMMPS be built with an FFT library.  See the Build settings doc page for details."
},
{
    "command": "fix pimd",
    "html_filename": "fix_pimd.html",
    "short_description": "This command performs quantum molecular dynamics simulations based on the Feynman path integral to include effects of tunneling and zero-point motion",
    "description": "This command performs quantum molecular dynamics simulations based on\nthe Feynman path integral to include effects of tunneling and\nzero-point motion.  In this formalism, the isomorphism of a quantum\npartition function for the original system to a classical partition\nfunction for a ring-polymer system is exploited, to efficiently sample\nconfigurations from the canonical ensemble (Feynman).\nThe classical partition function and its components are given\nby the following equations:\n\n\\[\\begin{split}Z = & \\int d{\\bf q} d{\\bf p} \\cdot \\textrm{exp} [ -\\beta H_{eff} ] \\\\\nH_{eff} = & \\bigg(\\sum_{i=1}^P \\frac{p_i^2}{2m_i}\\bigg) + V_{eff} \\\\\nV_{eff} = & \\sum_{i=1}^P \\bigg[ \\frac{mP}{2\\beta^2 \\hbar^2} (q_i - q_{i+1})^2 + \\frac{1}{P} V(q_i)\\bigg]\\end{split}\\]\nThe interested user is referred to any of the numerous references on\nthis methodology, but briefly, each quantum particle in a path\nintegral simulation is represented by a ring-polymer of P quasi-beads,\nlabeled from 1 to P.  During the simulation, each quasi-bead interacts\nwith beads on the other ring-polymers with the same imaginary time\nindex (the second term in the effective potential above).  The\nquasi-beads also interact with the two neighboring quasi-beads through\nthe spring potential in imaginary-time space (first term in effective\npotential).  To sample the canonical ensemble, a Nose-Hoover massive\nchain thermostat is applied (Tuckerman).  With the\nmassive chain algorithm, a chain of NH thermostats is coupled to each\ndegree of freedom for each quasi-bead.  The keyword temp sets the\ntarget temperature for the system and the keyword nhc sets the\nnumber Nc of thermostats in each chain.  For example, for a\nsimulation of N particles with P beads in each ring-polymer, the total\nnumber of NH thermostats would be 3 x N x P x Nc.\n\nNote\nThis fix implements a complete velocity-verlet integrator\ncombined with NH massive chain thermostat, so no other time\nintegration fix should be used.\n\nThe method keyword determines what style of PIMD is performed.  A\nvalue of pimd is standard PIMD.  A value of nmpimd is for\nnormal-mode PIMD.  A value of cmd is for centroid molecular dynamics\n(CMD).  The difference between the styles is as follows.\nIn standard PIMD, the value used for a bead’s fictitious mass is\narbitrary.  A common choice is to use Mi = m/P, which results in the\nmass of the entire ring-polymer being equal to the real quantum\nparticle.  But it can be difficult to efficiently integrate the\nequations of motion for the stiff harmonic interactions in the ring\npolymers.\nA useful way to resolve this issue is to integrate the equations of\nmotion in a normal mode representation, using Normal Mode\nPath-Integral Molecular Dynamics (NMPIMD) (Cao1).  In NMPIMD,\nthe NH chains are attached to each normal mode of the ring-polymer and\nthe fictitious mass of each mode is chosen as Mk = the eigenvalue of\nthe Kth normal mode for k > 0. The k = 0 mode, referred to as the\nzero-frequency mode or centroid, corresponds to overall translation of\nthe ring-polymer and is assigned the mass of the real particle.\nMotion of the centroid can be effectively uncoupled from the other\nnormal modes by scaling the fictitious masses to achieve a partial\nadiabatic separation.  This is called a Centroid Molecular Dynamics\n(CMD) approximation (Cao2).  The time-evolution (and resulting\ndynamics) of the quantum particles can be used to obtain centroid time\ncorrelation functions, which can be further used to obtain the true\nquantum correlation function for the original system.  The CMD method\nalso uses normal modes to evolve the system, except only the k > 0\nmodes are thermostatted, not the centroid degrees of freedom.\nThe keyword fmass sets a further scaling factor for the fictitious\nmasses of beads, which can be used for the Partial Adiabatic CMD\n(Hone), or to be set as P, which results in the fictitious\nmasses to be equal to the real particle masses.\nThe keyword sp is a scaling factor on Planck’s constant, which can\nbe useful for debugging or other purposes.  The default value of 1.0\nis appropriate for most situations.\nThe PIMD algorithm in LAMMPS is implemented as a hyper-parallel scheme\nas described in (Calhoun).  In LAMMPS this is done by using\nmulti-replica feature in LAMMPS, where each\nquasi-particle system is stored and simulated on a separate partition\nof processors.  The following diagram illustrates this approach.  The\noriginal system with 2 ring polymers is shown in red.  Since each ring\nhas 4 quasi-beads (imaginary time slices), there are 4 replicas of the\nsystem, each running on one of the 4 partitions of processors.  Each\nreplica (shown in green) owns one quasi-bead in each ring.\n\nTo run a PIMD simulation with M quasi-beads in each ring polymer using\nN MPI tasks for each partition’s domain-decomposition, you would use P\n= MxN processors (cores) and run the simulation as follows:\nmpirun -np P lmp_mpi -partition MxN -in script\n\n\nNote that in the LAMMPS input script for a multi-partition simulation,\nit is often very useful to define a uloop-style variable such as\nvariable ibead uloop M pad\n\n\nwhere M is the number of quasi-beads (partitions) used in the\ncalculation.  The uloop variable can then be used to manage I/O\nrelated tasks for each of the partitions, e.g.\ndump dcd all dcd 10 system_${ibead}.dcd\nrestart 1000 system_${ibead}.restart1 system_${ibead}.restart2\nread_restart system_${ibead}.restart2",
    "syntax": "fix ID group-ID pimd keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * pimd = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = method or fmass or sp or temp or nhc\n * method value = pimd or nmpimd or cmd\n * fmass value = scaling factor on mass\n * sp value = scaling factor on Planck constant\n * temp value = temperature (temperarate units)\n * nhc value = Nc = number of chains in Nose-Hoover thermostat",
    "examples": "fix 1 all pimd method nmpimd fmass 1.0 sp 2.0 temp 300.0 nhc 4",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nA PIMD simulation can be initialized with a single data file read via\nthe read_data command.  However, this means all\nquasi-beads in a ring polymer will have identical positions and\nvelocities, resulting in identical trajectories for all quasi-beads.\nTo avoid this, users can simply initialize velocities with different\nrandom number seeds assigned to each partition, as defined by the\nuloop variable, e.g.\nvelocity all create 300.0 1234${ibead} rot yes dist gaussian"
},
{
    "command": "fix planeforce",
    "html_filename": "fix_planeforce.html",
    "short_description": "Adjust the forces on each atom in the group so that only the components of force in the plane specified by the normal vector (x,y,z) remain",
    "description": "Adjust the forces on each atom in the group so that only the\ncomponents of force in the plane specified by the normal vector\n(x,y,z) remain.  This is done by subtracting out the component of\nforce perpendicular to the plane.\nIf the initial velocity of the atom is 0.0 (or in the plane), then it\nshould continue to move in the plane thereafter.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.",
    "syntax": "fix ID group-ID planeforce x y z",
    "parameters": " * ID, group-ID are documented in fix command\n * planeforce = style name of this fix command\n * x y z = 3-vector that is normal to the plane",
    "examples": "fix hold boundary planeforce 1.0 0.0 0.0",
    "restrictions": "\nnone"
},
{
    "command": "fix plumed",
    "html_filename": "fix_plumed.html",
    "short_description": "This fix instructs LAMMPS to call the PLUMED library, which allows one to perform various forms of trajectory analysis on the fly and to also use methods such as umbrella sampling and metadynamics to enhance the sampling of phase space",
    "description": "This fix instructs LAMMPS to call the PLUMED library, which\nallows one to perform various forms of trajectory analysis on the fly\nand to also use methods such as umbrella sampling and metadynamics to\nenhance the sampling of phase space.\nThe documentation included here only describes the fix plumed command\nitself.  This command is LAMMPS specific, whereas most of the\nfunctionality implemented in PLUMED will work with a range of MD codes,\nand when PLUMED is used as a stand alone code for analysis.  The full\ndocumentation for PLUMED is available online and included\nin the PLUMED source code.  The PLUMED library development is hosted at\nhttps://github.com/plumed/plumed2\nA detailed discussion of the code can be found in (PLUMED).\nThere is an example input for using this package with LAMMPS in the\nexamples/USER/plumed directory.\n\nThe command to make LAMMPS call PLUMED during a run requires two keyword\nvalue pairs pointing to the PLUMED input file and an output file for the\nPLUMED log. The user must specify these arguments every time PLUMED is\nto be used.  Furthermore, the fix plumed command should appear in the\nLAMMPS input file after relevant input parameters (e.g. the timestep)\nhave been set.\nThe group-ID entry is ignored. LAMMPS will always pass all the atoms\nto PLUMED and there can only be one instance of the plumed fix at a\ntime. The way the plumed fix is implemented ensures that the minimum\namount of information required is communicated.  Furthermore, PLUMED\nsupports multiple, completely independent collective variables, multiple\nindependent biases and multiple independent forms of analysis.  There is\nthus really no restriction in functionality by only allowing only one\nplumed fix in the LAMMPS input.\nThe plumedfile keyword allows the user to specify the name of the\nPLUMED input file.  Instructions as to what should be included in a\nplumed input file can be found in the documentation for PLUMED\nThe outfile keyword allows the user to specify the name of a file in\nwhich to output the PLUMED log.  This log file normally just repeats the\ninformation that is contained in the input file to confirm it was\ncorrectly read and parsed.  The names of the files in which the results\nare stored from the various analysis options performed by PLUMED will\nbe specified by the user in the PLUMED input file.\nRestart, fix_modify, output, run start/stop, minimize info:\nWhen performing a restart of a calculation that involves PLUMED you must\ninclude a RESTART command in the PLUMED input file as detailed in the\nPLUMED documentation.  When the restart command is found in\nthe PLUMED input PLUMED will append to the files that were generated in\nthe run that was performed previously.  No part of the PLUMED restart\ndata is included in the LAMMPS restart files.  Furthermore, any history\ndependent bias potentials that were accumulated in previous calculations\nwill be read in when the RESTART command is included in the PLUMED\ninput.\nThe fix_modify energy option is not supported by\nthis fix.\nNothing is computed by this fix that can be accessed by any of the\noutput commands within LAMMPS.  All the quantities\nof interest can be output by commands that are native to PLUMED,\nhowever.",
    "syntax": "fix ID group-ID plumed keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * plumed = style name of this fix command\n * keyword = plumedfile or outfile\n * plumedfile arg = name of PLUMED input file to use (default: NULL)\n * outfile arg = name of file on which to write the PLUMED log (default: NULL)",
    "examples": "fix pl all plumed all plumed plumedfile plumed.dat outfile p.log",
    "restrictions": "This fix is part of the USER-PLUMED package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThere can only be one plumed fix active at a time."
},
{
    "command": "fix poems",
    "html_filename": "fix_poems.html",
    "short_description": "Treats one or more sets of atoms as coupled rigid bodies",
    "description": "Treats one or more sets of atoms as coupled rigid bodies.  This means\nthat each timestep the total force and torque on each rigid body is\ncomputed and the coordinates and velocities of the atoms are updated\nso that the collection of bodies move as a coupled set.  This can be\nuseful for treating a large biomolecule as a collection of connected,\ncoarse-grained particles.\nThe coupling, associated motion constraints, and time integration is\nperformed by the software package Parallelizable Open source Efficient Multibody Software (POEMS) which computes the\nconstrained rigid-body motion of articulated (jointed) multibody\nsystems (Anderson).  POEMS was written and is distributed\nby Prof Kurt Anderson, his graduate student Rudranarayan Mukherjee,\nand other members of his group at Rensselaer Polytechnic Institute\n(RPI).  Rudranarayan developed the LAMMPS/POEMS interface.  For\ncopyright information on POEMS and other details, please refer to the\ndocuments in the poems directory distributed with LAMMPS.\nThis fix updates the positions and velocities of the rigid atoms with\na constant-energy time integration, so you should not update the same\natoms via other fixes (e.g. nve, nvt, npt, temp/rescale, langevin).\nEach body must have a non-degenerate inertia tensor, which means if\nmust contain at least 3 non-collinear atoms.  Which atoms are in which\nbodies can be defined via several options.\nFor option group, each of the listed groups is treated as a rigid\nbody.  Note that only atoms that are also in the fix group are\nincluded in each rigid body.\nFor option molecule, each set of atoms in the group with a different\nmolecule ID is treated as a rigid body.\nFor option file, sets of atoms are read from the specified file and\neach set is treated as a rigid body.  Each line of the file specifies\na rigid body in the following format:\nID type atom1-ID atom2-ID atom3-ID …\nID as an integer from 1 to M (the number of rigid bodies).  Type is\nany integer; it is not used by the fix poems command.  The remaining\narguments are IDs of atoms in the rigid body, each typically from 1 to\nN (the number of atoms in the system).  Only atoms that are also in\nthe fix group are included in each rigid body.  Blank lines and lines\nthat begin with ‘#’ are skipped.\nA connection between a pair of rigid bodies is inferred if one atom is\ncommon to both bodies.  The POEMS solver treats that atom as a\nspherical joint with 3 degrees of freedom.  Currently, a collection of\nbodies can only be connected by joints as a linear chain.  The entire\ncollection of rigid bodies can represent one or more chains.  Other\nconnection topologies (tree, ring) are not allowed, but will be added\nlater.  Note that if no joints exist, it is more efficient to use the\nfix rigid command to simulate the system.\nWhen the poems fix is defined, it will print out statistics on the\ntotal # of clusters, bodies, joints, atoms involved.  A cluster in\nthis context means a set of rigid bodies connected by joints.\nFor computational efficiency, you should turn off pairwise and bond\ninteractions within each rigid body, as they no longer contribute to\nthe motion.  The “neigh_modify exclude” and “delete_bonds” commands\ncan be used to do this if each rigid body is a group.\nFor computational efficiency, you should only define one fix poems\nwhich includes all the desired rigid bodies.  LAMMPS will allow\nmultiple poems fixes to be defined, but it is more expensive.\nThe degrees-of-freedom removed by coupled rigid bodies are accounted\nfor in temperature and pressure computations.  Similarly, the rigid\nbody contribution to the pressure virial is also accounted for.  The\nlatter is only correct if forces within the bodies have been turned\noff, and there is only a single fix poems defined.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify bodyforces option is supported by\nthis fix style to set whether per-body forces and torques are computed\nearly or late in a timestep, i.e. at the post-force stage or at the\nfinal-integrate stage, respectively.\nNo global or per-atom quantities are stored by this fix for access by\nvarious output commands.  No parameter of this fix\ncan be used with the start/stop keywords of the run\ncommand.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID plumed keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * plumed = style name of this fix command\n * keyword = plumedfile or outfile\n * plumedfile arg = name of PLUMED input file to use (default: NULL)\n * outfile arg = name of file on which to write the PLUMED log (default: NULL)",
    "examples": "fix 3 fluid poems group clump1 clump2 clump3\nfix 3 fluid poems file cluster.list",
    "restrictions": "This fix is part of the POEMS package.  It is only enabled if LAMMPS\nwas built with that package, which also requires the POEMS library be\nbuilt and linked with LAMMPS.  See the Build package doc page for more info."
},
{
    "command": "fix pour",
    "html_filename": "fix_pour.html",
    "short_description": "Insert finite-size particles or molecules into the simulation box every few timesteps within a specified region until N particles or molecules have been inserted",
    "description": "Insert finite-size particles or molecules into the simulation box\nevery few timesteps within a specified region until N particles or\nmolecules have been inserted.  This is typically used to model the\npouring of granular particles into a container under the influence of\ngravity.  For the remainder of this doc page, a single inserted atom\nor molecule is referred to as a “particle”.\nIf inserted particles are individual atoms, they are assigned the\nspecified atom type.  If they are molecules, the type of each atom in\nthe inserted molecule is specified in the file read by the\nmolecule command, and those values are added to the\nspecified atom type.  E.g. if the file specifies atom types 1,2,3, and\nthose are the atom types you want for inserted molecules, then specify\ntype = 0.  If you specify type = 2, the in the inserted molecule\nwill have atom types 3,4,5.\nAll atoms in the inserted particle are assigned to two groups: the\ndefault group “all” and the group specified in the fix pour command\n(which can also be “all”).\nThis command must use the region keyword to define an insertion\nvolume.  The specified region must have been previously defined with a\nregion command.  It must be of type block or a z-axis\ncylinder and must be defined with side = in.  The cylinder style\nof region can only be used with 3d simulations.\nIndividual atoms are inserted, unless the mol keyword is used.  It\nspecifies a template-ID previously defined using the\nmolecule command, which reads a file that defines the\nmolecule.  The coordinates, atom types, center-of-mass, moments of\ninertia, etc, as well as any bond/angle/etc and special neighbor\ninformation for the molecule can be specified in the molecule file.\nSee the molecule command for details.  The only\nsettings required to be in this file are the coordinates and types of\natoms in the molecule.\nIf the molecule template contains more than one molecule, the relative\nprobability of depositing each molecule can be specified by the\nmolfrac keyword.  N relative probabilities, each from 0.0 to 1.0, are\nspecified, where N is the number of molecules in the template.  Each\ntime a molecule is inserted, a random number is used to sample from\nthe list of relative probabilities.  The N values must sum to 1.0.\nIf you wish to insert molecules via the mol keyword, that will be\ntreated as rigid bodies, use the rigid keyword, specifying as its\nvalue the ID of a separate fix rigid/small\ncommand which also appears in your input script.\n\nNote\nIf you wish the new rigid molecules (and other rigid molecules)\nto be thermostatted correctly via fix rigid/small/nvt\nor fix rigid/small/npt, then you need to use the\n“fix_modify dynamic/dof yes” command for the rigid fix.  This is to\ninform that fix that the molecule count will vary dynamically.\n\nIf you wish to insert molecules via the mol keyword, that will have\ntheir bonds or angles constrained via SHAKE, use the shake keyword,\nspecifying as its value the ID of a separate fix shake command which also appears in your input script.\nEach timestep particles are inserted, they are placed randomly inside\nthe insertion volume so as to mimic a stream of poured particles.  If\nthey are molecules they are also oriented randomly.  Each atom in the\nparticle is tested for overlaps with existing particles, including\neffects due to periodic boundary conditions if applicable.  If an\noverlap is detected, another random insertion attempt is made; see the\nvol keyword discussion below.  The larger the volume of the\ninsertion region, the more particles that can be inserted at any one\ntimestep.  Particles are inserted again after enough time has elapsed\nthat the previously inserted particles fall out of the insertion\nvolume under the influence of gravity.  Insertions continue every so\nmany timesteps until the desired # of particles has been inserted.\n\nNote\nIf you are monitoring the temperature of a system where the\nparticle count is changing due to adding particles, you typically\nshould use the compute_modify dynamic yes\ncommand for the temperature compute you are using.\n\n\nAll other keywords are optional with defaults as shown below.\nThe diam option is only used when inserting atoms and specifies the\ndiameters of inserted particles.  There are 3 styles: one, range,\nor poly.  For one, all particles will have diameter D.  For\nrange, the diameter of each particle will be chosen randomly and\nuniformly between the specified Dlo and Dhi bounds.  For poly, a\nseries of Npoly diameters is specified.  For each diameter a\npercentage value from 0.0 to 1.0 is also specified.  The Npoly\npercentages must sum to 1.0.  For the example shown above with “diam 2\n0.7 0.4 1.5 0.6”, all inserted particles will have a diameter of 0.7\nor 1.5.  40% of the particles will be small; 60% will be large.\nNote that for molecule insertion, the diameters of individual atoms in\nthe molecule can be specified in the file read by the\nmolecule command.  If not specified, the diameter of\neach atom in the molecule has a default diameter of 1.0.\nThe id option has two settings which are used to determine the atom\nor molecule IDs to assign to inserted particles/molecules.  In both\ncases a check is done of the current system to find the maximum\ncurrent atom and molecule ID of any existing particle.  Newly inserted\nparticles and molecules are assigned IDs that increment those max\nvalues.  For the max setting, which is the default, this check is\ndone at every insertion step, which allows for particles to leave the\nsystem, and their IDs to potentially be re-used.  For the next\nsetting this check is done only once when the fix is specified, which\ncan be more efficient if you are sure particles will not be added in\nsome other way.\nThe vol option specifies what volume fraction of the insertion\nvolume will be filled with particles.  For particles with a size\nspecified by the diam range keyword, they are assumed to all be of\nmaximum diameter Dhi for purposes of computing their contribution to\nthe volume fraction.\nThe higher the volume fraction value, the more particles are inserted\neach timestep.  Since inserted particles cannot overlap, the maximum\nvolume fraction should be no higher than about 0.6.  Each timestep\nparticles are inserted, LAMMPS will make up to a total of M tries to\ninsert the new particles without overlaps, where M = # of inserted\nparticles * Nattempt.  If LAMMPS is unsuccessful at completing all\ninsertions, it prints a warning.\nThe dens and vel options enable inserted particles to have a range\nof densities or xy velocities.  The specific values for a particular\ninserted particle will be chosen randomly and uniformly between the\nspecified bounds.  Internally, the density value for a particle is\nconverted to a mass, based on the radius (volume) of the particle.\nThe vz or vy value for option vel assigns a z-velocity (3d) or\ny-velocity (2d) to each inserted particle.\nThe rate option moves the insertion volume in the z direction (3d)\nor y direction (2d).  This enables pouring particles from a\nsuccessively higher height over time.\nThe ignore option is useful when running a simulation that used line\nsegment (2d) or triangle (3d) particles, typically to define\nboundaries for spherical granular particles to interact with.  See the\natom_style line or tri command for details.  Lines\nand triangles store their size, and if the size is large it may\noverlap (in a spherical sense) with the insertion region, even if the\nline/triangle is oriented such that there is no actual overlap.  This\ncan prevent particles from being inserted.  The ignore keyword\ncauses the overlap check to skip any line or triangle particles.\nObviously you should only use it if there is in fact no overlap of the\nline or triangle particles with the insertion region.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  This means you must be careful when restarting a\npouring simulation, when the restart file was written in the middle of\nthe pouring operation.  Specifically, you should use a new fix pour\ncommand in the input script for the restarted simulation that\ncontinues the operation.  You will need to adjust the arguments of the\noriginal fix pour command to do this.\nAlso note that because the state of the random number generator is not\nsaved in restart files, you cannot do “exact” restarts with this fix,\nwhere the simulation continues on the same as if no restart had taken\nplace.  However, in a statistical sense, a restarted simulation should\nproduce the same behavior if you adjust the fix pour parameters\nappropriately.\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID pour N type seed keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * pour = style name of this fix command\n * N = # of particles to insert\n * type = atom type to assign to inserted particles (offset for molecule insertion)\n * seed = random # seed (positive integer)\n * one or more keyword/value pairs may be appended to args\n * keyword = region or diam or vol or rate or dens or vel or mol or rigid or shake or ignore\n * region value = region-ID\n *   region-ID = ID of region to use as insertion volume\n * diam values = dstyle args\n *   dstyle = one or range or poly\n *     one args = D\n *       D = single diameter for inserted particles (distance units)\n *     range args = Dlo Dhi\n *       Dlo,Dhi = range of diameters for inserted particles (distance units)\n *     poly args = Npoly D1 P1 D2 P2 ...\n *       Npoly = # of (D,P) pairs\n *       D1,D2,... = diameter for subset of inserted particles (distance units)\n *       P1,P2,... = percentage of inserted particles with this diameter (0-1)\n * id values = idflag\n *   idflag = max or next = how to choose IDs for inserted particles and molecules\n * vol values = fraction Nattempt\n *   fraction = desired volume fraction for filling insertion volume\n *   Nattempt = max # of insertion attempts per particle\n * rate value = V\n *   V = z velocity (3d) or y velocity (2d) at which\n *       insertion volume moves (velocity units)\n * dens values = Rholo Rhohi\n *   Rholo,Rhohi = range of densities for inserted particles (mass/volume units)\n * vel values (3d) = vxlo vxhi vylo vyhi vz\n * vel values (2d) = vxlo vxhi vy\n *   vxlo,vxhi = range of x velocities for inserted particles (velocity units)\n *   vylo,vyhi = range of y velocities for inserted particles (velocity units)\n *   vz = z velocity (3d) assigned to inserted particles (velocity units)\n *   vy = y velocity (2d) assigned to inserted particles (velocity units)\n * mol value = template-ID\n *   template-ID = ID of molecule template specified in a separate molecule command\n * molfrac values = f1 f2 ... fN\n *   f1 to fN = relative probability of creating each of N molecules in template-ID\n * rigid value = fix-ID\n *   fix-ID = ID of fix rigid/small command\n * shake value = fix-ID\n *   fix-ID = ID of fix shake command\n * ignore value = none\n *   skip any line or triangle particles when detecting possible\n *     overlaps with inserted particles",
    "examples": "fix 3 all pour 1000 2 29494 region myblock\nfix 2 all pour 10000 1 19985583 region disk vol 0.33 100 rate 1.0 diam range 0.9 1.1\nfix 2 all pour 10000 1 19985583 region disk diam poly 2 0.7 0.4 1.5 0.6\nfix ins all pour 500 1 4767548 vol 0.8 10 region slab mol object rigid myRigid",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nFor 3d simulations, a gravity fix in the -z direction must be defined\nfor use in conjunction with this fix.  For 2d simulations, gravity\nmust be defined in the -y direction.\nThe specified insertion region cannot be a “dynamic” region, as\ndefined by the region command."
},
{
    "command": "fix precession/spin",
    "html_filename": "fix_precession_spin.html",
    "short_description": "This fix applies a precession torque to each magnetic spin in the group",
    "description": "This fix applies a precession torque to each magnetic spin in the group.\nStyle zeeman is used for the simulation of the interaction\nbetween the magnetic spins in the defined group and an external\nmagnetic field:\n\n\\[H_{Zeeman} = -g \\sum_{i=0}^{N}\\mu_{i}\\, \\vec{s}_{i} \\cdot\\vec{B}_{ext}\\]\nwith:\n\n\\(\\vec{B}_{ext}\\) the external magnetic field (in T)\n\\(g\\) the Lande factor (hard-coded as \\(g=2.0\\))\n\\(\\vec{s}_i\\) the unitary vector describing the orientation of spin \\(i\\)\n\\(\\mu_i\\) the atomic moment of spin \\(i\\) given as a multiple of the\nBohr magneton \\(\\mu_B\\) (for example, \\(\\mu_i \\approx 2.2\\) in bulk iron).\n\nThe field value in Tesla is multiplied by the gyromagnetic\nratio, \\(g \\cdot \\mu_B/\\hbar\\), converting it into a precession frequency in\nrad.THz (in metal units and with \\(\\mu_B = 5.788 eV/T\\)).\nAs a comparison, the figure below displays the simulation of a\nsingle spin (of norm \\(\\mu_i = 1.0\\)) submitted to an external\nmagnetic field of \\(\\vert B_{ext}\\vert = 10.0\\; \\mathrm{Tesla}\\) (and oriented along the z\naxis).\nThe upper plot shows the average magnetization along the\nexternal magnetic field axis and the lower plot the Zeeman\nenergy, both as a function of temperature.\nThe reference result is provided by the plot of the Langevin\nfunction for the same parameters.\n\nThe temperature effects are accounted for by connecting the spin\n\\(i\\) to a thermal bath using a Langevin thermostat (see\nfix langevin/spin for the definition of\nthis thermostat).\nStyle anisotropy is used to simulate an easy axis or an easy plane\nfor the magnetic spins in the defined group:\n\n\\[H_{aniso}  = -\\sum_{{ i}=1}^{N} K_{an}(\\mathbf{r}_{i})\\, \\left( \\vec{s}_{i} \\cdot \\vec{n}_{i} \\right)^2\\]\nwith \\(n\\) defining the direction of the anisotropy, and \\(K\\) (in eV) its intensity.\nIf \\(K > 0\\), an easy axis is defined, and if \\(K < 0\\), an easy plane is defined.\nStyle cubic is used to simulate a cubic anisotropy, with three\npossible easy axis for the magnetic spins in the defined group:\n\n\\[H_{cubic} = -\\sum_{{ i}=1}^{N} K_{1}\n\\Big[\n\\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n\\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2 +\n\\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2\n\\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2 +\n\\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n\\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2 \\Big]\n+K_{2}^{(c)} \\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n\\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2\n\\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2\\]\nwith \\(K_1\\) and \\(K_{2c}\\) (in eV) the intensity coefficients and\n\\(\\vec{n}_1\\), \\(\\vec{n}_2\\) and \\(\\vec{n}_3\\) defining the three anisotropic directions\ndefined by the command (from n1x to n3z).\nFor \\(\\vec{n}_1 = (1 0 0)\\), \\(\\vec{n}_2 = (0 1 0)\\), and \\(\\vec{n}_3 = (0 0 1)\\), \\(K_1 < 0\\) defines an\niron type anisotropy (easy axis along the \\((0 0 1)\\)-type cube\nedges), and \\(K_1 > 0\\) defines a nickel type anisotropy (easy axis\nalong the \\((1 1 1)\\)-type cube diagonals).\n\\(K_2^c > 0\\) also defines easy axis along the \\((1 1 1)\\)-type cube\ndiagonals.\nSee chapter 2 of (Skomski) for more details on cubic\nanisotropies.\nIn all cases, the choice of \\((x y z)\\) only imposes the vector\ndirections for the forces. Only the direction of the vector is\nimportant; its length is ignored (the entered vectors are\nnormalized).\nThose styles can be combined within one single command line.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nBy default, the energy associated to this fix is not added to the potential\nenergy of the system.\nThe fix_modify energy option is supported by this fix\nto add this magnetic potential energy to the potential energy of the system,\nfix             1 all precession/spin zeeman 1.0 0.0 0.0 1.0\nfix_modify      1 energy yes\n\n\nThis fix computes a global scalar which can be accessed by various\noutput commands.\nNo information about this fix is written to binary restart files.",
    "syntax": "fix ID group precession/spin style args",
    "parameters": " * ID, group are documented in fix command\n * precession/spin = style name of this fix command\n * style = zeeman or anisotropy or cubic\n * zeeman args = H x y z\n *   H = intensity of the magnetic field (in Tesla)\n *   x y z = vector direction of the field\n * anisotropy args = K x y z\n *   K = intensity of the magnetic anisotropy (in eV)\n *   x y z = vector direction of the anisotropy\n * cubic args = K1 K2c n1x n1y n1x n2x n2y n2z n3x n3y n3z\n *   K1 and K2c = intensity of the magnetic anisotropy (in eV)\n *   n1x to n3z = three direction vectors of the cubic anisotropy",
    "examples": "fix 1 all precession/spin zeeman 0.1 0.0 0.0 1.0\nfix 1 3 precession/spin anisotropy 0.001 0.0 0.0 1.0\nfix 1 iron precession/spin cubic 0.001 0.0005 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0\nfix 1 all precession/spin zeeman 0.1 0.0 0.0 1.0 anisotropy 0.001 0.0 0.0 1.0",
    "restrictions": "The precession/spin style is part of the SPIN package.  This style\nis only enabled if LAMMPS was built with this package, and if the\natom_style “spin” was declared.  See the Build package doc page for more info."
},
{
    "command": "fix press/berendsen",
    "html_filename": "fix_press_berendsen.html",
    "short_description": "Reset the pressure of the system by using a Berendsen barostat (Berendsen), which rescales the system volume and (optionally) the atoms coordinates within the simulation box every timestep",
    "description": "Reset the pressure of the system by using a Berendsen barostat\n(Berendsen), which rescales the system volume and\n(optionally) the atoms coordinates within the simulation box every\ntimestep.\nRegardless of what atoms are in the fix group, a global pressure is\ncomputed for all atoms.  Similarly, when the size of the simulation\nbox is changed, all atoms are re-scaled to new positions, unless the\nkeyword dilate is specified with a value of partial, in which case\nonly the atoms in the fix group are re-scaled.  The latter can be\nuseful for leaving the coordinates of atoms in a solid substrate\nunchanged and controlling the pressure of a surrounding fluid.\n\nNote\nUnlike the fix npt or fix nph\ncommands which perform Nose/Hoover barostatting AND time integration,\nthis fix does NOT perform time integration.  It only modifies the box\nsize and atom coordinates to effect barostatting.  Thus you must use a\nseparate time integration fix, like fix nve or fix nvt to actually update the positions and velocities of\natoms.  This fix can be used in conjunction with thermostatting fixes\nto control the temperature, such as fix nvt or fix langevin or fix temp/berendsen.\n\nSee the Howto baroostat doc page for a\ndiscussion of different ways to perform barostatting.\n\nThe barostat is specified using one or more of the iso, aniso,\nx, y, z, and couple keywords.  These keywords give you the\nability to specify the 3 diagonal components of an external stress\ntensor, and to couple various of these components together so that the\ndimensions they represent are varied together during a\nconstant-pressure simulation.  Unlike the fix npt and\nfix nph commands, this fix cannot be used with triclinic\n(non-orthogonal) simulation boxes to control all 6 components of the\ngeneral pressure tensor.\nThe target pressures for each of the 3 diagonal components of the\nstress tensor can be specified independently via the x, y, z,\nkeywords, which correspond to the 3 simulation box dimensions.  For\neach component, the external pressure or tensor component at each\ntimestep is a ramped value during the run from Pstart to Pstop.\nIf a target pressure is specified for a component, then the\ncorresponding box dimension will change during a simulation.  For\nexample, if the y keyword is used, the y-box length will change.  A\nbox dimension will not change if that component is not specified,\nalthough you have the option to change that dimension via the fix deform command.\nFor all barostat keywords, the Pdamp parameter determines the time\nscale on which pressure is relaxed.  For example, a value of 10.0\nmeans to relax the pressure in a timespan of (roughly) 10 time units\n(tau or fmsec or psec - see the units command).\n\nNote\nA Berendsen barostat will not work well for arbitrary values of\nPdamp.  If Pdamp is too small, the pressure and volume can\nfluctuate wildly; if it is too large, the pressure will take a very\nlong time to equilibrate.  A good choice for many models is a Pdamp\nof around 1000 timesteps.  However, note that Pdamp is specified in\ntime units, and that timesteps are NOT the same as time units for most\nunits settings.\n\n\nNote\nThe relaxation time is actually also a function of the bulk\nmodulus of the system (inverse of isothermal compressibility).  The\nbulk modulus has units of pressure and is the amount of pressure that\nwould need to be applied (isotropically) to reduce the volume of the\nsystem by a factor of 2 (assuming the bulk modulus was a constant,\nindependent of density, which it’s not).  The bulk modulus can be set\nvia the keyword modulus.  The Pdamp parameter is effectively\nmultiplied by the bulk modulus, so if the pressure is relaxing faster\nthan expected or desired, increasing the bulk modulus has the same\neffect as increasing Pdamp.  The converse is also true.  LAMMPS does\nnot attempt to guess a correct value of the bulk modulus; it just uses\n10.0 as a default value which gives reasonable relaxation for a\nLennard-Jones liquid, but will be way off for other materials and way\ntoo small for solids.  Thus you should experiment to find appropriate\nvalues of Pdamp and/or the modulus when using this fix.\n\n\nThe couple keyword allows two or three of the diagonal components of\nthe pressure tensor to be “coupled” together.  The value specified\nwith the keyword determines which are coupled.  For example, xz\nmeans the Pxx and Pzz components of the stress tensor are coupled.\nXyz means all 3 diagonal components are coupled.  Coupling means two\nthings: the instantaneous stress will be computed as an average of the\ncorresponding diagonal components, and the coupled box dimensions will\nbe changed together in lockstep, meaning coupled dimensions will be\ndilated or contracted by the same percentage every timestep.  The\nPstart, Pstop, Pdamp parameters for any coupled dimensions must\nbe identical.  Couple xyz can be used for a 2d simulation; the z\ndimension is simply ignored.\n\nThe iso and aniso keywords are simply shortcuts that are\nequivalent to specifying several other keywords together.\nThe keyword iso means couple all 3 diagonal components together when\npressure is computed (hydrostatic pressure), and dilate/contract the\ndimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\nspecifying these 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple xyz\n\n\nThe keyword aniso means x, y, and z dimensions are controlled\nindependently using the Pxx, Pyy, and Pzz components of the\nstress tensor as the driving forces, and the specified scalar external\npressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\nthese 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple none\n\n\n\nThis fix computes a temperature and pressure each timestep.  To do\nthis, the fix creates its own computes of style “temp” and “pressure”,\nas if these commands had been issued:\ncompute fix-ID_temp group-ID temp\ncompute fix-ID_press group-ID pressure fix-ID_temp\n\n\nSee the compute temp and compute pressure commands for details.  Note that the\nIDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n+ underscore + “press”, and the group for the new computes is the same\nas the fix group.\nNote that these are NOT the computes used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp\nand thermo_press.  This means you can change the attributes of this\nfix’s temperature or pressure via the\ncompute_modify command or print this temperature\nor pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp or\nthermo_press will have no effect on this fix.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp and press options are\nsupported by this fix.  You can use them to assign a\ncompute you have defined to this fix which will be used\nin its temperature and pressure calculations.  If you do this, note\nthat the kinetic energy derived from the compute temperature should be\nconsistent with the virial term computed using all atoms for the\npressure.  LAMMPS will warn you if you choose to compute temperature\non a subset of atoms.\nNo global or per-atom quantities are stored by this fix for access by\nvarious output commands.\nThis fix can ramp its target pressure over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID press/berendsen keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * press/berendsen = style name of this fix command\n * one or more keyword value pairs may be appended\n * keyword = iso or aniso or x or y or z or couple or dilate or modulus\n *   iso or aniso values = Pstart Pstop Pdamp\n *     Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n *     Pdamp = pressure damping parameter (time units)\n *   x or y or z values = Pstart Pstop Pdamp\n *     Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n *     Pdamp = stress damping parameter (time units)\n *   couple = none or xyz or xy or yz or xz\n *   modulus value = bulk modulus of system (pressure units)\n *   dilate value = all or partial",
    "examples": "fix 1 all press/berendsen iso 0.0 0.0 1000.0\nfix 2 all press/berendsen aniso 0.0 0.0 1000.0 dilate partial",
    "restrictions": "Any dimension being adjusted by this fix must be periodic."
},
{
    "command": "fix print",
    "html_filename": "fix_print.html",
    "short_description": "Print a text string every N steps during a simulation run",
    "description": "Print a text string every N steps during a simulation run.  This can\nbe used for diagnostic purposes or as a debugging tool to monitor some\nquantity during a run.  The text string must be a single argument, so\nit should be enclosed in double quotes if it is more than one word.\nIf it contains variables it must be enclosed in double quotes to\ninsure they are not evaluated when the input script line is read, but\nwill instead be evaluated each time the string is printed.\nInstead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\nname is the variable name.  In this case, the variable is evaluated at\nthe beginning of a run to determine the next timestep at which the\nstring will be written out.  On that timestep, the variable will be\nevaluated again to determine the next timestep, etc.\nThus the variable should return timestep values.  See the stagger()\nand logfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\nthis context. For example, the following commands will print output at\ntimesteps 10,20,30,100,200,300,1000,2000,etc:\nvariable        s equal logfreq(10,3,10)\nfix extra all print v_s \"Coords of marker atom = $x $y $z\"\n\n\nThe specified group-ID is ignored by this fix.\nSee the variable command for a description of equal\nstyle variables which are the most useful ones to use with the fix\nprint command, since they are evaluated afresh each timestep that the\nfix print line is output.  Equal-style variables calculate formulas\ninvolving mathematical operations, atom properties, group properties,\nthermodynamic properties, global values calculated by a\ncompute or fix, or references to other\nvariables.\nIf the file or append keyword is used, a filename is specified to\nwhich the output generated by this fix will be written.  If file is\nused, then the filename is overwritten if it already exists.  If\nappend is used, then the filename is appended to if it already\nexists, or created if it does not exist.\nIf the screen keyword is used, output by this fix to the screen and\nlogfile can be turned on or off as desired.\nThe title keyword allow specification of the string that will be\nprinted as the first line of the output file, assuming the file\nkeyword was used.  By default, the title line is as follows:\n# Fix print output for fix ID\n\n\nwhere ID is replaced with the fix-ID.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID print N string keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * print = style name of this fix command\n * N = print every N steps; N can be a variable (see below)\n * string = text string to print with optional variable names\n * zero or more keyword/value pairs may be appended\n * keyword = file or append or screen or title\n * file value = filename\n * append value = filename\n * screen value = yes or no\n * title value = string\n *   string =  text to print as 1st line of output file",
    "examples": "fix extra all print 100 \"Coords of marker atom = $x $y $z\"\nfix extra all print 100 \"Coords of marker atom = $x $y $z\" file coord.txt",
    "restrictions": "\nnone"
},
{
    "command": "fix propel/self",
    "html_filename": "fix_propel_self.html",
    "short_description": "Adds a force of a constant magnitude to each atom in the group",
    "description": "Adds a force of a constant magnitude to each atom in the group. The nature in\nwhich the force is added depends on the mode.\nFor mode = velocity, the active force acts along the velocity vector of\neach atom. This can be interpreted as a velocity-dependent friction,\nsuch as proposed by (Erdmann).\nFor mode = quat the force is applied along the axis obtained\nby rotating the x-axis along the atom’s quaternion. In other words, the\nforce is along the x-axis in the atom’s body frame. This mode requires\nall atoms in the group to have a quaternion, so atom_style should\neither be ellipsoid or body.  In combination with Langevin thermostat\nfor translation and rotation in the overdamped regime, the quaternion\nmode corresponds to the active Brownian particle model introduced by\n(Henkes), (Bialke) and (Fily).\nBy default, this fix is applied to all atoms in the group. You can\noverride this behavior by specifying the atom types the fix should work\non through the types keyword.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThis fix is not imposed  during minimization.",
    "syntax": "fix ID group-ID propel/self mode magnitude keyword values …",
    "parameters": " * ID, group-ID are documented in fix command\n * propel/self = style name of this fix command\n * mode = velocity or quat\n * magnitude = magnitude of the active force\n * one or more keyword/value pairs may be appended to args\n * keyword = types\n * types values = one or more atom types",
    "examples": "fix active_group all propel/self velocity 1.0\nfix constant_velocity all viscous 1.0\n\nfix active_group all propel/self quat 1.0\n\nfix active all propel/self quat 1.0 types 1 2 4",
    "restrictions": "In quat mode, this fix makes use of per-atom quaternions to take\ninto account the fact that the orientation can rotate and hence the\ndirection of the active force can change. The quat mode\nof this fix only works with atom_style ellipsoid."
},
{
    "command": "fix property/atom",
    "html_filename": "fix_property_atom.html",
    "short_description": "Create one or more additional per-atom vectors to store information about atoms and to use during a simulation",
    "description": "Create one or more additional per-atom vectors to store information\nabout atoms and to use during a simulation.  The specified group-ID\nis ignored by this fix.\nThe atom style used for a simulation defines a set of per-atom\nproperties, as explained on the atom_style and\nread_data doc pages.  The latter command allows these\nproperties to be defined for each atom in the system when a data file\nis read.  This fix will augment the set of properties with new custom\nones. This can be useful in several scenarios.\nIf the atom style does not define molecule IDs, per-atom charge,\nor per-atom mass, they can be added using the mol, q or rmass\nkeywords.  This can be useful, e.g, to define “molecules” to use as\nrigid bodies with the fix rigid command, or just to\ncarry around an extra flag with the atoms (stored as a molecule ID)\nthat can be used to group atoms without having to use the group\ncommand (which is limited to a total of 32 groups including all).\nAnother application would be to use the rmass flag in order to have\nper-atom masses instead of per-type masses, for example this can be\nuseful to study isotope effects with partial isotope substitution.\nPlease see below for an example of simulating a mixture\nof light and heavy water with the TIP4P water potential.\nAn alternative to using fix property/atom in these ways is to\nuse an atom style that does define molecule IDs or charge or per-atom\nmass (indirectly via diameter and density) or to use a hybrid atom\nstyle that combines two or more atom styles\nto provide the union of all atom properties. However, this has two\npractical drawbacks:  first, it typically necessitates changing the\nformat of the data file, which can be tedious for large systems;\nand second, it may define additional properties that are not needed\nsuch as bond lists, which has some overhead when there are no bonds.\nIn the future, we may add additional per-atom properties similar to\nmol, q or rmass, which “turn-on” specific properties defined\nby some atom styles, so they can be used by atom styles that do not\ndefine them.\nMore generally, the i_name and d_name vectors allow one or more\nnew custom per-atom properties to be defined.  Each name must be\nunique and can use alphanumeric or underscore characters.  These\nvectors can store whatever values you decide are useful in your\nsimulation.  As explained below there are several ways to initialize\nand access and output these values, both via input script commands and\nin new code that you add to LAMMPS.\nThis is effectively a simple way to add per-atom properties to a model\nwithout needing to write code for a new atom style\nthat defines the properties.  Note however that implementing a new\natom style allows new atom properties to be more tightly and\nseamlessly integrated with the rest of the code.\nThe new atom properties encode values that migrate with atoms to new\nprocessors and are written to restart files.  If you want the new\nproperties to also be defined for ghost atoms, then use the ghost\nkeyword with a value of yes.  This will invoke extra communication\nwhen ghost atoms are created (at every re-neighboring) to insure the\nnew properties are also defined for the ghost atoms.\n\nNote\nIf you use this command with the mol, q or rmass vectors,\nthen you most likely want to set ghost yes, since these properties\nare stored with ghost atoms if you use an atom_style\nthat defines them, and many LAMMPS operations that use molecule IDs or\ncharge, such as neighbor lists and pair styles, will expect ghost\natoms to have these values.  LAMMPS will issue a warning it you define\nthose vectors but do not set ghost yes.\n\n\nNote\nThe properties for ghost atoms are not updated every timestep,\nbut only once every few steps when neighbor lists are re-built.  Thus\nthe ghost keyword is suitable for static properties, like molecule\nIDs, but not for dynamic properties that change every step.  For the\nlatter, the code you add to LAMMPS to change the properties will also\nneed to communicate their new values to/from ghost atoms, an operation\nthat can be invoked from within a pair style or\nfix or compute that you write.\n\n\nNote\nIf this fix is defined after the simulation box is created,\na ‘run 0’ command should be issued to properly initialize the storage\ncreated by this fix.\n\n\nThis fix is one of a small number that can be defined in an input\nscript before the simulation box is created or atoms are defined.\nThis is so it can be used with the read_data command\nas described below.\nPer-atom properties that are defined by the atom style are initialized when atoms are created, e.g. by\nthe read_data or create_atoms\ncommands.  The per-atom properties defined by this fix are not.  So\nyou need to initialize them explicitly.  This can be done by the\nread_data command, using its fix keyword and\npassing it the fix-ID of this fix.\nThus these commands:\nfix prop all property/atom mol d_flag\nread_data data.txt fix prop NULL Molecules\n\n\nwould allow a data file to have a section like this:\nMolecules\n\n1 4 1.5\n2 4 3.0\n3 10 1.0\n4 10 1.0\n5 10 1.0\n...\nN 763 4.5\n\n\nwhere N is the number of atoms, and the first field on each line is\nthe atom-ID, followed by a molecule-ID and a floating point value that\nwill be stored in a new property called “flag”.  Note that the list of\nper-atom properties can be in any order.\nAnother way of initializing the new properties is via the\nset command.  For example, if you wanted molecules\ndefined for every set of 10 atoms, based on their atom-IDs,\nthese commands could be used:\nfix prop all property/atom mol\nvariable cluster atom ((id-1)/10)+1\nset atom * mol v_cluster\nThe atom-style variable will create values for atoms\nwith IDs 31,32,33,…40 that are 4.0,4.1,4.2,…,4.9.  When the\nset commands assigns them to the molecule ID for each atom,\nthey will be truncated to an integer value, so atoms 31-40 will all be\nassigned a molecule ID of 4.\nNote that atomfile-style variables can also be used in\nplace of atom-style variables, which means in this case that the\nmolecule IDs could be read-in from a separate file and assigned by the\nset command.  This allows you to initialize new per-atom\nproperties in a completely general fashion.\n\nFor new atom properties specified as i_name or d_name, the\ncompute property/atom command can access\ntheir values.  This means that the values can be output via the dump custom command, accessed by fixes like fix ave/atom, accessed by other computes like compute reduce, or used in atom-style variables.\nFor example, these commands will output two new properties to a custom\ndump file:\nfix prop all property/atom i_flag1 d_flag2\ncompute 1 all property/atom i_flag1 d_flag2\ndump 1 all custom 100 tmp.dump id x y z c_1[1] c_1[2]\n\n\n\nIf you wish to add new pair styles,\nfixes, or computes that use the per-atom\nproperties defined by this fix, see the Modify atom\ndoc page which has details on how the properties can be accessed from\nadded classes.\n\nExample for using per-atom masses with TIP4P water to\nstudy isotope effects. When setting up simulations with the TIP4P pair styles for water, you have to provide exactly\none atom type each to identify the water oxygen and hydrogen\natoms. Since the atom mass is normally tied to the atom type, this\nmakes it impossible to study multiple isotopes in the same simulation.\nWith fix property/atom rmass however, the per-type masses are\nreplaced by per-atom masses. Asumming you have a working input deck\nfor regular TIP4P water, where water oxygen is atom type 1 and water\nhydrogen is atom type 2, the following lines of input script convert\nthis to using per-atom masses:\nfix Isotopes all property/atom rmass ghost yes\nset type 1 mass 15.9994\nset type 2 mass 1.008\n\n\nWhen writing out the system data with the write_data\ncommand, there will be a new section named with the fix-ID\n(i.e. Isotopes in this case). Alternatively, you can take an\nexisting data file and just add this Isotopes section with\none line per atom containing atom-ID and mass. Either way, the\nextended data file can be read back with:\nfix Isotopes all property/atom rmass ghost yes\nread_data tip4p-isotopes.data fix Isotopes NULL Isotopes\n\n\nPlease note that the first Isotopes refers to the fix-ID\nand the second to the name of the section. The following input\nscript code will now change the first 100 water molecules in this\nexample to heavy water:\ngroup hwat id 2:300:3\ngroup hwat id 3:300:3\nset group hwat mass 2.0141018\n\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the per-atom values it stores to binary restart files, so that the values can be restored when a\nsimulation is restarted.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID property/atom vec1 vec2 ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * property/atom = style name of this fix command\n * vec1,vec2,… = mol or q or rmass or i_name or d_name\n * mol = molecule IDs\n * q = charge\n * rmass = per-atom mass\n * i_name = new integer vector referenced by name\n * d_name = new floating-point vector referenced by name\n * zero of more keyword/value pairs may be appended\n * keyword = ghost\n * ghost value = no or yes for whether ghost atom info in communicated",
    "examples": "fix 1 all property/atom mol\nfix 1 all property/atom i_myflag1 i_myflag2\nfix 1 all property/atom d_sx d_sy d_sz",
    "restrictions": "\nnone"
},
{
    "command": "fix python/invoke",
    "html_filename": "fix_python_invoke.html",
    "short_description": "This fix allows you to call a Python function during a simulation run",
    "description": "This fix allows you to call a Python function during a simulation run.\nThe callback is either executed after forces have been applied to atoms\nor at the end of every N time steps.\nCallback functions must be declared in the global scope of the\nactive Python interpreter. This can either be done by defining it\ninline using the python command or by importing functions from other\nPython modules. If LAMMPS is driven using the library interface from\nPython, functions defined in the driving Python interpreter can also\nbe executed.\nEach callback is given a pointer object as first argument. This can be\nused to initialize an instance of the lammps Python interface, which\ngives access to the LAMMPS state from Python.\n\nWarning\nWhile you can access the state of LAMMPS via library functions\nfrom these callbacks, trying to execute input script commands will in the best\ncase not work or in the worst case result in undefined behavior.",
    "syntax": "fix ID group-ID python/invoke N callback function_name",
    "parameters": " * ID, group-ID are ignored by this fix\n * python/invoke = style name of this fix command\n * N = execute every N steps\n * callback = post_force or end_of_step\n * post_force = callback after force computations on atoms every N time steps\n * end_of_step = callback after every N time steps",
    "examples": "python post_force_callback here \"\"\"\nfrom lammps import lammps\n\ndef post_force_callback(lammps_ptr, vflag):\n    lmp = lammps(ptr=lammps_ptr)\n    # access LAMMPS state using Python interface\n\"\"\"\n\npython end_of_step_callback here \"\"\"\ndef end_of_step_callback(lammps_ptr):\n    lmp = lammps(ptr=lammps_ptr)\n    # access LAMMPS state using Python interface\n\"\"\"\n\nfix pf  all python/invoke 50 post_force post_force_callback\nfix eos all python/invoke 50 end_of_step end_of_step_callback",
    "restrictions": "This fix is part of the PYTHON package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nBuilding LAMMPS with the PYTHON package will link LAMMPS with the\nPython library on your system.  Settings to enable this are in the\nlib/python/Makefile.lammps file.  See the lib/python/README file for\ninformation on those settings."
},
{
    "command": "fix python/move",
    "html_filename": "fix_python_move.html",
    "short_description": "The python/move fix style provides a way to define ways how particles are moved during an MD run from python script code, that is loaded from a file into LAMMPS and executed at the various steps where other fixes can be executed",
    "description": "The python/move fix style provides a way to define ways how particles\nare moved during an MD run from python script code, that is loaded from\na file into LAMMPS and executed at the various steps where other fixes\ncan be executed. This python script must contain specific python class\ndefinitions.\nThis allows to implement complex position updates and also modified\ntime integration methods. Due to python being an interpreted language,\nhowever, the performance of this fix can be moderately to significantly\nslower than the corresponding C++ code. For specific cases, this\nperformance penalty can be limited through effective use of NumPy.\n\nThe python module file has to start with the following code:\nfrom __future__ import print_function\nimport lammps\nimport ctypes\nimport traceback\nimport numpy as np\n#\nclass LAMMPSFix(object):\n    def __init__(self, ptr, group_name=\"all\"):\n        self.lmp = lammps.lammps(ptr=ptr)\n        self.group_name = group_name\n#\nclass LAMMPSFixMove(LAMMPSFix):\n    def __init__(self, ptr, group_name=\"all\"):\n        super(LAMMPSFixMove, self).__init__(ptr, group_name)\n#\n    def init(self):\n        pass\n#\n    def initial_integrate(self, vflag):\n        pass\n#\n    def final_integrate(self):\n        pass\n#\n    def initial_integrate_respa(self, vflag, ilevel, iloop):\n        pass\n#\n    def final_integrate_respa(self, ilevel, iloop):\n        pass\n#\n    def reset_dt(self):\n        pass\nAny classes implementing new atom motion functionality have to be\nderived from the LAMMPSFixMove class, overriding the available\nmethods as needed.\nExamples for how to do this are in the examples/python folder.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix python/move pymodule.CLASS",
    "parameters": " * pymodule.CLASS = use class CLASS in module/file pymodule to compute how to move atoms",
    "examples": "fix  1 all python/move py_nve.NVE\nfix  1 all python/move py_nve.NVE_OPT",
    "restrictions": "This pair style is part of the PYTHON package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix qbmsst",
    "html_filename": "fix_qbmsst.html",
    "short_description": "This command performs the Quantum-Bath coupled Multi-Scale Shock Technique (QBMSST) integration",
    "description": "This command performs the Quantum-Bath coupled Multi-Scale Shock\nTechnique (QBMSST) integration. See (Qi) for a detailed\ndescription of this method.  QBMSST provides description of the\nthermodynamics and kinetics of shock processes while incorporating\nquantum nuclear effects.  The shockvel setting determines the steady\nshock velocity that will be simulated along direction dir.\nQuantum nuclear effects (fix qtb) can be crucial\nespecially when the temperature of the initial state is below the\nclassical limit or there is a great change in the zero point energies\nbetween the initial and final states. Theoretical post processing\nquantum corrections of shock compressed water and methane have been\nreported as much as 30% of the temperatures (Goldman).  A\nself-consistent method that couples the shock to a quantum thermal\nbath described by a colored noise Langevin thermostat has been\ndeveloped by Qi et al (Qi) and applied to shocked methane.  The\nonset of chemistry is reported to be at a pressure on the shock\nHugoniot that is 40% lower than observed with classical molecular\ndynamics.\nIt is highly recommended that the system be already in an equilibrium\nstate with a quantum thermal bath at temperature of T_init.  The fix\ncommand fix qtb at constant temperature T_init could\nbe used before applying this command to introduce self-consistent\nquantum nuclear effects into the initial state.\nThe parameters q, mu, e0, p0, v0 and tscale are described\nin the command fix msst. The values of e0, p0, or\nv0 will be calculated on the first step if not specified.  The\nparameter of damp, f_max, and N_f are described in the command\nfix qtb.\nThe fix qbmsst command couples the shock system to a quantum thermal\nbath with a rate that is proportional to the change of the total\nenergy of the shock system, \\(E^{tot} - E^{tot}_0\\).\nHere \\(E^{etot}\\) consists of both the system energy and a thermal\nterm, see (Qi), and \\(E^{tot}_0 = e0\\) is the\ninitial total energy.\nThe eta (\\(\\eta\\)) parameter is a unitless coupling constant\nbetween the shock system and the quantum thermal bath. A small \\(\\eta\\)\nvalue cannot adjust the quantum temperature fast enough during the\ntemperature ramping period of shock compression while large \\(\\eta\\)\nleads to big temperature oscillation. A value of \\(\\eta\\) between 0.3 and\n1 is usually appropriate for simulating most systems under shock\ncompression. We observe that different values of \\(\\eta\\) lead to almost\nthe same final thermodynamic state behind the shock, as expected.\nThe quantum temperature is updated every beta (\\(\\beta\\)) steps\nwith an integration time interval \\(\\beta\\) times longer than the\nsimulation time step. In that case, \\(E^{tot}\\) is taken as its\naverage over the past \\(\\beta\\) steps. The temperature of the quantum\nthermal bath \\(T^{qm}\\) changes dynamically according to\nthe following equation where \\(\\Delta_t\\) is the MD time step and\n\\(\\gamma\\) is the friction constant which is equal to the inverse\nof the damp parameter.\n\n\\[\\frac{dT^{qm}}{dt} = \\gamma\\eta\\sum^\\beta_{l=1}\\frac{E^{tot}(t-l\\Delta t) - E^{tot}_0}{3\\beta N k_B}\\]\nThe parameter T_init is the initial temperature of the quantum\nthermal bath and the system before shock loading.\nFor all pressure styles, the simulation box stays orthorhombic in\nshape. Parrinello-Rahman boundary conditions (tilted box) are\nsupported by LAMMPS, but are not implemented for QBMSST.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nBecause the state of the random number generator is not written to\nbinary restart files, this fix cannot be restarted\n“exactly” in an uninterrupted fashion. However, in a statistical\nsense, a restarted simulation should produce similar behaviors of the\nsystem as if it is not interrupted.  To achieve such a restart, one\nshould write explicitly the same value for q, mu, damp, f_max,\nN_f, eta, and beta and set tscale = 0 if the system is\ncompressed during the first run.\nThe progress of the QBMSST can be monitored by printing the global\nscalar and global vector quantities computed by the fix.  The global\nvector contains five values in this order:\n[dhugoniot, drayleigh, lagrangian_speed, lagrangian_position,\nquantum_temperature]\n\ndhugoniot is the departure from the Hugoniot (temperature units).\ndrayleigh is the departure from the Rayleigh line (pressure units).\nlagrangian_speed is the laboratory-frame Lagrangian speed (particle velocity) of the computational cell (velocity units).\nlagrangian_position is the computational cell position in the reference frame moving at the shock speed. This is the distance of the computational cell behind the shock front.\nquantum_temperature is the temperature of the quantum thermal bath \\(T^{qm}\\).\n\nTo print these quantities to the log file with descriptive column\nheaders, the following LAMMPS commands are suggested. Here the\nfix_modify energy command is also enabled to allow\nthe thermo keyword etotal to print the quantity \\(E^{tot}\\).  See\nalso the thermo_style command.\nfix             fix_id all msst z\nfix_modify      fix_id energy yes\nvariable        dhug    equal f_fix_id[1]\nvariable        dray    equal f_fix_id[2]\nvariable        lgr_vel equal f_fix_id[3]\nvariable        lgr_pos equal f_fix_id[4]\nvariable        T_qm    equal f_fix_id[5]\nthermo_style    custom  step temp ke pe lz pzz etotal v_dhug v_dray v_lgr_vel v_lgr_pos v_T_qm f_fix_id\n\n\nThe global scalar under the entry f_fix_id is the quantity of thermo\nenergy as an extra part of \\(E^{tot}\\). This global scalar and the\nvector of 5 quantities can be accessed by various output commands.\nIt is worth noting that the temp keyword\nunder the thermo_style command print the\ninstantaneous classical temperature \\(T^{cl}\\) as described\nin the command fix qtb.",
    "syntax": "fix ID group-ID qbmsst dir shockvel keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * qbmsst = style name of this fix\n * dir = x or y or z\n * shockvel = shock velocity (strictly positive, velocity units)\n * zero or more keyword/value pairs may be appended\n * keyword = q or mu or p0 or v0 or e0 or tscale or damp or seedor f_max or N_f or eta or beta or T_init\n * q value = cell mass-like parameter (mass^2/distance^4 units)\n * mu value = artificial viscosity (mass/distance/time units)\n * p0 value = initial pressure in the shock equations (pressure units)\n * v0 value = initial simulation cell volume in the shock equations (distance^3 units)\n * e0 value = initial total energy (energy units)\n * tscale value = reduction in initial temperature (unitless fraction between 0.0 and 1.0)\n * damp value = damping parameter (time units) inverse of friction gamma\n * seed value = random number seed (positive integer)\n * f_max value = upper cutoff frequency of the vibration spectrum (1/time units)\n * N_f value = number of frequency bins (positive integer)\n * eta value = coupling constant between the shock system and the quantum thermal bath (positive unitless)\n * beta value = the quantum temperature is updated every beta time steps (positive integer)\n * T_init value = quantum temperature for the initial state (temperature units)",
    "examples": "# (liquid methane modeled with the REAX force field, real units)\nfix 1 all qbmsst z 0.122 q 25 mu 0.9 tscale 0.01 damp 200 seed 35082 f_max 0.3 N_f 100 eta 1 beta 400 T_init 110\n# (quartz modeled with the BKS force field, metal units)\nfix 2 all qbmsst z 72 q 40 tscale 0.05 damp 1 seed 47508 f_max 120.0 N_f 100 eta 1.0 beta 500 T_init 300\n\n\nTwo example input scripts are given, including shocked\n\\(\\alpha\\textrm{-quartz}\\) and shocked liquid methane.  The input\nscript first equilibrates an initial state with the quantum thermal\nbath at the target temperature and then applies fix qbmsst to simulate\nshock compression with quantum nuclear correction.  The following two\nfigures plot relevant quantities for shocked\n\\(\\alpha\\textrm{-quartz}\\).\n\nFigure 1. Classical temperature\n\\(T_{cl} = \\sum \\frac{m_iv_i^2}{3Nk_B}\\) vs. time for coupling the\n\\(\\alpha\\textrm{-quartz}\\) initial state with the quantum thermal\nbath at target quantum temperature \\(T^{qm} = 300 K\\). The NpH\nensemble is used for time integration while QTB provides the colored\nrandom force. \\(T^{cl}\\) converges at the timescale of damp\nwhich is set to be 1 ps.\n\nFigure 2. Quantum temperature and pressure vs. time for simulating\nshocked \\(\\alpha\\textrm{-quartz}\\) with fix qbmsst. The shock\npropagates along the z direction. Restart of the fix qbmsst command\nis demonstrated in the example input script. Thermodynamic quantities\nstay continuous before and after the restart.",
    "restrictions": "This fix style is part of the USER-QTB package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nAll cell dimensions must be periodic. This fix can not be used with a\ntriclinic cell.  The QBMSST fix has been tested only for the group-ID\nall."
},
{
    "command": "fix qeq/point",
    "html_filename": "fix_qeq.html",
    "short_description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano) (also known as the matrix inversion method) and in (Rick and Stuart) (also known as the extended Lagrangian method) based on the electronegativity equilization principle",
    "description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano) (also known\nas the matrix inversion method) and in (Rick and Stuart) (also\nknown as the extended Lagrangian method) based on the\nelectronegativity equilization principle.\nThese fixes can be used with any pair style in\nLAMMPS, so long as per-atom charges are defined.  The most typical\nuse-case is in conjunction with a pair style that\nperforms charge equilibration periodically (e.g. every timestep), such\nas the ReaxFF or Streitz-Mintmire potential.\nBut these fixes can also be used with\npotentials that normally assume per-atom charges are fixed, e.g. a\nBuckingham or LJ/Coulombic potential.\nBecause the charge equilibration calculation is effectively\nindependent of the pair style, these fixes can also be used to perform\na one-time assignment of charges to atoms.  For example, you could\ndefine the QEq fix, perform a zero-timestep run via the run\ncommand without any pair style defined which would set per-atom\ncharges (based on the current atom configuration), then remove the fix\nvia the unfix command before performing further dynamics.\n\nNote\nComputing and using charge values different from published\nvalues defined for a fixed-charge potential like Buckingham or CHARMM\nor AMBER, can have a strong effect on energies and forces, and\nproduces a different model than the published versions.\n\n\nNote\nThe fix qeq/comb command must still be used\nto perform charge equilibration with the COMB potential.  The fix qeq/reax\ncommand can be used to perform charge equilibration with the ReaxFF force field, although fix qeq/shielded yields the\nsame results as fix qeq/reax if Nevery, cutoff, and tolerance\nare the same.  Eventually the fix qeq/reax command will be deprecated.\n\nThe QEq method minimizes the electrostatic energy of the system (or\nequalizes the derivative of energy with respect to charge of all the\natoms) by adjusting the partial charge on individual atoms based on\ninteractions with their neighbors within cutoff.  It requires a few\nparameters, in metal units, for each atom type which provided in a\nfile specified by qfile.  The file has the following format\n1 chi eta gamma zeta qcore\n2 chi eta gamma zeta qcore\n...\nNtype chi eta gamma zeta qcore\n\n\nThere have to be parameters given for every atom type. Wildcard entries\nare possible using the same syntax as elsewhere in LAMMPS\n(i.e., n*m, n*, *m, *). Later entries will overwrite previous ones.\nEmpty lines or any text following the pound sign (#) are ignored.\nEach line starts with the atom type followed by five parameters.\nOnly a subset of the parameters is used by each QEq style as described\nbelow, thus the others can be set to 0.0 if desired, but all five\nentries per line are required.\n\nchi = electronegativity in energy units\neta = self-Coulomb potential in energy units\ngamma = shielded Coulomb constant defined by ReaxFF force field in distance units\nzeta = Slater type orbital exponent defined by the Streitz-Mintmire potential in reverse distance units\nqcore = charge of the nucleus defined by the Streitz-Mintmire potential potential in charge units\n\nThe qeq/point style describes partial charges on atoms as point\ncharges.  Interaction between a pair of charged particles is 1/r,\nwhich is the simplest description of the interaction between charges.\nOnly the chi and eta parameters from the qfile file are used.\nNote that Coulomb catastrophe can occur if repulsion between the pair\nof charged particles is too weak.  This style solves partial charges\non atoms via the matrix inversion method.  A tolerance of 1.0e-6 is\nusually a good number.\nThe qeq/shielded style describes partial charges on atoms also as\npoint charges, but uses a shielded Coulomb potential to describe the\ninteraction between a pair of charged particles.  Interaction through\nthe shielded Coulomb is given by equation (13) of the ReaxFF force field paper.  The shielding accounts for charge overlap\nbetween charged particles at small separation.  This style is the same\nas fix qeq/reax, and can be used with pair_style reax/c.  Only the chi, eta, and gamma\nparameters from the qfile file are used. When using the string\nreax/c as filename, these parameters are extracted directly from\nan active reax/c pair style.  This style solves partial\ncharges on atoms via the matrix inversion method.  A tolerance of\n1.0e-6 is usually a good number.\nThe qeq/slater style describes partial charges on atoms as spherical\ncharge densities centered around atoms via the Slater 1s orbital, so\nthat the interaction between a pair of charged particles is the\nproduct of two Slater 1s orbitals.  The expression for the Slater\n1s orbital is given under equation (6) of the\nStreitz-Mintmire paper.  Only the chi, eta, zeta, and\nqcore parameters from the qfile file are used. When using the string\ncoul/streitz as filename, these parameters are extracted directly from\nan active coul/streitz pair style.  This style solves\npartial charges on atoms via the matrix inversion method.  A tolerance\nof 1.0e-6 is usually a good number.  Keyword alpha can be used to\nchange the Slater type orbital exponent.\nThe qeq/dynamic style describes partial charges on atoms as point\ncharges that interact through 1/r, but the extended Lagrangian method\nis used to solve partial charges on atoms.  Only the chi and eta\nparameters from the qfile file are used.  Note that Coulomb\ncatastrophe can occur if repulsion between the pair of charged\nparticles is too weak.  A tolerance of 1.0e-3 is usually a good\nnumber.  Keyword qdamp can be used to change the damping factor, while\nkeyword qstep can be used to change the time step size.\nThe *qeq/fire* style describes the same charge model and charge\nsolver as the qeq/dynamic style, but employs a FIRE minimization\nalgorithm to solve for equilibrium charges.\nKeyword qdamp can be used to change the damping factor, while\nkeyword qstep can be used to change the time step size.\nNote that qeq/point, qeq/shielded, and qeq/slater describe\ndifferent charge models, whereas the matrix inversion method and the\nextended Lagrangian method (qeq/dynamic and qeq/fire) are\ndifferent solvers.\nNote that qeq/point, qeq/dynamic and qeq/fire styles all describe\ncharges as point charges that interact through 1/r relationship, but\nsolve partial charges on atoms using different solvers.  These three\nstyles should yield comparable results if\nthe QEq parameters and Nevery, cutoff, and tolerance are the\nsame.  Style qeq/point is typically faster, qeq/dynamic scales\nbetter on larger sizes, and qeq/fire is faster than qeq/dynamic.\n\nNote\nTo avoid the evaluation of the derivative of charge with respect\nto position, which is typically ill-defined, the system should have a\nzero net charge.\n\n\nNote\nDeveloping QEq parameters (chi, eta, gamma, zeta, and qcore) is\nnon-trivial.  Charges on atoms are not guaranteed to equilibrate with\narbitrary choices of these parameters.  We do not develop these QEq\nparameters.  See the examples/qeq directory for some examples.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about these fixes is written to binary restart files.  No global scalar or vector or per-atom\nquantities are stored by these fixes for access by various output commands.  No parameter of these fixes can be used\nwith the start/stop keywords of the run command.\nThexe fixes are invoked during energy minimization.",
    "syntax": "fix ID group-ID style Nevery cutoff tolerance maxiter qfile keyword ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = qeq/point or qeq/shielded or qeq/slater or qeq/dynamic or qeq/fire\n * Nevery = perform charge equilibration every this many steps\n * cutoff = global cutoff for charge-charge interactions (distance unit)\n * tolerance = precision to which charges will be equilibrated\n * maxiter = maximum iterations to perform charge equilibration\n * qfile = a filename with QEq parameters or coul/streitz or reax/c\n * zero or more keyword/value pairs may be appended\n * keyword = alpha or qdamp or qstep\n * alpha value = Slater type orbital exponent (qeq/slater only)\n * qdamp value = damping factor for damped dynamics charge solver (qeq/dynamic and qeq/fire only)\n * qstep value = time step size for damped dynamics charge solver (qeq/dynamic and qeq/fire only)",
    "examples": "fix 1 all qeq/point 1 10 1.0e-6 200 param.qeq1\nfix 1 qeq qeq/shielded 1 8 1.0e-6 100 param.qeq2\nfix 1 all qeq/slater 5 10 1.0e-6 100 params alpha 0.2\nfix 1 qeq qeq/dynamic 1 12 1.0e-3 100 my_qeq\nfix 1 all qeq/fire 1 10 1.0e-3 100 my_qeq qdamp 0.2 qstep 0.1",
    "restrictions": "These fixes are part of the QEQ package.  They are only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix qeq/comb",
    "html_filename": "fix_qeq_comb.html",
    "short_description": "Perform charge equilibration (QeQ) in conjunction with the COMB (Charge-Optimized Many-Body) potential as described in (COMB_1) and (COMB_2)",
    "description": "Perform charge equilibration (QeQ) in conjunction with the COMB\n(Charge-Optimized Many-Body) potential as described in\n(COMB_1) and (COMB_2).  It performs the charge\nequilibration portion of the calculation using the so-called QEq\nmethod, whereby the charge on each atom is adjusted to minimize the\nenergy of the system.  This fix can only be used with the COMB\npotential; see the fix qeq/reax command for a QeQ\ncalculation that can be used with any potential.\nOnly charges on the atoms in the specified group are equilibrated.\nThe fix relies on the pair style (COMB in this case) to calculate the\nper-atom electronegativity (effective force on the charges).  An\nelectronegativity equalization calculation (or QEq) is performed in an\niterative fashion, which in parallel requires communication at each\niteration for processors to exchange charge information about nearby\natoms with each other.  See Rappe_and_Goddard and\nRick_and_Stuart for details.\nDuring a run, charge equilibration is performed every Nevery time\nsteps.  Charge equilibration is also always enforced on the first step\nof each run.  The precision argument controls the tolerance for the\ndifference in electronegativity for all atoms during charge\nequilibration.  Precision is a trade-off between the cost of\nperforming charge equilibration (more iterations) and accuracy.\nIf the file keyword is used, then information about each\nequilibration calculation is written to the specified file.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is performing charge equilibration. Default is\nthe outermost level.\nThis fix produces a per-atom vector which can be accessed by various\noutput commands.  The vector stores the gradient\nof the charge on each atom.  The per-atom values be accessed on any\ntimestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThis fix can be invoked during energy minimization.",
    "syntax": "fix ID group-ID qeq/comb Nevery precision keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * qeq/comb = style name of this fix command\n * Nevery = perform charge equilibration every this many steps\n * precision = convergence criterion for charge equilibration\n * zero or more keyword/value pairs may be appended\n * keyword = file\n * file value = filename\n *   filename = name of file to write QEQ equilibration info to",
    "examples": "fix 1 surface qeq/comb 10 0.0001",
    "restrictions": "This fix command currently only supports pair style *comb*."
},
{
    "command": "fix qeq/reax",
    "html_filename": "fix_qeq_reax.html",
    "short_description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano)",
    "description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano).  It is\ntypically used in conjunction with the ReaxFF force field model as\nimplemented in the pair_style reax/c command, but\nit can be used with any potential in LAMMPS, so long as it defines and\nuses charges on each atom.  The fix qeq/comb\ncommand should be used to perform charge equilibration with the COMB potential.  For more technical details about the\ncharge equilibration performed by fix qeq/reax, see the\n(Aktulga) paper.\nThe QEq method minimizes the electrostatic energy of the system by\nadjusting the partial charge on individual atoms based on interactions\nwith their neighbors.  It requires some parameters for each atom type.\nIf the params setting above is the word “reax/c”, then these are\nextracted from the pair_style reax/c command and\nthe ReaxFF force field file it reads in.  If a file name is specified\nfor params, then the parameters are taken from the specified file\nand the file must contain one line for each atom type.  The latter\nform must be used when performing QeQ with a non-ReaxFF potential.\nEach line should be formatted as follows:\nitype chi eta gamma\n\n\nwhere itype is the atom type from 1 to Ntypes, chi denotes the\nelectronegativity in eV, eta denotes the self-Coulomb\npotential in eV, and gamma denotes the valence orbital\nexponent.  Note that these 3 quantities are also in the ReaxFF\npotential file, except that eta is defined here as twice the eta value\nin the ReaxFF file. Note that unlike the rest of LAMMPS, the units\nof this fix are hard-coded to be A, eV, and electronic charge.\nThe optional dual keyword allows to perform the optimization\nof the S and T matrices in parallel. This is only supported for\nthe qeq/reax/omp style. Otherwise they are processed separately.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  No global scalar or vector or per-atom\nquantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\nwith the start/stop keywords of the run command.\nThis fix is invoked during energy minimization.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID qeq/reax Nevery cutlo cuthi tolerance params args",
    "parameters": " * ID, group-ID are documented in fix command\n * qeq/reax = style name of this fix command\n * Nevery = perform QEq every this many steps\n * cutlo,cuthi = lo and hi cutoff for Taper radius\n * tolerance = precision to which charges will be equilibrated\n * params = reax/c or a filename\n * args   = dual (optional)",
    "examples": "fix 1 all qeq/reax 1 0.0 10.0 1.0e-6 reax/c\nfix 1 all qeq/reax 1 0.0 10.0 1.0e-6 param.qeq",
    "restrictions": "This fix is part of the USER-REAXC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix does not correctly handle interactions\ninvolving multiple periodic images of the same atom. Hence, it should not\nbe used for periodic cell dimensions less than 10 angstroms."
},
{
    "command": "fix qmmm",
    "html_filename": "fix_qmmm.html",
    "short_description": "This fix provides functionality to enable a quantum mechanics/molecular mechanics (QM/MM) coupling of LAMMPS to a quantum mechanical code",
    "description": "This fix provides functionality to enable a quantum\nmechanics/molecular mechanics (QM/MM) coupling of LAMMPS to a quantum\nmechanical code.  The current implementation only supports an ONIOM\nstyle mechanical coupling to the Quantum ESPRESSO plane\nwave DFT package.  Electrostatic coupling is in preparation and the\ninterface has been written in a manner that coupling to other QM codes\nshould be possible without changes to LAMMPS itself.\nThe interface code for this is in the lib/qmmm directory of the LAMMPS\ndistribution and is being made available at this early stage of\ndevelopment in order to encourage contributions for interfaces to\nother QM codes.  This will allow the LAMMPS side of the implementation\nto be adapted if necessary before being finalized.\nDetails about how to use this fix are currently documented in the\ndescription of the QM/MM interface code itself in lib/qmmm/README.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global scalar or vector or per-atom\nquantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\nwith the start/stop keywords of the run command.  This\nfix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID qmmm",
    "parameters": " * ID, group-ID are documented in fix command\n * qmmm = style name of this fix command",
    "examples": "fix 1 qmol qmmm",
    "restrictions": "This fix is part of the USER-QMMM package.  It is only enabled if\nLAMMPS was built with that package. It also requires building a\nlibrary provided with LAMMPS.  See the Build package doc page for more info.\nThe fix is only functional when LAMMPS is built as a library and\nlinked with a compatible QM program and a QM/MM front end into a QM/MM\nexecutable.  See the lib/qmmm/README file for details.\nRelated commands: none\nDefault: none"
},
{
    "command": "fix qtb",
    "html_filename": "fix_qtb.html",
    "short_description": "This command performs the quantum thermal bath scheme proposed by (Dammak) to include self-consistent quantum nuclear effects, when used in conjunction with the fix nve or fix nph commands",
    "description": "This command performs the quantum thermal bath scheme proposed by\n(Dammak) to include self-consistent quantum nuclear effects,\nwhen used in conjunction with the fix nve or fix nph commands.\nClassical molecular dynamics simulation does not include any quantum\nnuclear effect. Quantum treatment of the vibrational modes will\nintroduce zero point energy into the system, alter the energy power\nspectrum and bias the heat capacity from the classical limit. Missing\nall the quantum nuclear effects, classical MD cannot model systems at\ntemperatures lower than their classical limits. This effect is\nespecially important for materials with a large population of hydrogen\natoms and thus higher classical limits.\nThe equation of motion implemented by this command follows a Langevin\nform:\n\n\\[m_i a_i = f_i + R_i - m_i\\gamma v_i\\]\nHere \\(m_i, a_i, f_i, R_i, \\gamma, \\textrm{and} v_i\\)\nrepresent in this order mass, acceleration, force exerted by all other atoms, random\nforce, frictional coefficient (the inverse of damping parameter damp),\nand velocity. The random force \\(R_i\\) is “colored” so\nthat any vibrational mode with frequency \\(\\omega\\) will have a\ntemperature-sensitive energy \\(\\theta(\\omega,T)\\) which\nresembles the energy expectation for a quantum harmonic oscillator\nwith the same natural frequency:\n\n\\[\\theta(\\omega T) = \\frac{\\hbar}{2} + \\hbar\\omega \\left[\\exp(\\frac{\\hbar\\omega}{k_B T})-1 \\right]^{-1}\\]\nTo efficiently generate the random forces, we employ the method\nof (Barrat), that circumvents the need to generate all\nrandom forces for all times before the simulation. The memory\nrequirement of this approach is less demanding and independent\nof the simulation duration. Since the total random force \\(R_{tot}\\)\ndoes not necessarily vanish for a finite number of atoms,\n\\(R_i\\) is replaced by \\(R_i - \\frac{R_{tot}}{N_{tot}}\\)\nto avoid collective motion of the system.\nThe temp parameter sets the target quantum temperature. LAMMPS will\nstill have an output temperature in its thermo style. That is the\ninstantaneous classical temperature \\(T^{cl}\\) derived from\nthe atom velocities at thermal equilibrium. A non-zero\n\\(T^{cl}\\) will be present even when the quantum\ntemperature approaches zero. This is associated with zero-point energy\nat low temperatures.\n\n\\[T^{cl} = \\sum \\frac{m_i v_i^2}{3 N k_B}\\]\nThe damp parameter is specified in time units, and it equals the\ninverse of the frictional coefficient \\(\\gamma\\). \\(\\gamma\\)\nshould be as small as possible but slightly larger than the timescale\nof anharmonic coupling in the system which is about 10 ps to 100\nps. When \\(\\gamma\\) is too large, it gives an energy spectrum that\ndiffers from the desired Bose-Einstein spectrum. When \\(\\gamma\\)\nis too small, the quantum thermal bath coupling to the system will be\nless significant than anharmonic effects, reducing to a classical\nlimit. We find that setting \\(\\gamma\\) between 5 THz and 1 THz\ncould be appropriate depending on the system.\nThe random number seed is a positive integer used to initiate a\nMarsaglia random number generator. Each processor uses the input seed\nto generate its own unique seed and its own stream of random\nnumbers. Thus the dynamics of the system will not be identical on two\nruns on different numbers of processors.\nThe f_max parameter truncate the noise frequency domain so that\nvibrational modes with frequencies higher than f_max will not be\nmodulated. If we denote \\(\\Delta t\\) as the time interval for the\nMD integration, f_max is always reset by the code to make\n\\(\\alpha = (int)(2\\) f_max \\(\\Delta t)^{-1}\\) a\npositive integer and print out relative information. An appropriate\nvalue for the cutoff frequency f_max would be around 2~3 \\(f_D\\),\nwhere \\(f_D\\) is the Debye frequency.\nThe N_f parameter is the frequency grid size, the number of points\nfrom 0 to f_max in the frequency domain that will be\nsampled. 3*2N_f per-atom random numbers are required\nin the random force generation and there could be as many atoms as in\nthe whole simulation that can migrate into every individual\nprocessor. A larger N_f provides a more accurate sampling of the\nspectrum while consumes more memory.  With fixed f_max and\n\\(\\gamma\\), N_f should be big enough to converge the classical\ntemperature \\(T^{cl}\\) as a function of target quantum bath\ntemperature. Memory usage per processor could be from 10 to 100\nMbytes.\n\nNote\nUnlike the fix nvt command which performs\nNose/Hoover thermostatting AND time integration, this fix does NOT\nperform time integration. It only modifies forces to a colored\nthermostat. Thus you must use a separate time integration fix, like\nfix nve or fix nph to actually\nupdate the velocities and positions of atoms (as shown in the\nexamples). Likewise, this fix should not normally be used with\nother fixes or commands that also specify system temperatures ,\ne.g. fix nvt and fix temp/rescale.\n\n\nRestart, fix_modify, output, run start/stop, minimizie info:\nNo information about this fix is written to binary restart files.  Because the state of the random number generator is not\nsaved in restart files, this means you cannot do “exact” restarts with\nthis fix. However, in a statistical sense, a restarted simulation\nshould produce similar behaviors of the system.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID qtb keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * qtb = style name of this fix\n * zero or more keyword/value pairs may be appended\n * keyword = temp or damp or seed or f_max or N_f\n * temp value = target quantum temperature (temperature units)\n * damp value = damping parameter (time units) inverse of friction gamma\n * seed value = random number seed (positive integer)\n * f_max value = upper cutoff frequency of the vibration spectrum (1/time units)\n * N_f value = number of frequency bins (positive integer)",
    "examples": "# (liquid methane modeled with the REAX force field, real units)\nfix 1 all nve\nfix 1 all qtb temp 110 damp 200 seed 35082 f_max 0.3 N_f 100\n# (quartz modeled with the BKS force field, metal units)\nfix 2 all nph iso 1.01325 1.01325 1\nfix 2 all qtb temp 300 damp 1 seed 47508 f_max 120.0 N_f 100",
    "restrictions": "This fix style is part of the USER-QTB package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "fix reax/c/bonds",
    "html_filename": "fix_reaxc_bonds.html",
    "short_description": "Write out the bond information computed by the ReaxFF potential specified by pair_style reax/c in the exact same format as the original stand-alone ReaxFF code of Adri van Duin",
    "description": "Write out the bond information computed by the ReaxFF potential specified\nby pair_style reax/c in the exact same format as the\noriginal stand-alone ReaxFF code of Adri van Duin.  The bond information\nis written to filename on timesteps that are multiples of Nevery,\nincluding timestep 0.  For time-averaged chemical species analysis,\nplease see the fix reaxc/c/species command.\nThe specified group-ID is ignored by this fix.\nThe format of the output file should be reasonably self-explanatory.\nThe meaning of the column header abbreviations is as follows:\n\nid = atom id\ntype = atom type\nnb = number of bonds\nid_1 = atom id of first bond\nid_nb = atom id of Nth bond\nmol = molecule id\nbo_1 = bond order of first bond\nbo_nb = bond order of Nth bond\nabo = atom bond order (sum of all bonds)\nnlp = number of lone pairs\nq = atomic charge\n\nIf the filename ends with “.gz”, the output file is written in gzipped\nformat.  A gzipped dump file will be about 3x smaller than the text\nversion, but will also take longer to write.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed in Speed\nof the manual.  The accelerated styles take the same arguments and\nshould produce the same results, except for round-off and precision\nissues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee Speed of the manual for\nmore instructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID reaxc/bonds Nevery filename",
    "parameters": " * ID, group-ID are documented in fix command\n * reax/bonds = style name of this fix command\n * Nevery = output interval in timesteps\n * filename = name of output file",
    "examples": "fix 1 all reax/c/bonds 100 bonds.reaxc",
    "restrictions": "The fix reax/c/bonds command requires that the pair_style reax/c is invoked.  This fix is part of the\nUSER-REAXC package.  It is only enabled if LAMMPS was built with that\npackage.  See the Build package doc page for more\ninfo.\nTo write gzipped bond files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option."
},
{
    "command": "fix reax/c/species",
    "html_filename": "fix_reaxc_species.html",
    "short_description": "Write out the chemical species information computed by the ReaxFF potential specified by pair_style reax/c",
    "description": "Write out the chemical species information computed by the ReaxFF\npotential specified by pair_style reax/c.\nBond-order values (either averaged or instantaneous, depending on\nvalue of Nrepeat) are used to determine chemical bonds.  Every\nNfreq timesteps, chemical species information is written to\nfilename as a two line output.  The first line is a header\ncontaining labels. The second line consists of the following:\ntimestep, total number of molecules, total number of distinct species,\nnumber of molecules of each species.  In this context, “species” means\na unique molecule.  The chemical formula of each species is given in\nthe first line.\nIf the filename ends with “.gz”, the output file is written in gzipped\nformat.  A gzipped dump file will be about 3x smaller than the text version,\nbut will also take longer to write.\nOptional keyword cutoff can be assigned to change the minimum\nbond-order values used in identifying chemical bonds between pairs of\natoms.  Bond-order cutoffs should be carefully chosen, as bond-order\ncutoffs that are too small may include too many bonds (which will\nresult in an error), while cutoffs that are too large will result in\nfragmented molecules.  The default cutoff of 0.3 usually gives good\nresults.\nThe optional keyword element can be used to specify the chemical\nsymbol printed for each LAMMPS atom type. The number of symbols must\nmatch the number of LAMMPS atom types and each symbol must consist of\n1 or 2 alphanumeric characters. Normally, these symbols should be\nchosen to match the chemical identity of each LAMMPS atom type, as\nspecified using the reax/c pair_coeff command and\nthe ReaxFF force field file.\nThe optional keyword position writes center-of-mass positions of\neach identified molecules to file filepos every posfreq timesteps.\nThe first line contains information on timestep, total number of\nmolecules, total number of distinct species, and box dimensions.  The\nsecond line is a header containing labels.  From the third line\ndownward, each molecule writes a line of output containing the\nfollowing information: molecule ID, number of atoms in this molecule,\nchemical formula, total charge, and center-of-mass xyz positions of\nthis molecule.  The xyz positions are in fractional coordinates\nrelative to the box dimensions.\nFor the keyword position, the filepos is the name of the output\nfile.  It can contain the wildcard character “*”.  If the “*”\ncharacter appears in filepos, then one file per snapshot is written\nat posfreq and the “*” character is replaced with the timestep\nvalue.  For example, AuO.pos.* becomes AuO.pos.0, AuO.pos.1000, etc.\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the bond-order values are sampled to get the average bond\norder.  The species analysis is performed using the average bond-order\non timesteps that are a multiple of Nfreq.  The average is over\nNrepeat bond-order samples, computed in the preceding portion of the\nsimulation every Nevery timesteps.  Nfreq must be a multiple of\nNevery and Nevery must be non-zero even if Nrepeat is 1.\nAlso, the timesteps\ncontributing to the average bond-order cannot overlap,\ni.e. Nrepeat*Nevery can not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then bond-order\nvalues on timesteps 90,92,94,96,98,100 will be used to compute the\naverage bond-order for the species analysis output on timestep 100.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes both a global vector of length 2 and a per-atom\nvector, either of which can be accessed by various output commands.  The values in the global vector are\n“intensive”.\nThe 2 values in the global vector are as follows:\n\n1 = total number of molecules\n2 = total number of distinct species\n\nThe per-atom vector stores the molecule ID for each atom as identified\nby the fix.  If an atom is not in a molecule, its ID will be 0.\nFor atoms in the same molecule, the molecule ID for all of them\nwill be the same and will be equal to the smallest atom ID of\nany atom in the molecule.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed in Speed\nof the manual.  The accelerated styles take the same arguments and\nshould produce the same results, except for round-off and precision\nissues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee Speed of the manual for\nmore instructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID reax/c/species Nevery Nrepeat Nfreq filename keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * reax/c/species = style name of this command\n * Nevery = sample bond-order every this many timesteps\n * Nrepeat = # of bond-order samples used for calculating averages\n * Nfreq = calculate average bond-order every this many timesteps\n * filename = name of output file\n * zero or more keyword/value pairs may be appended\n * keyword = cutoff or element or position\n * cutoff value = I J Cutoff\n *   I, J = atom types\n *   Cutoff = Bond-order cutoff value for this pair of atom types\n * element value = Element1, Element2, ...\n * position value = posfreq filepos\n *   posfreq = write position files every this many timestep\n *   filepos = name of position output file",
    "examples": "fix 1 all reax/c/species 10 10 100 species.out\nfix 1 all reax/c/species 1 2 20 species.out cutoff 1 1 0.40 cutoff 1 2 0.55\nfix 1 all reax/c/species 1 100 100 species.out element Au O H position 1000 AuOH.pos",
    "restrictions": "The “fix reax/c/species” currently only works with pair_style reax/c and it requires that the pair_style reax/c be invoked.  This fix is part of the\nUSER-REAXC package.  It is only enabled if LAMMPS was built with that\npackage.  See the Build package doc page for more\ninfo.\nTo write gzipped species files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option.\nIt should be possible to extend it to other reactive pair_styles (such as\nrebo, airebo,\ncomb, and bop), but this has not yet been done."
},
{
    "command": "fix recenter",
    "html_filename": "fix_recenter.html",
    "short_description": "Constrain the center-of-mass position of a group of atoms by adjusting the coordinates of the atoms every timestep",
    "description": "Constrain the center-of-mass position of a group of atoms by adjusting\nthe coordinates of the atoms every timestep.  This is simply a small\nshift that does not alter the dynamics of the system or change the\nrelative coordinates of any pair of atoms in the group.  This can be\nused to insure the entire collection of atoms (or a portion of them)\ndo not drift during the simulation due to random perturbations\n(e.g. fix langevin thermostatting).\nDistance units for the x,y,z values are determined by the setting of\nthe units keyword, as discussed below.  One or more x,y,z values can\nalso be specified as NULL, which means exclude that dimension from\nthis operation.  Or it can be specified as INIT which means to\nconstrain the center-of-mass to its initial value at the beginning of\nthe run.\nThe center-of-mass (COM) is computed for the group specified by the\nfix.  If the current COM is different than the specified x,y,z, then a\ngroup of atoms has their coordinates shifted by the difference.  By\ndefault the shifted group is also the group specified by the fix.  A\ndifferent group can be shifted by using the shift keyword.  For\nexample, the COM could be computed on a protein to keep it in the\ncenter of the simulation box.  But the entire system (protein + water)\ncould be shifted.\nIf the units keyword is set to box, then the distance units of\nx,y,z are defined by the units command - e.g. Angstroms\nfor real units.  A lattice value means the distance units are in\nlattice spacings.  The lattice command must have been\npreviously used to define the lattice spacing.  A fraction value\nmeans a fractional distance between the lo/hi box boundaries, e.g. 0.5\n= middle of the box.  The default is to use lattice units.\nNote that the velocity command can be used to create\nvelocities with zero aggregate linear and/or angular momentum.\n\nNote\nThis fix performs its operations at the same point in the\ntimestep as other time integration fixes, such as fix nve, fix nvt, or fix npt.\nThus fix recenter should normally be the last such fix specified in\nthe input script, since the adjustments it makes to atom coordinates\nshould come after the changes made by time integration.  LAMMPS will\nwarn you if your fixes are not ordered this way.\n\n\nNote\nIf you use this fix on a small group of atoms (e.g. a molecule\nin solvent) without using the shift keyword to adjust the positions\nof all atoms in the system, then the results can be unpredictable.\nFor example, if the molecule is pushed consistently in one direction\nby a flowing solvent, its velocity will increase.  But its coordinates\nwill be re-centered, meaning it is moved back towards the force.  Thus\nover time, the velocity and effective temperature of the molecule\ncould become very large, though it won’t actually be moving due to the\nre-centering.  If you are thermostatting the entire system, then the\nsolvent would be cooled to compensate.  A better solution for this\nsimulation scenario is to use the fix spring command\nto tether the molecule in place.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the distance the\ngroup is moved by fix recenter.\nThis fix also computes global 3-vector which can be accessed by\nvarious output commands.  The 3 quantities in the\nvector are xyz components of displacement applied to the group of\natoms by the fix.\nThe scalar and vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID recenter x y z keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * recenter = style name of this fix command\n * x,y,z = constrain center-of-mass to these coords (distance units),         any coord can also be NULL or INIT (see below)\n * zero or more keyword/value pairs may be appended\n * keyword = shift or units\n * shift value = group-ID\n *   group-ID = group of atoms whose coords are shifted\n * units value = box or lattice or fraction",
    "examples": "fix 1 all recenter 0.0 0.5 0.0\nfix 1 all recenter INIT INIT NULL\nfix 1 all recenter INIT 0.0 0.0 units box",
    "restrictions": "This fix should not be used with an x,y,z setting that causes a large\nshift in the system on the 1st timestep, due to the requested COM\nbeing very different from the initial COM.  This could cause atoms to\nbe lost, especially in parallel.  Instead, use the\ndisplace_atoms command, which can be used to\nmove atoms a large distance."
},
{
    "command": "fix restrain",
    "html_filename": "fix_restrain.html",
    "short_description": "Restrain the motion of the specified sets of atoms by making them part of a bond or angle or dihedral interaction whose strength can vary over time during a simulation",
    "description": "Restrain the motion of the specified sets of atoms by making them part\nof a bond or angle or dihedral interaction whose strength can vary\nover time during a simulation.  This is functionally similar to\ncreating a bond or angle or dihedral for the same atoms in a data\nfile, as specified by the read_data command, albeit\nwith a time-varying pre-factor coefficient, and except for exclusion\nrules, as explained below.\nFor the purpose of force field parameter-fitting or mapping a molecular\npotential energy surface, this fix reduces the hassle and risk\nassociated with modifying data files.  In other words, use this fix to\ntemporarily force a molecule to adopt a particular conformation.  To\ncreate a permanent bond or angle or dihedral, you should modify the\ndata file.\n\nNote\nAdding a bond/angle/dihedral with this command does not apply\nthe exclusion rules and weighting factors specified by the\nspecial_bonds command to atoms in the restraint\nthat are now bonded (1-2,1-3,1-4 neighbors) as a result.  If they are\nclose enough to interact in a pair_style sense\n(non-bonded interaction), then the bond/angle/dihedral restraint\ninteraction will simply be superposed on top of that interaction.\n\nThe group-ID specified by this fix is ignored.\nThe second example above applies a restraint to hold the dihedral\nangle formed by atoms 1, 2, 3, and 4 near 120 degrees using a constant\nrestraint coefficient.  The fourth example applies similar restraints\nto multiple dihedral angles using a restraint coefficient that\nincreases from 0.0 to 2000.0 over the course of the run.\n\nNote\nAdding a force to atoms implies a change in their potential\nenergy as they move due to the applied force field.  For dynamics via\nthe run command, this energy can be added to the system’s\npotential energy for thermodynamic output (see below).  For energy\nminimization via the minimize command, this energy\nmust be added to the system’s potential energy to formulate a\nself-consistent minimization problem (see below).\n\nIn order for a restraint to be effective, the restraint force must\ntypically be significantly larger than the forces associated with\nconventional force field terms.  If the restraint is applied during a\ndynamics run (as opposed to during an energy minimization), a large\nrestraint coefficient can significantly reduce the stable timestep\nsize, especially if the atoms are initially far from the preferred\nconformation.  You may need to experiment to determine what value of \\(K\\)\nworks best for a given application.\nFor the case of finding a minimum energy structure for a single\nmolecule with particular restraints (e.g. for fitting force field\nparameters or constructing a potential energy surface), commands such\nas the following may be useful:\n# minimize molecule energy with restraints\nvelocity all create 600.0 8675309 mom yes rot yes dist gaussian\nfix NVE all nve\nfix TFIX all langevin 600.0 0.0 100 24601\nfix REST all restrain dihedral 2 1 3 8 0.0 5000.0 ${angle1} dihedral 3 1 2 9 0.0 5000.0 ${angle2}\nfix_modify REST energy yes\nrun 10000\nfix TFIX all langevin 0.0 0.0 100 24601\nfix REST all restrain dihedral 2 1 3 8 5000.0 5000.0 ${angle1} dihedral 3 1 2 9 5000.0 5000.0 ${angle2}\nfix_modify REST energy yes\nrun 10000\n# sanity check for convergence\nminimize 1e-6 1e-9 1000 100000\n# report unrestrained energies\nunfix REST\nrun 0\n\n\n\nThe bond keyword applies a bond restraint to the specified atoms\nusing the same functional form used by the bond_style harmonic command.  The potential associated with\nthe restraint is\n\n\\[E = K (r - r_0)^2\\]\nwith the following coefficients:\n\n\\(K\\) (energy/distance^2)\n\\(r_0\\) (distance)\n\n\\(K\\) and \\(r_0\\) are specified with the fix.  Note that the usual 1/2 factor\nis included in \\(K\\).\n\nThe angle keyword applies an angle restraint to the specified atoms\nusing the same functional form used by the angle_style harmonic command.  The potential associated with\nthe restraint is\n\n\\[E = K (\\theta - \\theta_0)^2\\]\nwith the following coefficients:\n\n\\(K\\) (energy/radian^2)\n\\(\\theta_0\\) (degrees)\n\n\\(K\\) and \\(\\theta_0\\) are specified with the fix.  Note that the usual 1/2\nfactor is included in \\(K\\).\n\nThe dihedral keyword applies a dihedral restraint to the specified\natoms using a simplified form of the function used by the\ndihedral_style charmm command.  The potential\nassociated with the restraint is\n\n\\[E = K [ 1 + \\cos (n \\phi - d) ]\\]\nwith the following coefficients:\n\n\\(K\\) (energy)\n\\(n\\) (multiplicity, >= 0)\n\\(d\\) (degrees) = \\(\\phi_0 + 180\\)\n\n\\(K\\) and \\(\\phi_0\\) are specified with the fix.  Note that the value of the\ndihedral multiplicity \\(n\\) is set by default to 1. You can use the\noptional mult keyword to set it to a different positive integer.\nAlso note that the energy will be a minimum when the\ncurrent dihedral angle \\(\\phi\\) is equal to \\(\\phi_0\\).\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the potential energy associated with this fix to the\nsystem’s potential energy as part of thermodynamic output.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\n\nNote\nIf you want the fictitious potential energy associated with the\nadded forces to be included in the total potential energy of the\nsystem (the quantity being minimized), you MUST enable the\nfix_modify energy option for this fix.\n\nThis fix computes a global scalar and a global vector of length 3,\nwhich can be accessed by various output commands.\nThe scalar is the total potential energy for all the restraints as\ndiscussed above. The vector values are the sum of contributions to the\nfollowing individual categories:\n\n1 = bond energy\n2 = angle energy\n3 = dihedral energy\n\nThe scalar and vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.",
    "syntax": "fix ID group-ID restrain keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * restrain = style name of this fix command\n * one or more keyword/arg pairs may be appended\n * keyword = bond or angle or dihedral\n * bond args = atom1 atom2 Kstart Kstop r0\n *   atom1,atom2 = IDs of 2 atoms in bond\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   r0 = equilibrium bond distance (distance units)\n * angle args = atom1 atom2 atom3 Kstart Kstop theta0\n *   atom1,atom2,atom3 = IDs of 3 atoms in angle, atom2 = middle atom\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   theta0 = equilibrium angle theta (degrees)\n * dihedral args = atom1 atom2 atom3 atom4 Kstart Kstop phi0 keyword/value\n *   atom1,atom2,atom3,atom4 = IDs of 4 atoms in dihedral in linear order\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   phi0 = equilibrium dihedral angle phi (degrees)\n *   keyword/value = optional keyword value pairs. supported keyword/value pairs:\n *     mult n = dihedral multiplicity n (integer >= 0, default = 1)",
    "examples": "fix holdem all restrain bond 45 48 2000.0 2000.0 2.75\nfix holdem all restrain dihedral 1 2 3 4 2000.0 2000.0 120.0\nfix holdem all restrain bond 45 48 2000.0 2000.0 2.75 dihedral 1 2 3 4 2000.0 2000.0 120.0\nfix texas_holdem all restrain dihedral 1 2 3 4 0.0 2000.0 120.0 dihedral 1 2 3 5 0.0 2000.0 -120.0 dihedral 1 2 3 6 0.0 2000.0 0.0",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "fix rhok",
    "html_filename": "fix_rhok.html",
    "short_description": "The fix applies a force to atoms given by the potential  \\[\\begin{split}U  = &  \\frac{1}{2} K (|\\rho_{\\vec{k}}| - a)^2 \\\\ \\rho_{\\vec{k}}  = & \\sum_j^N \\exp(-i\\vec{k} \\cdot \\vec{r}_j )/\\sqrt{N} \\\\ \\vec{k}  = & (2\\pi n_x /L_x , 2\\pi n_y  /L_y , 2\\pi n_z/L_z )\\end{split}\\] as described in (Pedersen)",
    "description": "The fix applies a force to atoms given by the potential\n\n\\[\\begin{split}U  = &  \\frac{1}{2} K (|\\rho_{\\vec{k}}| - a)^2 \\\\\n\\rho_{\\vec{k}}  = & \\sum_j^N \\exp(-i\\vec{k} \\cdot \\vec{r}_j )/\\sqrt{N} \\\\\n\\vec{k}  = & (2\\pi n_x /L_x , 2\\pi n_y  /L_y , 2\\pi n_z/L_z )\\end{split}\\]\nas described in (Pedersen).\nThis field, which biases configurations with long-range order, can be\nused to study crystal-liquid interfaces and determine melting\ntemperatures (Pedersen).\nAn example of using the interface pinning method is located in the\nexamples/USER/misc/rhok directory.",
    "syntax": "fix ID group-ID restrain keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * restrain = style name of this fix command\n * one or more keyword/arg pairs may be appended\n * keyword = bond or angle or dihedral\n * bond args = atom1 atom2 Kstart Kstop r0\n *   atom1,atom2 = IDs of 2 atoms in bond\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   r0 = equilibrium bond distance (distance units)\n * angle args = atom1 atom2 atom3 Kstart Kstop theta0\n *   atom1,atom2,atom3 = IDs of 3 atoms in angle, atom2 = middle atom\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   theta0 = equilibrium angle theta (degrees)\n * dihedral args = atom1 atom2 atom3 atom4 Kstart Kstop phi0 keyword/value\n *   atom1,atom2,atom3,atom4 = IDs of 4 atoms in dihedral in linear order\n *   Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n *   phi0 = equilibrium dihedral angle phi (degrees)\n *   keyword/value = optional keyword value pairs. supported keyword/value pairs:\n *     mult n = dihedral multiplicity n (integer >= 0, default = 1)",
    "examples": "fix bias all rhok 16 0 0 4.0 16.0\nfix 1 all npt temp 0.8 0.8 4.0 z 2.2 2.2 8.0\n# output of 4 values from fix rhok: U_bias rho_k_RE  rho_k_IM  |rho_k|\nthermo_style custom step temp pzz lz f_bias f_bias[1] f_bias[2] f_bias[3]",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix rigid",
    "html_filename": "fix_rigid.html",
    "short_description": "Treat one or more sets of atoms as independent rigid bodies",
    "description": "Treat one or more sets of atoms as independent rigid bodies.  This\nmeans that each timestep the total force and torque on each rigid body\nis computed as the sum of the forces and torques on its constituent\nparticles.  The coordinates, velocities, and orientations of the atoms\nin each body are then updated so that the body moves and rotates as a\nsingle entity.  This is implemented by creating internal data structures\nfor each rigid body and performing time integration on these data\nstructures.  Positions, velocities, and orientations of the constituent\nparticles are regenerated from the rigid body data structures in every\ntime step. This restricts which operations and fixes can be applied to\nrigid bodies. See below for a detailed discussion.\nExamples of large rigid bodies are a colloidal particle, or portions\nof a biomolecule such as a protein.\nExample of small rigid bodies are patchy nanoparticles, such as those\nmodeled in this paper by Sharon Glotzer’s group, clumps of\ngranular particles, lipid molecules consisting of one or more point\ndipoles connected to other spheroids or ellipsoids, irregular\nparticles built from line segments (2d) or triangles (3d), and\ncoarse-grain models of nano or colloidal particles consisting of a\nsmall number of constituent particles.  Note that the fix shake command can also be used to rigidify small\nmolecules of 2, 3, or 4 atoms, e.g. water molecules.  That fix treats\nthe constituent atoms as point masses.\nThese fixes also update the positions and velocities of the atoms in\neach rigid body via time integration, in the NVE, NVT, NPT, or NPH\nensemble, as described below.\nThere are two main variants of this fix, fix rigid and fix\nrigid/small.  The NVE/NVT/NPT/NHT versions belong to one of the two\nvariants, as their style names indicate.\n\nNote\nNot all of the bodystyle options and keyword/value options are\navailable for both the rigid and rigid/small variants.  See\ndetails below.\n\nThe rigid styles are typically the best choice for a system with a\nsmall number of large rigid bodies, each of which can extend across\nthe domain of many processors.  It operates by creating a single\nglobal list of rigid bodies, which all processors contribute to.\nMPI_Allreduce operations are performed each timestep to sum the\ncontributions from each processor to the force and torque on all the\nbodies.  This operation will not scale well in parallel if large\nnumbers of rigid bodies are simulated.\nThe rigid/small styles are typically best for a system with a large\nnumber of small rigid bodies.  Each body is assigned to the atom\nclosest to the geometrical center of the body.  The fix operates using\nlocal lists of rigid bodies owned by each processor and information is\nexchanged and summed via local communication between neighboring\nprocessors when ghost atom info is accumulated.\n\nNote\nTo use the rigid/small styles the ghost atom cutoff must be\nlarge enough to span the distance between the atom that owns the body\nand every other atom in the body.  This distance value is printed out\nwhen the rigid bodies are defined.  If the\npair_style cutoff plus neighbor skin does not span\nthis distance, then you should use the comm_modify cutoff command with a setting epsilon larger than\nthe distance.\n\nWhich of the two variants is faster for a particular problem is hard\nto predict.  The best way to decide is to perform a short test run.\nBoth variants should give identical numerical answers for short runs.\nLong runs should give statistically similar results, but round-off\ndifferences may accumulate to produce divergent trajectories.\n\nNote\nYou should not update the atoms in rigid bodies via other\ntime-integration fixes (e.g. fix nve, fix nvt, fix npt, fix move),\nor you will have conflicting updates to positions and velocities\nresulting in unphysical behavior in most cases. When performing a hybrid\nsimulation with some atoms in rigid bodies, and some not, a separate\ntime integration fix like fix nve or fix nvt should be used for the non-rigid particles.\n\n\nNote\nThese fixes are overkill if you simply want to hold a collection\nof atoms stationary or have them move with a constant velocity.  A\nsimpler way to hold atoms stationary is to not include those atoms in\nyour time integration fix.  E.g. use “fix 1 mobile nve” instead of\n“fix 1 all nve”, where “mobile” is the group of atoms that you want to\nmove.  You can move atoms with a constant velocity by assigning them\nan initial velocity (via the velocity command),\nsetting the force on them to 0.0 (via the fix setforce command), and integrating them as usual\n(e.g. via the fix nve command).\n\n\nWarning\nThe aggregate properties of each rigid body are\ncalculated at the start of a simulation run and are maintained in\ninternal data structures. The properties include the position and\nvelocity of the center-of-mass of the body, its moments of inertia, and\nits angular momentum.  This is done using the properties of the\nconstituent atoms of the body at that point in time (or see the infile\nkeyword option).  Thereafter, changing these properties of individual\natoms in the body will have no effect on a rigid body’s dynamics, unless\nthey effect any computation of per-atom forces or torques. If the\nkeyword reinit is set to yes (the default), the rigid body data\nstructures will be recreated at the beginning of each run command;\nif the keyword reinit is set to no, the rigid body data structures\nwill be built only at the very first run command and maintained for\nas long as the rigid fix is defined. For example, you might think you\ncould displace the atoms in a body or add a large velocity to each atom\nin a body to make it move in a desired direction before a 2nd run is\nperformed, using the set or\ndisplace_atoms or velocity\ncommands.  But these commands will not affect the internal attributes\nof the body unless reinit is set to yes. With reinit set to no\n(or using the infile option, which implies reinit no) the position\nand velocity of individual atoms in the body will be reset when time\nintegration starts again.\n\n\nEach rigid body must have two or more atoms.  An atom can belong to at\nmost one rigid body.  Which atoms are in which bodies can be defined\nvia several options.\n\nNote\nWith the rigid/small styles, which require that bodystyle be\nspecified as molecule or custom, you can define a system that has\nno rigid bodies initially.  This is useful when you are using the\nmol keyword in conjunction with another fix that is adding rigid\nbodies on-the-fly as molecules, such as fix deposit\nor fix pour.\n\nFor bodystyle single the entire fix group of atoms is treated as one\nrigid body.  This option is only allowed for the rigid styles.\nFor bodystyle molecule, atoms are grouped into rigid bodies by their\nrespective molecule IDs: each set of atoms in the fix group with the\nsame molecule ID is treated as a different rigid body.  This option is\nallowed for both the rigid and rigid/small styles.  Note that\natoms with a molecule ID = 0 will be treated as a single rigid body.\nFor a system with atomic solvent (typically this is atoms with\nmolecule ID = 0) surrounding rigid bodies, this may not be what you\nwant.  Thus you should be careful to use a fix group that only\nincludes atoms you want to be part of rigid bodies.\nBodystyle custom is similar to bodystyle molecule except that it\nis more flexible in using other per-atom properties to define the sets\nof atoms that form rigid bodies.  An integer vector defined by the\nfix property/atom command can be used.  Or an\natom-style or atomfile-style variable can be used; the\nfloating-point value produced by the variable is rounded to an\ninteger.  As with bodystyle molecule, each set of atoms in the fix\ngroups with the same integer value is treated as a different rigid\nbody.  Since fix property/atom vectors and atom-style variables\nproduce values for all atoms, you should be careful to use a fix group\nthat only includes atoms you want to be part of rigid bodies.\n\nNote\nTo compute the initial center-of-mass position and other\nproperties of each rigid body, the image flags for each atom in the\nbody are used to “unwrap” the atom coordinates.  Thus you must insure\nthat these image flags are consistent so that the unwrapping creates a\nvalid rigid body (one where the atoms are close together),\nparticularly if the atoms in a single rigid body straddle a periodic\nboundary.  This means the input data file or restart file must define\nthe image flags for each atom consistently or that you have used the\nset command to specify them correctly.  If a dimension is\nnon-periodic then the image flag of each atom must be 0 in that\ndimension, else an error is generated.\n\nThe force and torque keywords discussed next are only allowed for\nthe rigid styles.\nBy default, each rigid body is acted on by other atoms which induce an\nexternal force and torque on its center of mass, causing it to\ntranslate and rotate.  Components of the external center-of-mass force\nand torque can be turned off by the force and torque keywords.\nThis may be useful if you wish a body to rotate but not translate, or\nvice versa, or if you wish it to rotate or translate continuously\nunaffected by interactions with other particles.  Note that if you\nexpect a rigid body not to move or rotate by using these keywords, you\nmust insure its initial center-of-mass translational or angular\nvelocity is 0.0.  Otherwise the initial translational or angular\nmomentum the body has will persist.\nAn xflag, yflag, or zflag set to off means turn off the component of\nforce of torque in that dimension.  A setting of on means turn on\nthe component, which is the default.  Which rigid body(s) the settings\napply to is determined by the first argument of the force and\ntorque keywords.  It can be an integer M from 1 to Nbody, where\nNbody is the number of rigid bodies defined.  A wild-card asterisk can\nbe used in place of, or in conjunction with, the M argument to set the\nflags for multiple rigid bodies.  This takes the form “*” or “*n” or\n“n*” or “m*n”.  If N = the number of rigid bodies, then an asterisk\nwith no numeric values means all bodies from 1 to N.  A leading\nasterisk means all bodies from 1 to n (inclusive).  A trailing\nasterisk means all bodies from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).  Note that you can use the\nforce or torque keywords as many times as you like.  If a\nparticular rigid body has its component flags set multiple times, the\nsettings from the final keyword are used.\n\nNote\nFor computational efficiency, you may wish to turn off pairwise\nand bond interactions within each rigid body, as they no longer\ncontribute to the motion.  The neigh_modify exclude and delete_bonds\ncommands are used to do this.  If the rigid bodies have strongly\noverlapping atoms, you may need to turn off these interactions to\navoid numerical problems due to large equal/opposite intra-body forces\nswamping the contribution of small inter-body forces.\n\nFor computational efficiency, you should typically define one fix\nrigid or fix rigid/small command which includes all the desired rigid\nbodies.  LAMMPS will allow multiple rigid fixes to be defined, but it\nis more expensive.\n\nThe constituent particles within a rigid body can be point particles\n(the default in LAMMPS) or finite-size particles, such as spheres or\nellipsoids or line segments or triangles.  See the atom_style sphere and ellipsoid and line and tri commands for more\ndetails on these kinds of particles.  Finite-size particles contribute\ndifferently to the moment of inertia of a rigid body than do point\nparticles.  Finite-size particles can also experience torque (e.g. due\nto frictional granular interactions) and have an\norientation.  These contributions are accounted for by these fixes.\nForces between particles within a body do not contribute to the\nexternal force or torque on the body.  Thus for computational\nefficiency, you may wish to turn off pairwise and bond interactions\nbetween particles within each rigid body.  The neigh_modify exclude and delete_bonds\ncommands are used to do this.  For finite-size particles this also\nmeans the particles can be highly overlapped when creating the rigid\nbody.\n\nThe rigid, rigid/nve, rigid/small, and rigid/small/nve styles\nperform constant NVE time integration.  They are referred to below as\nthe 4 NVE rigid styles.  The only difference is that the rigid and\nrigid/small styles use an integration technique based on Richardson\niterations.  The rigid/nve and rigid/small/nve styles uses the\nmethods described in the paper by Miller, which are thought\nto provide better energy conservation than an iterative approach.\nThe rigid/nvt and rigid/nvt/small styles performs constant NVT\nintegration using a Nose/Hoover thermostat with chains as described\noriginally in (Hoover) and (Martyna), which\nthermostats both the translational and rotational degrees of freedom\nof the rigid bodies.  They are referred to below as the 2 NVT rigid\nstyles.  The rigid-body algorithm used by rigid/nvt is described in\nthe paper by Kamberaj.\nThe rigid/npt, rigid/nph, rigid/npt/small, and rigid/nph/small\nstyles perform constant NPT or NPH integration using a Nose/Hoover\nbarostat with chains.  They are referred to below as the 4 NPT and NPH\nrigid styles.  For the NPT case, the same Nose/Hoover thermostat is\nalso used as with rigid/nvt and rigid/nvt/small.\nThe barostat parameters are specified using one or more of the iso,\naniso, x, y, z and couple keywords.  These keywords give you\nthe ability to specify 3 diagonal components of the external stress\ntensor, and to couple these components together so that the dimensions\nthey represent are varied together during a constant-pressure\nsimulation.  The effects of these keywords are similar to those\ndefined in fix npt/nph\n\nNote\nCurrently the rigid/npt, rigid/nph, rigid/npt/small, and\nrigid/nph/small styles do not support triclinic (non-orthogonal)\nboxes.\n\nThe target pressures for each of the 6 components of the stress tensor\ncan be specified independently via the x, y, z keywords, which\ncorrespond to the 3 simulation box dimensions.  For each component,\nthe external pressure or tensor component at each timestep is a ramped\nvalue during the run from Pstart to Pstop. If a target pressure is\nspecified for a component, then the corresponding box dimension will\nchange during a simulation.  For example, if the y keyword is used,\nthe y-box length will change.  A box dimension will not change if that\ncomponent is not specified, although you have the option to change\nthat dimension via the fix deform command.\nFor all barostat keywords, the Pdamp parameter operates like the\nTdamp parameter, determining the time scale on which pressure is\nrelaxed.  For example, a value of 10.0 means to relax the pressure in\na timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\nthe units command).\nRegardless of what atoms are in the fix group (the only atoms which\nare time integrated), a global pressure or stress tensor is computed\nfor all atoms.  Similarly, when the size of the simulation box is\nchanged, all atoms are re-scaled to new positions, unless the keyword\ndilate is specified with a dilate-group-ID for a group that\nrepresents a subset of the atoms.  This can be useful, for example, to\nleave the coordinates of atoms in a solid substrate unchanged and\ncontrolling the pressure of a surrounding fluid.  Another example is a\nsystem consisting of rigid bodies and point particles where the\nbarostat is only coupled with the rigid bodies.  This option should be\nused with care, since it can be unphysical to dilate some atoms and\nnot others, because it can introduce large, instantaneous\ndisplacements between a pair of atoms (one dilated, one not) that are\nfar from the dilation origin.\nThe couple keyword allows two or three of the diagonal components of\nthe pressure tensor to be “coupled” together.  The value specified\nwith the keyword determines which are coupled.  For example, xz\nmeans the Pxx and Pzz components of the stress tensor are coupled.\nXyz means all 3 diagonal components are coupled.  Coupling means two\nthings: the instantaneous stress will be computed as an average of the\ncorresponding diagonal components, and the coupled box dimensions will\nbe changed together in lockstep, meaning coupled dimensions will be\ndilated or contracted by the same percentage every timestep.  The\nPstart, Pstop, Pdamp parameters for any coupled dimensions must\nbe identical.  Couple xyz can be used for a 2d simulation; the z\ndimension is simply ignored.\nThe iso and aniso keywords are simply shortcuts that are\nequivalent to specifying several other keywords together.\nThe keyword iso means couple all 3 diagonal components together when\npressure is computed (hydrostatic pressure), and dilate/contract the\ndimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\nspecifying these 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple xyz\n\n\nThe keyword aniso means x, y, and z dimensions are controlled\nindependently using the Pxx, Pyy, and Pzz components of the\nstress tensor as the driving forces, and the specified scalar external\npressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\nthese 4 keywords:\nx Pstart Pstop Pdamp\ny Pstart Pstop Pdamp\nz Pstart Pstop Pdamp\ncouple none\n\n\n\nThe keyword/value option pairs are used in the following ways.\nThe reinit keyword determines, whether the rigid body properties\nare re-initialized between run commands. With the option yes (the\ndefault) this is done, with the option no this is not done. Turning\noff the re-initialization can be helpful to protect rigid bodies against\nunphysical manipulations between runs or when properties cannot be\neasily re-computed (e.g. when read from a file). When using the infile\nkeyword, the reinit option is automatically set to no.\nThe langevin and temp and tparam keywords perform thermostatting\nof the rigid bodies, altering both their translational and rotational\ndegrees of freedom.  What is meant by “temperature” of a collection of\nrigid bodies and how it can be monitored via the fix output is\ndiscussed below.\nThe langevin keyword applies a Langevin thermostat to the constant\nNVE time integration performed by any of the 4 NVE rigid styles:\nrigid, rigid/nve, rigid/small, rigid/small/nve.  It cannot be\nused with the 2 NVT rigid styles: rigid/nvt, rigid/small/nvt.  The\ndesired temperature at each timestep is a ramped value during the run\nfrom Tstart to Tstop.  The Tdamp parameter is specified in time\nunits and determines how rapidly the temperature is relaxed.  For\nexample, a value of 100.0 means to relax the temperature in a timespan\nof (roughly) 100 time units (tau or fmsec or psec - see the\nunits command).  The random # seed must be a positive\ninteger.\nThe way that Langevin thermostatting operates is explained on the fix langevin doc page.  If you wish to simply viscously\ndamp the rotational motion without thermostatting, you can set\nTstart and Tstop to 0.0, which means only the viscous drag term in\nthe Langevin thermostat will be applied.  See the discussion on the\nfix viscous doc page for details.\n\nNote\nWhen the langevin keyword is used with fix rigid versus fix\nrigid/small, different dynamics will result for parallel runs.  This\nis because of the way random numbers are used in the two cases.  The\ndynamics for the two cases should be statistically similar, but will\nnot be identical, even for a single timestep.\n\nThe temp and tparam keywords apply a Nose/Hoover thermostat to the\nNVT time integration performed by the 2 NVT rigid styles.  They cannot\nbe used with the 4 NVE rigid styles.  The desired temperature at each\ntimestep is a ramped value during the run from Tstart to Tstop.\nThe Tdamp parameter is specified in time units and determines how\nrapidly the temperature is relaxed.  For example, a value of 100.0\nmeans to relax the temperature in a timespan of (roughly) 100 time\nunits (tau or fmsec or psec - see the units command).\nNose/Hoover chains are used in conjunction with this thermostat.  The\ntparam keyword can optionally be used to change the chain settings\nused.  Tchain is the number of thermostats in the Nose Hoover chain.\nThis value, along with Tdamp can be varied to dampen undesirable\noscillations in temperature that can occur in a simulation.  As a rule\nof thumb, increasing the chain length should lead to smaller\noscillations. The keyword pchain specifies the number of\nthermostats in the chain thermostatting the barostat degrees of\nfreedom.\n\nNote\nThere are alternate ways to thermostat a system of rigid bodies.\nYou can use fix langevin to treat the individual\nparticles in the rigid bodies as effectively immersed in an implicit\nsolvent, e.g. a Brownian dynamics model.  For hybrid systems with both\nrigid bodies and solvent particles, you can thermostat only the\nsolvent particles that surround one or more rigid bodies by\nappropriate choice of groups in the compute and fix commands for\ntemperature and thermostatting.  The solvent interactions with the\nrigid bodies should then effectively thermostat the rigid body\ntemperature as well without use of the Langevin or Nose/Hoover options\nassociated with the fix rigid commands.\n\n\nThe mol keyword can only be used with the rigid/small styles.  It\nmust be used when other commands, such as fix deposit or fix pour, add rigid\nbodies on-the-fly during a simulation.  You specify a template-ID\npreviously defined using the molecule command, which\nreads a file that defines the molecule.  You must use the same\ntemplate-ID that the other fix which is adding rigid bodies uses.\nThe coordinates, atom types, atom diameters, center-of-mass, and\nmoments of inertia can be specified in the molecule file.  See the\nmolecule command for details.  The only settings\nrequired to be in this file are the coordinates and types of atoms in\nthe molecule, in which case the molecule command calculates the other\nquantities itself.\nNote that these other fixes create new rigid bodies, in addition to\nthose defined initially by this fix via the bodystyle setting.\nAlso note that when using the mol keyword, extra restart information\nabout all rigid bodies is written out whenever a restart file is\nwritten out.  See the NOTE in the next section for details.\n\nThe infile keyword allows a file of rigid body attributes to be read\nin from a file, rather then having LAMMPS compute them.  There are 5\nsuch attributes: the total mass of the rigid body, its center-of-mass\nposition, its 6 moments of inertia, its center-of-mass velocity, and\nthe 3 image flags of the center-of-mass position.  For rigid bodies\nconsisting of point particles or non-overlapping finite-size\nparticles, LAMMPS can compute these values accurately.  However, for\nrigid bodies consisting of finite-size particles which overlap each\nother, LAMMPS will ignore the overlaps when computing these 4\nattributes.  The amount of error this induces depends on the amount of\noverlap.  To avoid this issue, the values can be pre-computed\n(e.g. using Monte Carlo integration).\nThe format of the file is as follows.  Note that the file does not\nhave to list attributes for every rigid body integrated by fix rigid.\nOnly bodies which the file specifies will have their computed\nattributes overridden.  The file can contain initial blank lines or\ncomment lines starting with “#” which are ignored.  The first\nnon-blank, non-comment line should list N = the number of lines to\nfollow.  The N successive lines contain the following information:\nID1 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\nID2 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n...\nIDN masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n\n\nThe rigid body IDs are all positive integers.  For the single\nbodystyle, only an ID of 1 can be used.  For the group bodystyle,\nIDs from 1 to Ng can be used where Ng is the number of specified\ngroups.  For the molecule bodystyle, use the molecule ID for the\natoms in a specific rigid body as the rigid body ID.\nThe masstotal and center-of-mass coordinates (xcm,ycm,zcm) are\nself-explanatory.  The center-of-mass should be consistent with what\nis calculated for the position of the rigid body with all its atoms\nunwrapped by their respective image flags.  If this produces a\ncenter-of-mass that is outside the simulation box, LAMMPS wraps it\nback into the box.\nThe 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz) should be the\nvalues consistent with the current orientation of the rigid body\naround its center of mass.  The values are with respect to the\nsimulation box XYZ axes, not with respect to the principal axes of the\nrigid body itself.  LAMMPS performs the latter calculation internally.\nThe (vxcm,vycm,vzcm) values are the velocity of the center of mass.\nThe (lx,ly,lz) values are the angular momentum of the body.  The\n(vxcm,vycm,vzcm) and (lx,ly,lz) values can simply be set to 0 if you\nwish the body to have no initial motion.\nThe (ixcm,iycm,izcm) values are the image flags of the center of mass\nof the body.  For periodic dimensions, they specify which image of the\nsimulation box the body is considered to be in.  An image of 0 means\nit is inside the box as defined.  A value of 2 means add 2 box lengths\nto get the true value.  A value of -1 means subtract 1 box length to\nget the true value.  LAMMPS updates these flags as the rigid bodies\ncross periodic boundaries during the simulation.\n\nNote\nIf you use the infile or mol keywords and write restart\nfiles during a simulation, then each time a restart file is written,\nthe fix also write an auxiliary restart file with the name\nrfile.rigid, where “rfile” is the name of the restart file,\ne.g. tmp.restart.10000 and tmp.restart.10000.rigid.  This auxiliary\nfile is in the same format described above.  Thus it can be used in a\nnew input script that restarts the run and re-specifies a rigid fix\nusing an infile keyword and the appropriate filename.  Note that the\nauxiliary file will contain one line for every rigid body, even if the\noriginal file only listed a subset of the rigid bodies.\n\n\nIf you use a temperature compute with a group that\nincludes particles in rigid bodies, the degrees-of-freedom removed by\neach rigid body are accounted for in the temperature (and pressure)\ncomputation, but only if the temperature group includes all the\nparticles in a particular rigid body.\nA 3d rigid body has 6 degrees of freedom (3 translational, 3\nrotational), except for a collection of point particles lying on a\nstraight line, which has only 5, e.g a dimer.  A 2d rigid body has 3\ndegrees of freedom (2 translational, 1 rotational).\n\nNote\nYou may wish to explicitly subtract additional\ndegrees-of-freedom if you use the force and torque keywords to\neliminate certain motions of one or more rigid bodies.  LAMMPS does\nnot do this automatically.\n\nThe rigid body contribution to the pressure of the system (virial) is\nalso accounted for by this fix.\n\nIf your simulation is a hybrid model with a mixture of rigid bodies\nand non-rigid particles (e.g. solvent) there are several ways these\nrigid fixes can be used in tandem with fix nve, fix nvt, fix npt, and fix nph.\nIf you wish to perform NVE dynamics (no thermostatting or\nbarostatting), use one of 4 NVE rigid styles to integrate the rigid\nbodies, and fix nve to integrate the non-rigid\nparticles.\nIf you wish to perform NVT dynamics (thermostatting, but no\nbarostatting), you can use one of the 2 NVT rigid styles for the rigid\nbodies, and any thermostatting fix for the non-rigid particles (fix nvt, fix langevin, fix temp/berendsen).  You can also use one of the\n4 NVE rigid styles for the rigid bodies and thermostat them using fix langevin on the group that contains all the\nparticles in the rigid bodies.  The net force added by fix langevin to each rigid body effectively thermostats\nits translational center-of-mass motion.  Not sure how well it does at\nthermostatting its rotational motion.\nIf you with to perform NPT or NPH dynamics (barostatting), you cannot\nuse both fix npt and the NPT or NPH rigid styles.  This\nis because there can only be one fix which monitors the global\npressure and changes the simulation box dimensions.  So you have 3\nchoices:\n\nUse one of the 4 NPT or NPH styles for the rigid bodies.  Use the\ndilate all option so that it will dilate the positions of the\nnon-rigid particles as well.  Use fix nvt (or any other\nthermostat) for the non-rigid particles.\nUse fix npt for the group of non-rigid particles.  Use\nthe dilate all option so that it will dilate the center-of-mass\npositions of the rigid bodies as well.  Use one of the 4 NVE or 2 NVT\nrigid styles for the rigid bodies.\nUse fix press/berendsen to compute the\npressure and change the box dimensions.  Use one of the 4 NVE or 2 NVT\nrigid styles for the rigid bodies.  Use fix nvt (or any\nother thermostat) for the non-rigid particles.\n\nIn all case, the rigid bodies and non-rigid particles both contribute\nto the global pressure and the box is scaled the same by any of the\nbarostatting fixes.\nYou could even use the 2nd and 3rd options for a non-hybrid simulation\nconsisting of only rigid bodies, assuming you give fix npt an empty group, though it’s an odd thing to do.  The\nbarostatting fixes (fix npt and fix press/berensen) will monitor the pressure\nand change the box dimensions, but not time integrate any particles.\nThe integration of the rigid bodies will be performed by fix\nrigid/nvt.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about the 4 NVE rigid styles is written to binary restart files.  The exception is if the infile or\nmol keyword is used, in which case an auxiliary file is written out\nwith rigid body information each time a restart file is written, as\nexplained above for the infile keyword.  For the 2 NVT rigid styles,\nthe state of the Nose/Hoover thermostat is written to binary restart files.  Ditto for the 4 NPT and NPH rigid styles, and\nthe state of the Nose/Hoover barostat.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify energy option is supported by the 6\nNVT, NPT, NPH rigid styles to add the energy change induced by the\nthermostatting to the system’s potential energy as part of\nthermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to keeping the objects rigid to the\nsystem’s virial as part of thermodynamic output.\nThe default is virial yes\nThe fix_modify temp and press options are\nsupported by the 4 NPT and NPH rigid styles to change the computes\nused to calculate the instantaneous pressure tensor.  Note that the 2\nNVT rigid fixes do not use any external compute to compute\ninstantaneous temperature.\nThe fix_modify bodyforces option is supported by\nall rigid styles to set whether per-body forces and torques are\ncomputed early or late in a timestep, i.e. at the post-force stage or\nat the final-integrate stage or the timestep, respectively.\nThe 2 NVE rigid fixes compute a global scalar which can be accessed by\nvarious output commands.  The scalar value\ncalculated by these fixes is “intensive”.  The scalar is the current\ntemperature of the collection of rigid bodies.  This is averaged over\nall rigid bodies and their translational and rotational degrees of\nfreedom.  The translational energy of a rigid body is 1/2 m v^2, where\nm = total mass of the body and v = the velocity of its center of mass.\nThe rotational energy of a rigid body is 1/2 I w^2, where I = the\nmoment of inertia tensor of the body and w = its angular velocity.\nDegrees of freedom constrained by the force and torque keywords\nare removed from this calculation, but only for the rigid and\nrigid/nve fixes.\nThe 6 NVT, NPT, NPH rigid fixes compute a global scalar which can be\naccessed by various output commands.  The scalar\nvalue calculated by these fixes is “extensive”.  The scalar is the\ncumulative energy change due to the thermostatting and barostatting\nthe fix performs.\nAll of the rigid styles (not the rigid/small styles) compute a\nglobal array of values which can be accessed by various output commands.  Similar information about the bodies\ndefined by the rigid/small styles can be accessed via the compute rigid/local command.\nThe number of rows in the array is equal to the number of rigid\nbodies.  The number of columns is 15.  Thus for each rigid body, 15\nvalues are stored: the xyz coords of the center of mass (COM), the xyz\ncomponents of the COM velocity, the xyz components of the force acting\non the COM, the xyz components of the torque acting on the COM, and\nthe xyz image flags of the COM.\nThe center of mass (COM) for each body is similar to unwrapped\ncoordinates written to a dump file.  It will always be inside (or\nslightly outside) the simulation box.  The image flags have the same\nmeaning as image flags for atom positions (see the “dump” command).\nThis means you can calculate the unwrapped COM by applying the image\nflags to the COM, the same as when unwrapped coordinates are written\nto a dump file.\nThe force and torque values in the array are not affected by the\nforce and torque keywords in the fix rigid command; they reflect\nvalues before any changes are made by those keywords.\nThe ordering of the rigid bodies (by row in the array) is as follows.\nFor the single keyword there is just one rigid body.  For the\nmolecule keyword, the bodies are ordered by ascending molecule ID.\nFor the group keyword, the list of group IDs determines the ordering\nof bodies.\nThe array values calculated by these fixes are “intensive”, meaning\nthey are independent of the number of atoms in the simulation.\nNo parameter of these fixes can be used with the start/stop keywords\nof the run command.  These fixes are not invoked during\nenergy minimization.",
    "syntax": "fix ID group-ID style bodystyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = rigid or rigid/nve or rigid/nvt or rigid/npt or rigid/nph or rigid/small or rigid/nve/small or rigid/nvt/small or rigid/npt/small or rigid/nph/small\n * bodystyle = single or molecule or group\n * single args = none\n * molecule args = none\n * custom args = i_propname or v_varname\n *   i_propname = an integer property defined via fix property/atom\n *   v_varname  = an atom-style or atomfile-style variable\n * group args = N groupID1 groupID2 ...\n *   N = # of groups\n *   groupID1, groupID2, ... = list of N group IDs\n * zero or more keyword/value pairs may be appended\n * keyword = langevin or reinit or temp or iso or aniso or x or y or z or couple or tparam or pchain or dilate or force or torque or infile\n * langevin values = Tstart Tstop Tperiod seed\n *   Tstart,Tstop = desired temperature at start/stop of run (temperature units)\n *   Tdamp = temperature damping parameter (time units)\n *   seed = random number seed to use for white noise (positive integer)\n * reinit = yes or no\n * temp values = Tstart Tstop Tdamp\n *   Tstart,Tstop = desired temperature at start/stop of run (temperature units)\n *   Tdamp = temperature damping parameter (time units)\n * iso or aniso values = Pstart Pstop Pdamp\n *   Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n *   Pdamp = pressure damping parameter (time units)\n * x or y or z values = Pstart Pstop Pdamp\n *   Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n *   Pdamp = stress damping parameter (time units)\n * couple = none or xyz or xy or yz or xz\n * tparam values = Tchain Titer Torder\n *   Tchain = length of Nose/Hoover thermostat chain\n *   Titer = number of thermostat iterations performed\n *   Torder = 3 or 5 = Yoshida-Suzuki integration parameters\n * pchain values = Pchain\n *   Pchain = length of the Nose/Hoover thermostat chain coupled with the barostat\n * dilate value = dilate-group-ID\n *   dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n * force values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass force is active\n * torque values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n * infile filename\n *   filename = file with per-body values of mass, center-of-mass, moments of inertia\n * mol value = template-ID\n *   template-ID = ID of molecule template specified in a separate molecule command",
    "examples": "fix 1 clump rigid single reinit yes\nfix 1 clump rigid/small molecule\nfix 1 clump rigid single force 1 off off on langevin 1.0 1.0 1.0 428984\nfix 1 polychains rigid/nvt molecule temp 1.0 1.0 5.0 reinit no\nfix 1 polychains rigid molecule force 1*5 off off off force 6*10 off off on\nfix 1 polychains rigid/small molecule langevin 1.0 1.0 1.0 428984\nfix 2 fluid rigid group 3 clump1 clump2 clump3 torque * off off off\nfix 1 rods rigid/npt molecule temp 300.0 300.0 100.0 iso 0.5 0.5 10.0\nfix 1 particles rigid/npt molecule temp 1.0 1.0 5.0 x 0.5 0.5 1.0 z 0.5 0.5 1.0 couple xz\nfix 1 water rigid/nph molecule iso 0.5 0.5 1.0\nfix 1 particles rigid/npt/small molecule temp 1.0 1.0 1.0 iso 0.5 0.5 1.0\n\nvariable bodyid atom 1.0*gmask(clump1)+2.0*gmask(clump2)+3.0*gmask(clump3)\nfix 1 clump rigid custom v_bodyid\n\nvariable bodyid atomfile bodies.txt\nfix 1 clump rigid custom v_bodyid\n\nfix 0 all property/atom i_bodyid\nread_restart data.rigid fix 0 NULL Bodies\nfix 1 clump rigid/small custom i_bodyid",
    "restrictions": "These fixes are all part of the RIGID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nAssigning a temperature via the velocity create\ncommand to a system with rigid bodies may not have\nthe desired outcome for two reasons.  First, the velocity command can\nbe invoked before the rigid-body fix is invoked or initialized and the\nnumber of adjusted degrees of freedom (DOFs) is known.  Thus it is not\npossible to compute the target temperature correctly.  Second, the\nassigned velocities may be partially canceled when constraints are\nfirst enforced, leading to a different temperature than desired.  A\nworkaround for this is to perform a run 0 command, which\ninsures all DOFs are accounted for properly, and then rescale the\ntemperature to the desired value before performing a simulation.  For\nexample:\nvelocity all create 300.0 12345\nrun 0                             # temperature may not be 300K\nvelocity all scale 300.0          # now it should be"
},
{
    "command": "fix rigid/meso",
    "html_filename": "fix_rigid_meso.html",
    "short_description": "Treat one or more sets of mesoscopic SPH/SDPD particles as independent rigid bodies",
    "description": "Treat one or more sets of mesoscopic SPH/SDPD particles as independent\nrigid bodies.  This means that each timestep the total force and torque\non each rigid body is computed as the sum of the forces and torques on\nits constituent particles.  The coordinates and velocities of the\nparticles in each body are then updated so that the body moves and\nrotates as a single entity using the methods described in the paper by\n(Miller). Density and internal energy of the particles will\nalso be updated. This is implemented by creating internal data structures\nfor each rigid body and performing time integration on these data\nstructures.  Positions and velocities of the constituent particles are\nregenerated from the rigid body data structures in every time step. This\nrestricts which operations and fixes can be applied to rigid bodies. See\nbelow for a detailed discussion.\nThe operation of this fix is exactly like that described by the\nfix rigid/nve command, except that particles’ density,\ninternal energy and extrapolated velocity are also updated.\n\nNote\nYou should not update the particles in rigid bodies via other\ntime-integration fixes (e.g. fix meso,\nfix meso/stationary), or you will have conflicting\nupdates to positions and velocities resulting in unphysical behavior in most\ncases. When performing a hybrid simulation with some atoms in rigid bodies,\nand some not, a separate time integration fix like fix meso\nshould be used for the non-rigid particles.\n\n\nNote\nThese fixes are overkill if you simply want to hold a collection\nof particles stationary or have them move with a constant velocity. To\nhold particles stationary use fix meso/stationary instead. If you would like to\nmove particles with a constant velocity use fix meso/move.\n\n\nWarning\nThe aggregate properties of each rigid body are\ncalculated at the start of a simulation run and are maintained in\ninternal data structures. The properties include the position and\nvelocity of the center-of-mass of the body, its moments of inertia, and\nits angular momentum.  This is done using the properties of the\nconstituent particles of the body at that point in time (or see the infile\nkeyword option).  Thereafter, changing these properties of individual\nparticles in the body will have no effect on a rigid body’s dynamics, unless\nthey effect any computation of per-particle forces or torques. If the\nkeyword reinit is set to yes (the default), the rigid body data\nstructures will be recreated at the beginning of each run command;\nif the keyword reinit is set to no, the rigid body data structures\nwill be built only at the very first run command and maintained for\nas long as the rigid fix is defined. For example, you might think you\ncould displace the particles in a body or add a large velocity to each particle\nin a body to make it move in a desired direction before a 2nd run is\nperformed, using the set or\ndisplace_atoms or velocity\ncommands.  But these commands will not affect the internal attributes\nof the body unless reinit is set to yes. With reinit set to no\n(or using the infile option, which implies reinit no) the position\nand velocity of individual particles in the body will be reset when time\nintegration starts again.\n\n\nEach rigid body must have two or more particles.  A particle can belong\nto at most one rigid body.  Which particles are in which bodies can be\ndefined via several options.\nFor bodystyle single the entire fix group of particles is treated as\none rigid body.\nFor bodystyle molecule, particles are grouped into rigid bodies by their\nrespective molecule IDs: each set of particles in the fix group with the\nsame molecule ID is treated as a different rigid body.  Note that particles\nwith a molecule ID = 0 will be treated as a single rigid body. For a\nsystem with solvent (typically this is particles with molecule ID = 0)\nsurrounding rigid bodies, this may not be what you want.  Thus you\nshould be careful to use a fix group that only includes particles you\nwant to be part of rigid bodies.\nBodystyle custom is similar to bodystyle molecule except that it\nis more flexible in using other per-atom properties to define the sets\nof particles that form rigid bodies.  An integer vector defined by the\nfix property/atom command can be used.  Or an\natom-style or atomfile-style variable can be used; the\nfloating-point value produced by the variable is rounded to an\ninteger.  As with bodystyle molecule, each set of particles in the fix\ngroups with the same integer value is treated as a different rigid\nbody.  Since fix property/atom vectors and atom-style variables\nproduce values for all particles, you should be careful to use a fix group\nthat only includes particles you want to be part of rigid bodies.\nFor bodystyle group, each of the listed groups is treated as a\nseparate rigid body.  Only particles that are also in the fix group are\nincluded in each rigid body.\n\nNote\nTo compute the initial center-of-mass position and other\nproperties of each rigid body, the image flags for each particle in the\nbody are used to “unwrap” the particle coordinates.  Thus you must\ninsure that these image flags are consistent so that the unwrapping\ncreates a valid rigid body (one where the particles are close together)\n, particularly if the particles in a single rigid body straddle a\nperiodic boundary.  This means the input data file or restart file must\ndefine the image flags for each particle consistently or that you have\nused the set command to specify them correctly.  If a\ndimension is non-periodic then the image flag of each particle must be\n0 in that dimension, else an error is generated.\n\nBy default, each rigid body is acted on by other particles which induce\nan external force and torque on its center of mass, causing it to\ntranslate and rotate.  Components of the external center-of-mass force\nand torque can be turned off by the force and torque keywords.\nThis may be useful if you wish a body to rotate but not translate, or\nvice versa, or if you wish it to rotate or translate continuously\nunaffected by interactions with other particles.  Note that if you\nexpect a rigid body not to move or rotate by using these keywords, you\nmust insure its initial center-of-mass translational or angular\nvelocity is 0.0. Otherwise the initial translational or angular\nmomentum, the body has, will persist.\nAn xflag, yflag, or zflag set to off means turn off the component of\nforce or torque in that dimension.  A setting of on means turn on\nthe component, which is the default.  Which rigid body(s) the settings\napply to is determined by the first argument of the force and\ntorque keywords.  It can be an integer M from 1 to Nbody, where\nNbody is the number of rigid bodies defined.  A wild-card asterisk can\nbe used in place of, or in conjunction with, the M argument to set the\nflags for multiple rigid bodies.  This takes the form “*” or “*n” or\n“n*” or “m*n”.  If N = the number of rigid bodies, then an asterisk\nwith no numeric values means all bodies from 1 to N.  A leading\nasterisk means all bodies from 1 to n (inclusive).  A trailing\nasterisk means all bodies from n to N (inclusive).  A middle asterisk\nmeans all bodies from m to n (inclusive).  Note that you can use the\nforce or torque keywords as many times as you like.  If a\nparticular rigid body has its component flags set multiple times, the\nsettings from the final keyword are used.\nFor computational efficiency, you should typically define one fix\nrigid/meso command which includes all the desired rigid bodies. LAMMPS\nwill allow multiple rigid/meso fixes to be defined, but it is more\nexpensive.\n\nThe keyword/value option pairs are used in the following ways.\nThe reinit keyword determines, whether the rigid body properties\nare re-initialized between run commands. With the option yes (the\ndefault) this is done, with the option no this is not done. Turning\noff the re-initialization can be helpful to protect rigid bodies against\nunphysical manipulations between runs or when properties cannot be\neasily re-computed (e.g. when read from a file). When using the infile\nkeyword, the reinit option is automatically set to no.\n\nThe infile keyword allows a file of rigid body attributes to be read\nin from a file, rather then having LAMMPS compute them.  There are 5\nsuch attributes: the total mass of the rigid body, its center-of-mass\nposition, its 6 moments of inertia, its center-of-mass velocity, and\nthe 3 image flags of the center-of-mass position.  For rigid bodies\nconsisting of point particles or non-overlapping finite-size\nparticles, LAMMPS can compute these values accurately.  However, for\nrigid bodies consisting of finite-size particles which overlap each\nother, LAMMPS will ignore the overlaps when computing these 4\nattributes.  The amount of error this induces depends on the amount of\noverlap.  To avoid this issue, the values can be pre-computed\n(e.g. using Monte Carlo integration).\nThe format of the file is as follows.  Note that the file does not\nhave to list attributes for every rigid body integrated by fix rigid.\nOnly bodies which the file specifies will have their computed\nattributes overridden.  The file can contain initial blank lines or\ncomment lines starting with “#” which are ignored.  The first\nnon-blank, non-comment line should list N = the number of lines to\nfollow.  The N successive lines contain the following information:\nID1 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\nID2 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n...\nIDN masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n\n\nThe rigid body IDs are all positive integers.  For the single\nbodystyle, only an ID of 1 can be used.  For the group bodystyle,\nIDs from 1 to Ng can be used where Ng is the number of specified\ngroups.  For the molecule bodystyle, use the molecule ID for the\natoms in a specific rigid body as the rigid body ID.\nThe masstotal and center-of-mass coordinates (xcm,ycm,zcm) are\nself-explanatory.  The center-of-mass should be consistent with what\nis calculated for the position of the rigid body with all its atoms\nunwrapped by their respective image flags.  If this produces a\ncenter-of-mass that is outside the simulation box, LAMMPS wraps it\nback into the box.\nThe 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz) should be the\nvalues consistent with the current orientation of the rigid body\naround its center of mass.  The values are with respect to the\nsimulation box XYZ axes, not with respect to the principal axes of the\nrigid body itself.  LAMMPS performs the latter calculation internally.\nThe (vxcm,vycm,vzcm) values are the velocity of the center of mass.\nThe (lx,ly,lz) values are the angular momentum of the body.  The\n(vxcm,vycm,vzcm) and (lx,ly,lz) values can simply be set to 0 if you\nwish the body to have no initial motion.\nThe (ixcm,iycm,izcm) values are the image flags of the center of mass\nof the body.  For periodic dimensions, they specify which image of the\nsimulation box the body is considered to be in.  An image of 0 means\nit is inside the box as defined.  A value of 2 means add 2 box lengths\nto get the true value.  A value of -1 means subtract 1 box length to\nget the true value.  LAMMPS updates these flags as the rigid bodies\ncross periodic boundaries during the simulation.\n\nNote\nIf you use the infile keyword and write restart\nfiles during a simulation, then each time a restart file is written,\nthe fix also write an auxiliary restart file with the name\nrfile.rigid, where “rfile” is the name of the restart file,\ne.g. tmp.restart.10000 and tmp.restart.10000.rigid.  This auxiliary\nfile is in the same format described above.  Thus it can be used in a\nnew input script that restarts the run and re-specifies a rigid fix\nusing an infile keyword and the appropriate filename.  Note that the\nauxiliary file will contain one line for every rigid body, even if the\noriginal file only listed a subset of the rigid bodies.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information is written to binary restart files.\nIf the infile keyword is used, an auxiliary file is written out\nwith rigid body information each time a restart file is written, as\nexplained above for the infile keyword.\nNone of the fix_modify options are relevant to this\nfix.\nThis fix computes a global array of values which can be accessed by\nvarious output commands.\nThe number of rows in the array is equal to the number of rigid\nbodies.  The number of columns is 28.  Thus for each rigid body, 28\nvalues are stored: the xyz coords of the center of mass (COM), the xyz\ncomponents of the COM velocity, the xyz components of the force acting\non the COM, the components of the 4-vector quaternion representing the\norientation of the rigid body, the xyz components of the angular velocity\nof the body around its COM, the xyz components of the torque acting on the\nCOM, the 3 principal components of the moment of inertia, the xyz components\nof the angular momentum of the body around its COM, and the xyz image\nflags of the COM.\nThe center of mass (COM) for each body is similar to unwrapped\ncoordinates written to a dump file.  It will always be inside (or\nslightly outside) the simulation box.  The image flags have the same\nmeaning as image flags for particle positions (see the “dump” command).\nThis means you can calculate the unwrapped COM by applying the image\nflags to the COM, the same as when unwrapped coordinates are written\nto a dump file.\nThe force and torque values in the array are not affected by the\nforce and torque keywords in the fix rigid command; they reflect\nvalues before any changes are made by those keywords.\nThe ordering of the rigid bodies (by row in the array) is as follows.\nFor the single keyword there is just one rigid body.  For the\nmolecule keyword, the bodies are ordered by ascending molecule ID.\nFor the group keyword, the list of group IDs determines the ordering\nof bodies.\nThe array values calculated by this fix are “intensive”, meaning they\nare independent of the number of particles in the simulation.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID rigid/meso bodystyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * rigid/meso = style name of this fix command\n * bodystyle = single or molecule or group\n * single args = none\n * molecule args = none\n * custom args = i_propname or v_varname\n *   i_propname = an integer property defined via fix property/atom\n *   v_varname  = an atom-style or atomfile-style variable\n * group args = N groupID1 groupID2 ...\n *   N = # of groups\n *   groupID1, groupID2, ... = list of N group IDs\n * zero or more keyword/value pairs may be appended\n * keyword = reinit or force or torque or infile\n * reinit = yes or no\n * force values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass force is active\n * torque values = M xflag yflag zflag\n *   M = which rigid body from 1-Nbody (see asterisk form below)\n *   xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n * infile filename\n *   filename = file with per-body values of mass, center-of-mass, moments of inertia",
    "examples": "fix 1 ellipsoid rigid/meso single\nfix 1 rods      rigid/meso molecule\nfix 1 spheres   rigid/meso single force 1 off off on\nfix 1 particles rigid/meso molecule force 1*5 off off off force 6*10 off off on\nfix 2 spheres   rigid/meso group 3 sphere1 sphere2 sphere3 torque * off off off",
    "restrictions": "This fix is part of the USER-SDPD package and also depends on the RIGID\npackage.  It is only enabled if LAMMPS was built with both packages. See\nthe Build package doc page for more info.\nThis fix requires that atoms store density and internal energy as\ndefined by the atom_style meso command.\nAll particles in the group must be mesoscopic SPH/SDPD particles."
},
{
    "command": "fix rx",
    "html_filename": "fix_rx.html",
    "short_description": "Fix rx solves the reaction kinetic ODEs for a given reaction set that is defined within the file associated with this command",
    "description": "Fix rx solves the reaction kinetic ODEs for a given reaction set that is\ndefined within the file associated with this command.\nFor a general reaction such that\n\n\\[\\nu_{A}A + \\nu_{B}B \\rightarrow \\nu_{C}C\\]\nthe reaction rate equation is defined to be of the form\n\n\\[r = k(T)[A]^{\\nu_{A}}[B]^{\\nu_{B}}\\]\nIn the current implementation, the exponents are defined to be equal\nto the stoichiometric coefficients.  A given reaction set consisting\nof n reaction equations will contain a total of m species.  A set\nof m ordinary differential equations (ODEs) that describe the change\nin concentration of a given species as a function of time are then\nconstructed based on the n reaction rate equations.\nThe ODE systems are solved over the full DPD timestep dt using either a 4th\norder Runge-Kutta rk4 method with a fixed step-size h, specified\nby the lammps_rk4 keyword, or a 4th order Runge-Kutta-Fehlberg (rkf45) method\nwith an adaptive step-size for h. The number of ODE steps per DPD timestep\nfor the rk4 method is optionally specified immediately after the rk4\nkeyword. The ODE step-size is set as dt/num_steps. Smaller\nstep-sizes tend to yield more accurate results but there is not\ncontrol on the error. For error control, use the rkf45 ODE solver.\nThe rkf45 method adjusts the step-size so that the local truncation error is held\nwithin the specified absolute and relative tolerances. The initial step-size h0\ncan be specified by the user or estimated internally. It is recommended that the user\nspecify h0 since this will generally reduced the number of ODE integration steps\nrequired. h0 is defined as dt / min_steps if min_steps >= 1. If min_steps == 0,\nh0 is estimated such that an explicit Euler method would likely produce\nan acceptable solution. This is generally overly conservative for the 4th-order\nmethod and users are advised to specify h0 as some fraction of the DPD timestep.\nFor small DPD timesteps, only one step may be necessary depending upon the tolerances.\nNote that more than min_steps ODE steps may be taken depending upon the ODE stiffness\nbut no more than max_steps will be taken. If max_steps is reached, an error warning\nis printed and the simulation is stopped.\nAfter each ODE step, the solution error e is tested and weighted using the absTol\nand relTol values. The error vector is weighted as e / (relTol * |u| + absTol)\nwhere u is the solution vector. If the norm of the error is <= 1, the solution is\naccepted, h is increased by a proportional amount, and the next ODE step is begun.\nOtherwise, h is shrunk and the ODE step is repeated.\nRun-time diagnostics are available for the rkf45 ODE solver. The frequency\n(in time-steps) that diagnostics are reported is controlled by the last (optional)\n12th argument. A negative frequency means that diagnostics are reported once at the\nend of each run. A positive value N means that the diagnostics are reported once\nper N time-steps.\nThe diagnostics report the average # of integrator steps and RHS function evaluations\nand run-time per ODE as well as the average/RMS/min/max per process. If the\nreporting frequency is 1, the RMS/min/max per ODE are also reported. The per ODE\nstatistics can be used to adjust the tolerance and min/max step parameters. The\nstatistics per MPI process can be useful to examine any load imbalance caused by the\nadaptive ODE solver. (Some DPD particles can take longer to solve than others. This\ncan lead to an imbalance across the MPI processes.)\n\nThe filename specifies a file that contains the entire set of reaction\nkinetic equations and corresponding Arrhenius parameters.  The format of\nthis file is described below.\nThere is no restriction on the total number or reaction equations that\nare specified.  The species names are arbitrary string names that are\nassociated with the species concentrations.  Each species in a given\nreaction must be preceded by it’s stoichiometric coefficient.  The\nonly delimiters that are recognized between the species are either a\n+ or = character.  The = character corresponds to an\nirreversible reaction.  After specifying the reaction, the reaction\nrate constant is determined through the temperature dependent\nArrhenius equation:\n\n\\[k = AT^{n}e^{\\frac{-E_{a}}{k_{B}T}}\\]\nwhere A is the Arrhenius factor in time units or concentration/time\nunits, n is the unitless exponent of the temperature dependence, and\n\\(E_a\\) is the activation energy in energy units.  The temperature\ndependence can be removed by specifying the exponent as zero.\nThe internal temperature of the coarse-grained particles can be used\nin constructing the reaction rate constants at every DPD timestep by\nspecifying the keyword none.  Alternatively, the keyword lucy can\nbe specified to compute a local-average particle internal temperature\nfor use in the reaction rate constant expressions.  The local-average\nparticle internal temperature is defined as:\n\n\\[\\theta_i^{-1} = \\frac{\\sum_{j=1}\\omega_{Lucy}\\left(r_{ij}\\right)\\theta_j^{-1}}{\\sum_{j=1}\\omega_{Lucy}\\left(r_{ij}\\right)}\\]\nwhere the Lucy function is expressed as:\n\n\\[\\omega_{Lucy}\\left(r_{ij}\\right) = \\left( 1 + \\frac{3r_{ij}}{r_c} \\right) \\left( 1 - \\frac{r_{ij}}{r_c} \\right)^3\\]\nThe self-particle interaction is included in the above equation.\nThe stoichiometric coefficients for the reaction mechanism are stored\nin either a sparse or dense matrix format. The dense matrix should only be\nused for small reaction mechanisms. The sparse matrix should be used when there\nare many reactions (e.g., more than 5). This allows the number of reactions and\nspecies to grow while keeping the computational cost tractable. The matrix\nformat can be specified as using either the sparse or dense keywords.\nIf all stoichiometric coefficients for a reaction are small integers (whole\nnumbers <= 3), a fast exponential function is used. This can save significant\ncomputational time so users are encouraged to use integer coefficients\nwhere possible.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# Rxn equations and parameters                                               (one or more comment or blank lines)\n\n1.0 hcn + 1.0 no2 = 1.0  no + 0.5 n2  + 0.5 h2 + 1.0 co   2.49E+01 0.0 1.34  (rxn equation, A, n, Ea)\n1.0 hcn + 1.0  no = 1.0  co + 1.0 n2  + 0.5 h2            2.16E+00 0.0 1.52\n...\n1.0  no + 1.0  co = 0.5  n2 + 1.0 co2                     1.66E+06 0.0 0.69\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.\nFollowing a blank line, the next N lines list the N reaction\nequations.  Each species within the reaction equation is specified\nthrough its stoichiometric coefficient and a species tag.  Reactant\nspecies are specified on the left-hand side of the equation and\nproduct species are specified on the right-hand side of the equation.\nAfter specifying the reactant and product species, the final three\narguments of each line represent the Arrhenius parameter A, the\ntemperature exponent n, and the activation energy Ea.\nNote that the species tags that are defined in the reaction equations\nare used by the fix eos/table/rx command to\ndefine the thermodynamic properties of each species.  Furthermore, the\nnumber of species molecules (i.e., concentration) can be specified\neither with the set command using the “d_” prefix or by\nreading directly the concentrations from a data file.  For the latter\ncase, the read_data command with the fix keyword\nshould be specified, where the fix-ID will be the “fix rx`ID with a <SPECIES”>`_ suffix, e.g.\nfix          foo all rx reaction.file …\nread_data    data.dpd fix foo_SPECIES NULL Species\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID rx file localTemp matrix solver minSteps ...",
    "parameters": " * ID, group-ID are documented in fix command\n * rx = style name of this fix command\n * file = filename containing the reaction kinetic equations and Arrhenius parameters\n * localTemp = none,lucy = no local temperature averaging or local temperature defined through Lucy weighting function\n * matrix = sparse, dense format for the stoichiometric matrix\n * solver = lammps_rk4,rkf45 = rk4 is an explicit 4th order Runge-Kutta method; rkf45 is an adaptive 4th-order Runge-Kutta-Fehlberg method\n * minSteps = # of steps for rk4 solver or minimum # of steps for rkf45 (rk4 or rkf45)\n * maxSteps = maximum number of steps for the rkf45 solver (rkf45 only)\n * relTol = relative tolerance for the rkf45 solver (rkf45 only)\n * absTol = absolute tolerance for the rkf45 solver (rkf45 only)\n * diag   = Diagnostics frequency for the rkf45 solver (optional, rkf45 only)",
    "examples": "fix 1 all rx kinetics.rx none dense lammps_rk4\nfix 1 all rx kinetics.rx none sparse lammps_rk4 1\nfix 1 all rx kinetics.rx lucy sparse lammps_rk4 10\nfix 1 all rx kinetics.rx none dense rkf45 1 100 1e-6 1e-8\nfix 1 all rx kinetics.rx none dense rkf45 1 100 1e-6 1e-8 -1",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand.\nThis command can only be used with a constant energy or constant\nenthalpy DPD simulation."
},
{
    "command": "fix saed/vtk",
    "html_filename": "fix_saed_vtk.html",
    "short_description": "Time average computed intensities from compute saed and write output to a file in the 3rd generation vtk image data format for visualization directly in parallelized visualization software packages like ParaView and VisIt",
    "description": "Time average computed intensities from compute saed and\nwrite output to a file in the 3rd generation vtk image data format for\nvisualization directly in parallelized visualization software packages\nlike ParaView and VisIt. Note that if no time averaging is done, this\ncommand can be used as a convenient way to simply output diffraction\nintensities at a single snapshot.\nTo produce output in the image data vtk format ghost data is added\noutside the Kmax range assigned in the compute saed. The ghost data is\nassigned a value of -1 and can be removed setting a minimum isovolume\nof 0 within the visualization software. SAED images can be created by\nvisualizing a spherical slice of the data that is centered at\nR_Ewald*[h k l]/norm([h k l]), where R_Ewald=1/lambda.\nThe group specified within this command is ignored. However, note that\nspecified values may represent calculations performed by saed computes\nwhich store their own “group” definitions.\nFix saed/vtk is designed to work only with compute saed\nvalues, e.g.\ncompute 3 top saed 0.0251 Al O\nfix saed/vtk 1 1 1 c_3 file Al2O3_001.saed\n\n\n\nThe Nevery, Nrepeat, and Nfreq arguments specify on what\ntimesteps the input values will be used in order to contribute to the\naverage.  The final averaged quantities are generated on timesteps\nthat are a multiple of Nfreq.  The average is over Nrepeat\nquantities, computed in the preceding portion of the simulation every\nNevery timesteps.  Nfreq must be a multiple of Nevery and\nNevery must be non-zero even if Nrepeat is 1.\nAlso, the timesteps\ncontributing to the average value cannot overlap,\ni.e. Nrepeat*Nevery can not exceed Nfreq.\nFor example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\ntimesteps 90,92,94,96,98,100 will be used to compute the final average\non timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\ntimestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\naveraging is done; values are simply generated on timesteps\n100,200,etc.\n\nThe output for fix ave/time/saed is a file written with the 3rd generation\nvtk image data formatting.  The filename assigned by the file keyword is\nappended with _N.vtk where N is an index (0,1,2…) to account for multiple\ndiffraction intensity outputs.\nBy default the header contains the following information (with example data):\n# vtk DataFile Version 3.0 c_SAED\nImage data set\nASCII\nDATASET STRUCTURED_POINTS\nDIMENSIONS 337 219 209\nASPECT_RATIO 0.00507953 0.00785161 0.00821458\nORIGIN -0.853361 -0.855826 -0.854316\nPOINT_DATA 15424827\nSCALARS intensity float\nLOOKUP_TABLE default\n...data\n\n\nIn this example, kspace is sampled across a 337 x 219 x 209 point mesh\nwhere the mesh spacing is approximately 0.005, 0.007, and 0.008\ninv(length) units in the k1, k2, and k3 directions, respectively.\nThe data is shifted by -0.85, -0.85, -0.85 inv(length) units so that\nthe origin will lie at 0, 0, 0.   Here, 15,424,827 kspace points are\nsampled in total.\n\nAdditional optional keywords also affect the operation of this fix.\nThe ave keyword determines how the values produced every Nfreq\nsteps are averaged with values produced on previous steps that were\nmultiples of Nfreq, before they are accessed by another output\ncommand or written to a file.\nIf the ave setting is one, then the values produced on timesteps\nthat are multiples of Nfreq are independent of each other; they are\noutput as-is without further averaging.\nIf the ave setting is running, then the values produced on\ntimesteps that are multiples of Nfreq are summed and averaged in a\ncumulative sense before being output.  Each output value is thus the\naverage of the value produced on that timestep with all preceding\nvalues.  This running average begins when the fix is defined; it can\nonly be restarted by deleting the fix via the unfix\ncommand, or by re-defining the fix by re-specifying it.\nIf the ave setting is window, then the values produced on\ntimesteps that are multiples of Nfreq are summed and averaged within\na moving “window” of time, so that the last M values are used to\nproduce the output.  E.g. if M = 3 and Nfreq = 1000, then the output\non step 10000 will be the average of the individual values on steps\n8000,9000,10000.  Outputs on early steps will average over less than M\nvalues if they are not available.\nThe start keyword specifies what timestep averaging will begin on.\nThe default is step 0.  Often input values can be 0.0 at time 0, so\nsetting start to a larger value can avoid including a 0.0 in a\nrunning or windowed average.\nThe file keyword allows a filename to be specified.  Every Nfreq\nsteps, the vector of saed intensity data is written to a new file using\nthe 3rd generation vtk format.  The base of each file is assigned by\nthe file keyword and this string is appended with _N.vtk where N is\nan index (0,1,2…) to account for situations with multiple diffraction\nintensity outputs.\nThe overwrite keyword will continuously overwrite the output file\nwith the latest output, so that it only contains one timestep worth of\noutput.  This option can only be used with the ave running setting.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID saed/vtk Nevery Nrepeat Nfreak c_ID attribute args ... keyword args ...",
    "parameters": " * ID, group-ID are documented in fix command\n * saed/vtk = style name of this fix command\n * Nevery = use input values every this many timesteps\n * Nrepeat = # of times to use input values for calculating averages\n * Nfreq = calculate averages every this many timesteps\n * c_ID = saed compute ID\n * keyword = file or ave or start or file or overwrite:l\n *   ave args = one or running or window M\n *     one = output a new average value every Nfreq steps\n *     running = output cumulative average of all previous Nfreq steps\n *     window M = output average of M most recent Nfreq steps\n *   start args = Nstart\n *     Nstart = start averaging on this timestep\n *   file arg = filename\n *     filename = name of file to output time averages to\n *   overwrite arg = none = overwrite output file with only latest output",
    "examples": "compute 1 all saed 0.0251 Al O Kmax 1.70 Zone 0 0 1 dR_Ewald 0.01 c 0.5 0.5 0.5\ncompute 2 all saed 0.0251 Ni Kmax 1.70 Zone 0 0 0 c 0.05 0.05 0.05 manual echo\n\nfix 1 all saed/vtk 1 1 1 c_1 file Al2O3_001.saed\nfix 2 all saed/vtk 1 1 1 c_2 file Ni_000.saed",
    "restrictions": "The attributes for fix_saed_vtk must match the values assigned in the\nassociated compute_saed command."
},
{
    "command": "fix setforce",
    "html_filename": "fix_setforce.html",
    "short_description": "Set each component of force on each atom in the group to the specified values fx,fy,fz",
    "description": "Set each component of force on each atom in the group to the specified\nvalues fx,fy,fz.  This erases all previously computed forces on the\natom, though additional fixes could add new forces.  This command can\nbe used to freeze certain atoms in the simulation by zeroing their\nforce, either for running dynamics or performing an energy\nminimization.  For dynamics, this assumes their initial velocity is\nalso zero.\nAny of the fx,fy,fz values can be specified as NULL which means do not\nalter the force component in that dimension.\nAny of the 3 quantities defining the force components can be specified\nas an equal-style or atom-style variable, namely fx,\nfy, fz.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value used to determine the\nforce component.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent force field.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent force\nfield with optional time-dependence as well.\nIf the region keyword is used, the atom must also be in the\nspecified geometric region in order to have force added\nto it.\n\nStyle spin suffix sets the components of the magnetic precession\nvectors instead of the mechanical forces. This also erases all\npreviously computed magnetic precession vectors on the atom, though\nadditional magnetic fixes could add new forces.\nThis command can be used to freeze the magnetic moment of certain\natoms in the simulation by zeroing their precession vector.\nAll options defined above remain valid, they just apply to the magnetic\nprecession vectors instead of the forces.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThe region keyword is also supported by Kokkos, but a Kokkos-enabled\nregion must be used. See the region region command for\nmore information.\nThese accelerated styles are part of the r Kokkos package.  They are\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify respa option is supported by\nthis fix. This allows to set at which level of the r-RESPA\nintegrator the fix is setting the forces to the desired values; on all\nother levels, the force is set to 0.0 for the atoms in the fix group,\nso that setforce values are not counted multiple times. Default is to\nto override forces at the outermost level.\nThis fix computes a global 3-vector of forces, which can be accessed\nby various output commands.  This is the total\nforce on the group of atoms before the forces on individual atoms are\nchanged by the fix.  The vector values calculated by this fix are\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command, but you cannot set\nforces to any value besides zero when performing a minimization.  Use\nthe fix addforce command if you want to apply a\nnon-zero force to atoms during a minimization.",
    "syntax": "fix ID group-ID setforce fx fy fz keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * setforce = style name of this fix command\n * fx,fy,fz = force component values\n * any of fx,fy,fz can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to have added force",
    "examples": "fix freeze indenter setforce 0.0 0.0 0.0\nfix 2 edge setforce NULL 0.0 0.0\nfix 1 edge setforce/spin 0.0 0.0 0.0\nfix 2 edge setforce NULL 0.0 v_oscillate",
    "restrictions": "The fix setforce/spin only makes sense when LAMMPS was built with the\nSPIN package."
},
{
    "command": "fix shake",
    "html_filename": "fix_shake.html",
    "short_description": "Apply bond and angle constraints to specified bonds and angles in the simulation by either the SHAKE or RATTLE algorithms",
    "description": "Apply bond and angle constraints to specified bonds and angles in the\nsimulation by either the SHAKE or RATTLE algorithms.  This typically\nenables a longer timestep.\nSHAKE vs RATTLE:\nThe SHAKE algorithm was invented for schemes such as standard Verlet\ntimestepping, where only the coordinates are integrated and the\nvelocities are approximated as finite differences to the trajectories\n(Ryckaert et al. (1977)).  If the velocities are\nintegrated explicitly, as with velocity Verlet which is what LAMMPS\nuses as an integration method, a second set of constraining forces is\nrequired in order to eliminate velocity components along the bonds\n(Andersen (1983)).\nIn order to formulate individual constraints for SHAKE and RATTLE,\nfocus on a single molecule whose bonds are constrained.  Let Ri and Vi\nbe the position and velocity of atom i at time n, for\ni =1,…,N, where N is the number of sites of our reference\nmolecule. The distance vector between sites i and j is given by\n\n\\[\\mathbf r^{n+1}_{ij} = \\mathbf r^n_j - \\mathbf r^n_i\\]\nThe constraints can then be formulated as\n\n\\[\\begin{split}\\mathbf r^{n+1}_{ij} \\cdot \\mathbf r^{n+1}_{ij} &= d^2_{ij} \\quad \\text{and} \\\\\n\\mathbf v^{n+1}_{ij} \\cdot \\mathbf r^{n+1}_{ij} &= 0\\end{split}\\]\nThe SHAKE algorithm satisfies the first condition, i.e. the sites at\ntime n+1 will have the desired separations Dij immediately after the\ncoordinates are integrated.  If we also enforce the second condition,\nthe velocity components along the bonds will vanish.  RATTLE satisfies\nboth conditions.  As implemented in LAMMPS, fix rattle uses fix shake\nfor satisfying the coordinate constraints. Therefore the settings and\noptional keywords are the same for both fixes, and all the information\nbelow about SHAKE is also relevant for RATTLE.\nSHAKE:\nEach timestep the specified bonds and angles are reset to their\nequilibrium lengths and angular values via the SHAKE algorithm\n(Ryckaert et al. (1977)).  This is done by applying an\nadditional constraint force so that the new positions preserve the\ndesired atom separations.  The equations for the additional force are\nsolved via an iterative method that typically converges to an accurate\nsolution in a few iterations.  The desired tolerance (e.g. 1.0e-4 = 1\npart in 10000) and maximum # of iterations are specified as arguments.\nSetting the N argument will print statistics to the screen and log\nfile about regarding the lengths of bonds and angles that are being\nconstrained.  Small delta values mean SHAKE is doing a good job.\nIn LAMMPS, only small clusters of atoms can be constrained.  This is\nso the constraint calculation for a cluster can be performed by a\nsingle processor, to enable good parallel performance.  A cluster is\ndefined as a central atom connected to others in the cluster by\nconstrained bonds.  LAMMPS allows for the following kinds of clusters\nto be constrained: one central atom bonded to 1 or 2 or 3 atoms, or\none central atom bonded to 2 others and the angle between the 3 atoms\nalso constrained.  This means water molecules or CH2 or CH3 groups may\nbe constrained, but not all the C-C backbone bonds of a long polymer\nchain.\nThe b constraint lists bond types that will be constrained.  The t\nconstraint lists atom types.  All bonds connected to an atom of the\nspecified type will be constrained.  The m constraint lists atom\nmasses.  All bonds connected to atoms of the specified masses will be\nconstrained (within a fudge factor of MASSDELTA specified in\nfix_shake.cpp).  The a constraint lists angle types.  If both bonds\nin the angle are constrained then the angle will also be constrained\nif its type is in the list.\nFor all constraints, a particular bond is only constrained if both\natoms in the bond are in the group specified with the SHAKE fix.\nThe degrees-of-freedom removed by SHAKE bonds and angles are accounted\nfor in temperature and pressure computations.  Similarly, the SHAKE\ncontribution to the pressure of the system (virial) is also accounted\nfor.\n\nNote\nThis command works by using the current forces on atoms to\ncalculate an additional constraint force which when added will leave\nthe atoms in positions that satisfy the SHAKE constraints (e.g. bond\nlength) after the next time integration step.  If you define fixes\n(e.g. fix efield) that add additional force to the\natoms after fix shake operates, then this fix will not take them into\naccount and the time integration will typically not satisfy the SHAKE\nconstraints.  The solution for this is to make sure that fix shake is\ndefined in your input script after any other fixes which add or change\nforces (to atoms that fix shake operates on).\n\n\nThe mol keyword should be used when other commands, such as fix deposit or fix pour, add molecules\non-the-fly during a simulation, and you wish to constrain the new\nmolecules via SHAKE.  You specify a template-ID previously defined\nusing the molecule command, which reads a file that\ndefines the molecule.  You must use the same template-ID that the\ncommand adding molecules uses.  The coordinates, atom types, special\nbond restrictions, and SHAKE info can be specified in the molecule\nfile.  See the molecule command for details.  The only\nsettings required to be in this file (by this command) are the SHAKE\ninfo of atoms in the molecule.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRATTLE:\nThe velocity constraints lead to a linear system of equations which\ncan be solved analytically.  The implementation of the algorithm in\nLAMMPS closely follows (Andersen (1983)).\n\nNote\nThe fix rattle command modifies forces and velocities and thus\nshould be defined after all other integration fixes in your input\nscript.  If you define other fixes that modify velocities or forces\nafter fix rattle operates, then fix rattle will not take them into\naccount and the overall time integration will typically not satisfy\nthe RATTLE constraints.  You can check whether the constraints work\ncorrectly by setting the value of RATTLE_DEBUG in src/fix_rattle.cpp\nto 1 and recompiling LAMMPS.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThe fix_modify virial option is supported by this\nfix to add the contribution due to keeping the constraints to the\nsystem’s virial as part of thermodynamic output.\nThe default is virial yes\nNo information about these fixes is written to binary restart files.  None of the fix_modify options\nare relevant to these fixes.  No global or per-atom quantities are\nstored by these fixes for access by various output commands.  No parameter of these fixes can be used\nwith the start/stop keywords of the run command.  These\nfixes are not invoked during energy minimization.",
    "syntax": "fix ID group-ID style tol iter N constraint values ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = shake or rattle = style name of this fix command\n * tol = accuracy tolerance of SHAKE solution\n * iter = max # of iterations in each SHAKE solution\n * N = print SHAKE statistics every this many timesteps (0 = never)\n * one or more constraint/value pairs are appended\n * constraint = b or a or t or m\n * b values = one or more bond types\n * a values = one or more angle types\n * t values = one or more atom types\n * m value = one or more mass values\n * zero or more keyword/value pairs may be appended\n * keyword = mol\n * mol value = template-ID\n *   template-ID = ID of molecule template specified in a separate molecule command",
    "examples": "fix 1 sub shake 0.0001 20 10 b 4 19 a 3 5 2\nfix 1 sub shake 0.0001 20 10 t 5 6 m 1.0 a 31\nfix 1 sub shake 0.0001 20 10 t 5 6 m 1.0 a 31 mol myMol\nfix 1 sub rattle 0.0001 20 10 t 5 6 m 1.0 a 31\nfix 1 sub rattle 0.0001 20 10 t 5 6 m 1.0 a 31 mol myMol",
    "restrictions": "These fixes are part of the RIGID package.  They are only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nFor computational efficiency, there can only be one shake or rattle\nfix defined in a simulation.\nIf you use a tolerance that is too large or a max-iteration count that\nis too small, the constraints will not be enforced very strongly,\nwhich can lead to poor energy conservation.  You can test for this in\nyour system by running a constant NVE simulation with a particular set\nof SHAKE parameters and monitoring the energy versus time.\nSHAKE or RATTLE should not be used to constrain an angle at 180\ndegrees (e.g. linear CO2 molecule).  This causes numeric difficulties.\nYou can use fix rigid or fix rigid/small instead to\nmake a linear molecule rigid.\nRelated commands: none\nDefault: none\n\n(Ryckaert) J.-P. Ryckaert, G. Ciccotti and H. J. C. Berendsen,\nJ of Comp Phys, 23, 327-341 (1977).\n(Andersen) H. Andersen, J of Comp Phys, 52, 24-34 (1983)."
},
{
    "command": "fix shardlow",
    "html_filename": "fix_shardlow.html",
    "short_description": "Specifies that the Shardlow splitting algorithm (SSA) is to be used to integrate the DPD equations of motion",
    "description": "Specifies that the Shardlow splitting algorithm (SSA) is to be used to\nintegrate the DPD equations of motion.  The SSA splits the integration\ninto a stochastic and deterministic integration step.  The fix\nshardlow performs the stochastic integration step and must be used\nin conjunction with a deterministic integrator (e.g. fix nve or fix nph).  The stochastic\nintegration of the dissipative and random forces is performed prior to\nthe deterministic integration of the conservative force. Further\ndetails regarding the method are provided in (Lisal) and\n(Larentzos1).\nThe fix shardlow must be used with the pair_style dpd/fdt or pair_style dpd/fdt/energy command to properly initialize the\nfluctuation-dissipation theorem parameter(s) sigma (and kappa, if\nnecessary).\nNote that numerous variants of DPD can be specified by choosing an\nappropriate combination of the integrator and pair_style dpd/fdt command.  DPD under isothermal conditions can\nbe specified by using fix shardlow, fix nve and pair_style\ndpd/fdt.  DPD under isoenergetic conditions can be specified by\nusing fix shardlow, fix nve and pair_style dpd/fdt/energy.  DPD\nunder isobaric conditions can be specified by using fix shardlow, fix\nnph and pair_style dpd/fdt.  DPD under isoenthalpic conditions can\nbe specified by using fix shardlow, fix nph and pair_style\ndpd/fdt/energy.  Examples of each DPD variant are provided in the\nexamples/USER/dpd directory.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID shardlow",
    "parameters": " * ID, group-ID are documented in fix command\n * shardlow = style name of this fix command",
    "examples": "fix 1 all shardlow",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix is currently limited to orthogonal simulation cell\ngeometries.\nThis fix must be used with an additional fix that specifies time\nintegration, e.g. fix nve or fix nph.\nThe Shardlow splitting algorithm requires the sizes of the sub-domain\nlengths to be larger than twice the cutoff+skin.  Generally, the\ndomain decomposition is dependent on the number of processors\nrequested."
},
{
    "command": "fix smd",
    "html_filename": "fix_smd.html",
    "short_description": "This fix implements several options of steered MD (SMD) as reviewed in (Izrailev), which allows to induce conformational changes in systems and to compute the potential of mean force (PMF) along the assumed reaction coordinate (Park) based on Jarzynski’s equality (Jarzynski)",
    "description": "This fix implements several options of steered MD (SMD) as reviewed in\n(Izrailev), which allows to induce conformational changes\nin systems and to compute the potential of mean force (PMF) along the\nassumed reaction coordinate (Park) based on Jarzynski’s\nequality (Jarzynski).  This fix borrows a lot from fix spring and fix setforce.\nYou can apply a moving spring force to a group of atoms (tether\nstyle) or between two groups of atoms (couple style).  The spring\ncan then be used in either constant velocity (cvel) mode or in\nconstant force (cfor) mode to induce transitions in your systems.\nWhen running in tether style, you may need some way to fix some\nother part of the system (e.g. via fix spring/self)\nThe tether style attaches a spring between a point at a distance of\nR0 away from a fixed point x,y,z and the center of mass of the fix\ngroup of atoms.  A restoring force of magnitude K (R - R0) Mi / M is\napplied to each atom in the group where K is the spring constant, Mi\nis the mass of the atom, and M is the total mass of all atoms in the\ngroup.  Note that K thus represents the total force on the group of\natoms, not a per-atom force.\nIn cvel mode the distance R is incremented or decremented\nmonotonously according to the pulling (or pushing) velocity.\nIn cfor mode a constant force is added and the actual distance\nin direction of the spring is recorded.\nThe couple style links two groups of atoms together.  The first\ngroup is the fix group; the second is specified by group-ID2.  The\ngroups are coupled together by a spring that is at equilibrium when\nthe two groups are displaced by a vector in direction x,y,z with\nrespect to each other and at a distance R0 from that displacement.\nNote that x,y,z only provides a direction and will be internally\nnormalized. But since it represents the absolute displacement of\ngroup-ID2 relative to the fix group, (1,1,0) is a different spring\nthan (-1,-1,0).  For each vector component, the displacement can be\ndescribed with the auto parameter. In this case the direction is\nre-computed in every step, which can be useful for steering a local\nprocess where the whole object undergoes some other change.  When the\nrelative positions and distance between the two groups are not in\nequilibrium, the same spring force described above is applied to atoms\nin each of the two groups.\nFor both the tether and couple styles, any of the x,y,z values can\nbe specified as NULL which means do not include that dimension in the\ndistance calculation or force application.\nFor constant velocity pulling (cvel mode), the running integral\nover the pulling force in direction of the spring is recorded and\ncan then later be used to compute the potential of mean force (PMF)\nby averaging over multiple independent trajectories along the same\npulling path.\nRestart, fix_modify, output, run start/stop, minimize info:\nThe fix stores the direction of the spring, current pulling target\ndistance and the running PMF to binary restart files.\nSee the read_restart command for info on how to\nre-specify a fix in an input script that reads a restart file, so that\nthe operation of the fix continues in an uninterrupted fashion.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the added forces on atoms to the\nsystem’s virial as part of thermodynamic output.\nThe default is virial no\nThe fix_modify respa option is supported by\nthis fix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a vector list of 7 quantities, which can be accessed\nby various output commands.  The quantities in the\nvector are in this order: the x-, y-, and z-component of the pulling\nforce, the total force in direction of the pull, the equilibrium\ndistance of the spring, the distance between the two reference points,\nand finally the accumulated PMF (the sum of pulling forces times\ndisplacement).\nThe force is the total force on the group of atoms by the spring.  In\nthe case of the couple style, it is the force on the fix group\n(group-ID) or the negative of the force on the 2nd group (group-ID2).\nThe vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID smd type values keyword values",
    "parameters": " * ID, group-ID are documented in fix command\n * smd  = style name of this fix command\n * mode = cvel or cfor to select constant velocity or constant force SMD\n * cvel values = K vel\n *   K = spring constant (force/distance units)\n *   vel = velocity of pulling (distance/time units)\n * cfor values = force\n *   force = pulling force (force units)\n * keyword = tether or couple\n * tether values = x y z R0\n *   x,y,z = point to which spring is tethered\n *   R0 = distance of end of spring from tether point (distance units)\n * couple values = group-ID2 x y z R0\n *   group-ID2 = 2nd group to couple to fix group with a spring\n *   x,y,z = direction of spring, automatically computed with 'auto'\n *   R0 = distance of end of spring (distance units)",
    "examples": "fix  pull    cterm smd cvel 20.0 -0.00005 tether NULL NULL 100.0 0.0\nfix  pull    cterm smd cvel 20.0 -0.0001 tether 25.0 25 25.0 0.0\nfix  stretch cterm smd cvel 20.0  0.0001 couple nterm auto auto auto 0.0\nfix  pull    cterm smd cfor  5.0 tether 25.0 25.0 25.0 0.0",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix smd/adjust_dt",
    "html_filename": "fix_smd_adjust_dt.html",
    "short_description": "The fix calculates a new stable time increment for use with the SMD time integrators",
    "description": "The fix calculates a new stable time increment for use with the SMD\ntime integrators.\nThe stable time increment is based on multiple conditions. For the SPH\npair styles, a CFL criterion (Courant, Friedrichs & Lewy, 1928) is\nevaluated, which determines the speed of sound cannot propagate\nfurther than a typical spacing between particles within a single time\nstep to ensure no information is lost. For the contact pair styles, a\nlinear analysis of the pair potential determines a stable maximum time\nstep.\nThis fix inquires the minimum stable time increment across all\nparticles contained in the group for which this fix is defined. An\nadditional safety factor s_fact is applied to the time increment.\nSee this PDF guide to use Smooth Mach\nDynamics in LAMMPS.\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor minimization.",
    "syntax": "fix ID group-ID smd/adjust_dt arg",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/adjust_dt = style name of this fix command\n * arg = s_fact\n * s_fact = safety factor",
    "examples": "fix 1 all smd/adjust_dt 0.1",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix smd/integrate_tlsph",
    "html_filename": "fix_smd_integrate_tlsph.html",
    "short_description": "The fix performs explicit time integration for particles which interact according with the Total-Lagrangian SPH pair style",
    "description": "The fix performs explicit time integration for particles which\ninteract according with the Total-Lagrangian SPH pair style.\nSee this PDF guide to using Smooth Mach\nDynamics in LAMMPS.\nThe limit_velocity keyword will control the velocity, scaling the\nnorm of the velocity vector to max_vel in case it exceeds this\nvelocity limit.\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor\nminimization. This fix has no outputs.",
    "syntax": "fix ID group-ID smd/integrate_tlsph keyword values",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/integrate_tlsph = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = limit_velocity\n * limit_velocity value = max_vel\n *   max_vel = maximum allowed velocity",
    "examples": "fix 1 all smd/integrate_tlsph\nfix 1 all smd/integrate_tlsph limit_velocity 1000",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix smd/integrate_ulsph",
    "html_filename": "fix_smd_integrate_ulsph.html",
    "short_description": "The fix performs explicit time integration for particles which interact with the updated Lagrangian SPH pair style",
    "description": "The fix performs explicit time integration for particles which\ninteract with the updated Lagrangian SPH pair style.\nSee this PDF guide to using Smooth Mach\nDynamics in LAMMPS.\nThe adjust_radius keyword activates dynamic adjustment of the\nper-particle SPH smoothing kernel radius such that the number of\nneighbors per particles remains within the interval min_nn to\nmax_nn. The parameter adjust_radius_factor determines the amount\nof adjustment per timestep. Typical values are adjust_radius_factor\n=1.02, min_nn =15, and max_nn =20.\nThe limit_velocity keyword will control the velocity, scaling the norm of\nthe velocity vector to max_vel in case it exceeds this velocity limit.\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor\nminimization. This fix has no outputs.",
    "syntax": "fix ID group-ID smd/integrate_ulsph keyword",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/integrate_ulsph = style name of this fix command\n * zero or more keyword/value pairs may be appended\n * keyword = adjust_radius or limit_velocity\n * adjust_radius values = adjust_radius_factor min_nn max_nnadjust_radius_factor = factor which scale the smooth/kernel radius\n * min_nn = minimum number of neighbors\n * max_nn = maximum number of neighbors\n * limit_velocity values = max_velocitymax_velocity = maximum allowed velocity.",
    "examples": "fix 1 all smd/integrate_ulsph adjust_radius 1.02 25 50\nfix 1 all smd/integrate_ulsph limit_velocity 1000",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nRelated commands: none\nDefault: none"
},
{
    "command": "fix smd/move_tri_surf",
    "html_filename": "fix_smd_move_triangulated_surface.html",
    "short_description": "This fix applies only to rigid surfaces read from ",
    "description": "This fix applies only to rigid surfaces read from .STL files via fix\nsmd/wall_surface .  It updates position\nand velocity for the particles in the group each timestep without\nregard to forces on the particles.  The rigid surfaces can thus be\nmoved along simple trajectories during the simulation.\nThe *LINEAR style moves particles with the specified constant velocity\nvector V = (Vx,Vy,Vz). This style also sets the velocity of each particle\nto V = (Vx,Vy,Vz).\nThe *WIGGLE style moves particles in an oscillatory fashion.\nParticles are moved along (vx, vy, vz) with constant velocity until a\ndisplacement of max_travel is reached. Then, the velocity vector is\nreversed. This process is repeated.\nThe *ROTATE style rotates particles around a rotation axis R =\n(Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz). The period of the\nrotation is also specified. This style also sets the velocity of each\nparticle to (omega cross Rperp) where omega is its angular velocity\naround the rotation axis and Rperp is a perpendicular vector from the\nrotation axis to the particle.\nSee this PDF guide to using Smooth Mach\nDynamics in LAMMPS.\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor\nminimization. This fix has no outputs.",
    "syntax": "fix ID group-ID smd/move_tri_surf keyword",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/move_tri_surf keyword = style name of this fix command\n * keyword = *LINEAR or *WIGGLE or *ROTATE\n * *LINEAR args = Vx Vy Vz\n *    Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n * *WIGGLE args = Vx Vy Vz max_travel\n *    vx,vy,vz = components of velocity vector (velocity units), any component can be specified as NULL\n *    max_travel = wiggle amplitude\n * *ROTATE args = Px Py Pz Rx Ry Rz period\n *    Px,Py,Pz = origin point of axis of rotation (distance units)\n *    Rx,Ry,Rz = axis of rotation vector\n *    period = period of rotation (time units)",
    "examples": "fix 1 tool smd/move_tri_surf *LINEAR 20 20 10\nfix 2 tool smd/move_tri_surf *WIGGLE 20 20 10\nfix 2 tool smd/move_tri_surf *ROTATE 0 0 0 5 2 1",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix smd/setvel",
    "html_filename": "fix_smd_setvel.html",
    "short_description": "Set each component of velocity on each particle in the group to the specified values vx,vy,vz, regardless of the forces acting on the particle",
    "description": "Set each component of velocity on each particle in the group to the specified\nvalues vx,vy,vz, regardless of the forces acting on the particle.  This command can\nbe used to impose velocity boundary conditions.\nAny of the vx,vy,vz values can be specified as NULL which means do not\nalter the velocity component in that dimension.\nThis fix is indented to be used together with a time integration fix.\nAny of the 3 quantities defining the velocity components can be specified\nas an equal-style or atom-style variable, namely vx,\nvy, vz.  If the value is a variable, it should be specified as\nv_name, where name is the variable name.  In this case, the variable\nwill be evaluated each timestep, and its value used to determine the\nforce component.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent velocity field.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent velocity\nfield with optional time-dependence as well.\nIf the region keyword is used, the particle must also be in the\nspecified geometric region in order to have its velocity set by this command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor minimization\nNone of the fix_modify options\nare relevant to this fix.\nThis fix computes a global 3-vector of forces, which can be accessed\nby various output commands.  This is the total\nforce on the group of atoms.  The vector values calculated by this fix\nare “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.",
    "syntax": "fix ID group-ID smd/setvel vx vy vz keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/setvel = style name of this fix command\n * vx,vy,vz = velocity component values\n * any of vx,vy,vz can be a variable (see below)\n * zero or more keyword/value pairs may be appended to args\n * keyword = region\n * region value = region-ID\n *   region-ID = ID of region particles must be in to have their velocities set",
    "examples": "fix top_velocity top_group setvel 1.0 0.0 0.0",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nRelated commands: none\nDefault: none"
},
{
    "command": "fix smd/wall_surface",
    "html_filename": "fix_smd_wall_surface.html",
    "short_description": "This fix creates reads a triangulated surface from a file in ",
    "description": "This fix creates reads a triangulated surface from a file in .STL\nformat.  For each triangle, a new particle is created which stores the\nbarycenter of the triangle and the vertex positions.  The radius of\nthe new particle is that of the minimum circle which encompasses the\ntriangle vertices.\nThe triangulated surface can be used as a complex rigid wall via the\nsmd/tri_surface pair style.  It\nis possible to move the triangulated surface via the\nsmd/move_tri_surf fix style.\nImmediately after a .STL file has been read, the simulation needs to\nbe run for 0 timesteps in order to properly register the new particles\nin the system. See the “funnel_flow” example in the USER-SMD examples\ndirectory.\nSee this PDF guide to use Smooth Mach\nDynamics in LAMMPS.\nRestart, fix_modify, output, run start/stop, minimize info:\nCurrently, no part of USER-SMD supports restarting nor\nminimization. This fix has no outputs.",
    "syntax": "fix ID group-ID smd/wall_surface arg type mol-ID",
    "parameters": " * ID, group-ID are documented in fix command\n * smd/wall_surface = style name of this fix command\n * arg = file\n * file = file name of a triangular mesh in stl format\n * type = particle type to be given to the new particles created by this fix\n * mol-ID = molecule-ID to be given to the new particles created by this fix (must be >= 65535)",
    "examples": "fix stl_surf all smd/wall_surface tool.stl 2 65535",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThe molecule ID given to the particles created by this fix have to be\nequal to or larger than 65535.\nWithin each .STL file, only a single triangulated object must be\npresent, even though the STL format allows for the possibility of\nmultiple objects in one file."
},
{
    "command": "fix spring/chunk",
    "html_filename": "fix_spring_chunk.html",
    "short_description": "Apply a spring force to the center-of-mass (COM) of chunks of atoms as defined by the compute chunk/atom command",
    "description": "Apply a spring force to the center-of-mass (COM) of chunks of atoms as\ndefined by the compute chunk/atom command.\nChunks can be molecules or spatial bins or other groupings of atoms.\nThis is a way of tethering each chunk to its initial COM coordinates.\nThe chunkID is the ID of a compute chunk/atom command defined in the\ninput script.  It is used to define the chunks.  The comID is the ID\nof a compute com/chunk command defined in the input script.  It is\nused to compute the COMs of each chunk.\nAt the beginning of the first run or\nminimize command after this fix is defined, the\ninitial COM of each chunk is calculated and stored as R0m, where M is\nthe chunk number.  Thereafter, at every timestep (or minimization\niteration), the current COM of each chunk is calculated as Rm.  A\nrestoring force of magnitude K (Rm - R0m) Mi / Mm is applied to each\natom in each chunk where K is the specified spring constant, Mi is\nthe mass of the atom, and Mm is the total mass of all atoms in the\nchunk.  Note that K thus represents the spring constant for the\ntotal force on each chunk of atoms, not for a spring applied to each\natom.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy stored in all the springs to the system’s potential\nenergy as part of thermodynamic output.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the energy of all\nthe springs, i.e. 0.5 * K * r^2 per-spring.\nThe scalar value calculated by this fix is “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the spring energies to be included in the total\npotential energy of the system (the quantity being minimized), you\nMUST enable the fix_modify energy option for this\nfix.",
    "syntax": "fix ID group-ID spring/chunk K chunkID comID",
    "parameters": " * ID, group-ID are documented in fix command\n * spring/chunk = style name of this fix command\n * K = spring constant for each chunk (force/distance units)\n * chunkID = ID of compute chunk/atom command\n * comID = ID of compute com/chunk command",
    "examples": "fix restrain all spring/chunk 100 chunkID comID",
    "restrictions": "\nnone"
},
{
    "command": "fix spring/rg",
    "html_filename": "fix_spring_rg.html",
    "short_description": "Apply a harmonic restraining force to atoms in the group to affect their central moment about the center of mass (radius of gyration)",
    "description": "Apply a harmonic restraining force to atoms in the group to affect\ntheir central moment about the center of mass (radius of gyration).\nThis fix is useful to encourage a protein or polymer to fold/unfold\nand also when sampling along the radius of gyration as a reaction\ncoordinate (i.e. for protein folding).\nThe radius of gyration is defined as RG in the first formula.  The\nenergy of the constraint and associated force on each atom is given by\nthe second and third formulas, when the group is at a different RG\nthan the target value RG0.\n\n\\[\\begin{split}{R_G}^2 & = \\frac{1}{M}\\sum_{i}^{N}{m_{i}\\left( x_{i} -\n\\frac{1}{M}\\sum_{j}^{N}{m_{j}x_{j}} \\right)^{2}} \\\\\nE & = K\\left( R_G - R_{G0} \\right)^{2} \\\\\nF_{i} & = 2K\\frac{m_{i}}{M}\\left( 1-\\frac{R_{G0}}{R_G}\n\\right)\\left( x_{i} - \\frac{1}{M}\\sum_{j}^{N}{m_{j}x_{j}} \\right)\\end{split}\\]\nThe (\\(x_i\\) - center-of-mass) term is computed taking into account\nperiodic boundary conditions, \\(m_i\\) is the mass of the atom, and\nM is the mass of the entire group.  Note that K is thus a force constant\nfor the aggregate force on the group of atoms, not a per-atom force.\nIf \\(R_{G0}\\) is specified as NULL, then the RG of the group is computed at\nthe time the fix is specified, and that value is used as the target.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.",
    "syntax": "fix ID group-ID spring/rg K RG0",
    "parameters": " * ID, group-ID are documented in fix command\n * spring/rg = style name of this fix command\n * K = harmonic force constant (force/distance units)\n * RG0 = target radius of gyration to constrain to (distance units)\n * if RG0 = NULL, use the current RG as the target value",
    "examples": "fix 1 protein spring/rg 5.0 10.0\nfix 2 micelle spring/rg 5.0 NULL",
    "restrictions": "\nnone"
},
{
    "command": "fix spring/self",
    "html_filename": "fix_spring_self.html",
    "short_description": "Apply a spring force independently to each atom in the group to tether it to its initial position",
    "description": "Apply a spring force independently to each atom in the group to tether\nit to its initial position.  The initial position for each atom is its\nlocation at the time the fix command was issued.  At each timestep,\nthe magnitude of the force on each atom is -Kr, where r is the\ndisplacement of the atom from its current position to its initial\nposition.  The distance r correctly takes into account any crossings\nof periodic boundary by the atom since it was in its initial\nposition.\nWith the (optional) dir flag, one can select in which direction the\nspring force is applied. By default, the restraint is applied in all\ndirections, but it can be limited to the xy-, xz-, yz-plane and the\nx-, y-, or z-direction, thus restraining the atoms to a line or a\nplane, respectively.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the original coordinates of tethered atoms to binary restart files, so that the spring effect will be the\nsame in a restarted simulation.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file, so that the\noperation of the fix continues in an uninterrupted fashion.\nThe fix_modify energy option is supported by this\nfix to add the energy stored in the per-atom springs to the system’s\npotential energy as part of thermodynamic output.\nThe fix_modify respa option is supported by\nthis fix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is an energy which is\nthe sum of the spring energy for each atom, where the per-atom energy\nis 0.5 * K * r^2.  The scalar value calculated by this fix is\n“extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the per-atom spring energy to be included in the\ntotal potential energy of the system (the quantity being minimized),\nyou MUST enable the fix_modify energy option for\nthis fix.",
    "syntax": "fix ID group-ID spring/self K dir",
    "parameters": " * ID, group-ID are documented in fix command\n * spring/self = style name of this fix command\n * K = spring constant (force/distance units)\n * dir = xyz, xy, xz, yz, x, y, or z (optional, default: xyz)",
    "examples": "fix tether boundary-atoms spring/self 10.0\nfix zrest  move spring/self 10.0 z",
    "restrictions": "\nnone"
},
{
    "command": "fix srd",
    "html_filename": "fix_srd.html",
    "short_description": "Treat a group of particles as stochastic rotation dynamics (SRD) particles that serve as a background solvent when interacting with big (colloidal) particles in groupbig-ID",
    "description": "Treat a group of particles as stochastic rotation dynamics (SRD)\nparticles that serve as a background solvent when interacting with big\n(colloidal) particles in groupbig-ID.  The SRD formalism is described\nin (Hecht).  The key idea behind using SRD particles as a\ncheap coarse-grained solvent is that SRD particles do not interact\nwith each other, but only with the solute particles, which in LAMMPS\ncan be spheroids, ellipsoids, or line segments, or triangles, or rigid\nbodies containing multiple spheroids or ellipsoids or line segments\nor triangles.  The collision and rotation properties of the model\nimbue the SRD particles with fluid-like properties, including an\neffective viscosity.  Thus simulations with large solute particles can\nbe run more quickly, to measure solute properties like diffusivity\nand viscosity in a background fluid.  The usual LAMMPS fixes for such\nsimulations, such as fix deform, fix viscosity, and fix nvt/sllod,\ncan be used in conjunction with the SRD model.\nFor more details on how the SRD model is implemented in LAMMPS, this paper describes the implementation and usage of pure SRD\nfluids.  This paper, which is nearly complete, describes\nthe implementation and usage of mixture systems (solute particles in\nan SRD fluid).  See the examples/srd directory for sample input\nscripts using SRD particles in both settings.\nThis fix does two things:\n\n\nIt advects the SRD particles, performing collisions between SRD\nand big particles or walls every timestep, imparting force and torque\nto the big particles.  Collisions also change the position and\nvelocity of SRD particles.\nIt resets the velocity distribution of SRD particles via random\nrotations every N timesteps.\n\n\nSRD particles have a mass, temperature, characteristic timestep\n\\(dt_{SRD}\\), and mean free path between collisions\n(\\(\\lambda\\)).  The fundamental equation relating these 4 quantities\nis\n\n\\[\\lambda = dt_{SRD} \\sqrt{\\frac{k_B T_{SRD}}{m}}\\]\nThe mass m of SRD particles is set by the mass command\nelsewhere in the input script.  The SRD timestep \\(dt_{SRD}\\) is N\ntimes the step dt defined by the timestep command.\nBig particles move in the normal way via a time integration fix with a short timestep dt.  SRD particles advect with a large\ntimestep \\(dt_{SRD} \\ge dt\\).\nIf the lamda keyword is not specified, the SRD temperature\n\\(T_{SRD}\\) is used in the above formula to compute \\(\\lambda\\).\nIf the lamda keyword is specified, then the Tsrd setting is ignored\nand the above equation is used to compute the SRD temperature.\nThe characteristic length scale for the SRD fluid is set by hgrid\nwhich is used to bin SRD particles for purposes of resetting their\nvelocities.  Normally hgrid is set to be 1/4 of the big particle\ndiameter or smaller, to adequately resolve fluid properties around the\nbig particles.\n\\(\\lambda\\) cannot be smaller than 0.6 * hgrid, else an error is\ngenerated (unless the shift keyword is used, see below).  The\nvelocities of SRD particles are bounded by Vmax, which is set so that an\nSRD particle will not advect further than \\(D_{max} = 4 \\lambda\\) in\n\\(dt_{SRD}\\).  This means that roughly speaking, \\(D_{max}\\)\nshould not be larger than a big particle diameter, else SRDs may pass\nthrough big particles without colliding.  A warning is generated if this\nis the case.\nCollisions between SRD particles and big particles or walls are\nmodeled as a lightweight SRD point particle hitting a heavy big\nparticle of given diameter or a wall at a point on its surface and\nbouncing off with a new velocity.  The collision changes the momentum\nof the SRD particle.  It imparts a force and torque to the big\nparticle.  It imparts a force to a wall.  Static or moving SRD walls\nare setup via the fix wall/srd command.  For the\nremainder of this doc page, a collision of an SRD particle with a wall\ncan be viewed as a collision with a big particle of infinite radius\nand mass.\nThe collision keyword sets the style of collisions.  The slip\nstyle means that the tangential component of the SRD particle momentum\nis preserved.  Thus a force is imparted to a big particle, but no\ntorque.  The normal component of the new SRD velocity is sampled from\na Gaussian distribution at temperature Tsrd.\nFor the noslip style, both the normal and tangential components of\nthe new SRD velocity are sampled from a Gaussian distribution at\ntemperature Tsrd.  Additionally, a new tangential direction for the\nSRD velocity is chosen randomly.  This collision style imparts torque\nto a big particle.  Thus a time integrator fix that rotates\nthe big particles appropriately should be used.\n\nThe overlap keyword should be set to yes if two (or more) big\nparticles can ever overlap.  This depends on the pair potential\ninteraction used for big-big interactions, or could be the case if\nmultiple big particles are held together as rigid bodies via the\nfix rigid command.  If the overlap keyword is no\nand big particles do in fact overlap, then SRD/big collisions can\ngenerate an error if an SRD ends up inside two (or more) big particles\nat once.  How this error is treated is determined by the inside\nkeyword.  Running with overlap set to no allows for faster collision\nchecking, so it should only be set to yes if needed.\nThe inside keyword determines how a collision is treated if the\ncomputation determines that the timestep started with the SRD particle\nalready inside a big particle.  If the setting is error then this\ngenerates an error message and LAMMPS stops.  If the setting is warn\nthen this generates a warning message and the code continues.  If the\nsetting is ignore then no message is generated.  One of the output\nquantities logged by the fix (see below) tallies the number of such\nevents, so it can be monitored.  Note that once an SRD particle is\ninside a big particle, it may remain there for several steps until it\ndrifts outside the big particle.\nThe exact keyword determines how accurately collisions are computed.\nA setting of yes computes the time and position of each collision as\nSRD and big particles move together.  A setting of no estimates the\nposition of each collision based on the end-of-timestep positions of\nthe SRD and big particle.  If overlap is set to yes, the setting of\nthe exact keyword is ignored since time-accurate collisions are\nneeded.\nThe radius keyword scales the effective size of big particles.  If\nbig particles will overlap as they undergo dynamics, then this keyword\ncan be used to scale down their effective collision radius by an\namount rfactor, so that SRD particle will only collide with one big\nparticle at a time.  For example, in a Lennard-Jones system at a\ntemperature of 1.0 (in reduced LJ units), the minimum separation\nbetween two big particles is as small as about 0.88 sigma.  Thus an\nrfactor value of 0.85 should prevent dual collisions.\nThe bounce keyword can be used to limit the maximum number of\ncollisions an SRD particle undergoes in a single timestep as it\nbounces between nearby big particles.  Note that if the limit is\nreached, the SRD can be left inside a big particle.  A setting of 0 is\nthe same as no limit.\n\nThere are 2 kinds of bins created and maintained when running an SRD\nsimulation.  The first are “SRD bins” which are used to bin SRD\nparticles and reset their velocities, as discussed above.  The second\nare “search bins” which are used to identify SRD/big particle\ncollisions.\nThe search keyword can be used to choose a search bin size for\nidentifying SRD/big particle collisions.  The default is to use the\nhgrid parameter for SRD bins as the search bin size.  Choosing a\nsmaller or large value may be more efficient, depending on the\nproblem.  But, in a statistical sense, it should not change the\nsimulation results.\nThe cubic keyword can be used to generate an error or warning when\nthe bin size chosen by LAMMPS creates SRD bins that are non-cubic or\ndifferent than the requested value of hgrid by a specified\ntolerance.  Note that using non-cubic SRD bins can lead to\nundetermined behavior when rotating the velocities of SRD particles,\nhence LAMMPS tries to protect you from this problem.\nLAMMPS attempts to set the SRD bin size to exactly hgrid.  However,\nthere must be an integer number of bins in each dimension of the\nsimulation box.  Thus the actual bin size will depend on the size and\nshape of the overall simulation box.  The actual bin size is printed\nas part of the SRD output when a simulation begins.\nIf the actual bin size in non-cubic by an amount exceeding the\ntolerance, an error or warning is printed, depending on the style of\nthe cubic keyword.  Likewise, if the actual bin size differs from\nthe requested hgrid value by an amount exceeding the tolerance, then\nan error or warning is printed.  The tolerance is a fractional\ndifference.  E.g. a tolerance setting of 0.01 on the shape means that\nif the ratio of any 2 bin dimensions exceeds (1 +/- tolerance) then an\nerror or warning is generated.  Similarly, if the ratio of any bin\ndimension with hgrid exceeds (1 +/- tolerance), then an error or\nwarning is generated.\n\nNote\nThe fix srd command can be used with simulations the size and/or\nshape of the simulation box changes.  This can be due to non-periodic\nboundary conditions or the use of fixes such as the fix deform or fix wall/srd commands\nto impose a shear on an SRD fluid or an interaction with an external\nwall.  If the box size changes then the size of SRD bins must be\nrecalculated every reneighboring.  This is not necessary if only the\nbox shape changes.  This re-binning is always done so as to fit an\ninteger number of bins in the current box dimension, whether it be a\nfixed, shrink-wrapped, or periodic boundary, as set by the\nboundary command.  If the box size or shape changes,\nthen the size of the search bins must be recalculated every\nreneighboring.  Note that changing the SRD bin size may alter the\nproperties of the SRD fluid, such as its viscosity.\n\nThe shift keyword determines whether the coordinates of SRD particles\nare randomly shifted when binned for purposes of rotating their\nvelocities.  When no shifting is performed, SRD particles are binned and\nthe velocity distribution of the set of SRD particles in each bin is\nadjusted via a rotation operator.  This is a statistically valid\noperation if SRD particles move sufficiently far between successive\nrotations.  This is determined by their mean-free path \\(\\lambda\\).\nIf \\(\\lambda\\) is less than 0.6 of the SRD bin size, then shifting\nis required.  A shift means that all of the SRD particles are shifted by\na vector whose coordinates are chosen randomly in the range [-1/2 bin\nsize, 1/2 bin size].  Note that all particles are shifted by the same\nvector.  The specified random number shiftseed is used to generate\nthese vectors.  This operation sufficiently randomizes which SRD\nparticles are in the same bin, even if \\(lambda\\) is small.\nIf the shift flag is set to no, then no shifting is performed, but\nbin data will be communicated if bins overlap processor boundaries.  An\nerror will be generated if \\(\\lambda < 0.6\\) of the SRD bin size.\nIf the shift flag is set to possible, then shifting is performed\nonly if \\(\\lambda < 0.6\\) of the SRD bin size.  A warning is\ngenerated to let you know this is occurring.  If the shift flag is set\nto yes then shifting is performed regardless of the magnitude of\n\\(\\lambda\\).  Note that the shiftseed is not used if the shift\nflag is set to no, but must still be specified.\nNote that shifting of SRD coordinates requires extra communication,\nhence it should not normally be enabled unless required.\nThe tstat keyword will thermostat the SRD particles to the specified\nTsrd.  This is done every N timesteps, during the velocity rotation\noperation, by rescaling the thermal velocity of particles in each SRD\nbin to the desired temperature.  If there is a streaming velocity\nassociated with the system, e.g. due to use of the fix deform command to perform a simulation undergoing\nshear, then that is also accounted for.  The mean velocity of each bin\nof SRD particles is set to the position-dependent streaming velocity,\nbased on the coordinates of the center of the SRD bin.  Note that\ncollisions of SRD particles with big particles or walls has a\nthermostatting effect on the colliding particles, so it may not be\nnecessary to thermostat the SRD particles on a bin by bin basis in\nthat case.  Also note that for streaming simulations, if no\nthermostatting is performed (the default), then it may take a long\ntime for the SRD fluid to come to equilibrium with a velocity profile\nthat matches the simulation box deformation.\nThe rescale keyword enables rescaling of an SRD particle’s velocity\nif it would travel more than 4 mean-free paths in an SRD timestep.  If\nan SRD particle exceeds this velocity it is possible it will be lost\nwhen migrating to other processors or that collisions with big\nparticles will be missed, either of which will generate errors.  Thus\nthe safest mode is to run with rescaling enabled.  However rescaling\nremoves kinetic energy from the system (the particle’s velocity is\nreduced).  The latter will not typically be a problem if\nthermostatting is enabled via the tstat keyword or if SRD collisions\nwith big particles or walls effectively thermostat the system.  If you\nwish to turn off rescaling (on is the default), e.g. for a pure SRD\nsystem with no thermostatting so that the temperature does not decline\nover time, the rescale keyword can be used.  The no value turns\nrescaling off during collisions and the per-bin velocity rotation\noperation.  The collide and rotate values turn it on for\none of the operations and off for the other.\n\n\nNote\nThis fix is normally used for simulations with a huge number of\nSRD particles relative to the number of big particles, e.g. 100 to 1.\nIn this scenario, computations that involve only big particles\n(neighbor list creation, communication, time integration) can slow\ndown dramatically due to the large number of background SRD particles.\n\nThree other input script commands will largely overcome this effect,\nspeeding up an SRD simulation by a significant amount.  These are the\natom_modify first, neigh_modify include, and comm_modify group\ncommands.  Each takes a group-ID as an argument, which in this case\nshould be the group-ID of the big solute particles.\nAdditionally, when a pair_style for big/big particle\ninteractions is specified, the pair_coeff command\nshould be used to turn off big/SRD interactions, e.g. by setting their\nepsilon or cutoff length to 0.0.\nThe “delete_atoms overlap” command may be useful in setting up an SRD\nsimulation to insure there are no initial overlaps between big and SRD\nparticles.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix tabulates several SRD statistics which are stored in a vector\nof length 12, which can be accessed by various output commands.  The vector values calculated by this fix\nare “intensive”, meaning they do not scale with the size of the\nsimulation.  Technically, the first 8 do scale with the size of the\nsimulation, but treating them as intensive means they are not scaled\nwhen printed as part of thermodynamic output.\nThese are the 12 quantities.  All are values for the current timestep,\nexcept for quantity 5 and the last three, each of which are\ncumulative quantities since the beginning of the run.\n\n\n# of SRD/big collision checks performed\n\n\n\n# of SRDs which had a collision\n\n\n\n# of SRD/big collisions (including multiple bounces)\n\n\n\n# of SRD particles inside a big particle\n\n\n\n# of SRD particles whose velocity was rescaled to be < Vmax\n\n\n\n# of bins for collision searching\n\n\n\n# of bins for SRD velocity rotation\n\n\n\n# of bins in which SRD temperature was computed\n\n\n\nSRD temperature\n\n\n\n# of SRD particles which have undergone max # of bounces\n\n\n\nmax # of bounces any SRD particle has had in a single step\n\n\n\n# of reneighborings due to SRD particles moving too far\n\n\n\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID srd N groupbig-ID Tsrd hgrid seed keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * srd = style name of this fix command\n * N = reset SRD particle velocities every this many timesteps\n * groupbig-ID = ID of group of large particles that SRDs interact with\n * Tsrd = temperature of SRD particles (temperature units)\n * hgrid = grid spacing for SRD grouping (distance units)\n * seed = random # seed (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = lamda or collision or overlap or inside or exact or radius or bounce or search or cubic or shift or tstat or rescale\n * lamda value = mean free path of SRD particles (distance units)\n * collision value = noslip or slip = collision model\n * overlap value = yes or no = whether big particles may overlap\n * inside value = error or warn or ignore = how SRD particles which end up inside a big particle are treated\n * exact value = yes or no\n * radius value = rfactor = scale collision radius by this factor\n * bounce value = Nbounce = max # of collisions an SRD particle can undergo in one timestep\n * search value = sgrid = grid spacing for collision partner searching (distance units)\n * cubic values = style tolerance\n *   style = error or warn\n *   tolerance = fractional difference allowed (0 <= tol <= 1)\n * shift values = flag shiftseed\n *   flag = yes or no or possible = SRD bin shifting for better statistics\n *     yes = perform bin shifting each time SRD velocities are rescaled\n *     no = no shifting\n *     possible = shift depending on mean free path and bin size\n *   shiftseed = random # seed (positive integer)\n * tstat value = yes or no = thermostat SRD particles or not\n * rescale value = yes or no or rotate or collide = rescaling of SRD velocities\n *   yes = rescale during velocity rotation and collisions\n *   no = no rescaling\n *   rotate = rescale during velocity rotation, but not collisions\n *   collide = rescale during collisions, but not velocity rotation",
    "examples": "fix 1 srd srd 10 big 1.0 0.25 482984\nfix 1 srd srd 10 big 0.5 0.25 482984 collision slip search 0.5",
    "restrictions": "This command can only be used if LAMMPS was built with the SRD\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "fix store/force",
    "html_filename": "fix_store_force.html",
    "short_description": "Store the forces on atoms in the group at the point during each timestep when the fix is invoked, as described below",
    "description": "Store the forces on atoms in the group at the point during each\ntimestep when the fix is invoked, as described below.  This is useful\nfor storing forces before constraints or other boundary conditions are\ncomputed which modify the forces, so that unmodified forces can be\nwritten to a dump file or accessed by other output commands that use per-atom quantities.\nThis fix is invoked at the point in the velocity-Verlet timestepping\nimmediately after pair, bond,\nangle, dihedral,\nimproper, and long-range\nforces have been calculated.  It is the point in the timestep when\nvarious fixes that compute constraint forces are calculated and\npotentially modify the force on each atom.  Examples of such fixes are\nfix shake, fix wall, and fix indent.\n\nNote\nThe order in which various fixes are applied which operate at\nthe same point during the timestep, is the same as the order they are\nspecified in the input script.  Thus normally, if you want to store\nper-atom forces due to force field interactions, before constraints\nare applied, you should list this fix first within that set of fixes,\ni.e. before other fixes that apply constraints.  However, if you wish\nto include certain constraints (e.g. fix shake) in the stored force,\nthen it could be specified after some fixes and before others.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix produces a per-atom array which can be accessed by various\noutput commands.  The number of columns for each\natom is 3, and the columns store the x,y,z forces on each atom.  The\nper-atom values be accessed on any timestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID store/force",
    "parameters": " * ID, group-ID are documented in fix command\n * store/force = style name of this fix command",
    "examples": "fix 1 all store/force",
    "restrictions": "\nnone"
},
{
    "command": "fix store/state",
    "html_filename": "fix_store_state.html",
    "short_description": "Define a fix that stores attributes for each atom in the group at the time the fix is defined",
    "description": "Define a fix that stores attributes for each atom in the group at the\ntime the fix is defined.  If N is 0, then the values are never\nupdated, so this is a way of archiving an atom attribute at a given\ntime for future use in a calculation or output.  See the discussion of\noutput commands that take fixes as inputs.\nIf N is not zero, then the attributes will be updated every N\nsteps.\n\nNote\nActually, only atom attributes specified by keywords like xu\nor vy or radius are initially stored immediately at the point in\nyour input script when the fix is defined.  Attributes specified by a\ncompute, fix, or variable are not initially stored until the first run\nfollowing the fix definition begins.  This is because calculating\nthose attributes may require quantities that are not defined in\nbetween runs.\n\nThe list of possible attributes is the same as that used by the dump custom command, which describes their meaning.\nIf the com keyword is set to yes then the xu, yu, and zu\ninputs store the position of each atom relative to the center-of-mass\nof the group of atoms, instead of storing the absolute position.\nThe requested values are stored in a per-atom vector or array as\ndiscussed below.  Zeroes are stored for atoms not in the specified\ngroup.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the per-atom values it stores to binary restart files, so that the values can be restored when a\nsimulation is restarted.  See the read_restart\ncommand for info on how to re-specify a fix in an input script that\nreads a restart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nNone of the fix_modify options are relevant to this\nfix.\nIf a single input is specified, this fix produces a per-atom vector.\nIf multiple inputs are specified, a per-atom array is produced where\nthe number of columns for each atom is the number of inputs.  These\ncan be accessed by various output commands.  The\nper-atom values be accessed on any timestep.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID store/state N input1 input2 ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * store/state = style name of this fix command\n * N = store atom attributes every N steps, N = 0 for initial store only\n * input = one or more atom attributes\n * possible attributes = id, mol, type, mass,\n *                       x, y, z, xs, ys, zs, xu, yu, zu, xsu, ysu, zsu, ix, iy, iz,\n *                       vx, vy, vz, fx, fy, fz,\n *                       q, mux, muy, muz, mu,\n *                       radius, diameter, omegax, omegay, omegaz,\n *                       angmomx, angmomy, angmomz, tqx, tqy, tqz,\n *                       c_ID, c_ID[N], f_ID, f_ID[N], v_name,\n *                       d_name, i_name\n * id = atom ID\n * mol = molecule ID\n * type = atom type\n * mass = atom mass\n * x,y,z = unscaled atom coordinates\n * xs,ys,zs = scaled atom coordinates\n * xu,yu,zu = unwrapped atom coordinates\n * xsu,ysu,zsu = scaled unwrapped atom coordinates\n * ix,iy,iz = box image that the atom is in\n * vx,vy,vz = atom velocities\n * fx,fy,fz = forces on atoms\n * q = atom charge\n * mux,muy,muz = orientation of dipolar atom\n * mu = magnitued of dipole moment of atom\n * radius,diameter = radius.diameter of spherical particle\n * omegax,omegay,omegaz = angular velocity of spherical particle\n * angmomx,angmomy,angmomz = angular momentum of aspherical particle\n * tqx,tqy,tqz = torque on finite-size particles\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n * v_name = per-atom vector calculated by an atom-style variable with name\n * d_name = per-atom floating point vector name, managed by fix property/atom\n * i_name = per-atom integer vector name, managed by fix property/atom\n * zero or more keyword/value pairs may be appended\n * keyword = com\n * com value = yes or no",
    "examples": "fix 1 all store/state 0 x y z\nfix 1 all store/state 0 xu yu zu com yes\nfix 2 all store/state 1000 vx vy vz",
    "restrictions": "\nnone"
},
{
    "command": "fix temp/berendsen",
    "html_filename": "fix_temp_berendsen.html",
    "short_description": "Reset the temperature of a group of atoms by using a Berendsen thermostat (Berendsen), which rescales their velocities every timestep",
    "description": "Reset the temperature of a group of atoms by using a Berendsen\nthermostat (Berendsen), which rescales their velocities\nevery timestep.\nThe thermostat is applied to only the translational degrees of freedom\nfor the particles, which is an important consideration for finite-size\nparticles which have rotational degrees of freedom are being\nthermostatted with this fix.  The translational degrees of freedom can\nalso have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nThe desired temperature at each timestep is a ramped value during the\nrun from Tstart to Tstop.  The Tdamp parameter is specified in\ntime units and determines how rapidly the temperature is relaxed.  For\nexample, a value of 100.0 means to relax the temperature in a timespan\nof (roughly) 100 time units (tau or fmsec or psec - see the\nunits command).\nTstart can be specified as an equal-style variable.\nIn this case, the Tstop setting is ignored.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value used to determine the target temperature.\n\nNote\nThis thermostat will generate an error if the current\ntemperature is zero at the end of a timestep.  It cannot rescale a\nzero temperature.\n\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent temperature.\n\nNote\nUnlike the fix nvt command which performs\nNose/Hoover thermostatting AND time integration, this fix does NOT\nperform time integration.  It only modifies velocities to effect\nthermostatting.  Thus you must use a separate time integration fix,\nlike fix nve to actually update the positions of atoms\nusing the modified velocities.  Likewise, this fix should not normally\nbe used on atoms that also have their temperature controlled by\nanother fix - e.g. by fix nvt or fix langevin commands.\n\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp”, as if this command had been\nissued:\ncompute fix-ID_temp group-ID temp\n\n\nSee the compute temp command for details.  Note\nthat the ID of the new compute is the fix-ID + underscore + “temp”,\nand the group for the new compute is the same as the fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthis fix and by the compute should be the same.\nThe fix_modify energy option is supported by this\nfix to add the energy change implied by a velocity rescaling to the\nsystem’s potential energy as part of thermodynamic output.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID temp/berendsen Tstart Tstop Tdamp",
    "parameters": " * ID, group-ID are documented in fix command\n * temp/berendsen = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run\n * Tstart can be a variable (see below)\n * Tdamp = temperature damping parameter (time units)",
    "examples": "fix 1 all temp/berendsen 300.0 300.0 100.0",
    "restrictions": "This fix can be used with dynamic groups as defined by the\ngroup command.  Likewise it can be used with groups to\nwhich atoms are added or deleted over time, e.g. a deposition\nsimulation.  However, the conservation properties of the thermostat\nand barostat are defined for systems with a static set of atoms.  You\nmay observe odd behavior if the atoms in a group vary dramatically\nover time or the atom count becomes very small."
},
{
    "command": "fix temp/csvr",
    "html_filename": "fix_temp_csvr.html",
    "short_description": "Adjust the temperature with a canonical sampling thermostat that uses global velocity rescaling with Hamiltonian dynamics (temp/csvr) (Bussi1), or Langevin dynamics (temp/csld) (Bussi2)",
    "description": "Adjust the temperature with a canonical sampling thermostat that uses\nglobal velocity rescaling with Hamiltonian dynamics (temp/csvr)\n(Bussi1), or Langevin dynamics (temp/csld)\n(Bussi2).  In the case of temp/csvr the thermostat is\nsimilar to the empirical Berendsen thermostat in\ntemp/berendsen, but chooses the actual\nscaling factor from a suitably chosen (gaussian) distribution rather\nthan having it determined from the time constant directly. In the case\nof temp/csld the velocities are updated to a linear combination of\nthe current velocities with a gaussian distribution of velocities at\nthe desired temperature.  Both thermostats are applied every timestep.\nThe thermostat is applied to only the translational degrees of freedom\nfor the particles, which is an important consideration for finite-size\nparticles which have rotational degrees of freedom are being\nthermostatted with these fixes.  The translational degrees of freedom\ncan also have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nThe desired temperature at each timestep is a ramped value during the\nrun from Tstart to Tstop.  The Tdamp parameter is specified in\ntime units and determines how rapidly the temperature is relaxed.  For\nexample, a value of 100.0 means to relax the temperature in a timespan\nof (roughly) 100 time units (tau or fmsec or psec - see the\nunits command).\nTstart can be specified as an equal-style variable.\nIn this case, the Tstop setting is ignored.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value used to determine the target temperature.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent temperature.\n\nNote\nUnlike the fix nvt command which performs\nNose/Hoover thermostatting AND time integration, these fixes do NOT\nperform time integration. They only modify velocities to effect\nthermostatting.  Thus you must use a separate time integration fix,\nlike fix nve to actually update the positions of atoms\nusing the modified velocities.  Likewise, these fixes should not\nnormally be used on atoms that also have their temperature controlled\nby another fix - e.g. by fix nvt or fix langevin commands.\n\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nThese fixes compute a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp”, as if this command had been\nissued:\ncompute fix-ID_temp group-ID temp\n\n\nSee the compute temp command for details.  Note\nthat the ID of the new compute is the fix-ID + underscore + “temp”,\nand the group for the new compute is the same as the fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, these fixes can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about these fixes are written to binary restart files.\nThe fix_modify temp option is supported by these\nfixes.  You can use it to assign a temperature compute\nyou have defined to these fixes which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthese fixes and by the compute should be the same.\nThese fixes can ramp its target temperature over multiple runs, using\nthe start and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThese fixes are not invoked during energy minimization.\nThese fixes compute a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to the fix.  The scalar value calculated by this fix\nis “extensive”.",
    "syntax": "fix ID group-ID temp/csvr Tstart Tstop Tdamp seed",
    "parameters": " * fix ID group-ID temp/csld Tstart Tstop Tdamp seed\n * ID, group-ID are documented in fix command\n * temp/csvr or temp/csld = style name of this fix command\n * Tstart,Tstop = desired temperature at start/end of run\n * Tstart can be a variable (see below)\n * Tdamp = temperature damping parameter (time units)\n * seed = random number seed to use for white noise (positive integer)",
    "examples": "fix 1 all temp/csvr 300.0 300.0 100.0 54324\n\nfix 1 all temp/csld 100.0 300.0 10.0 123321",
    "restrictions": "These fixes are not compatible with fix shake.\nThe fix can be used with dynamic groups as defined by the\ngroup command.  Likewise it can be used with groups to\nwhich atoms are added or deleted over time, e.g. a deposition\nsimulation.  However, the conservation properties of the thermostat\nand barostat are defined for systems with a static set of atoms.  You\nmay observe odd behavior if the atoms in a group vary dramatically\nover time or the atom count becomes very small."
},
{
    "command": "fix temp/rescale",
    "html_filename": "fix_temp_rescale.html",
    "short_description": "Reset the temperature of a group of atoms by explicitly rescaling their velocities",
    "description": "Reset the temperature of a group of atoms by explicitly rescaling\ntheir velocities.\nThe rescaling is applied to only the translational degrees of freedom\nfor the particles, which is an important consideration if finite-size\nparticles which have rotational degrees of freedom are being\nthermostatted with this fix.  The translational degrees of freedom can\nalso have a bias velocity removed from them before thermostatting\ntakes place; see the description below.\nRescaling is performed every N timesteps.  The target temperature is a\nramped value between the Tstart and Tstop temperatures at the\nbeginning and end of the run.\n\nNote\nThis thermostat will generate an error if the current\ntemperature is zero at the end of a timestep it is invoked on.  It\ncannot rescale a zero temperature.\n\nTstart can be specified as an equal-style variable.\nIn this case, the Tstop setting is ignored.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value used to determine the target temperature.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent temperature.\nRescaling is only performed if the difference between the current and\ndesired temperatures is greater than the window value.  The amount\nof rescaling that is applied is a fraction (from 0.0 to 1.0) of the\ndifference between the actual and desired temperature.  E.g. if\nfraction = 1.0, the temperature is reset to exactly the desired\nvalue.\n\nNote\nUnlike the fix nvt command which performs\nNose/Hoover thermostatting AND time integration, this fix does NOT\nperform time integration.  It only modifies velocities to effect\nthermostatting.  Thus you must use a separate time integration fix,\nlike fix nve to actually update the positions of atoms\nusing the modified velocities.  Likewise, this fix should not normally\nbe used on atoms that also have their temperature controlled by\nanother fix - e.g. by fix nvt or fix langevin commands.\n\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nThis fix computes a temperature each timestep.  To do this, the fix\ncreates its own compute of style “temp”, as if one of this command had\nbeen issued:\ncompute fix-ID_temp group-ID temp\n\n\nSee the compute temp for details.  Note that the\nID of the new compute is the fix-ID + underscore + “temp”, and the\ngroup for the new compute is the same as the fix group.\nNote that this is NOT the compute used by thermodynamic output (see\nthe thermo_style command) with ID = thermo_temp.\nThis means you can change the attributes of this fix’s temperature\n(e.g. its degrees-of-freedom) via the\ncompute_modify command or print this temperature\nduring thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\nIt also means that changing attributes of thermo_temp will have no\neffect on this fix.\nLike other fixes that perform thermostatting, this fix can be used\nwith compute commands that calculate a temperature\nafter removing a “bias” from the atom velocities.  E.g. removing the\ncenter-of-mass velocity from a group of atoms or only calculating\ntemperature on the x-component of velocity or only calculating\ntemperature for atoms in a geometric region.  This is not done by\ndefault, but only if the fix_modify command is used\nto assign a temperature compute to this fix that includes such a bias\nterm.  See the doc pages for individual compute commands to determine which ones include a bias.  In\nthis case, the thermostat works in the following manner: the current\ntemperature is calculated taking the bias into account, bias is\nremoved from each atom, thermostatting is performed on the remaining\nthermal degrees of freedom, and the bias is added back in.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthis fix and by the compute should be the same.\nThe fix_modify energy option is supported by this\nfix to add the energy change implied by a velocity rescaling to the\nsystem’s potential energy as part of thermodynamic output.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID temp/rescale N Tstart Tstop window fraction",
    "parameters": " * ID, group-ID are documented in fix command\n * temp/rescale = style name of this fix command\n * N = perform rescaling every N steps\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * Tstart can be a variable (see below)\n * window = only rescale if temperature is outside this window (temperature units)\n * fraction = rescale to target temperature by this fraction",
    "examples": "fix 3 flow temp/rescale 100 1.0 1.1 0.02 0.5\nfix 3 boundary temp/rescale 1 1.0 1.5 0.05 1.0\nfix 3 boundary temp/rescale 1 1.0 1.5 0.05 1.0",
    "restrictions": "\nnone"
},
{
    "command": "fix temp/rescale/eff",
    "html_filename": "fix_temp_rescale_eff.html",
    "short_description": "Reset the temperature of a group of nuclei and electrons in the electron force field model by explicitly rescaling their velocities",
    "description": "Reset the temperature of a group of nuclei and electrons in the\nelectron force field model by explicitly rescaling\ntheir velocities.\nThe operation of this fix is exactly like that described by the fix temp/rescale command, except that the rescaling\nis also applied to the radial electron velocity for electron\nparticles.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify temp option is supported by this\nfix.  You can use it to assign a temperature compute\nyou have defined to this fix which will be used in its thermostatting\nprocedure, as described above.  For consistency, the group used by\nthis fix and by the compute should be the same.\nThe fix_modify energy option is supported by this\nfix to add the energy change implied by a velocity rescaling to the\nsystem’s potential energy as part of thermodynamic output.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nenergy change due to this fix.  The scalar value calculated by this\nfix is “extensive”.\nThis fix can ramp its target temperature over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID temp/rescale/eff N Tstart Tstop window fraction",
    "parameters": " * ID, group-ID are documented in fix command\n * temp/rescale/eff = style name of this fix command\n * N = perform rescaling every N steps\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * window = only rescale if temperature is outside this window (temperature units)\n * fraction = rescale to target temperature by this fraction",
    "examples": "fix 3 flow temp/rescale/eff 10 1.0 100.0 0.02 1.0",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix tfmc",
    "html_filename": "fix_tfmc.html",
    "short_description": "Perform uniform-acceptance force-bias Monte Carlo (fbMC) simulations, using the time-stamped force-bias Monte Carlo (tfMC) algorithm described in (Mees) and (Bal)",
    "description": "Perform uniform-acceptance force-bias Monte Carlo (fbMC) simulations,\nusing the time-stamped force-bias Monte Carlo (tfMC) algorithm\ndescribed in (Mees) and (Bal).\nOne successful use case of force-bias Monte Carlo methods is that they\ncan be used to extend the time scale of atomistic simulations, in\nparticular when long time scale relaxation effects must be considered;\nsome interesting examples are given in the review by (Neyts).\nAn example of a typical use case would be the modelling of chemical\nvapor deposition (CVD) processes on a surface, in which impacts by\ngas-phase species can be performed using MD, but subsequent relaxation\nof the surface is too slow to be done using MD only. Using tfMC can\nallow for a much faster relaxation of the surface, so that higher\nfluxes can be used, effectively extending the time scale of the\nsimulation. (Such an alternating simulation approach could be set up\nusing a loop.)\nThe initial version of tfMC algorithm in (Mees) contained an\nestimation of the effective time scale of such a simulation, but it\nwas later shown that the speed-up one can gain from a tfMC simulation\nis system- and process-dependent, ranging from none to several orders\nof magnitude. In general, solid-state processes such as\n(re)crystallization or growth can be accelerated by up to two or three\norders of magnitude, whereas diffusion in the liquid phase is not\naccelerated at all. The observed pseudodynamics when using the tfMC\nmethod is not the actual dynamics one would obtain using MD, but the\nrelative importance of processes can match the actual relative\ndynamics of the system quite well, provided Delta is chosen with\ncare. Thus, the system’s equilibrium is reached faster than in MD,\nalong a path that is generally roughly similar to a typical MD\nsimulation (but not necessarily so). See (Bal) for details.\nEach step, all atoms in the selected group are displaced using the\nstochastic tfMC algorithm, which is designed to sample the canonical\n(NVT) ensemble at the temperature Temp. Although tfMC is a Monte\nCarlo algorithm and thus strictly speaking does not perform time\nintegration, it is similar in the sense that it uses the forces on all\natoms in order to update their positions. Therefore, it is implemented\nas a time integration fix, and no other fixes of this type (such as\nfix nve) should be used at the same time. Because\nvelocities do not play a role in this kind of Monte Carlo simulations,\ninstantaneous temperatures as calculated by temperature computes or thermodynamic output have no meaning: the only relevant\ntemperature is the sampling temperature Temp.  Similarly, performing\ntfMC simulations does not require setting a timestep\nand the simulated time as calculated by LAMMPS is\nmeaningless.\nThe critical parameter determining the success of a tfMC simulation is\nDelta, the maximal displacement length of the lightest element in\nthe system: the larger it is, the longer the effective time scale of\nthe simulation will be (there is an approximately quadratic\ndependence). However, Delta must also be chosen sufficiently small\nin order to comply with detailed balance; in general values between 5\nand 10 % of the nearest neighbor distance are found to be a good\nchoice. For a more extensive discussion with specific examples, please\nrefer to (Bal), which also describes how the code calculates\nelement-specific maximal displacements from Delta, based on the\nfourth root of their mass.\nBecause of the uncorrelated movements of the atoms, the center-of-mass\nof the fix group will not necessarily be stationary, just like its\norientation. When the com keyword is used, all atom positions will\nbe shifted (after every tfMC iteration) in order to fix the position\nof the center-of-mass along the included directions, by setting the\ncorresponding flag to 1. The rot keyword does the same for the\nrotational component of the tfMC displacements after every iteration.\n\nNote\nthe com and rot keywords should not be used if an external\nforce is acting on the specified fix group, along the included\ndirections. This can be either a true external force (e.g.  through\nfix wall) or forces due to the interaction with atoms\nnot included in the fix group. This is because in such cases,\ntranslations or rotations of the fix group could be induced by these\nexternal forces, and removing them will lead to a violation of\ndetailed balance.\n\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nNone of the fix_modify options are relevant to this\nfix.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID tfmc Delta Temp seed keyword value",
    "parameters": " * ID, group-ID are documented in fix command\n * tfmc = style name of this fix command\n * Delta = maximal displacement length (distance units)\n * Temp = imposed temperature of the system\n * seed = random number seed (positive integer)\n * zero or more keyword/arg pairs may be appended\n * keyword = com or rot\n * com args = xflag yflag zflag\n *   xflag,yflag,zflag = 0/1 to exclude/include each dimension\n * rot args = none",
    "examples": "fix 1 all tfmc 0.1 1000.0 159345\nfix 1 all tfmc 0.05 600.0 658943 com 1 1 0\nfix 1 all tfmc 0.1 750.0 387068 com 1 1 1 rot",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info.\nThis fix is not compatible with fix shake."
},
{
    "command": "fix thermal/conductivity",
    "html_filename": "fix_thermal_conductivity.html",
    "short_description": "Use the Muller-Plathe algorithm described in this paper to exchange kinetic energy between two particles in different regions of the simulation box every N steps",
    "description": "Use the Muller-Plathe algorithm described in this paper to exchange kinetic energy between two particles\nin different regions of the simulation box every N steps.  This\ninduces a temperature gradient in the system.  As described below this\nenables the thermal conductivity of a material to be calculated.  This\nalgorithm is sometimes called a reverse non-equilibrium MD (reverse\nNEMD) approach to computing thermal conductivity.  This is because the\nusual NEMD approach is to impose a temperature gradient on the system\nand measure the response as the resulting heat flux.  In the\nMuller-Plathe method, the heat flux is imposed, and the temperature\ngradient is the system’s response.\nSee the compute heat/flux command for details\non how to compute thermal conductivity in an alternate way, via the\nGreen-Kubo formalism.\nThe simulation box is divided into Nbin layers in the edim\ndirection, where the layer 1 is at the low end of that dimension and\nthe layer Nbin is at the high end.  Every N steps, Nswap pairs of\natoms are chosen in the following manner.  Only atoms in the fix group\nare considered.  The hottest Nswap atoms in layer 1 are selected.\nSimilarly, the coldest Nswap atoms in the “middle” layer (see below)\nare selected.  The two sets of Nswap atoms are paired up and their\nvelocities are exchanged.  This effectively swaps their kinetic\nenergies, assuming their masses are the same.  If the masses are\ndifferent, an exchange of velocities relative to center of mass motion\nof the 2 atoms is performed, to conserve kinetic energy.  Over time,\nthis induces a temperature gradient in the system which can be\nmeasured using commands such as the following, which writes the\ntemperature profile (assuming z = edim) to the file tmp.profile:\ncompute   ke all ke/atom\nvariable  temp atom c_ke/1.5\ncompute   layers all chunk/atom bin/1d z lower 0.05 units reduced\nfix       3 all ave/chunk 10 100 1000 layers v_temp file tmp.profile\n\n\nNote that by default, Nswap = 1, though this can be changed by the\noptional swap keyword.  Setting this parameter appropriately, in\nconjunction with the swap rate N, allows the heat flux to be adjusted\nacross a wide range of values, and the kinetic energy to be exchanged\nin large chunks or more smoothly.\nThe “middle” layer for velocity swapping is defined as the Nbin/2 +\n1 layer.  Thus if Nbin = 20, the two swapping layers are 1 and 11.\nThis should lead to a symmetric temperature profile since the two\nlayers are separated by the same distance in both directions in a\nperiodic sense.  This is why Nbin is restricted to being an even\nnumber.\nAs described below, the total kinetic energy transferred by these\nswaps is computed by the fix and can be output.  Dividing this\nquantity by time and the cross-sectional area of the simulation box\nyields a heat flux.  The ratio of heat flux to the slope of the\ntemperature profile is proportional to the thermal conductivity of the\nfluid, in appropriate units.  See the Muller-Plathe paper for details.\n\nNote\nIf your system is periodic in the direction of the heat flux,\nthen the flux is going in 2 directions.  This means the effective heat\nflux in one direction is reduced by a factor of 2.  You will see this\nin the equations for thermal conductivity (kappa) in the Muller-Plathe\npaper.  LAMMPS is simply tallying kinetic energy which does not\naccount for whether or not your system is periodic; you must use the\nvalue appropriately to yield a kappa for your system.\n\n\nNote\nAfter equilibration, if the temperature gradient you observe is\nnot linear, then you are likely swapping energy too frequently and are\nnot in a regime of linear response.  In this case you cannot\naccurately infer a thermal conductivity and should try increasing the\nNevery parameter.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nkinetic energy transferred between the bottom and middle of the\nsimulation box (in the edim direction) is stored as a scalar\nquantity by this fix.  This quantity is zeroed when the fix is defined\nand accumulates thereafter, once every N steps.  The units of the\nquantity are energy; see the units command for details.\nThe scalar value calculated by this fix is “intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID thermal/conductivity N edim Nbin keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * thermal/conductivity = style name of this fix command\n * N = perform kinetic energy exchange every N steps\n * edim = x or y or z = direction of kinetic energy transfer\n * Nbin = # of layers in edim direction (must be even number)\n * zero or more keyword/value pairs may be appended\n * keyword = swap\n * swap value = Nswap = number of swaps to perform every N steps",
    "examples": "fix 1 all thermal/conductivity 100 z 20\nfix 1 all thermal/conductivity 50 z 20 swap 2",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nSwaps conserve both momentum and kinetic energy, even if the masses of\nthe swapped atoms are not equal.  Thus you should not need to\nthermostat the system.  If you do use a thermostat, you may want to\napply it only to the non-swapped dimensions (other than vdim).\nLAMMPS does not check, but you should not use this fix to swap the\nkinetic energy of atoms that are in constrained molecules, e.g. via\nfix shake or fix rigid.  This is\nbecause application of the constraints will alter the amount of\ntransferred momentum.  You should, however, be able to use flexible\nmolecules.  See the Zhang paper for a discussion and results\nof this idea.\nWhen running a simulation with large, massive particles or molecules\nin a background solvent, you may want to only exchange kinetic energy\nbetween solvent particles."
},
{
    "command": "fix ti/spring",
    "html_filename": "fix_ti_spring.html",
    "short_description": "This fix allows you to compute the free energy of crystalline solids by performing a nonequilibrium thermodynamic integration between the solid of interest and an Einstein crystal",
    "description": "This fix allows you to compute the free energy of crystalline solids\nby performing a nonequilibrium thermodynamic integration between the\nsolid of interest and an Einstein crystal. A detailed explanation of\nhow to use this command and choose its parameters for optimal\nperformance and accuracy is given in the paper by\nFreitas. The paper also presents a short summary of the\ntheory of nonequilibrium thermodynamic integration.\nThe thermodynamic integration procedure is performed by rescaling the\nforce on each atom. Given an atomic configuration the force (F) on\neach atom is given by\n\n\\[F = \\left( 1-\\lambda \\right) F_{\\text{solid}} + \\lambda F_{\\text{harm}}\\]\nwhere F_solid is the force that acts on an atom due to an interatomic\npotential (e.g. EAM potential), F_harm is the force due to the\nEinstein crystal harmonic spring, and lambda is the coupling parameter\nof the thermodynamic integration. An Einstein crystal is a solid where\neach atom is attached to its equilibrium position by a harmonic spring\nwith spring constant k. With this fix a spring force is applied\nindependently to each atom in the group defined by the fix to tether\nit to its initial position. The initial position of each atom is its\nposition at the time the fix command was issued.\nThe fix acts as follows: during the first t_eq steps after the fix\nis defined the value of lambda is zero. This is the period to\nequilibrate the system in the lambda = 0 state. After this the value\nof lambda changes dynamically during the simulation from 0 to 1\naccording to the function defined using the keyword function\n(described below), this switching from lambda from 0 to 1 is done in\nt_s steps. Then comes the second equilibration period of t_eq to\nequilibrate the system in the lambda = 1 state. After that, the\nswitching back to the lambda = 0 state is made using t_s timesteps\nand following the same switching function. After this period the value\nof lambda is kept equal to zero and the fix has no other effect on the\ndynamics of the system.\nThe processes described above is known as nonequilibrium thermodynamic\nintegration and is has been shown (Freitas) to present a\nmuch superior efficiency when compared to standard equilibrium\nmethods. The reason why the switching it is made in both directions\n(potential to Einstein crystal and back) is to eliminate the\ndissipated heat due to the nonequilibrium process. Further details\nabout nonequilibrium thermodynamic integration and its implementation\nin LAMMPS is available in Freitas.\nThe function keyword allows the use of two different lambda\npaths. Option 1 results in a constant rate of change of lambda with\ntime:\n\n\\[\\lambda(\\tau) = \\tau\\]\nwhere tau is the scaled time variable t/t_s. The option 2 performs\nthe lambda switching at a rate defined by the following switching\nfunction\n\n\\[\\lambda(\\tau) = \\tau^5 \\left( 70 \\tau^4 - 315 \\tau^3 + 540 \\tau^2 - 420 \\tau + 126 \\right)\\]\nThis function has zero slope as lambda approaches its extreme values\n(0 and 1), according to de Koning this results in\nsmaller fluctuations on the integral to be computed on the\nthermodynamic integration. The use of option 2 is recommended since\nit results in better accuracy and less dissipation without any\nincrease in computational resources cost.\n\nNote\nAs described in Freitas, it is important to keep the\ncenter-of-mass fixed during the thermodynamic integration. A nonzero\ntotal velocity will result in divergences during the integration due\nto the fact that the atoms are ‘attached’ to their equilibrium\npositions by the Einstein crystal. Check the option zero of fix langevin and velocity. The use of\nthe Nose-Hoover thermostat (fix nvt) is NOT\nrecommended due to its well documented issues with the canonical\nsampling of harmonic degrees of freedom (notice that the chain\noption will NOT solve this problem). The Langevin thermostat (fix langevin) correctly thermostats the system and we\nadvise its usage with ti/spring command.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the original coordinates of tethered atoms to binary restart files, so that the spring effect will be the\nsame in a restarted simulation. See the read restart command for info on how to re-specify a fix\nin an input script that reads a restart file, so that the operation of\nthe fix continues in an uninterrupted fashion.\nThe fix modify energy option is supported by this\nfix to add the energy stored in the per-atom springs to the system’s\npotential energy as part of thermodynamic output.\nThis fix computes a global scalar and a global vector quantities which\ncan be accessed by various output commands. The\nscalar is an energy which is the sum of the spring energy for each\natom, where the per-atom energy is 0.5 * k * r^2. The vector has 2\npositions, the first one is the coupling parameter lambda and the\nsecond one is the time derivative of lambda. The scalar and vector\nvalues calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the per-atom spring energy to be included in the\ntotal potential energy of the system (the quantity being minimized),\nyou MUST enable the fix modify energy option for\nthis fix.",
    "syntax": "fix ID group-ID ti/spring k t_s t_eq keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * ti/spring = style name of this fix command\n * k = spring constant (force/distance units)\n * t_eq = number of steps for the equilibration procedure\n * t_s = number of steps for the switching procedure\n * zero or more keyword/value pairs may be appended to args\n * keyword = function\n * function value = function-ID\n *   function-ID = ID of the switching function (1 or 2)\n * Example:\n * fix 1 all ti/spring 50.0 2000 1000 function 2",
    "examples": "fix 1 all thermal/conductivity 100 z 20\nfix 1 all thermal/conductivity 50 z 20 swap 2",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "fix tmd",
    "html_filename": "fix_tmd.html",
    "short_description": "Perform targeted molecular dynamics (TMD) on a group of atoms",
    "description": "Perform targeted molecular dynamics (TMD) on a group of atoms.  A\nholonomic constraint is used to force the atoms to move towards (or\naway from) the target configuration.  The parameter “rho” is\nmonotonically decreased (or increased) from its initial value to\nrho_final at the end of the run.\nRho has distance units and is a measure of the root-mean-squared\ndistance (RMSD) between the current configuration of the atoms in the\ngroup and the target coordinates listed in file1.  Thus a value of\nrho_final = 0.0 means move the atoms all the way to the final\nstructure during the course of the run.\nThe target file1 can be ASCII text or a gzipped text file (detected by\na .gz suffix).  The format of the target file1 is as follows:\n0.0 25.0 xlo xhi\n0.0 25.0 ylo yhi\n0.0 25.0 zlo zhi\n125     24.97311   1.69005     23.46956 0 0 -1\n126     1.94691    2.79640     1.92799  1 0 0\n127     0.15906    3.46099     0.79121  1 0 0\n...\n\n\nThe first 3 lines may or may not be needed, depending on the format of\nthe atoms to follow.  If image flags are included with the atoms, the\n1st 3 lo/hi lines must appear in the file.  If image flags are not\nincluded, the 1st 3 lines should not appear.  The 3 lines contain the\nsimulation box dimensions for the atom coordinates, in the same format\nas in a LAMMPS data file (see the read_data command).\nThe remaining lines each contain an atom ID and its target x,y,z\ncoordinates.  The atom lines (all or none of them) can optionally be\nfollowed by 3 integer values: nx,ny,nz.  For periodic dimensions, they\nspecify which image of the box the atom is considered to be in, i.e. a\nvalue of N (positive or negative) means add N times the box length to\nthe coordinate to get the true value.\nThe atom lines can be listed in any order, but every atom in the group\nmust be listed in the file.  Atoms not in the fix group may also be\nlisted; they will be ignored.\nTMD statistics are written to file2 every N timesteps, unless N is\nspecified as 0, which means no statistics.\nThe atoms in the fix tmd group should be integrated (via a fix nve,\nnvt, npt) along with other atoms in the system.\nRestarts can be used with a fix tmd command.  For example, imagine a\n10000 timestep run with a rho_initial = 11 and a rho_final = 1.  If a\nrestart file was written after 2000 time steps, then the configuration\nin the file would have a rho value of 9.  A new 8000 time step run\ncould be performed with the same rho_final = 1 to complete the\nconformational change at the same transition rate.  Note that for\nrestarted runs, the name of the TMD statistics file should be changed\nto prevent it being overwritten.\nFor more information about TMD, see (Schlitter1) and\n(Schlitter2).\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nThis fix can ramp its rho parameter over multiple runs, using the\nstart and stop keywords of the run command.  See the\nrun command for details of how to do this.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID tmd rho_final file1 N file2",
    "parameters": " * ID, group-ID are documented in fix command\n * tmd = style name of this fix command\n * rho_final = desired value of rho at the end of the run (distance units)\n * file1 = filename to read target structure from\n * N = dump TMD statistics every this many timesteps, 0 = no dump\n * file2 = filename to write TMD statistics to (only needed if N > 0)",
    "examples": "fix 1 all nve\nfix 2 tmdatoms tmd 1.0 target_file 100 tmd_dump_file",
    "restrictions": "All TMD fixes must be listed in the input script after all integrator\nfixes (nve, nvt, npt) are applied.  This ensures that atoms are moved\nbefore their positions are corrected to comply with the constraint.\nAtoms that have a TMD fix applied should not be part of a group to\nwhich a SHAKE fix is applied.  This is because LAMMPS assumes there\nare not multiple competing holonomic constraints applied to the same\natoms.\nTo read gzipped target files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option.  See the Build settings\ndoc page for details.\nRelated commands: none\nDefault: none\n\n(Schlitter1) Schlitter, Swegat, Mulders, “Distance-type reaction\ncoordinates for modelling activated processes”, J Molecular Modeling,\n7, 171-177 (2001).\n(Schlitter2) Schlitter and Klahn, “The free energy of a reaction\ncoordinate at multiple constraints: a concise formulation”, Molecular\nPhysics, 101, 3439-3443 (2003)."
},
{
    "command": "fix ttm",
    "html_filename": "fix_ttm.html",
    "short_description": "Use a two-temperature model (TTM) to represent heat transfer through and between electronic and atomic subsystems",
    "description": "Use a two-temperature model (TTM) to represent heat transfer through\nand between electronic and atomic subsystems.  LAMMPS models the\natomic subsystem as usual with a molecular dynamics model and the\nclassical force field specified by the user, but the electronic\nsubsystem is modeled as a continuum, or a background “gas”, on a\nregular grid.  Energy can be transferred spatially within the grid\nrepresenting the electrons.  Energy can also be transferred between\nthe electronic and the atomic subsystems.  The algorithm underlying\nthis fix was derived by D. M.  Duffy and A. M. Rutherford and is\ndiscussed in two J Physics: Condensed Matter papers: (Duffy)\nand (Rutherford).  They used this algorithm in cascade\nsimulations where a primary knock-on atom (PKA) was initialized with a\nhigh velocity to simulate a radiation event.\nThe description in this sub-section applies to both fix ttm and fix\nttm/mod.  Fix ttm/mod adds options to account for external heat\nsources (e.g. at a surface) and for specifying parameters that allow\nthe electronic heat capacity to depend strongly on electronic\ntemperature.  It is more expensive computationally than fix ttm\nbecause it treats the thermal diffusion equation as non-linear.  More\ndetails on fix ttm/mod are given below.\nHeat transfer between the electronic and atomic subsystems is carried\nout via an inhomogeneous Langevin thermostat.  This thermostat differs\nfrom the regular Langevin thermostat (fix langevin) in three important ways.  First, the\nLangevin thermostat is applied uniformly to all atoms in the\nuser-specified group for a single target temperature, whereas the TTM\nfix applies Langevin thermostatting locally to atoms within the\nvolumes represented by the user-specified grid points with a target\ntemperature specific to that grid point.  Second, the Langevin\nthermostat couples the temperature of the atoms to an infinite heat\nreservoir, whereas the heat reservoir for fix TTM is finite and\nrepresents the local electrons.  Third, the TTM fix allows users to\nspecify not just one friction coefficient, but rather two independent\nfriction coefficients: one for the electron-ion interactions\n(gamma_p), and one for electron stopping (gamma_s).\nWhen the friction coefficient due to electron stopping, gamma_s, is\nnon-zero, electron stopping effects are included for atoms moving\nfaster than the electron stopping critical velocity, v_0.  For\nfurther details about this algorithm, see (Duffy) and\n(Rutherford).\nEnergy transport within the electronic subsystem is solved according\nto the heat diffusion equation with added source terms for heat\ntransfer between the subsystems:\n\n\\[C_e \\rho_e \\frac{\\partial T_e}{\\partial t} =\n\\bigtriangledown (\\kappa_e \\bigtriangledown T_e) -\ng_p (T_e - T_a) + g_s T_a'\\]\nwhere C_e is the specific heat, rho_e is the density, kappa_e is the\nthermal conductivity, T is temperature, the “e” and “a” subscripts\nrepresent electronic and atomic subsystems respectively, g_p is the\ncoupling constant for the electron-ion interaction, and g_s is the\nelectron stopping coupling parameter.  C_e, rho_e, and kappa_e are\nspecified as parameters to the fix.  The other quantities are derived.\nThe form of the heat diffusion equation used here is almost the same\nas that in equation 6 of (Duffy), with the exception that the\nelectronic density is explicitly represented, rather than being part\nof the specific heat parameter.\nCurrently, fix ttm assumes that none of the user-supplied parameters\nwill vary with temperature. Note that (Duffy) used a tanh()\nfunctional form for the temperature dependence of the electronic\nspecific heat, but ignored temperature dependencies of any of the\nother parameters.  See more discussion below for fix ttm/mod.\nThese fixes require use of periodic boundary conditions and a 3D\nsimulation.  Periodic boundary conditions are also used in the heat\nequation solve for the electronic subsystem.  This varies from the\napproach of (Rutherford) where the atomic subsystem was\nembedded within a larger continuum representation of the electronic\nsubsystem.\nThe initial electronic temperature input file, T_infile, is a text\nfile LAMMPS reads in with no header and with four numeric columns\n(ix,iy,iz,Temp) and with a number of rows equal to the number of\nuser-specified grid points (Nx by Ny by Nz).  The ix,iy,iz are node\nindices from 0 to nxnodes-1, etc.  For example, the initial electronic\ntemperatures on a 1 by 2 by 3 grid could be specified in a T_infile\nas follows:\n0 0 0 1.0\n0 0 1 1.0\n0 0 2 1.0\n0 1 0 2.0\n0 1 1 2.0\n0 1 2 2.0\n\n\nwhere the electronic temperatures along the y=0 plane have been set to\n1.0, and the electronic temperatures along the y=1 plane have been set\nto 2.0.  The order of lines in this file is no important.  If all the\nnodal values are not specified, LAMMPS will generate an error.\nThe temperature output file, T_oufile, is created and written by\nthis fix.  Temperatures for both the electronic and atomic subsystems\nat every node and every N timesteps are output.  If N is specified as\nzero, no output is generated, and no output filename is needed.  The\nformat of the output is as follows.  One long line is written every\noutput timestep.  The timestep itself is given in the first column.\nThe next Nx*Ny*Nz columns contain the temperatures for the atomic\nsubsystem, and the final Nx*Ny*Nz columns contain the temperatures for\nthe electronic subsystem.  The ordering of the Nx*Ny*Nz columns is\nwith the z index varying fastest, y the next fastest, and x the\nslowest.\nThese fixes do not change the coordinates of their atoms; they only\nscales their velocities.  Thus a time integration fix (e.g. fix nve) should still be used to time integrate the affected\natoms.  The fixes should not normally be used on atoms that have their\ntemperature controlled by another fix - e.g. fix nvt or\nfix langevin.\n\nNote\nThe current implementations of these fixes create a copy of the\nelectron grid that overlays the entire simulation domain, for each\nprocessor.  Values on the grid are summed across all processors.  Thus\nyou should insure that this grid is not too large, else your\nsimulation could incur high memory and communication costs.\n\n\nAdditional details for fix ttm/mod\nFix ttm/mod uses the heat diffusion equation with possible external\nheat sources (e.g. laser heating in ablation simulations):\n\n\\[C_e \\rho_e \\frac{\\partial T_e}{\\partial t} =\n\\bigtriangledown (\\kappa_e \\bigtriangledown T_e) -\ng_p (T_e - T_a) + g_s T_a' + \\theta (x-x_{surface})I_0 \\exp(-x/l_{skin})\\]\nwhere theta is the Heaviside step function, I_0 is the (absorbed)\nlaser pulse intensity for ablation simulations, l_skin is the depth\nof skin-layer, and all other designations have the same meaning as in\nthe former equation. The duration of the pulse is set by the parameter\ntau in the init_file.\nFix ttm/mod also allows users to specify the dependencies of C_e and\nkappa_e on the electronic temperature. The specific heat is expressed\nas\n\n\\[C_e = C_0 + (a_0 + a_1 X + a_2 X^2 + a_3 X^3 + a_4 X^4) \\exp (-(AX)^2)\\]\nwhere X = T_e/1000, and the thermal conductivity is defined as\nkappa_e = D_e*rho_e*C_e, where D_e is the thermal diffusion\ncoefficient.\nElectronic pressure effects are included in the TTM model to account\nfor the blast force acting on ions because of electronic pressure\ngradient (see (Chen), (Norman)).  The total force\nacting on an ion is:\n\n\\[{\\vec F}_i = - \\partial U / \\partial {\\vec r}_i + {\\vec F}_{langevin} - \\nabla P_e/n_{ion}\\]\nwhere F_langevin is a force from Langevin thermostat simulating\nelectron-phonon coupling, and nabla P_e/n_ion is the electron blast\nforce.\nThe electronic pressure is taken to be P_e = B*rho_e*C_e*T_e\nThe current fix ttm/mod implementation allows TTM simulations with a\nvacuum. The vacuum region is defined as the grid cells with zero\nelectronic temperature. The numerical scheme does not allow energy\nexchange with such cells. Since the material can expand to previously\nunoccupied region in some simulations, the vacuum border can be\nallowed to move. It is controlled by the surface_movement parameter\nin the init_file. If it is set to 1, then “vacuum” cells can be\nchanged to “electron-filled” cells with the temperature T_e_min if\natoms move into them (currently only implemented for the case of\n1-dimensional motion of flat surface normal to the X axis). The\ninitial borders of vacuum can be set in the init_file via lsurface\nand rsurface parameters. In this case, electronic pressure gradient\nis calculated as\n\n\\[\\nabla_x P_e = \\left[\\frac{C_e{}T_e(x)\\lambda}{(x+\\lambda)^2} + \\frac{x}{x+\\lambda}\\frac{(C_e{}T_e)_{x+\\Delta x}-(C_e{}T_e)_{x}}{\\Delta x} \\right]\\]\nwhere lambda is the electron mean free path (see (Norman),\n(Pisarev))\nThe fix ttm/mod parameter file init_file has the following syntax/\nEvery line with the odd number is considered as a comment and\nignored. The lines with the even numbers are treated as follows:\na_0, energy/(temperature*electron) units\na_1, energy/(temperature^2*electron) units\na_2, energy/(temperature^3*electron) units\na_3, energy/(temperature^4*electron) units\na_4, energy/(temperature^5*electron) units\nC_0, energy/(temperature*electron) units\nA, 1/temperature units\nrho_e, electrons/volume units\nD_e, length^2/time units\ngamma_p, mass/time units\ngamma_s, mass/time units\nv_0, length/time units\nI_0, energy/(time*length^2) units\nlsurface, electron grid units (positive integer)\nrsurface, electron grid units (positive integer)\nl_skin, length units\ntau, time units\nB, dimensionless\nlambda, length units\nn_ion, ions/volume units\nsurface_movement: 0 to disable tracking of surface motion, 1 to enable\nT_e_min, temperature units\n\nRestart, fix_modify, output, run start/stop, minimize info:\nThese fixes write the state of the electronic subsystem and the energy\nexchange between the subsystems to binary restart files.  See the read_restart command\nfor info on how to re-specify a fix in an input script that reads a\nrestart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nBecause the state of the random number generator is not saved in the\nrestart files, this means you cannot do “exact” restarts with this\nfix, where the simulation continues on the same as if no restart had\ntaken place.  However, in a statistical sense, a restarted simulation\nshould produce the same behavior.\nNone of the fix_modify options are relevant to these\nfixes.\nBoth fixes compute 2 output quantities stored in a vector of length 2,\nwhich can be accessed by various output commands.\nThe first quantity is the total energy of the electronic\nsubsystem. The second quantity is the energy transferred from the\nelectronic to the atomic subsystem on that timestep. Note that the\nvelocity verlet integrator applies the fix ttm forces to the atomic\nsubsystem as two half-step velocity updates: one on the current\ntimestep and one on the subsequent timestep.  Consequently, the change\nin the atomic subsystem energy is lagged by half a timestep relative\nto the change in the electronic subsystem energy. As a result of this,\nusers may notice slight fluctuations in the sum of the atomic and\nelectronic subsystem energies reported at the end of the timestep.\nThe vector values calculated are “extensive”.\nNo parameter of the fixes can be used with the start/stop keywords\nof the run command.  The fixes are not invoked during\nenergy minimization.",
    "syntax": "fix ID group-ID ttm seed C_e rho_e kappa_e gamma_p gamma_s v_0 Nx Ny Nz T_infile N T_outfile",
    "parameters": " * fix ID group-ID ttm/mod seed init_file Nx Ny Nz T_infile N T_outfile\n * ID, group-ID are documented in fix command\n * style = ttm or ttm_mod\n * seed = random number seed to use for white noise (positive integer)\n * remaining arguments for fix ttm:\n * C_e  = electronic specific heat (energy/(electron*temperature) units)\n * rho_e = electronic density (electrons/volume units)\n * kappa_e = electronic thermal conductivity (energy/(time*distance*temperature) units)\n * gamma_p = friction coefficient due to electron-ion interactions (mass/time units)\n * gamma_s = friction coefficient due to electronic stopping (mass/time units)\n * v_0 = electronic stopping critical velocity (velocity units)\n * Nx = number of thermal solve grid points in the x-direction (positive integer)\n * Ny = number of thermal solve grid points in the y-direction (positive integer)\n * Nz = number of thermal solve grid points in the z-direction (positive integer)\n * T_infile = filename to read initial electronic temperature from\n * N = dump TTM temperatures every this many timesteps, 0 = no dump\n * T_outfile = filename to write TTM temperatures to (only needed if N > 0)\n * remaining arguments for fix ttm/mod:\n * init_file = file with the parameters to TTM\n * Nx = number of thermal solve grid points in the x-direction (positive integer)\n * Ny = number of thermal solve grid points in the y-direction (positive integer)\n * Nz = number of thermal solve grid points in the z-direction (positive integer)\n * T_infile = filename to read initial electronic temperature from\n * N = dump TTM temperatures every this many timesteps, 0 = no dump\n * T_outfile = filename to write TTM temperatures to (only needed if N > 0)",
    "examples": "fix 2 all ttm 699489 1.0 1.0 10 0.1 0.0 2.0 1 12 1 initialTs 1000 T.out\nfix 2 all ttm 123456 1.0 1.0 1.0 1.0 1.0 5.0 5 5 5 Te.in 1 Te.out\nfix 2 all ttm/mod 34277 parameters.txt 5 5 5 T_init 10 T_out",
    "restrictions": "Fix ttm is part of the MISC package. It is only enabled if LAMMPS\nwas built with that package.  Fix ttm/mod is part of the USER-MISC\npackage. It is only enabled if LAMMPS was built with that package.\nSee the Build package doc page for more info.\nThese fixes can only be used for 3d simulations and orthogonal\nsimulation boxes.  You must also use periodic\nboundary conditions."
},
{
    "command": "fix tune/kspace",
    "html_filename": "fix_tune_kspace.html",
    "short_description": "This fix tests each kspace style (Ewald, PPPM, and MSM), and automatically selects the fastest style to use for the remainder of the run",
    "description": "This fix tests each kspace style (Ewald, PPPM, and MSM), and\nautomatically selects the fastest style to use for the remainder\nof the run. If the fastest style is Ewald or PPPM, the fix also\nadjusts the Coulombic cutoff towards optimal speed. Future versions\nof this fix will automatically select other kspace parameters\nto use for maximum simulation speed. The kspace parameters may\ninclude the style, cutoff, grid points in each direction, order,\nEwald parameter, MSM parallelization cut-point, MPI tasks to use, etc.\nThe rationale for this fix is to provide the user with\nas-fast-as-possible simulations that include long-range electrostatics\n(kspace) while meeting the user-prescribed accuracy requirement. A\nsimple heuristic could never capture the optimal combination of\nparameters for every possible run-time scenario. But by performing\nshort tests of various kspace parameter sets, this fix allows\nparameters to be tailored specifically to the user’s machine, MPI\nranks, use of threading or accelerators, the simulated system, and the\nsimulation details. In addition, it is possible that parameters could\nbe evolved with the simulation on-the-fly, which is useful for systems\nthat are dynamically evolving (e.g. changes in box size/shape or\nnumber of particles).\nWhen this fix is invoked, LAMMPS will perform short timed tests of\nvarious parameter sets to determine the optimal parameters. Tests are\nperformed on-the-fly, with a new test initialized every N steps. N should\nbe chosen large enough so that adequate CPU time lapses between tests,\nthereby providing statistically significant timings. But N should not be\nchosen to be so large that an unfortunate parameter set test takes an\ninordinate amount of wall time to complete. An N of 100 for most problems\nseems reasonable. Once an optimal parameter set is found, that set is\nused for the remainder of the run.\nThis fix uses heuristics to guide it’s selection of parameter sets to test,\nbut the actual timed results will be used to decide which set to use in the\nsimulation.\nIt is not necessary to discard trajectories produced using sub-optimal\nparameter sets, or a mix of various parameter sets, since the user-prescribed\naccuracy will have been maintained throughout. However, some users may prefer\nto use this fix only to discover the optimal parameter set for a given setup\nthat can then be used on subsequent production runs.\nThis fix starts with kspace parameters that are set by the user with the\nkspace_style and kspace_modify\ncommands. The prescribed accuracy will be maintained by this fix throughout\nthe simulation.\nNone of the fix_modify options are relevant to this\nfix.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID tune/kspace N",
    "parameters": " * ID, group-ID are documented in fix command\n * tune/kspace = style name of this fix command\n * N = invoke this fix every N steps",
    "examples": "fix 2 all tune/kspace 100",
    "restrictions": "This fix is part of the KSPACE package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nDo not set “neigh_modify once yes” or else this fix will never be\ncalled.  Reneighboring is required.\nThis fix is not compatible with a hybrid pair style, long-range dispersion,\nTIP4P water support, or long-range point dipole support."
},
{
    "command": "fix vector",
    "html_filename": "fix_vector.html",
    "short_description": "Use one or more global values as inputs every few timesteps, and simply store them",
    "description": "Use one or more global values as inputs every few timesteps, and\nsimply store them.  For a single specified value, the values are\nstored as a global vector of growing length.  For multiple specified\nvalues, they are stored as rows in a global array, whose number of\nrows is growing.  The resulting vector or array can be used by other\noutput commands.\nOne way to to use this command is to accumulate a vector that is\ntime-integrated using the variable trap() function.\nFor example the velocity auto-correlation function (VACF) can be\ntime-integrated, to yield a diffusion coefficient, as follows:\ncompute         2 all vacf\nfix             5 all vector 1 c_2[4]\nvariable        diff equal dt*trap(f_5)\nthermo_style    custom step v_diff\nThe group specified with this command is ignored.  However, note that\nspecified values may represent calculations performed by computes and\nfixes which store their own “group” definitions.\nEach listed value can be the result of a compute or\nfix or the evaluation of an equal-style or vector-style\nvariable.  In each case, the compute, fix, or variable\nmust produce a global quantity, not a per-atom or local quantity.  And\nthe global quantity must be a scalar, not a vector or array.\nComputes that produce global quantities are those which\ndo not have the word atom in their style name.  Only a few\nfixes produce global quantities.  See the doc pages for\nindividual fixes for info on which ones produce such values.\nVariables of style equal or vector are the only\nones that can be used with this fix.  Variables of style atom cannot\nbe used, since they produce per-atom values.\nThe Nevery argument specifies on what timesteps the input values\nwill be used in order to be stored.  Only timesteps that are a\nmultiple of Nevery, including timestep 0, will contribute values.\nNote that if you perform multiple runs, using the “pre no” option of\nthe run command to avoid initialization on subsequent runs,\nthen you need to use the stop keyword with the first run\ncommand with a timestep value that encompasses all the runs.  This is\nso that the vector or array stored by this fix can be allocated to a\nsufficient size.\n\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the global scalar calculated by the compute is used.  If a\nbracketed term is appended, the Ith element of the global vector\ncalculated by the compute is used.\nNote that there is a compute reduce command\nwhich can sum per-atom quantities into a global scalar or vector which\ncan thus be accessed by fix vector.  Or it can be a compute defined\nnot in your input script, but by thermodynamic output or other fixes such as fix nvt\nor fix temp/rescale.  See the doc pages for\nthese commands which give the IDs of these computes.  Users can also\nwrite code for their own compute styles and add them to LAMMPS.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If no bracketed term is\nappended, the global scalar calculated by the fix is used.  If a\nbracketed term is appended, the Ith element of the global vector\ncalculated by the fix is used.\nNote that some fixes only produce their values on certain timesteps,\nwhich must be compatible with Nevery, else an error will result.\nUsers can also write code for their own fix styles and add them to LAMMPS.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  An equal-style or\nvector-style variable can be referenced; the latter requires a\nbracketed term to specify the Ith element of the vector calculated by\nthe variable.  See the variable command for details.\nNote that variables of style equal and vector define a formula\nwhich can reference individual atom properties or thermodynamic\nkeywords, or they can invoke other computes, fixes, or variables when\nthey are evaluated, so this is a very general means of specifying\nquantities to be stored by fix vector.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix produces a global vector or global array which can be\naccessed by various output commands.  The values\ncan only be accessed on timesteps that are multiples of Nevery.\nA vector is produced if only a single input value is specified.\nAn array is produced if multiple input values are specified.\nThe length of the vector or the number of rows in the array grows\nby 1 every Nevery timesteps.\nIf the fix produces a vector, then the entire vector will be either\n“intensive” or “extensive”, depending on whether the values stored in\nthe vector are “intensive” or “extensive”.  If the fix produces an\narray, then all elements in the array must be the same, either\n“intensive” or “extensive”.  If a compute or fix provides the value\nstored, then the compute or fix determines whether the value is\nintensive or extensive; see the doc page for that compute or fix for\nfurther info.  Values produced by a variable are treated as intensive.\nThis fix can allocate storage for stored values accumulated over\nmultiple runs, using the start and stop keywords of the\nrun command.  See the run command for details of\nhow to do this.  If using the run pre no command option,\nthis is required to allow the fix to allocate sufficient storage for\nstored values.\nThis fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID vector Nevery value1 value2 ...",
    "parameters": " * ID, group-ID are documented in fix command\n * vector = style name of this fix command\n * Nevery = use input values every this many timesteps\n * one or more input values can be listed\n * value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = global scalar calculated by a compute with ID\n * c_ID[I] = Ith component of global vector calculated by a compute with ID\n * f_ID = global scalar calculated by a fix with ID\n * f_ID[I] = Ith component of global vector calculated by a fix with ID\n * v_name = value calculated by an equal-style variable with name\n * v_name[I] = Ith component of vector-style variable with name",
    "examples": "fix 1 all vector 100 c_myTemp\nfix 1 all vector 5 c_myTemp v_integral",
    "restrictions": "\nnone"
},
{
    "command": "fix viscosity",
    "html_filename": "fix_viscosity.html",
    "short_description": "Use the Muller-Plathe algorithm described in this paper to exchange momenta between two particles in different regions of the simulation box every N steps",
    "description": "Use the Muller-Plathe algorithm described in this paper to exchange momenta between two particles in\ndifferent regions of the simulation box every N steps.  This induces a\nshear velocity profile in the system.  As described below this enables\na viscosity of the fluid to be calculated.  This algorithm is\nsometimes called a reverse non-equilibrium MD (reverse NEMD) approach\nto computing viscosity.  This is because the usual NEMD approach is to\nimpose a shear velocity profile on the system and measure the response\nvia an off-diagonal component of the stress tensor, which is\nproportional to the momentum flux.  In the Muller-Plathe method, the\nmomentum flux is imposed, and the shear velocity profile is the\nsystem’s response.\nThe simulation box is divided into Nbin layers in the pdim\ndirection, where the layer 1 is at the low end of that dimension and\nthe layer Nbin is at the high end.  Every N steps, Nswap pairs of\natoms are chosen in the following manner.  Only atoms in the fix group\nare considered.  Nswap atoms in layer 1 with positive velocity\ncomponents in the vdim direction closest to the target value V are\nselected.  Similarly, Nswap atoms in the “middle” layer (see below) with\nnegative velocity components in the vdim direction closest to the\nnegative of the target value V are selected.  The two sets of Nswap\natoms are paired up and their vdim momenta components are swapped\nwithin each pair.  This resets their velocities, typically in opposite\ndirections.  Over time, this induces a shear velocity profile in the\nsystem which can be measured using commands such as the following,\nwhich writes the profile to the file tmp.profile:\ncompute layers all chunk/atom bin/1d z lower 0.05 units reduced\nfix f1 all ave/chunk 100 10 1000 layers vx file tmp.profile\n\n\nNote that by default, Nswap = 1 and vtarget = INF, though this can be\nchanged by the optional swap and vtarget keywords.  When vtarget =\nINF, one or more atoms with the most positive and negative velocity\ncomponents are selected.  Setting these parameters appropriately, in\nconjunction with the swap rate N, allows the momentum flux rate to be\nadjusted across a wide range of values, and the momenta to be\nexchanged in large chunks or more smoothly.\nThe “middle” layer for momenta swapping is defined as the Nbin/2 + 1\nlayer.  Thus if Nbin = 20, the two swapping layers are 1 and 11.\nThis should lead to a symmetric velocity profile since the two layers\nare separated by the same distance in both directions in a periodic\nsense.  This is why Nbin is restricted to being an even number.\nAs described below, the total momentum transferred by these velocity\nswaps is computed by the fix and can be output.  Dividing this\nquantity by time and the cross-sectional area of the simulation box\nyields a momentum flux.  The ratio of momentum flux to the slope of\nthe shear velocity profile is proportional to the viscosity of the\nfluid, in appropriate units.  See the Muller-Plathe paper for details.\n\nNote\nIf your system is periodic in the direction of the momentum\nflux, then the flux is going in 2 directions.  This means the\neffective momentum flux in one direction is reduced by a factor of 2.\nYou will see this in the equations for viscosity in the Muller-Plathe\npaper.  LAMMPS is simply tallying momentum which does not account for\nwhether or not your system is periodic; you must use the value\nappropriately to yield a viscosity for your system.\n\n\nNote\nAfter equilibration, if the velocity profile you observe is not\nlinear, then you are likely swapping momentum too frequently and are\nnot in a regime of linear response.  In this case you cannot\naccurately infer a viscosity and should try increasing the Nevery\nparameter.\n\nAn alternative method for calculating a viscosity is to run a NEMD\nsimulation, as described on the Howto nemd doc page.\nNEMD simulations deform the simulation box via the fix deform command.  Thus they cannot be run on a charged\nsystem using a PPPM solver since PPPM does not\ncurrently support non-orthogonal boxes.  Using fix viscosity keeps the\nbox orthogonal; thus it does not suffer from this limitation.\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the cumulative\nmomentum transferred between the bottom and middle of the simulation\nbox (in the pdim direction) is stored as a scalar quantity by this\nfix.  This quantity is zeroed when the fix is defined and accumulates\nthereafter, once every N steps.  The units of the quantity are\nmomentum = mass*velocity.  The scalar value calculated by this fix is\n“intensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID viscosity N vdim pdim Nbin keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * viscosity = style name of this fix command\n * N = perform momentum exchange every N steps\n * vdim = x or y or z = which momentum component to exchange\n * pdim = x or y or z = direction of momentum transfer\n * Nbin = # of layers in pdim direction (must be even number)\n * zero or more keyword/value pairs may be appended\n * keyword = swap or target\n * swap value = Nswap = number of swaps to perform every N steps\n * vtarget value = V or INF = target velocity of swap partners (velocity units)",
    "examples": "fix 1 all viscosity 100 x z 20\nfix 1 all viscosity 50 x z 20 swap 2 vtarget 1.5",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nSwaps conserve both momentum and kinetic energy, even if the masses of\nthe swapped atoms are not equal.  Thus you should not need to\nthermostat the system.  If you do use a thermostat, you may want to\napply it only to the non-swapped dimensions (other than vdim).\nLAMMPS does not check, but you should not use this fix to swap\nvelocities of atoms that are in constrained molecules, e.g. via fix shake or fix rigid.  This is because\napplication of the constraints will alter the amount of transferred\nmomentum.  You should, however, be able to use flexible molecules.\nSee the Maginn paper for an example of using this algorithm\nin a computation of alcohol molecule properties.\nWhen running a simulation with large, massive particles or molecules\nin a background solvent, you may want to only exchange momenta between\nsolvent particles."
},
{
    "command": "fix viscous",
    "html_filename": "fix_viscous.html",
    "short_description": "Add a viscous damping force to atoms in the group that is proportional to the velocity of the atom",
    "description": "Add a viscous damping force to atoms in the group that is proportional\nto the velocity of the atom.  The added force can be thought of as a\nfrictional interaction with implicit solvent, i.e. the no-slip Stokes\ndrag on a spherical particle.  In granular simulations this can be\nuseful for draining the kinetic energy from the system in a controlled\nfashion.  If used without additional thermostatting (to add kinetic\nenergy to the system), it has the effect of slowly (or rapidly)\nfreezing the system; hence it can also be used as a simple energy\nminimization technique.\nThe damping force \\(F_i\\) is given by \\(F_i = - \\gamma v_i\\).\nThe larger the coefficient, the faster the kinetic energy is reduced.\nIf the optional keyword scale is used, \\(\\gamma\\) can scaled up or\ndown by the specified factor for atoms of that type.  It can be used\nmultiple times to adjust \\(\\gamma\\) for several atom types.\n\nNote\nYou should specify gamma in force/velocity units.  This is not\nthe same as mass/time units, at least for some of the LAMMPS\nunits options like “real” or “metal” that are not\nself-consistent.\n\nIn a Brownian dynamics context, \\(\\gamma = \\frac{k_B T}{D}\\), where\n\\(k_B =\\) Boltzmann’s constant, T = temperature, and D = particle\ndiffusion coefficient.  D can be written as \\(\\frac{k_B T}{3 \\pi\n\\eta d}\\), where \\(\\eta =\\) dynamic viscosity of the frictional fluid\nand d = diameter of particle.  This means \\(\\gamma = 3 \\pi \\eta d\\),\nand thus is proportional to the viscosity of the fluid and the particle\ndiameter.\nIn the current implementation, rather than have the user specify a\nviscosity, \\(\\gamma\\) is specified directly in force/velocity units.\nIf needed, \\(\\gamma\\) can be adjusted for atoms of different sizes\n(i.e. \\(\\sigma\\)) by using the scale keyword.\nNote that Brownian dynamics models also typically include a randomized\nforce term to thermostat the system at a chosen temperature.  The\nfix langevin command does this.  It has the same\nviscous damping term as fix viscous and adds a random force to each\natom.  The random force term is proportional to the square root of the\nchosen thermostatting temperature.  Thus if you use fix langevin with a\ntarget \\(T = 0\\), its random force term is zero, and you are\nessentially performing the same operation as fix viscous.  Also note\nthat the gamma of fix viscous is related to the damping parameter of\nfix langevin, however the former is specified in\nunits of force/velocity and the latter in units of time, so that it can\nmore easily be used as a thermostat.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options are\nrelevant to this fix.  No global or per-atom quantities are stored by\nthis fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is modifying forces. Default is the outermost level.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.  This fix should only\nbe used with damped dynamics minimizers that allow for\nnon-conservative forces.  See the min_style command\nfor details.",
    "syntax": "fix ID group-ID viscous gamma keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * viscous = style name of this fix command\n * gamma = damping coefficient (force/velocity units)\n * zero or more keyword/value pairs may be appended\n * keyword = scale\n *   scale values = type ratio\n *     type = atom type (1-N)\n *     ratio = factor to scale the damping coefficient by",
    "examples": "fix 1 flow viscous 0.1\nfix 1 damp viscous 0.5 scale 3 2.5",
    "restrictions": "\nnone"
},
{
    "command": "fix wall/lj93",
    "html_filename": "fix_wall.html",
    "short_description": "Bound the simulation domain on one or more of its faces with a flat wall that interacts with the atoms in the group by generating a force on the atom in a direction perpendicular to the wall",
    "description": "Bound the simulation domain on one or more of its faces with a flat\nwall that interacts with the atoms in the group by generating a force\non the atom in a direction perpendicular to the wall.  The energy of\nwall-particle interactions depends on the style.\nFor style wall/lj93, the energy E is given by the 9/3 potential:\n\n\\[E = \\epsilon \\left[ \\frac{2}{15} \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                      \\left(\\frac{\\sigma}{r}\\right)^3 \\right]\n                      \\qquad r < r_c\\]\nFor style wall/lj126, the energy E is given by the 12/6 potential:\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c\\]\nFor style wall/lj1043, the energy E is given by the 10/4/3 potential:\n\n\\[E = 2 \\pi \\epsilon \\left[ \\frac{2}{5} \\left(\\frac{\\sigma}{r}\\right)^{10} -\n                      \\left(\\frac{\\sigma}{r}\\right)^4 -\n                      \\frac{\\sqrt(2)\\sigma^3}{3\\left(r+\\left(0.61/\\sqrt(2)\\right)\\sigma\\right)^3}\\right]\n                      \\qquad r < r_c\\]\nFor style wall/colloid, the energy E is given by an integrated form\nof the pair_style colloid potential:\n\n\\[\\begin{split}E = & \\epsilon \\left[ \\frac{\\sigma^{6}}{7560}\n\\left(\\frac{6R-D}{D^{7}} + \\frac{D+8R}{(D+2R)^{7}} \\right) \\right. \\\\\n & \\left. - \\frac{1}{6} \\left(\\frac{2R(D+R) + D(D+2R)\n \\left[ \\ln D - \\ln (D+2R) \\right]}{D(D+2R)} \\right) \\right] \\qquad r < r_c\\end{split}\\]\nFor style wall/harmonic, the energy E is given by a harmonic spring\npotential:\n\n\\[E = \\epsilon \\quad (r - r_c)^2 \\qquad r < r_c\\]\nFor style wall/morse, the energy E is given by a Morse potential:\n\n\\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n    \\qquad r < r_c\\]\nIn all cases, r is the distance from the particle to the wall at\nposition coord, and \\(r_c\\) is the cutoff distance at which the\nparticle and wall no longer interact.  The energy of the wall\npotential is shifted so that the wall-particle interaction energy is\n0.0 at the cutoff distance.\nUp to 6 walls or faces can be specified in a single command: xlo,\nxhi, ylo, yhi, zlo, zhi.  A lo face interacts with\nparticles near the lower side of the simulation box in that dimension.\nA hi face interacts with particles near the upper side of the\nsimulation box in that dimension.\nThe position of each wall can be specified in one of 3 ways: as the\nEDGE of the simulation box, as a constant value, or as a variable.  If\nEDGE is used, then the corresponding boundary of the current\nsimulation box is used.  If a numeric constant is specified then the\nwall is placed at that position in the appropriate dimension (x, y, or\nz).  In both the EDGE and constant cases, the wall will never move.\nIf the wall position is a variable, it should be specified as v_name,\nwhere name is an equal-style variable name.  In this\ncase the variable is evaluated each timestep and the result becomes\nthe current position of the reflecting wall.  Equal-style variables\ncan specify formulas with various mathematical functions, and include\nthermo_style command keywords for the simulation\nbox parameters and timestep and elapsed time.  Thus it is easy to\nspecify a time-dependent wall position.  See examples below.\nFor the wall/lj93 and wall/lj126 and wall/lj1043 styles,\n\\(\\epsilon\\) and \\(\\sigma\\) are the usual Lennard-Jones parameters, which\ndetermine the strength and size of the particle as it interacts with\nthe wall.  Epsilon has energy units.  Note that this \\(\\epsilon\\) and\n\\(\\sigma\\) may be different than any \\(\\epsilon\\) or \\(\\sigma\\) values defined\nfor a pair style that computes particle-particle interactions.\nThe wall/lj93 interaction is derived by integrating over a 3d\nhalf-lattice of Lennard-Jones 12/6 particles.  The wall/lj126\ninteraction is effectively a harder, more repulsive wall interaction.\nThe wall/lj1043 interaction is yet a different form of wall\ninteraction, described in Magda et al in (Magda).\nFor the wall/colloid style, R is the radius of the colloid particle,\nD is the distance from the surface of the colloid particle to the wall\n(r-R), and \\(\\sigma\\) is the size of a constituent LJ particle\ninside the colloid particle and wall.  Note that the cutoff distance Rc\nin this case is the distance from the colloid particle center to the\nwall.  The prefactor \\(\\epsilon\\) can be thought of as an effective\nHamaker constant with energy units for the strength of the colloid-wall\ninteraction.  More specifically, the \\(\\epsilon\\) pre-factor is\n\\(4\\pi^2 \\rho_{wall} \\rho_{colloid} \\epsilon \\sigma^6\\), where\n\\(\\epsilon\\) and \\(\\sigma\\) are the LJ parameters for the\nconstituent LJ particles. \\(\\rho_{wall}\\) and \\(\\rho_{colloid}\\)\nare the number density of the constituent particles, in the wall and\ncolloid respectively, in units of 1/volume.\nThe wall/colloid interaction is derived by integrating over\nconstituent LJ particles of size \\(\\sigma\\) within the colloid particle\nand a 3d half-lattice of Lennard-Jones 12/6 particles of size \\(\\sigma\\)\nin the wall.  As mentioned in the preceding paragraph, the density of\nparticles in the wall and colloid can be different, as specified by\nthe \\(\\epsilon\\) pre-factor.\nFor the wall/harmonic style, \\(\\epsilon\\) is effectively the spring\nconstant K, and has units (energy/distance^2).  The input parameter\n\\(\\sigma\\) is ignored.  The minimum energy position of the harmonic\nspring is at the cutoff.  This is a repulsive-only spring since the\ninteraction is truncated at the cutoff\nFor the wall/morse style, the three parameters are in this order:\n\\(D_0\\) the depth of the potential, \\(\\alpha\\) the width parameter, and\n\\(r_0\\) the location of the minimum.  \\(D_0\\) has energy units, \\(\\alpha\\)\ninverse distance units, and \\(r_0\\) distance units.\nFor any wall, the \\(\\epsilon\\) and/or \\(\\sigma\\) and/or \\(\\alpha\\) parameter can\nbe specified\nas an equal-style variable, in which case it should be\nspecified as v_name, where name is the variable name.  As with a\nvariable wall position, the variable is evaluated each timestep and\nthe result becomes the current epsilon or sigma of the wall.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent wall interaction.\n\nNote\nFor all of the styles, you must insure that r is always > 0 for\nall particles in the group, or LAMMPS will generate an error.  This\nmeans you cannot start your simulation with particles at the wall\nposition coord (r = 0) or with particles on the wrong side of the\nwall (r < 0).  For the wall/lj93 and wall/lj126 styles, the energy\nof the wall/particle interaction (and hence the force on the particle)\nblows up as r -> 0.  The wall/colloid style is even more\nrestrictive, since the energy blows up as D = r-R -> 0.  This means\nthe finite-size particles of radius R must be a distance larger than R\nfrom the wall position coord.  The harmonic style is a softer\npotential and does not blow up as r -> 0, but you must use a large\nenough \\(\\epsilon\\) that particles always reamin on the correct side of\nthe wall (r > 0).\n\nThe units keyword determines the meaning of the distance units used\nto define a wall position, but only when a numeric constant or\nvariable is used.  It is not relevant when EDGE is used to specify a\nface position.  In the variable case, the variable is assumed to\nproduce a value compatible with the units setting you specify.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings.\nThe fld keyword can be used with a yes setting to invoke the wall\nconstraint before pairwise interactions are computed.  This allows an\nimplicit FLD model using pair_style lubricateU\nto include the wall force in its calculations.  If the setting is\nno, wall forces are imposed after pairwise interactions, in the\nusual manner.\nThe pbc keyword can be used with a yes setting to allow walls to\nbe specified in a periodic dimension.  See the\nboundary command for options on simulation box\nboundaries.  The default for pbc is no, which means the system\nmust be non-periodic when using a wall.  But you may wish to use a\nperiodic box.  E.g. to allow some particles to interact with the wall\nvia the fix group-ID, and others to pass through it and wrap around a\nperiodic box.  In this case you should insure that the wall if\nsufficiently far enough away from the box boundary.  If you do not,\nthen particles may interact with both the wall and with periodic\nimages on the other side of the box, which is probably not what you\nwant.\n\nHere are examples of variable definitions that move the wall position\nin a time-dependent fashion using equal-style\nvariables.  The wall interaction parameters (epsilon,\nsigma) could be varied with additional variable definitions.\nvariable ramp equal ramp(0,10)\nfix 1 all wall xlo v_ramp 1.0 1.0 2.5\n\nvariable linear equal vdisplace(0,20)\nfix 1 all wall xlo v_linear 1.0 1.0 2.5\n\nvariable wiggle equal swiggle(0.0,5.0,3.0)\nfix 1 all wall xlo v_wiggle 1.0 1.0 2.5\n\nvariable wiggle equal cwiggle(0.0,5.0,3.0)\nfix 1 all wall xlo v_wiggle 1.0 1.0 2.5\n\n\nThe ramp(lo,hi) function adjusts the wall position linearly from lo to\nhi over the course of a run.  The vdisplace(c0,velocity) function does\nsomething similar using the equation position = c0 + velocity*delta,\nwhere delta is the elapsed time.\nThe swiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, where omega = 2 PI\n/ period:\nposition = c0 + A sin(omega*delta)\nThe cwiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, which will have an\ninitial wall velocity of 0.0, and thus may impose a gentler\nperturbation on the particles:\nposition = c0 + A (1 - cos(omega*delta))\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy of interaction between atoms and each wall to\nthe system’s potential energy as part of thermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the interaction between\natoms and each wall to the system’s virial as part of thermodynamic output. The default is virial no\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar energy and a global vector of\nforces, which can be accessed by various output commands.  Note that the scalar energy is the sum\nof interactions with all defined walls.  If you want the energy on a\nper-wall basis, you need to use multiple fix wall commands.  The\nlength of the vector is equal to the number of walls defined by the\nfix.  Each vector value is the normal force on a specific wall.  Note\nthat an outward force on a wall will be a negative value for lo\nwalls and a positive value for hi walls.  The scalar and vector\nvalues calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the atom/wall interaction energy to be included in\nthe total potential energy of the system (the quantity being\nminimized), you MUST enable the fix_modify energy\noption for this fix.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "fix ID group-ID style face args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * style = wall/lj93 or wall/lj126 or wall/lj1043 or wall/colloid or wall/harmonic or wall/morse\n * one or more face/arg pairs may be appended\n * face = xlo or xhi or ylo or yhi or zlo or zhi\n * args for styles lj93 or lj126 or lj1043 or colloid or harmonic\n * args = coord epsilon sigma cutoff\n * coord = position of wall = EDGE or constant or variable\n *   EDGE = current lo or hi edge of simulation box\n *   constant = number like 0.0 or -30.0 (distance units)\n *   variable = equal-style variable like v_x or v_wiggle\n * epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n *   epsilon can be a variable (see below)\n * sigma = size factor for wall-particle interaction (distance units)\n *   sigma can be a variable (see below)\n * cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n * args for style morse\n * args = coord D_0 alpha r_0 cutoff\n * coord = position of wall = EDGE or constant or variable\n *   EDGE = current lo or hi edge of simulation box\n *   constant = number like 0.0 or -30.0 (distance units)\n *   variable = equal-style variable like v_x or v_wiggle\n * D_0 = depth of the potential (energy units)\n *   D_0 can be a variable (see below)\n * alpha = width factor for wall-particle interaction (1/distance units)\n *   alpha can be a variable (see below)\n * r_0 = distance of the potential minimum from the face of region (distance units)\n *   r_0 can be a variable (see below)\n * cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n * zero or more keyword/value pairs may be appended\n * keyword = units or fld\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units\n * fld value = yes or no\n *   yes = invoke the wall constraint to be compatible with implicit FLD\n *   no = invoke the wall constraint in the normal way\n * pbc value = yes or no\n *   yes = allow periodic boundary in a wall dimension\n *   no = require non-perioidic boundaries in any wall dimension",
    "examples": "fix wallhi all wall/lj93 xlo -1.0 1.0 1.0 2.5 units box\nfix wallhi all wall/lj93 xhi EDGE 1.0 1.0 2.5\nfix wallhi all wall/morse xhi EDGE 1.0 1.0 1.0 2.5 units box\nfix wallhi all wall/lj126 v_wiggle 23.2 1.0 1.0 2.5\nfix zwalls all wall/colloid zlo 0.0 1.0 1.0 0.858 zhi 40.0 1.0 1.0 0.858",
    "restrictions": "\nnone"
},
{
    "command": "fix wall/body/polygon",
    "html_filename": "fix_wall_body_polygon.html",
    "short_description": "This fix is for use with 2d models of body particles of style rounded/polygon",
    "description": "This fix is for use with 2d models of body particles of style\nrounded/polygon.  It bounds the simulation domain with wall(s).  All\nparticles in the group interact with the wall when they are close\nenough to touch it.  The nature of the interaction between the wall\nand the polygon particles is the same as that between the polygon\nparticles themselves, which is similar to a Hookean potential.  See\nthe Howto body doc page for more details on using\nbody particles.\nThe parameters k_n, c_n, c_t have the same meaning and units as\nthose specified with the pair_style body/rounded/polygon command.\nThe wallstyle can be planar or cylindrical.  The 2 planar options\nspecify a pair of walls in a dimension.  Wall positions are given by\nlo and hi.  Either of the values can be specified as NULL if a\nsingle wall is desired.  For a zcylinder wallstyle, the cylinder’s\naxis is at x = y = 0.0, and the radius of the cylinder is specified.\nOptionally, the wall can be moving, if the wiggle keyword is\nappended.\nFor the wiggle keyword, the wall oscillates sinusoidally, similar to\nthe oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\nparticles.  The arguments to the wiggle keyword specify a dimension\nfor the motion, as well as it’s amplitude and period.  Note that\nif the dimension is in the plane of the wall, this is effectively a\nshearing motion.  If the dimension is perpendicular to the wall, it is\nmore of a shaking motion.  A zcylinder wall can only be wiggled in\nthe z dimension.\nEach timestep, the position of a wiggled wall in the appropriate dim\nis set according to this equation:\nposition = coord + A - A cos (omega * delta)\nwhere coord is the specified initial position of the wall, A is\nthe amplitude, omega is 2 PI / period, and delta is the time\nelapsed since the fix was specified.  The velocity of the wall is set\nto the derivative of this expression.\nRestart, fix_modify, output, run start/stop, minimize info:\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/body/polygon k_n c_n c_t wallstyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/body/polygon = style name of this fix command\n * k_n = normal repulsion strength (force/distance or pressure units)\n * c_n = normal damping coefficient (force/distance or pressure units)\n * c_t = tangential damping coefficient (force/distance or pressure units)\n * wallstyle = xplane or yplane or zplane or zcylinder\n * args = list of arguments for a particular style\n * xplane or yplane args = lo hi\n *   lo,hi = position of lower and upper plane (distance units), either can be NULL)\n * zcylinder args = radius\n *   radius = cylinder radius (distance units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = wiggle\n * wiggle values = dim amplitude period\n *   dim = x or y or z\n *   amplitude = size of oscillation (distance units)\n *   period = time of oscillation (time units)",
    "examples": "fix 1 all wall/body/polygon 1000.0 20.0 5.0 xplane -10.0 10.0",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nAny dimension (xy) that has a wall must be non-periodic."
},
{
    "command": "fix wall/body/polyhedron",
    "html_filename": "fix_wall_body_polyhedron.html",
    "short_description": "This fix is for use with 3d models of body particles of style rounded/polyhedron",
    "description": "This fix is for use with 3d models of body particles of style\nrounded/polyhedron.  It bounds the simulation domain with wall(s).\nAll particles in the group interact with the wall when they are close\nenough to touch it.  The nature of the interaction between the wall\nand the polygon particles is the same as that between the polygon\nparticles themselves, which is similar to a Hookean potential.  See\nthe Howto body doc page for more details on using\nbody particles.\nThe parameters k_n, c_n, c_t have the same meaning and units as\nthose specified with the pair_style body/rounded/polyhedron command.\nThe wallstyle can be planar or cylindrical.  The 3 planar options\nspecify a pair of walls in a dimension.  Wall positions are given by\nlo and hi.  Either of the values can be specified as NULL if a\nsingle wall is desired.  For a zcylinder wallstyle, the cylinder’s\naxis is at x = y = 0.0, and the radius of the cylinder is specified.\nOptionally, the wall can be moving, if the wiggle keyword is appended.\nFor the wiggle keyword, the wall oscillates sinusoidally, similar to\nthe oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\nparticles.  The arguments to the wiggle keyword specify a dimension\nfor the motion, as well as it’s amplitude and period.  Note that\nif the dimension is in the plane of the wall, this is effectively a\nshearing motion.  If the dimension is perpendicular to the wall, it is\nmore of a shaking motion.  A zcylinder wall can only be wiggled in\nthe z dimension.\nEach timestep, the position of a wiggled wall in the appropriate dim\nis set according to this equation:\nposition = coord + A - A cos (omega * delta)\nwhere coord is the specified initial position of the wall, A is\nthe amplitude, omega is 2 PI / period, and delta is the time\nelapsed since the fix was specified.  The velocity of the wall is set\nto the derivative of this expression.\nRestart, fix_modify, output, run start/stop, minimize info:\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/body/polyhedron k_n c_n c_t wallstyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/body/polyhedron = style name of this fix command\n * k_n = normal repulsion strength (force/distance units or pressure units - see discussion below)\n * c_n = normal damping coefficient (force/distance units or pressure units - see discussion below)\n * c_t = tangential damping coefficient (force/distance units or pressure units - see discussion below)\n * wallstyle = xplane or yplane or zplane or zcylinder\n * args = list of arguments for a particular style\n * xplane or yplane args = lo hi\n *   lo,hi = position of lower and upper plane (distance units), either can be NULL)\n * zcylinder args = radius\n *   radius = cylinder radius (distance units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = wiggle\n * wiggle values = dim amplitude period\n *   dim = x or y or z\n *   amplitude = size of oscillation (distance units)\n *   period = time of oscillation (time units)",
    "examples": "fix 1 all wall/body/polyhedron 1000.0 20.0 5.0 xplane -10.0 10.0",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nAny dimension (xyz) that has a wall must be non-periodic."
},
{
    "command": "fix wall/ees",
    "html_filename": "fix_wall_ees.html",
    "short_description": "Fix wall/ees bounds the simulation domain on one or more of its faces with a flat wall that interacts with the ellipsoidal atoms in the group by generating a force on the atom in a direction perpendicular to the wall and a torque parallel with the wall",
    "description": "Fix wall/ees bounds the simulation domain on one or more of its\nfaces with a flat wall that interacts with the ellipsoidal atoms in the\ngroup by generating a force on the atom in a direction perpendicular to\nthe wall and a torque parallel with the wall.  The energy of\nwall-particle interactions E is given by:\n\n\\[E = \\epsilon \\left[ \\frac{2  \\sigma_{LJ}^{12} \\left(7 r^5+14 r^3 \\sigma_{n}^2+3 r \\sigma_{n}^4\\right) }{945 \\left(r^2-\\sigma_{n}^2\\right)^7} -\\frac{ \\sigma_{LJ}^6 \\left(2 r \\sigma_{n}^3+\\sigma_{n}^2 \\left(r^2-\\sigma_{n}^2\\right)\\log{ \\left[\\frac{r-\\sigma_{n}}{r+\\sigma_{n}}\\right]}\\right) }{12 \\sigma_{n}^5 \\left(r^2-\\sigma_{n}^2\\right)} \\right]\\qquad \\sigma_n < r < r_c\\]\nIntroduced by Babadi and Ejtehadi in (Babadi). Here,\nr is the distance from the particle to the wall at position coord,\nand Rc is the cutoff distance at which the particle and wall no\nlonger interact. Also, \\(\\sigma_n\\) is the distance between center of\nellipsoid and the nearest point of its surface to the wall as shown below.\n\nDetails of using this command and specifications are the same as\nfix/wall command. You can also find an example in USER/ees/ under\nexamples/ directory.\nThe prefactor \\(\\epsilon\\) can be thought of as an\neffective Hamaker constant with energy units for the strength of the\nellipsoid-wall interaction.  More specifically, the \\(\\epsilon\\)\npre-factor is\n\n\\[8 \\pi^2 \\quad \\rho_{wall} \\quad \\rho_{ellipsoid} \\quad \\epsilon \\quad \\sigma_a \\quad \\sigma_b \\quad \\sigma_c\\]\nwhere \\(\\epsilon\\) is the LJ energy parameter for the constituent LJ\nparticles and \\(\\sigma_a\\), \\(\\sigma_b\\), and \\(\\sigma_c\\)\nare the radii of the ellipsoidal particles. \\(\\rho_{wall}\\) and\n\\(\\rho_{ellipsoid}\\) are the number density of the constituent\nparticles, in the wall and ellipsoid respectively, in units of 1/volume.\n\nNote\nYou must insure that r is always bigger than \\(\\sigma_n\\) for\nall particles in the group, or LAMMPS will generate an error.  This\nmeans you cannot start your simulation with particles touching the wall\nposition coord (\\(r = \\sigma_n\\)) or with particles penetrating\nthe wall (\\(0 =< r < \\sigma_n\\)) or with particles on the wrong\nside of the wall (\\(r < 0\\)).\n\nFix wall/region/ees treats the surface of the geometric region defined\nby the region-ID as a bounding wall which interacts with nearby\nellipsoidal particles according to the EES potential introduced above.\nOther details of this command are the same as for the fix wall/region command.  One may also find an example\nof using this fix in the examples/USER/misc/ees/ directory.",
    "syntax": "fix ID group-ID style args",
    "parameters": " * ID, group-ID are documented in fix command\n * style = wall/ees or wall/region/ees\n * args for style wall/ees: one or more face parameters groups may be appended\n * face = xlo or xhi or ylo or yhi or zlo or zhi\n * parameters = coord epsilon sigma cutoff\n *   coord = position of wall = EDGE or constant or variable\n *     EDGE = current lo or hi edge of simulation box\n *     constant = number like 0.0 or -30.0 (distance units)\n *     variable = equal-style variable like v_x or v_wiggle\n *   epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n *     epsilon can be a variable (see below)\n *   sigma = size factor for wall-particle interaction (distance units)\n *     sigma can be a variable (see below)\n *   cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n * args for style wall/region/ees: region-ID epsilon sigma cutoff\n *   region-ID = region whose boundary will act as wall\n *   epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n *   sigma = size factor for wall-particle interaction (distance units)\n *   cutoff = distance from wall at which wall-particle interaction is cut off (distance units)",
    "examples": "fix wallhi all wall/ees xlo -1.0 1.0 1.0 2.5 units box\nfix wallhi all wall/ees xhi EDGE 1.0 1.0 2.5\nfix wallhi all wall/ees v_wiggle 23.2 1.0 1.0 2.5\nfix zwalls all wall/ees zlo 0.0 1.0 1.0 0.858 zhi 40.0 1.0 1.0 0.858\n\nfix ees_cube all wall/region/ees myCube 1.0 1.0 2.5",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis fix requires that atoms be ellipsoids as defined by the\natom_style ellipsoid command."
},
{
    "command": "fix wall/gran",
    "html_filename": "fix_wall_gran.html",
    "short_description": "Bound the simulation domain of a granular system with a frictional wall",
    "description": "Bound the simulation domain of a granular system with a frictional\nwall.  All particles in the group interact with the wall when they are\nclose enough to touch it.\nThe nature of the wall/particle interactions are determined by the\nfstyle setting.  It can be any of the styles defined by the\npair_style gran/* or the more general\npair_style granular commands.  Currently the\noptions are hooke, hooke/history, or hertz/history for the\nformer, and granular with all the possible options of the associated\npair_coeff command for the latter.  The equation for the force\nbetween the wall and particles touching it is the same as the\ncorresponding equation on the pair_style gran/* and\npair_style granular doc pages, in the limit of\none of the two particles going to infinite radius and mass (flat wall).\nSpecifically, delta = radius - r = overlap of particle with wall, m_eff\n= mass of particle, and the effective radius of contact = RiRj/Ri+Rj is\nset to the radius of the particle.\nThe parameters Kn, Kt, gamma_n, gamma_t, xmu and dampflag\nhave the same meaning and units as those specified with the\npair_style gran/* commands.  This means a NULL can be\nused for either Kt or gamma_t as described on that page.  If a\nNULL is used for Kt, then a default value is used where Kt = 2/7\nKn.  If a NULL is used for gamma_t, then a default value is used\nwhere gamma_t = 1/2 gamma_n.\nAll the model choices for cohesion, tangential friction, rolling\nfriction and twisting friction supported by the pair_style granular through its pair_coeff command are also\nsupported for walls. These are discussed in greater detail on the doc\npage for pair_style granular.\nNote that you can choose a different force styles and/or different\nvalues for the wall/particle coefficients than for particle/particle\ninteractions.  E.g. if you wish to model the wall as a different\nmaterial.\n\nNote\nAs discussed on the doc page for pair_style gran/*, versions of LAMMPS before 9Jan09 used a\ndifferent equation for Hertzian interactions.  This means Hertizian\nwall/particle interactions have also changed.  They now include a\nsqrt(radius) term which was not present before.  Also the previous\nversions used Kn and Kt from the pairwise interaction and hardwired\ndampflag to 1, rather than letting them be specified directly.  This\nmeans you can set the values of the wall/particle coefficients\nappropriately in the current code to reproduce the results of a\nprevious Hertzian monodisperse calculation.  For example, for the\ncommon case of a monodisperse system with particles of diameter 1, Kn,\nKt, gamma_n, and gamma_s should be set sqrt(2.0) larger than they were\npreviously.\n\nThe effective mass m_eff in the formulas listed on the pair_style granular doc page is the mass of the particle for\nparticle/wall interactions (mass of wall is infinite).  If the\nparticle is part of a rigid body, its mass is replaced by the mass of\nthe rigid body in those formulas.  This is determined by searching for\na fix rigid command (or its variants).\nThe wallstyle can be planar or cylindrical.  The 3 planar options\nspecify a pair of walls in a dimension.  Wall positions are given by\nlo and hi.  Either of the values can be specified as NULL if a\nsingle wall is desired.  For a zcylinder wallstyle, the cylinder’s\naxis is at x = y = 0.0, and the radius of the cylinder is specified.\nOptionally, the wall can be moving, if the wiggle or shear\nkeywords are appended.  Both keywords cannot be used together.\nFor the wiggle keyword, the wall oscillates sinusoidally, similar to\nthe oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\ngranular particles.  The arguments to the wiggle keyword specify a\ndimension for the motion, as well as it’s amplitude and period.\nNote that if the dimension is in the plane of the wall, this is\neffectively a shearing motion.  If the dimension is perpendicular to\nthe wall, it is more of a shaking motion.  A zcylinder wall can only\nbe wiggled in the z dimension.\nEach timestep, the position of a wiggled wall in the appropriate dim\nis set according to this equation:\nposition = coord + A - A cos (omega * delta)\nwhere coord is the specified initial position of the wall, A is\nthe amplitude, omega is 2 PI / period, and delta is the time\nelapsed since the fix was specified.  The velocity of the wall is set\nto the derivative of this expression.\nFor the shear keyword, the wall moves continuously in the specified\ndimension with velocity vshear.  The dimension must be tangential to\nwalls with a planar wallstyle, e.g. in the y or z directions for\nan xplane wall.  For zcylinder walls, a dimension of z means the\ncylinder is moving in the z-direction along it’s axis.  A dimension of\nx or y means the cylinder is spinning around the z-axis, either in\nthe clockwise direction for vshear > 0 or counter-clockwise for\nvshear < 0.  In this case, vshear is the tangential velocity of\nthe wall at whatever radius has been defined.\nRestart, fix_modify, output, run start/stop, minimize info:\nThis fix writes the shear friction state of atoms interacting with the\nwall to binary restart files, so that a simulation can\ncontinue correctly if granular potentials with shear “history” effects\nare being used.  See the read_restart command for\ninfo on how to re-specify a fix in an input script that reads a\nrestart file, so that the operation of the fix continues in an\nuninterrupted fashion.\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/gran fstyle fstyle_params wallstyle args keyword values ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/gran = style name of this fix command\n * fstyle = style of force interactions between particles and wall\n * possible choices: hooke, hooke/history, hertz/history, granular\n * fstyle_params = parameters associated with force interaction style\n * For hooke, hooke/history, and hertz/history, fstyle_params are:\n *       Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n *       Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n *       gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n *       gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n *       xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n *       dampflag = 0 or 1 if tangential damping force is excluded or included\n * For granular, fstyle_params are set using the same syntax as for the pair_coeff command of pair_style granular\n * wallstyle = xplane or yplane or zplane or zcylinder\n * args = list of arguments for a particular style\n * xplane or yplane or zplane args = lo hi\n *   lo,hi = position of lower and upper plane (distance units), either can be NULL)\n * zcylinder args = radius\n *   radius = cylinder radius (distance units)\n * zero or more keyword/value pairs may be appended to args\n * keyword = wiggle or shear\n * wiggle values = dim amplitude period\n *   dim = x or y or z\n *   amplitude = size of oscillation (distance units)\n *   period = time of oscillation (time units)\n * shear values = dim vshear\n *   dim = x or y or z\n *   vshear = magnitude of shear velocity (velocity units)",
    "examples": "fix 1 all wall/gran hooke  200000.0 NULL 50.0 NULL 0.5 0 xplane -10.0 10.0\nfix 1 all wall/gran hooke/history 200000.0 NULL 50.0 NULL 0.5 0 zplane 0.0 NULL\nfix 2 all wall/gran hooke 100000.0 20000.0 50.0 30.0 0.5 1 zcylinder 15.0 wiggle z 3.0 2.0\nfix 3 all wall/gran/region granular hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping velocity region myBox\nfix 4 all wall/gran/region granular jkr 1e5 1500.0 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall region myCone\nfix 5 all wall/gran/region granular dmt 1e5 0.2 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall damping tsuji region myCone",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nAny dimension (xyz) that has a granular wall must be non-periodic."
},
{
    "command": "fix wall/gran/region",
    "html_filename": "fix_wall_gran_region.html",
    "short_description": "Treat the surface of the geometric region defined by the region-ID as a bounding frictional wall which interacts with nearby finite-size granular particles when they are close enough to touch the wall",
    "description": "Treat the surface of the geometric region defined by the region-ID\nas a bounding frictional wall which interacts with nearby finite-size\ngranular particles when they are close enough to touch the wall.  See\nthe fix wall/region and fix wall/gran commands for related kinds of walls for\nnon-granular particles and simpler wall geometries, respectively.\nHere are snapshots of example models using this command.\nCorresponding input scripts can be found in examples/granregion.\nClick on the images to see a bigger picture.  Movies of these\nsimulations are here on the Movies page of the LAMMPS\nweb site.\n\n\n\nThe distance between a particle and the region boundary is the\ndistance to the nearest point on the region surface.  The force the\nwall exerts on the particle is along the direction between that point\nand the particle center, which is the direction normal to the surface\nat that point.  Note that if the region surface is comprised of\nmultiple “faces”, then each face can exert a force on the particle if\nit is close enough.  E.g. for region_style block, a\nparticle in the interior, near a corner of the block, could feel wall\nforces from 1, 2, or 3 faces of the block.\nRegions are defined using the region command.  Note that\nthe region volume can be interior or exterior to the bounding surface,\nwhich will determine in which direction the surface interacts with\nparticles, i.e. the direction of the surface normal. The exception to\nthis is if one or more open options are specified for the region\ncommand, in which case particles interact with both the interior and\nexterior surfaces of regions.\nRegions can either be primitive shapes (block, sphere, cylinder, etc)\nor combinations of primitive shapes specified via the union or\nintersect region styles.  These latter styles can be used to\nconstruct particle containers with complex shapes.\nRegions can also move dynamically via the region command\nkeywords (move) and rotate, or change their shape by use of variables\nas inputs to the region command.  If such a region is used\nwith this fix, then the region surface will move in time in the\ncorresponding manner.\n\nNote\nAs discussed on the region command doc page,\nregions in LAMMPS do not get wrapped across periodic boundaries.  It\nis up to you to ensure that the region location with respect to\nperiodic or non-periodic boundaries is specified appropriately via the\nregion and boundary commands when using\na region as a wall that bounds particle motion.\n\n\nNote\nFor primitive regions with sharp corners and/or edges (e.g. a\nblock or cylinder), wall/particle forces are computed accurately for\nboth interior and exterior regions.  For union and intersect\nregions, additional sharp corners and edges may be present due to the\nintersection of the surfaces of 2 or more primitive volumes.  These\ncorners and edges can be of two types: concave or convex.  Concave\npoints/edges are like the corners of a cube as seen by particles in\nthe interior of a cube.  Wall/particle forces around these features\nare computed correctly.  Convex points/edges are like the corners of a\ncube as seen by particles exterior to the cube, i.e. the points jut\ninto the volume where particles are present.  LAMMPS does NOT compute\nthe location of these convex points directly, and hence wall/particle\nforces in the cutoff volume around these points suffer from\ninaccuracies.  The basic problem is that the outward normal of the\nsurface is not continuous at these points.  This can cause particles\nto feel no force (they don’t “see” the wall) when in one location,\nthen move a distance epsilon, and suddenly feel a large force because\nthey now “see” the wall.  In a worst-case scenario, this can blow\nparticles out of the simulation box.  Thus, as a general rule you\nshould not use the fix wall/gran/region command with union or\ninteresect regions that have convex points or edges resulting from\nthe union/intersection (convex points/edges in the union/intersection\ndue to a single sub-region are still OK).\n\n\nNote\nSimilarly, you should not define union or intersert regions\nfor use with this command that share an overlapping common face that\nis part of the overall outer boundary (interior boundary is OK), even\nif the face is smooth.  E.g. two regions of style block in a union\nregion, where the two blocks overlap on one or more of their faces.\nThis is because LAMMPS discards points that are part of multiple\nsub-regions when calculating wall/particle interactions, to avoid\ndouble-counting the interaction.  Having two coincident faces could\ncause the face to become invisible to the particles.  The solution is\nto make the two faces differ by epsilon in their position.\n\nThe nature of the wall/particle interactions are determined by the\nfstyle setting.  It can be any of the styles defined by the\npair_style gran/* or the more general\npair_style granular commands.  Currently the\noptions are hooke, hooke/history, or hertz/history for the\nformer, and granular with all the possible options of the associated\npair_coeff command for the latter.  The equation for the force\nbetween the wall and particles touching it is the same as the\ncorresponding equation on the pair_style gran/* and\npair_style granular doc pages, but the effective\nradius is calculated using the radius of the particle and the radius of\ncurvature of the wall at the contact point.\nSpecifically, delta = radius - r = overlap of particle with wall,\nm_eff = mass of particle, and RiRj/Ri+Rj is the effective radius, with\nRj replaced by the radius of curvature of the wall at the contact\npoint.  The radius of curvature can be negative for a concave wall\nsection, e.g. the interior of cylinder.  For a flat wall, delta =\nradius - r = overlap of particle with wall, m_eff = mass of particle,\nand the effective radius of contact is just the radius of the\nparticle.\nThe parameters Kn, Kt, gamma_n, gamma_t, xmu and dampflag\nhave the same meaning and units as those specified with the\npair_style gran/* commands.  This means a NULL can be\nused for either Kt or gamma_t as described on that page.  If a\nNULL is used for Kt, then a default value is used where Kt = 2/7\nKn.  If a NULL is used for gamma_t, then a default value is used\nwhere gamma_t = 1/2 gamma_n.\nAll the model choices for cohesion, tangential friction, rolling\nfriction and twisting friction supported by the pair_style granular through its pair_coeff command are also\nsupported for walls. These are discussed in greater detail on the doc\npage for pair_style granular.\nNote that you can choose a different force styles and/or different\nvalues for the 6 wall/particle coefficients than for particle/particle\ninteractions.  E.g. if you wish to model the wall as a different\nmaterial.\nRestart, fix_modify, output, run start/stop, minimize info:\nSimilar to fix wall/gran command, this fix writes\nthe shear friction state of atoms interacting with the wall to binary restart files, so that a simulation can continue\ncorrectly if granular potentials with shear “history” effects are\nbeing used.  This fix also includes info about a moving region in the\nrestart file.  See the read_restart command for\ninfo on how to re-specify a fix in an input script that reads a\nrestart file, so that the operation of the fix continues in an\nuninterrupted fashion.\n\nNote\nInformation about region definitions is NOT included in restart\nfiles, as discussed on the read_restart doc page.\nSo you must re-define your region and if it is a moving region, define\nits motion attributes in a way that is consistent with the simulation\nthat wrote the restart file.  In particular, if you want to change the\nregion motion attributes (e.g. its velocity), then you should ensure\nthe position/orientation of the region at the initial restart timestep\nis the same as it was on the timestep the restart file was written.\nIf this is not possible, you may need to ignore info in the restart\nfile by defining a new fix wall/gran/region command in your restart\nscript, e.g. with a different fix ID.  Or if you want to keep the\nshear history info but discard the region motion information, you can\nuse the same fix ID for fix wall/gran/region, but assign it a region\nwith a different region ID.\n\nNone of the fix_modify options are relevant to this\nfix.  No global or per-atom quantities are stored by this fix for\naccess by various output commands.  No parameter\nof this fix can be used with the start/stop keywords of the\nrun command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/gran/region fstyle fstyle_params wallstyle regionID",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/region = style name of this fix command\n * fstyle = style of force interactions between particles and wall\n * possible choices: hooke, hooke/history, hertz/history, granular\n * fstyle_params = parameters associated with force interaction style\n * For hooke, hooke/history, and hertz/history, fstyle_params are:\n *       Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n *       Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n *       gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n *       gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n *       xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n *       dampflag = 0 or 1 if tangential damping force is excluded or included\n * For granular, fstyle_params are set using the same syntax as for the pair_coeff command of pair_style granular\n * wallstyle = region (see fix wall/gran for options for other kinds of walls)\n * region-ID = region whose boundary will act as wall",
    "examples": "fix wall all wall/gran/region hooke/history 1000.0 200.0 200.0 100.0 0.5 1 region myCone\nfix 3 all wall/gran/region granular hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping velocity region myBox\nfix 4 all wall/gran/region granular jkr 1e5 1500.0 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall region myCone\nfix 5 all wall/gran/region granular dmt 1e5 0.2 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall damping tsuji region myCone",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix wall/piston",
    "html_filename": "fix_wall_piston.html",
    "short_description": "Bound the simulation with a moving wall which reflect particles in the specified group and drive the system with an effective infinite-mass piston capable of driving shock waves",
    "description": "Bound the simulation with a moving wall which reflect particles in the\nspecified group and drive the system with an effective infinite-mass\npiston capable of driving shock waves.\nA momentum mirror technique is used, which means that if an atom (or\nthe wall) moves such that an atom is outside the wall on a timestep by\na distance delta (e.g. due to fix nve), then it is put\nback inside the face by the same delta, and the velocity relative to\nthe moving wall is flipped in z.  For instance, a stationary particle\nhit with a piston wall with velocity vz, will end the timestep with a\nvelocity of 2*vz.\nCurrently the face keyword can only be zlo.  This creates a piston\nmoving in the positive z direction.  Particles with z coordinate less\nthan the wall position are reflected to a z coordinate greater than\nthe wall position.  If the piston velocity is vpz and the particle\nvelocity before reflection is vzi, the particle velocity after\nreflection is -vzi + 2*vpz.\nThe initial position of the wall can be specified by the pos keyword.\nThe final velocity of the wall can be specified by the vel keyword\nThe ramp keyword will cause the wall/piston to adjust the velocity\nlinearly from zero velocity to vel over the course of the run. If\nthe ramp keyword is omitted then the wall/piston moves at a constant\nvelocity defined by vel.\nThe temp keyword will cause the region immediately in front of the\nwall/piston to be thermostatted with a Langevin thermostat.  This\nregion moves with the piston.  The damping and kicking are measured in\nthe reference frame of the piston.  So, a temperature of zero would\nmean all particles were moving at exactly the speed of the\nwall/piston.\nThe units keyword determines the meaning of the distance units used\nto define a wall position, but only when a numeric constant is used.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.  No global or per-atom quantities are stored\nby this fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/piston face ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/piston = style name of this fix command\n * face = zlo\n * zero or more keyword/value pairs may be appended\n * keyword = pos or vel or ramp or units\n * pos args = z\n *   z = z coordinate at which the piston begins (distance units)\n * vel args = vz\n *   vz = final velocity of the piston (velocity units)\n * ramp = use a linear velocity ramp from 0 to vz\n * temp args = target damp seed extent\n *   target = target velocity for region immediately ahead of the piston\n *   damp = damping parameter (time units)\n *   seed = random number seed for langevin kicks\n *   extent = extent of thermostatted region (distance units)\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units",
    "examples": "fix xwalls all wall/piston zlo\nfix walls all wall/piston zlo pos 1.0 vel 10.0 units box\nfix top all wall/piston zlo vel 10.0 ramp",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nThe face that has the wall/piston must be boundary type ‘s’\n(shrink-wrapped). The opposing face can be\nany boundary type other than periodic.\nA wall/piston should not be used with rigid bodies such as those\ndefined by a “fix rigid” command.  This is because the wall/piston\ndisplaces atoms directly rather than exerting a force on them."
},
{
    "command": "fix wall/reflect",
    "html_filename": "fix_wall_reflect.html",
    "short_description": "Bound the simulation with one or more walls which reflect particles in the specified group when they attempt to move through them",
    "description": "Bound the simulation with one or more walls which reflect particles\nin the specified group when they attempt to move through them.\nReflection means that if an atom moves outside the wall on a timestep\nby a distance delta (e.g. due to fix nve), then it is\nput back inside the face by the same delta, and the sign of the\ncorresponding component of its velocity is flipped.\nWhen used in conjunction with fix nve and\nrun_style verlet, the resultant time-integration\nalgorithm is equivalent to the primitive splitting algorithm (PSA)\ndescribed by Bond.  Because each reflection event\ndivides the corresponding timestep asymmetrically, energy conservation\nis only satisfied to O(dt), rather than to O(dt^2) as it would be for\nvelocity-Verlet integration without reflective walls.\nUp to 6 walls or faces can be specified in a single command: xlo,\nxhi, ylo, yhi, zlo, zhi.  A lo face reflects particles\nthat move to a coordinate less than the wall position, back in the\nhi direction.  A hi face reflects particles that move to a\ncoordinate higher than the wall position, back in the lo direction.\nThe position of each wall can be specified in one of 3 ways: as the\nEDGE of the simulation box, as a constant value, or as a variable.  If\nEDGE is used, then the corresponding boundary of the current\nsimulation box is used.  If a numeric constant is specified then the\nwall is placed at that position in the appropriate dimension (x, y, or\nz).  In both the EDGE and constant cases, the wall will never move.\nIf the wall position is a variable, it should be specified as v_name,\nwhere name is an equal-style variable name.  In this\ncase the variable is evaluated each timestep and the result becomes\nthe current position of the reflecting wall.  Equal-style variables\ncan specify formulas with various mathematical functions, and include\nthermo_style command keywords for the simulation\nbox parameters and timestep and elapsed time.  Thus it is easy to\nspecify a time-dependent wall position.\nThe units keyword determines the meaning of the distance units used\nto define a wall position, but only when a numeric constant or\nvariable is used.  It is not relevant when EDGE is used to specify a\nface position.  In the variable case, the variable is assumed to\nproduce a value compatible with the units setting you specify.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings.\n\nHere are examples of variable definitions that move the wall position\nin a time-dependent fashion using equal-style\nvariables.\nvariable ramp equal ramp(0,10)\nfix 1 all wall/reflect xlo v_ramp\n\nvariable linear equal vdisplace(0,20)\nfix 1 all wall/reflect xlo v_linear\n\nvariable wiggle equal swiggle(0.0,5.0,3.0)\nfix 1 all wall/reflect xlo v_wiggle\n\nvariable wiggle equal cwiggle(0.0,5.0,3.0)\nfix 1 all wall/reflect xlo v_wiggle\n\n\nThe ramp(lo,hi) function adjusts the wall position linearly from lo to\nhi over the course of a run.  The vdisplace(c0,velocity) function does\nsomething similar using the equation position = c0 + velocity*delta,\nwhere delta is the elapsed time.\nThe swiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, where omega = 2 PI\n/ period:\nposition = c0 + A sin(omega*delta)\nThe cwiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, which will have an\ninitial wall velocity of 0.0, and thus may impose a gentler\nperturbation on the particles:\nposition = c0 + A (1 - cos(omega*delta))\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages\ndoc page.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix\ncommand-line switch when you invoke LAMMPS, or you can\nuse the suffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options are\nrelevant to this fix.  No global or per-atom quantities are stored by\nthis fix for access by various output commands.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during\nenergy minimization.",
    "syntax": "fix ID group-ID wall/reflect face arg ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/reflect = style name of this fix command\n * one or more face/arg pairs may be appended\n * face = xlo or xhi or ylo or yhi or zlo or zhi\n * arg = EDGE or constant or variable\n *   EDGE = current lo edge of simulation box\n *   constant = number like 0.0 or 30.0 (distance units)\n *   variable = equal-style variable like v_x or v_wiggle\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units",
    "examples": "fix xwalls all wall/reflect xlo EDGE xhi EDGE\nfix walls all wall/reflect xlo 0.0 ylo 10.0 units box\nfix top all wall/reflect zhi v_pressdown",
    "restrictions": "Any dimension (xyz) that has a reflecting wall must be non-periodic.\nA reflecting wall should not be used with rigid bodies such as those\ndefined by a “fix rigid” command.  This is because the wall/reflect\ndisplaces atoms directly rather than exerts a force on them.  For\nrigid bodies, use a soft wall instead, such as fix wall/lj93.  LAMMPS will flag the use of a rigid fix with fix\nwall/reflect with a warning, but will not generate an error."
},
{
    "command": "fix wall/reflect/stochastic",
    "html_filename": "fix_wall_reflect_stochastic.html",
    "short_description": "Bound the simulation with one or more walls which reflect particles in the specified group when they attempt to move through them",
    "description": "Bound the simulation with one or more walls which reflect particles\nin the specified group when they attempt to move through them.\nReflection means that if an atom moves outside the wall on a timestep\n(e.g. due to the fix nve command), then it is put back\ninside the wall with a changed velocity.\nThis fix models treats the wall as a moving solid boundary with a\nfinite temperature, which can exchange energy with particles that\ncollide with it.  This is different than the simpler fix wall/reflect command which models mirror\nreflection.  For this fix, the post collision velocity of each\nparticle is treated stochastically.  The randomness can come from many\nsources: thermal motion of the wall atoms, surface roughness, etc.\nThree stochastic reflection models are currently implemented.\nFor rstyle diffusive, particles are reflected diffusively. Their\nvelocity distribution corresponds to an equilibrium distribution of\nparticles at the wall temperature.  No accommodation coefficients\nare specified.\nFor rstyle maxwell, particle reflection is Maxwellian which means\npartially diffusive and partially specular (Maxwell).  A\nsingle accommodation coeff is specified which must be between 0.0 and\n1.0 inclusive.  It determines the fraction of the collision which is\ndiffusive versus specular.  An accommodation coefficient of 1.0 is fully\ndiffusive; a coefficient of 0.0 is fully specular.\nFor rstyle cll, particle collisions are computed by the\nCercignani/Lampis model.  See CL and To for details.\nThree accommodations coefficient are specified.  Each must be between\n0.0 and 1.0 inclusive.  Two are velocity accommodation coefficients;\none is a normal kinetic energy accommodation.  The normal coeff is the\none corresponding to the normal of the wall itself.  For example if\nthe wall is ylo or yhi, accomx and accomz are the tangential\nvelocity accommodation coefficients, and accomy is the normal\nkinetic energy accommodation coefficient.\nThe optional units keyword determines the distance units used to\ndefine a wall position.  A box value selects standard distance units\nas defined by the units command, e.g. Angstroms for units\n= real or metal.  A lattice value means the distance units are in\nlattice spacings. The lattice command must have been\npreviously used to define the lattice spacings.",
    "syntax": "fix ID group-ID wall/reflect/stochastic rstyle seed face args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/reflect/stochastic = style name of this fix command\n * rstyle = diffusive or maxwell or ccl\n * seed = random seed for stochasticity (positive integer)\n * one or more face/args pairs may be appended\n * face = xlo or xhi or ylo or yhi or zlo or zhi\n * args = pos temp velx vely velz accomx accomy accomz\n *   pos = EDGE or constant\n *     EDGE = current lo or hi edge of simulation box\n *     constant = number like 0.0 or 30.0 (distance units)\n *   temp = wall temperature (temperature units)\n *   velx,vely,velz = wall velocity in x,y,z directions (velocity units)\n *   accomx,accomy,accomz = accommodation coeffs in x,y,z directions (unitless)\n *     not specified for rstyle = diffusive\n *     single accom coeff specified for rstyle maxwell\n *     all 3 coeffs specified for rstyle cll\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units",
    "examples": "fix zwalls all wall/reflect/stochastic diffusive 23424 zlo EDGE 300 0.1 0.1 0 zhi EDGE 200 0.1 0.1 0\nfix ywalls all wall/reflect/stochastic maxwell 345533 ylo 5.0 300 0.1 0.0 0.0 0.8 yhi 10.0 300 0.1 0.0 0.0 0.8\nfix xwalls all wall/reflect/stochastic cercignanilampis 2308 xlo 0.0 300 0.0 0.1 0.9 0.8 0.7 xhi EDGE 300 0.0 0.1 0 0.9 0.8 0.7 units box",
    "restrictions": "This fix has the same limitations as the fix wall/reflect command.  Any dimension (xyz) that\nhas a wall must be non-periodic.  It should not be used with rigid\nbodies such as those defined by the fix rigid\ncommand.  The wall velocity must lie on the same plane as the wall\nitself.\nThis fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "fix wall/region",
    "html_filename": "fix_wall_region.html",
    "short_description": "Treat the surface of the geometric region defined by the region-ID as a bounding wall which interacts with nearby particles according to the specified style",
    "description": "Treat the surface of the geometric region defined by the region-ID\nas a bounding wall which interacts with nearby particles according to\nthe specified style.\nThe distance between a particle and the surface is the distance to the\nnearest point on the surface and the force the wall exerts on the\nparticle is along the direction between that point and the particle,\nwhich is the direction normal to the surface at that point.  Note that\nif the region surface is comprised of multiple “faces”, then each face\ncan exert a force on the particle if it is close enough.  E.g. for\nregion_style block, a particle in the interior, near a\ncorner of the block, could feel wall forces from 1, 2, or 3 faces of\nthe block.\nRegions are defined using the region command.  Note that\nthe region volume can be interior or exterior to the bounding surface,\nwhich will determine in which direction the surface interacts with\nparticles, i.e. the direction of the surface normal.  The surface of\nthe region only exerts forces on particles “inside” the region; if a\nparticle is “outside” the region it will generate an error, because it\nhas moved through the wall.\nRegions can either be primitive shapes (block, sphere, cylinder, etc)\nor combinations of primitive shapes specified via the union or\nintersect region styles.  These latter styles can be used to\nconstruct particle containers with complex shapes.  Regions can also\nchange over time via the region command keywords (move)\nand rotate.  If such a region is used with this fix, then the of\nregion surface will move over time in the corresponding manner.\n\nNote\nAs discussed on the region command doc page,\nregions in LAMMPS do not get wrapped across periodic boundaries.  It\nis up to you to insure that periodic or non-periodic boundaries are\nspecified appropriately via the boundary command when\nusing a region as a wall that bounds particle motion.  This also means\nthat if you embed a region in your simulation box and want it to\nrepulse particles from its surface (using the “side out” option in the\nregion command), that its repulsive force will not be\nfelt across a periodic boundary.\n\n\nNote\nFor primitive regions with sharp corners and/or edges (e.g. a\nblock or cylinder), wall/particle forces are computed accurately for\nboth interior and exterior regions.  For union and intersect\nregions, additional sharp corners and edges may be present due to the\nintersection of the surfaces of 2 or more primitive volumes.  These\ncorners and edges can be of two types: concave or convex.  Concave\npoints/edges are like the corners of a cube as seen by particles in\nthe interior of a cube.  Wall/particle forces around these features\nare computed correctly.  Convex points/edges are like the corners of a\ncube as seen by particles exterior to the cube, i.e. the points jut\ninto the volume where particles are present.  LAMMPS does NOT compute\nthe location of these convex points directly, and hence wall/particle\nforces in the cutoff volume around these points suffer from\ninaccuracies.  The basic problem is that the outward normal of the\nsurface is not continuous at these points.  This can cause particles\nto feel no force (they don’t “see” the wall) when in one location,\nthen move a distance epsilon, and suddenly feel a large force because\nthey now “see” the wall.  In a worst-case scenario, this can blow\nparticles out of the simulation box.  Thus, as a general rule you\nshould not use the fix wall/gran/region command with union or\ninteresect regions that have convex points or edges resulting from\nthe union/intersection (convex points/edges in the union/intersection\ndue to a single sub-region are still OK).\n\n\nNote\nSimilarly, you should not define union or intersert regions\nfor use with this command that share an overlapping common face that\nis part of the overall outer boundary (interior boundary is OK), even\nif the face is smooth.  E.g. two regions of style block in a union\nregion, where the two blocks overlap on one or more of their faces.\nThis is because LAMMPS discards points that are part of multiple\nsub-regions when calculating wall/particle interactions, to avoid\ndouble-counting the interaction.  Having two coincident faces could\ncause the face to become invisible to the particles.  The solution is\nto make the two faces differ by epsilon in their position.\n\nThe energy of wall-particle interactions depends on the specified\nstyle.\nFor style lj93, the energy E is given by the 9/3 potential:\n\n\\[E = \\epsilon \\left[ \\frac{2}{15} \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                      \\left(\\frac{\\sigma}{r}\\right)^3 \\right]\n                      \\qquad r < r_c\\]\nFor style lj126, the energy E is given by the 12/6 potential:\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c\\]\nFor style wall/lj1043, the energy E is given by the 10/4/3 potential:\n\n\\[E = 2 \\pi \\epsilon \\left[ \\frac{2}{5} \\left(\\frac{\\sigma}{r}\\right)^{10} -\n                      \\left(\\frac{\\sigma}{r}\\right)^4 -\n                      \\frac{\\sqrt(2)\\sigma^3}{3\\left(r+\\left(0.61/\\sqrt(2)\\right)\\sigma\\right)^3}\\right]\n                      \\qquad r < r_c\\]\nFor style colloid, the energy E is given by an integrated form of\nthe pair_style colloid potential:\n\n\\[\\begin{split}E = & \\epsilon \\left[ \\frac{\\sigma^{6}}{7560}\n\\left(\\frac{6R-D}{D^{7}} + \\frac{D+8R}{(D+2R)^{7}} \\right) \\right. \\\\\n & \\left. - \\frac{1}{6} \\left(\\frac{2R(D+R) + D(D+2R)\n \\left[ \\ln D - \\ln (D+2R) \\right]}{D(D+2R)} \\right) \\right] \\qquad r < r_c\\end{split}\\]\nFor style wall/harmonic, the energy E is given by a harmonic spring\npotential (the distance parameter is ignored):\n\n\\[E = \\epsilon \\quad (r - r_c)^2 \\qquad r < r_c\\]\nFor style wall/morse, the energy E is given by the Morse potential:\n\n\\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n    \\qquad r < r_c\\]\nUnlike other styles, this requires three parameters (\\(D_0\\),\n\\(\\alpha\\), and \\(r_0\\) in this order) instead of two like\nfor the other wall styles.\nIn all cases, r is the distance from the particle to the region\nsurface, and Rc is the cutoff distance at which the particle and\nsurface no longer interact.  The cutoff is always the last argument.\nThe energy of the wall potential is shifted so that the wall-particle\ninteraction energy is 0.0 at the cutoff distance.\nFor a full description of these wall styles, see fix_style\nwall\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy of interaction between atoms and the wall to the\nsystem’s potential energy as part of thermodynamic output.\nThe fix_modify virial option is supported by this\nfix to add the contribution due to the interaction between\natoms and each wall to the system’s virial as part of thermodynamic output. The default is virial no\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar energy and a global 3-length vector\nof forces, which can be accessed by various output commands.  The scalar energy is the sum of energy\ninteractions for all particles interacting with the wall represented\nby the region surface.  The 3 vector quantities are the x,y,z\ncomponents of the total force acting on the wall due to the particles.\nThe scalar and vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the atom/wall interaction energy to be included in\nthe total potential energy of the system (the quantity being\nminimized), you MUST enable the fix_modify energy\noption for this fix.",
    "syntax": "fix ID group-ID wall/region region-ID style args ... cutoff",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/region = style name of this fix command\n * region-ID = region whose boundary will act as wall\n * style = lj93 or lj126 or lj1043 or colloid or harmonic or morse\n * args for styles lj93 or lj126 or lj1043 or colloid or harmonic =\n * epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n * sigma = size factor for wall-particle interaction (distance units)\n * args for style morse =\n * D_0 = depth of the potential (energy units)\n * alpha = width parameter (1/distance units)\n * r_0 = distance of the potential minimum from wall position (distance units)\n * cutoff = distance from wall at which wall-particle interaction is cut off (distance units)",
    "examples": "fix wall all wall/region mySphere lj93 1.0 1.0 2.5\nfix wall all wall/region mySphere harmonic 1.0 0.0 2.5\nfix wall all wall/region box_top morse 1.0 1.0 1.5 3.0",
    "restrictions": "\nnone"
},
{
    "command": "fix wall/srd",
    "html_filename": "fix_wall_srd.html",
    "short_description": "Bound the simulation with one or more walls which interact with stochastic reaction dynamics (SRD) particles as slip (smooth) or no-slip (rough) flat surfaces",
    "description": "Bound the simulation with one or more walls which interact with\nstochastic reaction dynamics (SRD) particles as slip (smooth) or\nno-slip (rough) flat surfaces.  The wall interaction is actually\ninvoked via the fix srd command, only on the group of\nSRD particles it defines, so the group setting for the fix wall/srd\ncommand is ignored.\nA particle/wall collision occurs if an SRD particle moves outside the\nwall on a timestep.  This alters the position and velocity of the SRD\nparticle and imparts a force to the wall.\nThe collision and Tsrd settings specified via the fix srd command affect the SRD/wall collisions.  A slip\nsetting for the collision keyword means that the tangential\ncomponent of the SRD particle momentum is preserved.  Thus only a\nnormal force is imparted to the wall.  The normal component of the new\nSRD velocity is sampled from a Gaussian distribution at temperature\nTsrd.\nFor a noslip setting of the collision keyword, both the normal and\ntangential components of the new SRD velocity are sampled from a\nGaussian distribution at temperature Tsrd.  Additionally, a new\ntangential direction for the SRD velocity is chosen randomly.  This\ncollision style imparts both a normal and tangential force to the\nwall.\nUp to 6 walls or faces can be specified in a single command: xlo,\nxhi, ylo, yhi, zlo, zhi.  A lo face reflects particles\nthat move to a coordinate less than the wall position, back in the\nhi direction.  A hi face reflects particles that move to a\ncoordinate higher than the wall position, back in the lo direction.\nThe position of each wall can be specified in one of 3 ways: as the\nEDGE of the simulation box, as a constant value, or as a variable.  If\nEDGE is used, then the corresponding boundary of the current\nsimulation box is used.  If a numeric constant is specified then the\nwall is placed at that position in the appropriate dimension (x, y, or\nz).  In both the EDGE and constant cases, the wall will never move.\nIf the wall position is a variable, it should be specified as v_name,\nwhere name is an equal-style variable name.  In this\ncase the variable is evaluated each timestep and the result becomes\nthe current position of the reflecting wall.  Equal-style variables\ncan specify formulas with various mathematical functions, and include\nthermo_style command keywords for the simulation\nbox parameters and timestep and elapsed time.  Thus it is easy to\nspecify a time-dependent wall position.\n\nNote\nBecause the trajectory of the SRD particle is tracked as it\ncollides with the wall, you must insure that r = distance of the\nparticle from the wall, is always > 0 for SRD particles, or LAMMPS\nwill generate an error.  This means you cannot start your simulation\nwith SRD particles at the wall position coord (r = 0) or with\nparticles on the wrong side of the wall (r < 0).\n\n\nNote\nIf you have 2 or more walls that come together at an edge or\ncorner (e.g. walls in the x and y dimensions), then be sure to set the\noverlap keyword to yes in the fix srd command,\nsince the walls effectively overlap when SRD particles collide with\nthem.  LAMMPS will issue a warning if you do not do this.\n\n\nNote\nThe walls of this fix only interact with SRD particles, as\ndefined by the fix srd command.  If you are simulating\na mixture containing other kinds of particles, then you should\ntypically use another wall command to act on the other\nparticles.  Since SRD particles will be colliding both with the walls\nand the other particles, it is important to insure that the other\nparticle’s finite extent does not overlap an SRD wall.  If you do not\ndo this, you may generate errors when SRD particles end up “inside”\nanother particle or a wall at the beginning of a collision step.\n\nThe units keyword determines the meaning of the distance units used\nto define a wall position, but only when a numeric constant is used.\nIt is not relevant when EDGE or a variable is used to specify a face\nposition.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings.\n\nHere are examples of variable definitions that move the wall position\nin a time-dependent fashion using equal-style\nvariables.\nvariable ramp equal ramp(0,10)\nfix 1 all wall/srd xlo v_ramp\n\nvariable linear equal vdisplace(0,20)\nfix 1 all wall/srd xlo v_linear\n\nvariable wiggle equal swiggle(0.0,5.0,3.0)\nfix 1 all wall/srd xlo v_wiggle\n\nvariable wiggle equal cwiggle(0.0,5.0,3.0)\nfix 1 all wall/srd xlo v_wiggle\n\n\nThe ramp(lo,hi) function adjusts the wall position linearly from lo to\nhi over the course of a run.  The displace(c0,velocity) function does\nsomething similar using the equation position = c0 + velocity*delta,\nwhere delta is the elapsed time.\nThe swiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, where omega = 2 PI\n/ period:\nposition = c0 + A sin(omega*delta)\nThe cwiggle(c0,A,period) function causes the wall position to\noscillate sinusoidally according to this equation, which will have an\ninitial wall velocity of 0.0, and thus may impose a gentler\nperturbation on the particles:\nposition = c0 + A (1 - cos(omega*delta))\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.  None of the fix_modify options\nare relevant to this fix.\nThis fix computes a global array of values which can be accessed by\nvarious output commands.  The number of rows in\nthe array is equal to the number of walls defined by the fix.  The\nnumber of columns is 3, for the x,y,z components of force on each\nwall.\nNote that an outward normal force on a wall will be a negative value\nfor lo walls and a positive value for hi walls.  The array values\ncalculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.  This fix is not invoked during energy minimization.",
    "syntax": "fix ID group-ID wall/srd face arg ... keyword value ...",
    "parameters": " * ID, group-ID are documented in fix command\n * wall/srd = style name of this fix command\n * one or more face/arg pairs may be appended\n * face = xlo or xhi or ylo or yhi or zlo or zhi\n * xlo,ylo,zlo arg = EDGE or constant or variable\n *   EDGE = current lo edge of simulation box\n *   constant = number like 0.0 or -30.0 (distance units)\n *   variable = equal-style variable like v_x or v_wiggle\n * xhi,yhi,zhi arg = EDGE or constant or variable\n *   EDGE = current hi edge of simulation box\n *   constant = number like 50.0 or 100.3 (distance units)\n *   variable = equal-style variable like v_x or v_wiggle\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = lattice or box\n *   lattice = the wall position is defined in lattice units\n *   box = the wall position is defined in simulation box units",
    "examples": "fix xwalls all wall/srd xlo EDGE xhi EDGE\nfix walls all wall/srd xlo 0.0 ylo 10.0 units box\nfix top all wall/srd zhi v_pressdown",
    "restrictions": "Any dimension (xyz) that has an SRD wall must be non-periodic."
},
{
    "command": "compute ackland/atom",
    "html_filename": "compute_ackland_atom.html",
    "short_description": "Defines a computation that calculates the local lattice structure according to the formulation given in (Ackland)",
    "description": "Defines a computation that calculates the local lattice structure\naccording to the formulation given in (Ackland).\nHistorically, LAMMPS had two, slightly different implementations of\nthe algorithm from the paper. With the legacy keyword, it is\npossible to switch between the pre-2015 (legacy yes) and post-2015\nimplementation (legacy no). The post-2015 variant is the default.\nIn contrast to the centro-symmetry parameter this method is stable against\ntemperature boost, because it is based not on the distance between\nparticles but the angles.  Therefore statistical fluctuations are\naveraged out a little more.  A comparison with the Common Neighbor\nAnalysis metric is made in the paper.\nThe result is a number which is mapped to the following different\nlattice structures:\n\n0 = UNKNOWN\n1 = BCC\n2 = FCC\n3 = HCP\n4 = ICO\n\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each of\nwhich computes this quantity.-\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.",
    "syntax": "compute ID group-ID ackland/atom keyword/value",
    "parameters": " * ID, group-ID are documented in compute command\n * ackland/atom = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = legacy\n * legacy yes/no = use (yes) or do not use (no) legacy ackland algorithm implementation",
    "examples": "compute 1 all ackland/atom\ncompute 1 all ackland/atom legacy yes",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThe per-atom vector values will be unitless since they are the\nintegers defined above."
},
{
    "command": "compute adf",
    "html_filename": "compute_adf.html",
    "short_description": "Define a computation that calculates one or more angular distribution functions (ADF) for a group of particles",
    "description": "Define a computation that calculates one or more angular distribution functions\n(ADF) for a group of particles.  Each ADF is calculated in histogram form\nby measuring the angle formed by a central atom and two neighbor atoms and\nbinning these angles into Nbin bins.\nOnly neighbors for which Rinner < R < Router are counted, where\nRinner and Router are specified separately for the first and second\nneighbor atom in each requested ADF.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses a neighbor list, it also means\nthose pairs will not be included in the ADF. This does not apply when\nusing long-range coulomb interactions (coul/long, coul/msm,\ncoul/wolf or similar.  One way to get around this would be to set\nspecial_bond scaling factors to very tiny numbers that are not exactly\nzero (e.g. 1.0e-50). Another workaround is to write a dump file, and\nuse the rerun command to compute the ADF for snapshots in\nthe dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\n\nNote\nIf you request any outer cutoff Router > force cutoff, or if no\npair style is defined,  e.g. the rerun command is being used to\npost-process a dump file of snapshots you must insure ghost atom information\nout to the largest value of Router + skin is communicated, via the\ncomm_modify cutoff command, else the ADF computation\ncannot be performed, and LAMMPS will give an error message.  The skin value\nis what is specified with the neighbor command.\n\nThe itypeN,jtypeN,ktypeN settings can be specified in one of two\nways.  An explicit numeric value can be used, as in the 1st example\nabove.  Or a wild-card asterisk can be used to specify a range of atom\ntypes as in the 2nd example above.\nThis takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nIf itypeN, jtypeN, and ktypeN are single values, as in the 1st example\nabove, this means that the ADF is computed where atoms of type itypeN\nare the central atom, and neighbor atoms of type jtypeN and ktypeN\nare forming the angle.  If any of itypeN, jtypeN, or ktypeN\nrepresent a range of values via\nthe wild-card asterisk, as in the 2nd example above, this means that the\nADF is computed where atoms of any of the range of types represented\nby itypeN are the central atom, and the angle is formed by two neighbors,\none neighbor in the range of types represented by jtypeN and another neighbor\nin the range of types represented by ktypeN.\nIf no itypeN, jtypeN, ktypeN settings are specified, then\nLAMMPS will generate a single ADF for all atoms in the group.\nThe inner cutoff is set to zero and the outer cutoff is set\nto the force cutoff. If no pair_style is specified, there is no\nforce cutoff and LAMMPS will give an error message. Note that\nin most cases, generating an ADF for all atoms is not a good thing.\nSuch an ADF is both uninformative and\nextremely expensive to compute.  For example, with liquid water\nwith a 10 A force cutoff, there are 80,000 angles per atom.\nIn addition, most of the interesting angular structure occurs for\nneighbors that are the closest to the central atom, involving\njust a few dozen angles.\nAngles for each ADF are generated by double-looping over the list of\nneighbors of each central atom I,\njust as they would be in the force calculation for\na three-body potential such as Stillinger-Weber.\nThe angle formed by central atom I and neighbor atoms J and K is included in an\nADF if the following criteria are met:\n\natoms I,J,K are all in the specified compute group\nthe distance between atoms I,J is between Rjinner and Rjouter\nthe distance between atoms I,K is between Rkinner and Rkouter\nthe type of the I atom matches itypeN (one or a range of types)\natoms I,J,K are distinct\nthe type of the J atom matches jtypeN (one or a range of types)\nthe type of the K atom matches ktypeN (one or a range of types)\n\nEach unique angle satisfying the above criteria is counted only once, regardless\nof whether either or both of the neighbor atoms making up the\nangle appear in both the J and K lists.\nIt is OK if a particular angle is included in more than\none individual histogram, due to the way the itypeN, jtypeN, ktypeN\narguments are specified.\nThe first ADF value for a bin is calculated from the histogram count by\ndividing by the total number of triples satisfying the criteria,\nso that the integral of the ADF w.r.t. angle is 1, i.e. the ADF\nis a probability density function.\nThe second ADF value is reported as a cumulative sum of\nall bins up to the current bins, averaged\nover atoms of type itypeN. It represents the\nnumber of angles per central atom with angle less\nthan or equal to the angle of the current bin,\nanalogous to the coordination\nnumber radial distribution function.\nThe ordinate optional keyword determines\nwhether the bins are of uniform angular size from zero\nto 180 (degree), zero to Pi (radian), or the\ncosine of the angle uniform in the range [-1,1] (cosine).\ncosine has the advantage of eliminating the acos() function\ncall, which speeds up the compute by 2-3x, and it is also preferred\non physical grounds, because the for uniformly distributed particles\nin 3D, the angular probability density w.r.t dtheta is\nsin(theta)/2, while for d(cos(theta)), it is 1/2,\nRegardless of which ordinate is chosen, the first column of ADF\nvalues is normalized w.r.t. the range of that ordinate, so that\nthe integral is 1.\nThe simplest way to output the results of the compute adf calculation\nto a file is to use the fix ave/time command, for\nexample:\ncompute myADF all adf 32 2 2 2 0.5 3.5 0.5 3.5\nfix 1 all ave/time 100 1 100 c_myADF[*] file tmp.adf mode vector\nOutput info:\nThis compute calculates a global array with the number of rows =\nNbins, and the number of columns = 1 + 2*Ntriples, where Ntriples is the\nnumber of I,J,K triples specified.  The first column has the bin\ncoordinate (angle-related ordinate at midpoint of bin). Each subsequent column has\nthe two ADF values for a specific set of (itypeN,jtypeN,ktypeN)\ninteractions, as described above.  These values can be used\nby any command that uses a global values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe array values calculated by this compute are all “intensive”.\nThe first column of array values is the angle-related ordinate, either\nthe angle in degrees or radians, or the cosine of the angle.  Each\nsubsequent pair of columns gives the first and second kinds of ADF\nfor a specific set of (itypeN,jtypeN,ktypeN). The values\nin the first ADF column are normalized numbers >= 0.0,\nwhose integral w.r.t. the ordinate is 1,\ni.e. the first ADF is a normalized probability distribution.\nThe values in the second ADF column are also numbers >= 0.0.\nThey are the cumulative density distribution of angles per atom.\nBy definition, this ADF is monotonically increasing from zero to\na maximum value equal to the average total number of\nangles per atom satisfying the ADF criteria.",
    "syntax": "compute ID group-ID adf Nbin itype1 jtype1 ktype1 Rjinner1 Rjouter1 Rkinner1 Rkouter1 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * adf = style name of this compute command\n * Nbin = number of ADF bins\n * itypeN = central atom type for Nth ADF histogram (see asterisk form below)\n * jtypeN = J atom type for Nth ADF histogram (see asterisk form below)\n * ktypeN = K atom type for Nth ADF histogram (see asterisk form below)\n * RjinnerN =  inner radius of J atom shell for Nth ADF histogram (distance units)\n * RjouterN =  outer radius of J atom shell for Nth ADF histogram (distance units)\n * RkinnerN = inner radius of K atom shell for Nth ADF histogram (distance units)\n * RkouterN =  outer radius of K atom shell for Nth ADF histogram (distance units)\n * zero or one keyword/value pairs may be appended\n * keyword = ordinate\n * ordinate value = degree or radian or cosine\n *   Choose the ordinate parameter for the histogram",
    "examples": "compute 1 fluid adf 32 1 1 1 0.0 1.2 0.0 1.2 &\n                       1 1 2 0.0 1.2 0.0 1.5 &\n                       1 2 2 0.0 1.5 0.0 1.5 &\n                       2 1 1 0.0 1.2 0.0 1.2 &\n                       2 1 2 0.0 1.5 2.0 3.5 &\n                       2 2 2 2.0 3.5 2.0 3.5\ncompute 1 fluid adf 32 1*2 1*2 1*2 0.5 3.5\ncompute 1 fluid adf 32",
    "restrictions": "The ADF is not computed for neighbors outside the force cutoff,\nsince processors (in parallel) don’t know about atom coordinates for\natoms further away than that distance.  If you want an ADF for larger\ndistances, you can use the rerun command to post-process\na dump file and set the cutoff for the potential to be longer in the\nrerun script.  Note that in the rerun context, the force cutoff is\narbitrary, since you aren’t running dynamics and thus are not changing\nyour model."
},
{
    "command": "compute angle",
    "html_filename": "compute_angle.html",
    "short_description": "Define a computation that extracts the angle energy calculated by each of the angle sub-styles used in the  “angle_style hybrid” angle_hybrid",
    "description": "Define a computation that extracts the angle energy calculated by each\nof the angle sub-styles used in the  “angle_style\nhybrid” angle_hybrid.html command.  These values are made accessible\nfor output or further processing by other commands.  The group\nspecified for this command is ignored.\nThis compute is useful when using angle_style hybrid if you want to know the portion of the total\nenergy contributed by one or more of the hybrid sub-styles.\nOutput info:\nThis compute calculates a global vector of length N where N is the\nnumber of sub_styles defined by the angle_style hybrid command, which can be accessed by indices\n1-N.  These values can be used by any command that uses global scalar\nor vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values are “extensive” and will be in energy\nunits.",
    "syntax": "compute ID group-ID angle",
    "parameters": " * ID, group-ID are documented in compute command\n * angle = style name of this compute command",
    "examples": "compute 1 all angle",
    "restrictions": "\nnone"
},
{
    "command": "compute angle/local",
    "html_filename": "compute_angle_local.html",
    "short_description": "Define a computation that calculates properties of individual angle interactions",
    "description": "Define a computation that calculates properties of individual angle\ninteractions.  The number of datums generated, aggregated across all\nprocessors, equals the number of angles in the system, modified by the\ngroup parameter as explained below.\nThe value theta is the angle for the 3 atoms in the interaction.\nThe value eng is the interaction energy for the angle.\nThe value v_name can be used together with the set keyword to\ncompute a user-specified function of the angle theta.  The name\nspecified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\nvariable which will store the angle theta.  This other variable must\nbe an internal-style variable defined in the input\nscript; its initial numeric value can be anything.  It must be an\ninternal-style variable, because this command resets its value\ndirectly.  The set keyword is used to identify the name of this\nother variable associated with theta.\nNote that the value of theta for each angle which stored in the\ninternal variable is in radians, not degrees.\nAs an example, these commands can be added to the bench/in.rhodo\nscript to compute the cosine and cosine^2 of every angle in the system\nand output the statistics in various ways:\nvariable t internal 0.0\nvariable cos equal cos(v_t)\nvariable cossq equal cos(v_t)*cos(v_t)\n\ncompute 1 all property/local aatom1 aatom2 aatom3 atype\ncompute 2 all angle/local eng theta v_cos v_cossq set theta t\ndump 1 all local 100 tmp.dump c_1[*] c_2[*]\n\ncompute 3 all reduce ave c_2[*]\nthermo_style custom step temp press c_3[*]\n\nfix 10 all ave/histo 10 10 100 -1 1 20 c_2[3] mode vector file tmp.histo\nThe dump local command will output the energy, angle,\ncosine(angle), cosine^2(angle) for every angle in the system.  The\nthermo_style command will print the average of\nthose quantities via the compute reduce command\nwith thermo output.  And the fix ave/histo\ncommand will histogram the cosine(angle) values and write them to a\nfile.\n\nThe local data stored by this command is generated by looping over all\nthe atoms owned on a processor and their angles.  An angle will only\nbe included if all 3 atoms in the angle are in the specified compute\ngroup.  Any angles that have been broken (see the\nangle_style command) by setting their angle type to\n0 are not included.  Angles that have been turned off (see the fix shake or delete_bonds commands) by\nsetting their angle type negative are written into the file, but their\nenergy will be 0.0.\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, angle output from the compute property/local command can be combined\nwith data from this command and output by the dump local\ncommand in a consistent way.\nHere is an example of how to do this:\ncompute 1 all property/local atype aatom1 aatom2 aatom3\ncompute 2 all angle/local theta eng\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_2[1] c_2[2]\n\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of values.  The length of the vector or number of rows in the\narray is the number of angles.  If a single value is specified, a\nlocal vector is produced.  If two or more values are specified, a\nlocal array is produced where the number of columns = the number of\nvalues.  The vector or array can be accessed by any command that uses\nlocal values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe output for theta will be in degrees.  The output for eng will\nbe in energy units.",
    "syntax": "compute ID group-ID angle/local value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * angle/local = style name of this compute command\n * one or more values may be appended\n * value = theta or eng or v_name\n * theta = tabulate angles\n * eng = tabulate angle energies\n * v_name = equal-style variable with name (see below)\n * zero or more keyword/args pairs may be appended\n * keyword = set\n * set args = theta name\n *   theta = only currently allowed arg\n *   name = name of variable to set with theta",
    "examples": "compute 1 all angle/local theta\ncompute 1 all angle/local eng theta\ncompute 1 all angle/local theta v_cos set theta t",
    "restrictions": "\nnone"
},
{
    "command": "compute angmom/chunk",
    "html_filename": "compute_angmom_chunk.html",
    "short_description": "Define a computation that calculates the angular momentum of multiple chunks of atoms",
    "description": "Define a computation that calculates the angular momentum of multiple\nchunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the 3 components of the angular momentum\nvector for each chunk, due to the velocity/momentum of the individual\natoms in the chunk around the center-of-mass of the chunk.  The\ncalculation includes all effects due to atoms passing through periodic\nboundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s angular\nmomentum in “unwrapped” form, by using the image flags associated with\neach atom.  See the dump custom command for a discussion\nof “unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute angmom/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all angmom/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n3 for the 3 xyz components of the angular momentum for each chunk.\nThese values can be accessed by any command that uses global array\nvalues from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array values are “intensive”.  The array values will be in\nmass-velocity-distance units.",
    "syntax": "compute ID group-ID angmom/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * angmom/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid angmom/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute basal/atom",
    "html_filename": "compute_basal_atom.html",
    "short_description": "Defines a computation that calculates the hexagonal close-packed “c” lattice vector for each atom in the group",
    "description": "Defines a computation that calculates the hexagonal close-packed “c”\nlattice vector for each atom in the group.  It does this by\ncalculating the normal unit vector to the basal plane for each atom.\nThe results enable efficient identification and characterization of\ntwins and grains in hexagonal close-packed structures.\nThe output of the compute is thus the 3 components of a unit vector\nassociated with each atom.  The components are set to 0.0 for\natoms not in the group.\nDetails of the calculation are given in (Barrett).\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each of\nwhich computes this quantity.\nAn example input script that uses this compute is provided\nin examples/USER/misc/basal.\nOutput info:\nThis compute calculates a per-atom array with 3 columns, which can be\naccessed by indices 1-3 by any command that uses per-atom values from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe per-atom vector values are unitless since the 3 columns represent\ncomponents of a unit vector.",
    "syntax": "compute ID group-ID basal/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * basal/atom = style name of this compute command",
    "examples": "compute 1 all basal/atom",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThe output of this compute will be meaningless unless the atoms are on\n(or near) hcp lattice sites, since the calculation assumes a\nwell-defined basal plane."
},
{
    "command": "compute body/local",
    "html_filename": "compute_body_local.html",
    "short_description": "Define a computation that calculates properties of individual body sub-particles",
    "description": "Define a computation that calculates properties of individual body\nsub-particles.  The number of datums generated, aggregated across all\nprocessors, equals the number of body sub-particles plus the number of\nnon-body particles in the system, modified by the group parameter as\nexplained below.  See the Howto body doc page for\nmore details on using body particles.\nThe local data stored by this command is generated by looping over all\nthe atoms.  An atom will only be included if it is in the group.  If\nthe atom is a body particle, then its N sub-particles will be looped\nover, and it will contribute N datums to the count of datums.  If it\nis not a body particle, it will contribute 1 datum.\nFor both body particles and non-body particles, the id keyword\nwill store the ID of the particle.\nFor both body particles and non-body particles, the type keyword\nwill store the type of the particle.\nThe integer keywords mean different things for body and non-body\nparticles.  If the atom is not a body particle, only its x, y, z\ncoordinates can be referenced, using the integer keywords 1,2,3.\nNote that this means that if you want to access more fields than this\nfor body particles, then you cannot include non-body particles in the\ngroup.\nFor a body particle, the integer keywords refer to fields calculated\nby the body style for each sub-particle.  The body style, as specified\nby the atom_style body, determines how many fields\nexist and what they are.  See the Howto_body doc\npage for details of the different styles.\nHere is an example of how to output body information using the dump local command with this compute.  If fields 1,2,3 for the\nbody sub-particles are x,y,z coordinates, then the dump file will be\nformatted similar to the output of a dump atom or custom\ncommand.\ncompute 1 all body/local type 1 2 3\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4]\n\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of keywords.  The length of the vector or number of rows in the\narray is the number of datums as described above.  If a single keyword\nis specified, a local vector is produced.  If two or more keywords are\nspecified, a local array is produced where the number of columns = the\nnumber of keywords.  The vector or array can be accessed by any\ncommand that uses local values from a compute as input.  See the\nHowto output doc page for an overview of LAMMPS\noutput options.\nThe units for output values depend on the body style.",
    "syntax": "compute ID group-ID body/local input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * body/local = style name of this compute command\n * one or more keywords may be appended\n * keyword = id or type or integer\n * id = atom ID of the body particle\n * type = atom type of the body particle\n * integer = 1,2,3,etc = index of fields defined by body style",
    "examples": "compute 1 all body/local type 1 2 3\ncompute 1 all body/local 3 6",
    "restrictions": "\nnone"
},
{
    "command": "compute bond",
    "html_filename": "compute_bond.html",
    "short_description": "Define a computation that extracts the bond energy calculated by each of the bond sub-styles used in the bond_style hybrid command",
    "description": "Define a computation that extracts the bond energy calculated by each\nof the bond sub-styles used in the bond_style hybrid command.  These values are made accessible\nfor output or further processing by other commands.  The group\nspecified for this command is ignored.\nThis compute is useful when using bond_style hybrid\nif you want to know the portion of the total energy contributed by one\nor more of the hybrid sub-styles.\nOutput info:\nThis compute calculates a global vector of length N where N is the\nnumber of sub_styles defined by the bond_style hybrid command, which can be accessed by indices 1-N.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values are “extensive” and will be in energy\nunits.",
    "syntax": "compute ID group-ID bond",
    "parameters": " * ID, group-ID are documented in compute command\n * bond = style name of this compute command",
    "examples": "compute 1 all bond",
    "restrictions": "\nnone"
},
{
    "command": "compute bond/local",
    "html_filename": "compute_bond_local.html",
    "short_description": "Define a computation that calculates properties of individual bond interactions",
    "description": "Define a computation that calculates properties of individual bond\ninteractions.  The number of datums generated, aggregated across all\nprocessors, equals the number of bonds in the system, modified by the\ngroup parameter as explained below.\nAll these properties are computed for the pair of atoms in a bond,\nwhether the 2 atoms represent a simple diatomic molecule, or are part\nof some larger molecule.\nThe value dist is the current length of the bond.\nThe value engpot is the potential energy for the bond,\nbased on the current separation of the pair of atoms in the bond.\nThe value force is the magnitude of the force acting between the\npair of atoms in the bond.\nThe values fx, fy, and fz are the xyz components of\nforce between the pair of atoms in the bond.\nThe remaining properties are all computed for motion of the two atoms\nrelative to the center of mass (COM) velocity of the 2 atoms in the\nbond.\nThe value engvib is the vibrational kinetic energy of the two atoms\nin the bond, which is simply 1/2 m1 v1^2 + 1/2 m2 v2^2, where v1 and\nv2 are the magnitude of the velocity of the 2 atoms along the bond\ndirection, after the COM velocity has been subtracted from each.\nThe value engrot is the rotational kinetic energy of the two atoms\nin the bond, which is simply 1/2 m1 v1^2 + 1/2 m2 v2^2, where v1 and\nv2 are the magnitude of the velocity of the 2 atoms perpendicular to\nthe bond direction, after the COM velocity has been subtracted from\neach.\nThe value engtrans is the translational kinetic energy associated\nwith the motion of the COM of the system itself, namely 1/2 (m1+m2)\nVcm^2 where Vcm = magnitude of the velocity of the COM.\nNote that these 3 kinetic energy terms are simply a partitioning of\nthe summed kinetic energy of the 2 atoms themselves.  I.e. total KE =\n1/2 m1 v1^2 + 1/2 m2 v2^2 = engvib + engrot + engtrans, where v1,v2\nare the magnitude of the velocities of the 2 atoms, without any\nadjustment for the COM velocity.\nThe value omega is the magnitude of the angular velocity of the\ntwo atoms around their COM position.\nThe value velvib is the magnitude of the relative velocity of the\ntwo atoms in the bond towards each other.  A negative value means the\n2 atoms are moving toward each other; a positive value means they are\nmoving apart.\nThe value v_name can be used together with the set keyword to\ncompute a user-specified function of the bond distance.  The name\nspecified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\nvariable which will store the bond distance.  This other variable must\nbe an internal-style variable defined in the input\nscript; its initial numeric value can be anything.  It must be an\ninternal-style variable, because this command resets its value\ndirectly.  The set keyword is used to identify the name of this\nother variable associated with theta.\nAs an example, these commands can be added to the bench/in.rhodo\nscript to compute the distance^2 of every bond in the system and\noutput the statistics in various ways:\nvariable d internal 0.0\nvariable dsq equal v_d*v_d\n\ncompute 1 all property/local batom1 batom2 btype\ncompute 2 all bond/local engpot dist v_dsq set dist d\ndump 1 all local 100 tmp.dump c_1[*] c_2[*]\n\ncompute 3 all reduce ave c_2[*]\nthermo_style custom step temp press c_3[*]\n\nfix 10 all ave/histo 10 10 100 0 6 20 c_2[3] mode vector file tmp.histo\nThe dump local command will output the energy, distance,\ndistance^2 for every bond in the system.  The\nthermo_style command will print the average of\nthose quantities via the compute reduce command\nwith thermo output.  And the fix ave/histo\ncommand will histogram the distance^2 values and write them to a file.\n\nThe local data stored by this command is generated by looping over all\nthe atoms owned on a processor and their bonds.  A bond will only be\nincluded if both atoms in the bond are in the specified compute group.\nAny bonds that have been broken (see the bond_style\ncommand) by setting their bond type to 0 are not included.  Bonds that\nhave been turned off (see the fix shake or\ndelete_bonds commands) by setting their bond type\nnegative are written into the file, but their energy will be 0.0.\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, bond output from the compute property/local command can be combined\nwith data from this command and output by the dump local\ncommand in a consistent way.\nHere is an example of how to do this:\ncompute 1 all property/local btype batom1 batom2\ncompute 2 all bond/local dist engpot\ndump 1 all local 1000 tmp.dump index c_1[*] c_2[*]\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of values.  The length of the vector or number of rows in the\narray is the number of bonds.  If a single value is specified, a local\nvector is produced.  If two or more values are specified, a local\narray is produced where the number of columns = the number of values.\nThe vector or array can be accessed by any command that uses local\nvalues from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe output for dist will be in distance units. The\noutput for velvib will be in velocity units. The output\nfor omega will be in velocity/distance units. The\noutput for engtrans, engvib, engrot, and engpot will be in\nenergy units. The output for force will be in force\nunits.",
    "syntax": "compute ID group-ID bond/local value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * bond/local = style name of this compute command\n * one or more values may be appended\n * value = dist or engpot or force or fx or fy or fz or engvib or engrot or engtrans or omega or velvib or v_name\n * dist = bond distance\n * engpot = bond potential energy\n * force = bond force\n * fx,fy,fz = components of bond force\n * engvib = bond kinetic energy of vibration\n * engrot = bond kinetic energy of rotation\n * engtrans = bond kinetic energy of translation\n * omega = magnitude of bond angular velocity\n * velvib = vibrational velocity along the bond length\n * v_name = equal-style variable with name (see below)\n * zero or more keyword/args pairs may be appended\n * keyword = set\n * set args = dist name\n *   dist = only currently allowed arg\n *   name = name of variable to set with distance (dist)",
    "examples": "compute 1 all bond/local engpot\ncompute 1 all bond/local dist engpot force\n\ncompute 1 all bond/local dist fx fy fz\n\ncompute 1 all angle/local dist v_distsq set dist d",
    "restrictions": "\nnone"
},
{
    "command": "compute centro/atom",
    "html_filename": "compute_centro_atom.html",
    "short_description": "Define a computation that calculates the centro-symmetry parameter for each atom in the group, for either FCC or BCC lattices, depending on the choice of the lattice argument",
    "description": "Define a computation that calculates the centro-symmetry parameter for\neach atom in the group, for either FCC or BCC lattices, depending on\nthe choice of the lattice argument.  In solid-state systems the\ncentro-symmetry parameter is a useful measure of the local lattice\ndisorder around an atom and can be used to characterize whether the\natom is part of a perfect lattice, a local defect (e.g. a dislocation\nor stacking fault), or at a surface.\nThe value of the centro-symmetry parameter will be 0.0 for atoms not\nin the specified compute group.\nThis parameter is computed using the following formula from\n(Kelchner)\n\n\\[CS = \\sum_{i = 1}^{N/2} | \\vec{R}_i + \\vec{R}_{i+N/2} |^2\\]\nwhere the \\(N\\) nearest neighbors of each atom are identified and\n\\(\\vec{R}_i\\) and \\(\\vec{R}_{i+N/2}\\) are vectors from the\ncentral atom to a particular pair of nearest neighbors.  There are\n\\(N (N-1)/2\\) possible neighbor pairs that can contribute to this\nformula.  The quantity in the sum is computed for each, and the\n\\(N/2\\) smallest are used.  This will typically be for pairs of\natoms in symmetrically opposite positions with respect to the central\natom; hence the \\(i+N/2\\) notation.\n\\(N\\) is an input parameter, which should be set to correspond to\nthe number of nearest neighbors in the underlying lattice of atoms.\nIf the keyword fcc or bcc is used, N is set to 12 and 8\nrespectively.  More generally, N can be set to a positive, even\ninteger.\nFor an atom on a lattice site, surrounded by atoms on a perfect\nlattice, the centro-symmetry parameter will be 0.  It will be near 0\nfor small thermal perturbations of a perfect lattice.  If a point\ndefect exists, the symmetry is broken, and the parameter will be a\nlarger positive value.  An atom at a surface will have a large\npositive parameter.  If the atom does not have \\(N\\) neighbors\n(within the potential cutoff), then its centro-symmetry parameter is\nset to 0.0.\nIf the keyword axes has the setting yes, then this compute also\nestimates three symmetry axes for each atom’s local neighborhood.  The\nfirst two of these are the vectors joining the two pairs of neighbor\natoms with smallest contributions to the centrosymmetry parameter,\ni.e. the two most symmetric pairs of atoms.  The third vector is\nnormal to the first two by the right-hand rule.  All three vectors are\nnormalized to unit length.  For FCC crystals, the first two vectors\nwill lie along a <110> direction, while the third vector will lie\nalong either a <100> or <111> direction.  For HCP crystals, the first\ntwo vectors will lie along <1000> directions, while the third vector\nwill lie along <0001>.  This provides a simple way to measure local\norientation in HCP structures.  In general, the axes keyword can be\nused to estimate the orientation of symmetry axes in the neighborhood\nof any atom.\nOnly atoms within the cutoff of the pairwise neighbor list are\nconsidered as possible neighbors.  Atoms not in the compute group are\nincluded in the \\(N\\) neighbors used in this calculation.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (e.g. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each with a\ncentro/atom style.\nOutput info:\nBy default, this compute calculates the centrosymmetry value for each\natom as a per-atom vector, which can be accessed by any command that\nuses per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nIf the axes keyword setting is yes, then a per-atom array is\ncalculated. The first column is the centrosymmetry parameter.  The\nnext three columns are the x, y, and z components of the first\nsymmetry axis, followed by the second, and third symmetry axes in\ncolumns 5-7 and 8-10.\nThe centrosymmetry values are unitless values >= 0.0.  Their magnitude\ndepends on the lattice style due to the number of contributing neighbor\npairs in the summation in the formula above.  And it depends on the\nlocal defects surrounding the central atom, as described above.  For\nthe axes yes case, the vector components are also unitless, since\nthey represent spatial directions.\nHere are typical centro-symmetry values, from a nanoindentation\nsimulation into gold (FCC).  These were provided by Jon Zimmerman\n(Sandia):\nBulk lattice = 0\nDislocation core ~ 1.0 (0.5 to 1.25)\nStacking faults ~ 5.0 (4.0 to 6.0)\nFree surface ~ 23.0\n\n\nThese values are *not* normalized by the square of the lattice\nparameter.  If they were, normalized values would be:\nBulk lattice = 0\nDislocation core ~ 0.06 (0.03 to 0.075)\nStacking faults ~ 0.3 (0.24 to 0.36)\nFree surface ~ 1.38\n\n\nFor BCC materials, the values for dislocation cores and free surfaces\nwould be somewhat different, due to their being only 8 neighbors instead\nof 12.",
    "syntax": "compute ID group-ID centro/atom lattice keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * centro/atom = style name of this compute command\n * lattice = fcc or bcc or N = # of neighbors per atom to include\n * zero or more keyword/value pairs may be appended\n * keyword = axes\n * axes value = no or yes\n *   no = do not calculate 3 symmetry axes\n *   yes = calculate 3 symmetry axes",
    "examples": "compute 1 all centro/atom fcc\n\ncompute 1 all centro/atom 8",
    "restrictions": "\nnone"
},
{
    "command": "compute chunk/atom",
    "html_filename": "compute_chunk_atom.html",
    "short_description": "Define a computation that calculates an integer chunk ID from 1 to Nchunk for each atom in the group",
    "description": "Define a computation that calculates an integer chunk ID from 1 to\nNchunk for each atom in the group.  Values of chunk IDs are determined\nby the style of chunk, which can be based on atom type or molecule\nID or spatial binning or a per-atom property or value calculated by\nanother compute, fix, or atom-style variable.  Per-atom chunk IDs can be used by other\ncomputes with “chunk” in their style name, such as compute com/chunk or compute msd/chunk.  Or they can be used by the fix ave/chunk command to sum and time average a\nvariety of per-atom properties over the atoms in each chunk.  Or they\ncan simply be accessed by any command that uses per-atom values from a\ncompute as input, as discussed on the Howto output\ndoc page.\nSee the Howto chunk doc page for an overview of how\nthis compute can be used with a variety of other commands to tabulate\nproperties of a simulation.  The page gives several examples of input\nscript commands that can be used to calculate interesting properties.\nConceptually it is important to realize that this compute does two\nsimple things.  First, it sets the value of Nchunk = the number of\nchunks, which can be a constant value or change over time.  Second, it\nassigns each atom to a chunk via a chunk ID.  Chunk IDs range from 1\nto Nchunk inclusive; some chunks may have no atoms assigned to them.\nAtoms that do not belong to any chunk are assigned a value of 0.  Note\nthat the two operations are not always performed together.  For\nexample, spatial bins can be setup once (which sets Nchunk), and\natoms assigned to those bins many times thereafter (setting their\nchunk IDs).\nAll other commands in LAMMPS that use chunk IDs assume there are\nNchunk number of chunks, and that every atom is assigned to one of\nthose chunks, or not assigned to any chunk.\nThere are many options for specifying for how and when Nchunk is\ncalculated, and how and when chunk IDs are assigned to atoms.  The\ndetails depend on the chunk style and its args, as well as\noptional keyword settings.  They can also depend on whether a fix ave/chunk command is using this compute, since\nthat command requires Nchunk to remain static across windows of\ntimesteps it specifies, while it accumulates per-chunk averages.\nThe details are described below.\n\nThe different chunk styles operate as follows.  For each style, how it\ncalculates Nchunk and assigns chunk IDs to atoms is explained.  Note\nthat using the optional keywords can change both of those actions, as\ndescribed further below where the keywords are discussed.\n\nThe binning styles perform a spatial binning of atoms, and assign an\natom the chunk ID corresponding to the bin number it is in.  Nchunk\nis set to the number of bins, which can change if the simulation box\nsize changes.  This also depends on the setting of the units\nkeyword; e.g. for reduced units the number of chunks may not change\neven if the box size does.\nThe bin/1d, bin/2d, and bin/3d styles define bins as 1d layers\n(slabs), 2d pencils, or 3d boxes.  The dim, origin, and delta\nsettings are specified 1, 2, or 3 times.  For 2d or 3d bins, there is\nno restriction on specifying dim = x before dim = y or z, or dim = y\nbefore dim = z.  Bins in a particular dim have a bin size in that\ndimension given by delta.  In each dimension, bins are defined\nrelative to a specified origin, which may be the lower/upper edge of\nthe simulation box (in that dimension), or its center point, or a\nspecified coordinate value.  Starting at the origin, sufficient bins\nare created in both directions to completely span the simulation box\nor the bounds specified by the optional bounds keyword.\nFor orthogonal simulation boxes, the bins are layers, pencils, or\nboxes aligned with the xyz coordinate axes.  For triclinic\n(non-orthogonal) simulation boxes, the bin faces are parallel to the\ntilted faces of the simulation box.  See the Howto triclinic doc page for a discussion of the\ngeometry of triclinic boxes in LAMMPS.  As described there, a tilted\nsimulation box has edge vectors a,b,c.  In that nomenclature, bins in\nthe x dimension have faces with normals in the “b” cross “c”\ndirection.  Bins in y have faces normal to the “a” cross “c”\ndirection.  And bins in z have faces normal to the “a” cross “b”\ndirection.  Note that in order to define the size and position of\nthese bins in an unambiguous fashion, the units option must be set\nto reduced when using a triclinic simulation box, as noted below.\nThe meaning of origin and delta for triclinic boxes is as follows.\nConsider a triclinic box with bins that are 1d layers or slabs in the\nx dimension.  No matter how the box is tilted, an origin of 0.0\nmeans start layers at the lower “b” cross “c” plane of the simulation\nbox and an origin of 1.0 means to start layers at the upper “b”\ncross “c” face of the box.  A delta value of 0.1 in reduced units\nmeans there will be 10 layers from 0.0 to 1.0, regardless of the\ncurrent size or shape of the simulation box.\nThe bin/sphere style defines a set of spherical shell bins around\nthe origin (xorig,yorig,zorig), using nsbin bins with radii\nequally spaced between srmin and srmax.  This is effectively a 1d\nvector of bins.  For example, if srmin = 1.0 and srmax = 10.0 and\nnsbin = 9, then the first bin spans 1.0 < r < 2.0, and the last bin\nspans 9.0 < r 10.0.  The geometry of the bins is the same whether the\nsimulation box is orthogonal or triclinic; i.e. the spherical shells\nare not tilted or scaled differently in different dimensions to\ntransform them into ellipsoidal shells.\nThe bin/cylinder style defines bins for a cylinder oriented along\nthe axis dim with the axis coordinates in the other two radial\ndimensions at (c1,c2).  For dim = x, c1/c2 = y/z; for dim = y,\nc1/c2 = x/z; for dim = z, c1/c2 = x/y.  This is effectively a 2d array\nof bins.  The first dimension is along the cylinder axis, the second\ndimension is radially outward from the cylinder axis.  The bin size\nand positions along the cylinder axis are specified by the origin\nand delta values, the same as for the bin/1d, bin/2d, and\nbin/3d styles.  There are ncbin concentric circle bins in the\nradial direction from the cylinder axis with radii equally spaced\nbetween crmin and crmax.  For example, if crmin = 1.0 and\ncrmax = 10.0 and ncbin = 9, then the first bin spans 1.0 < r <\n2.0, and the last bin spans 9.0 < r 10.0.  The geometry of the bins in\nthe radial dimensions is the same whether the simulation box is\northogonal or triclinic; i.e. the concentric circles are not tilted or\nscaled differently in the two different dimensions to transform them\ninto ellipses.\nThe created bins (and hence the chunk IDs) are numbered consecutively\nfrom 1 to the number of bins = Nchunk.  For bin2d and bin3d, the\nnumbering varies most rapidly in the first dimension (which could be\nx, y, or z), next rapidly in the 2nd dimension, and most slowly in the\n3rd dimension.  For bin/sphere, the bin with smallest radii is chunk\n1 and the bni with largest radii is chunk Nchunk = ncbin.  For\nbin/cylinder, the numbering varies most rapidly in the dimension\nalong the cylinder axis and most slowly in the radial direction.\nEach time this compute is invoked, each atom is mapped to a bin based\non its current position.  Note that between reneighboring timesteps,\natoms can move outside the current simulation box.  If the box is\nperiodic (in that dimension) the atom is remapping into the periodic\nbox for purposes of binning.  If the box in not periodic, the atom may\nhave moved outside the bounds of all bins.  If an atom is not inside\nany bin, the discard keyword is used to determine how a chunk ID is\nassigned to the atom.\n\nThe type style uses the atom type as the chunk ID.  Nchunk is set\nto the number of atom types defined for the simulation, e.g. via the\ncreate_box or read_data commands.\n\nThe molecule style uses the molecule ID of each atom as its chunk\nID.  Nchunk is set to the largest chunk ID.  Note that this excludes\nmolecule IDs for atoms which are not in the specified group or\noptional region.\nThere is no requirement that all atoms in a particular molecule are\nassigned the same chunk ID (zero or non-zero), though you probably\nwant that to be the case, if you wish to compute a per-molecule\nproperty.  LAMMPS will issue a warning if that is not the case, but\nonly the first time that Nchunk is calculated.\nNote that atoms with a molecule ID = 0, which may be non-molecular\nsolvent atoms, have an out-of-range chunk ID.  These atoms are\ndiscarded (not assigned to any chunk) or assigned to Nchunk,\ndepending on the value of the discard keyword.\n\nThe compute/fix/variable styles set the chunk ID of each atom based\non a quantity calculated and stored by a compute, fix, or variable.\nIn each case, it must be a per-atom quantity.  In each case the\nreferenced floating point values are converted to an integer chunk ID\nas follows.  The floating point value is truncated (rounded down) to\nan integer value.  If the integer value is <= 0, then a chunk ID of 0\nis assigned to the atom.  If the integer value is > 0, it becomes the\nchunk ID to the atom.  Nchunk is set to the largest chunk ID.  Note\nthat this excludes atoms which are not in the specified group or\noptional region.\nIf the style begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  If no bracketed integer is\nappended, the per-atom vector calculated by the compute is used.  If a\nbracketed integer is appended, the Ith column of the per-atom array\ncalculated by the compute is used.  Users can also write code for\ntheir own compute styles and add them to LAMMPS.\nIf the style begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  If no bracketed integer is\nappended, the per-atom vector calculated by the fix is used.  If a\nbracketed integer is appended, the Ith column of the per-atom array\ncalculated by the fix is used.  Note that some fixes only produce\ntheir values on certain timesteps, which must be compatible with the\ntimestep on which this compute accesses the fix, else an error\nresults.  Users can also write code for their own fix styles and add them to LAMMPS.\nIf a value begins with “v_”, a variable name for an atom or\natomfile style variable must follow which has been\npreviously defined in the input script.  Variables of style atom can\nreference thermodynamic keywords and various per-atom attributes, or\ninvoke other computes, fixes, or variables when they are evaluated, so\nthis is a very general means of generating per-atom quantities to\ntreat as a chunk ID.\n\nNormally, Nchunk = the number of chunks, is re-calculated every time\nthis fix is invoked, though the value may or may not change.  As\nexplained below, the nchunk keyword can be set to once which means\nNchunk will never change.\nIf a fix ave/chunk command uses this compute, it\ncan also turn off the re-calculation of Nchunk for one or more\nwindows of timesteps.  The extent of the windows, during which Nchunk\nis held constant, are determined by the Nevery, Nrepeat, Nfreq\nvalues and the ave keyword setting that are used by the fix ave/chunk command.\nSpecifically, if ave = one, then for each span of Nfreq\ntimesteps, Nchunk is held constant between the first timestep when\naveraging is done (within the Nfreq-length window), and the last\ntimestep when averaging is done (multiple of Nfreq).  If ave =\nrunning or window, then Nchunk is held constant forever,\nstarting on the first timestep when the fix ave/chunk command invokes this compute.\nNote that multiple fix ave/chunk commands can use\nthe same compute chunk/atom compute.  However, the time windows they\ninduce for holding Nchunk constant must be identical, else an error\nwill be generated.\n\nThe various optional keywords operate as follows.  Note that some of\nthem function differently or are ignored by different chunk styles.\nSome of them also have different default values, depending on\nthe chunk style, as listed below.\nThe region keyword applies to all chunk styles.  If used, an atom\nmust be in both the specified group and the specified geometric\nregion to be assigned to a chunk.\n\nThe nchunk keyword applies to all chunk styles.  It specifies how\noften Nchunk is recalculated, which in turn can affect the chunk IDs\nassigned to individual atoms.\nIf nchunk is set to once, then Nchunk is only calculated once,\nthe first time this compute is invoked.  If nchunk is set to\nevery, then Nchunk is re-calculated every time the compute is\ninvoked.  Note that, as described above, the use of this compute\nby the fix ave/chunk command can override\nthe every setting.\nThe default values for nchunk are listed below and depend on the\nchunk style and other system and keyword settings.  They attempt to\nrepresent typical use cases for the various chunk styles.  The\nnchunk value can always be set explicitly if desired.\n\nThe limit keyword can be used to limit the calculated value of\nNchunk = the number of chunks.  The limit is applied each time\nNchunk is calculated, which also limits the chunk IDs assigned to\nany atom.  The limit keyword is used by all chunk styles except the\nbinning styles, which ignore it.  This is because the number of bins\ncan be tailored using the bound keyword (described below) which\neffectively limits the size of Nchunk.\nIf limit is set to Nc = 0, then no limit is imposed on Nchunk,\nthough the compress keyword can still be used to reduce Nchunk, as\ndescribed below.\nIf Nc > 0, then the effect of the limit keyword depends on whether\nthe compress keyword is also used with a setting of yes, and\nwhether the compress keyword is specified before the limit keyword\nor after.\nIn all cases, Nchunk is first calculated in the usual way for each\nchunk style, as described above.\nFirst, here is what occurs if compress yes is not set.  If limit\nis set to Nc max, then Nchunk is reset to the smaller of Nchunk\nand Nc.  If limit is set to Nc exact, then Nchunk is reset to\nNc, whether the original Nchunk was larger or smaller than Nc.\nIf Nchunk shrank due to the limit setting, then atom chunk IDs >\nNchunk will be reset to 0 or Nchunk, depending on the setting of\nthe discard keyword.  If Nchunk grew, there will simply be some\nchunks with no atoms assigned to them.\nIf compress yes is set, and the compress keyword comes before the\nlimit keyword, the compression operation is performed first, as\ndescribed below, which resets Nchunk.  The limit keyword is then\napplied to the new Nchunk value, exactly as described in the\npreceding paragraph.  Note that in this case, all atoms will end up\nwith chunk IDs <= Nc, but their original values (e.g. molecule ID or\ncompute/fix/variable) may have been > Nc, because of the compression\noperation.\nIf compress yes is set, and the compress keyword comes after the\nlimit keyword, then the limit value of Nc is applied first to\nthe uncompressed value of Nchunk, but only if Nc < Nchunk\n(whether Nc max or Nc exact is used).  This effectively means all\natoms with chunk IDs > Nc have their chunk IDs reset to 0 or Nc,\ndepending on the setting of the discard keyword.  The compression\noperation is then performed, which may shrink Nchunk further.  If\nthe new Nchunk < Nc and limit = Nc exact is specified, then\nNchunk is reset to Nc, which results in extra chunks with no atoms\nassigned to them.  Note that in this case, all atoms will end up with\nchunk IDs <= Nc, and their original values (e.g. molecule ID or\ncompute/fix/variable value) will also have been <= Nc.\n\nThe ids keyword applies to all chunk styles.  If the setting is\nonce then the chunk IDs assigned to atoms the first time this\ncompute is invoked will be permanent, and never be re-computed.\nIf the setting is nfreq and if a fix ave/chunk\ncommand is using this compute, then in each of the Nchunk = constant\ntime windows (discussed above), the chunk ID’s assigned to atoms on\nthe first step of the time window will persist until the end of the\ntime window.\nIf the setting is every, which is the default, then chunk IDs are\nre-calculated on any timestep this compute is invoked.\n\nNote\nIf you want the persistent chunk-IDs calculated by this compute\nto be continuous when running from a restart file,\nthen you should use the same ID for this compute, as in the original\nrun.  This is so that the fix this compute creates to store per-atom\nquantities will also have the same ID, and thus be initialized\ncorrectly with chunk IDs from the restart file.\n\n\nThe compress keyword applies to all chunk styles and affects how\nNchunk is calculated, which in turn affects the chunk IDs assigned\nto each atom.  It is useful for converting a “sparse” set of chunk IDs\n(with many IDs that have no atoms assigned to them), into a “dense”\nset of IDs, where every chunk has one or more atoms assigned to it.\nTwo possible use cases are as follows.  If a large simulation box is\nmostly empty space, then the binning style may produce many bins\nwith no atoms.  If compress is set to yes, only bins with atoms\nwill be contribute to Nchunk.  Likewise, the molecule or\ncompute/fix/variable styles may produce large Nchunk values.  For\nexample, the compute cluster/atom command\nassigns every atom an atom ID for one of the atoms it is clustered\nwith.  For a million-atom system with 5 clusters, there would only be\n5 unique chunk IDs, but the largest chunk ID might be 1 million,\nresulting in Nchunk = 1 million.  If compress is set to yes,\nNchunk will be reset to 5.\nIf compress is set to no, which is the default, no compression is\ndone.  If it is set to yes, all chunk IDs with no atoms are removed\nfrom the list of chunk IDs, and the list is sorted.  The remaining\nchunk IDs are renumbered from 1 to Nchunk where Nchunk is the new\nlength of the list.  The chunk IDs assigned to each atom reflect\nthe new renumbering from 1 to Nchunk.\nThe original chunk IDs (before renumbering) can be accessed by the\ncompute property/chunk command and its\nid keyword, or by the fix ave/chunk command\nwhich outputs the original IDs as one of the columns in its global\noutput array.  For example, using the “compute cluster/atom” command\ndiscussed above, the original 5 unique chunk IDs might be atom IDs\n(27,4982,58374,857838,1000000).  After compression, these will be\nrenumbered to (1,2,3,4,5).  The original values (27,…,1000000) can\nbe output to a file by the fix ave/chunk command,\nor by using the fix ave/time command in\nconjunction with the compute property/chunk command.\n\nNote\nThe compression operation requires global communication across\nall processors to share their chunk ID values.  It can require large\nmemory on every processor to store them, even after they are\ncompressed, if there are a large number of unique chunk IDs with\natoms assigned to them.  It uses a STL map to find unique chunk IDs\nand store them in sorted order.  Each time an atom is assigned a\ncompressed chunk ID, it must access the STL map.  All of this means\nthat compression can be expensive, both in memory and CPU time.  The\nuse of the limit keyword in conjunction with the compress keyword\ncan affect these costs, depending on which keyword is used first.  So\nuse this option with care.\n\n\nThe discard keyword applies to all chunk styles.  It affects what\nchunk IDs are assigned to atoms that do not match one of the valid\nchunk IDs from 1 to Nchunk.  Note that it does not apply to atoms\nthat are not in the specified group or optionally specified region.\nThose atoms are always assigned a chunk ID = 0.\nIf the calculated chunk ID for an atom is not within the range 1 to\nNchunk then it is a “discard” atom.  Note that Nchunk may have\nbeen shrunk by the limit keyword.  Or the compress keyword may\nhave eliminated chunk IDs that were valid before the compression took\nplace, and are now not in the compressed list.  Also note that for the\nmolecule chunk style, if new molecules are added to the system,\ntheir chunk IDs may exceed a previously calculated Nchunk.\nLikewise, evaluation of a compute/fix/variable on a later timestep may\nreturn chunk IDs that are invalid for the previously calculated\nNchunk.\nAll the chunk styles except the binning styles, must use discard\nset to either yes or no.  If discard is set to yes, which is\nthe default, then every “discard” atom has its chunk ID set to 0.  If\ndiscard is set to no, every “discard” atom has its chunk ID set to\nNchunk.  I.e. it becomes part of the last chunk.\nThe binning styles use the discard keyword to decide whether to\ndiscard atoms outside the spatial domain covered by bins, or to assign\nthem to the bin they are nearest to.\nFor the bin/1d, bin/2d, bin/3d styles the details are as\nfollows.  If discard is set to yes, an out-of-domain atom will\nhave its chunk ID set to 0.  If discard is set to no, the atom\nwill have its chunk ID set to the first or last bin in that dimension.\nIf discard is set to mixed, which is the default, it will only\nhave its chunk ID set to the first or last bin if bins extend to the\nsimulation box boundary in that dimension.  This is the case if the\nbound keyword settings are lower and upper, which is the\ndefault.  If the bound keyword settings are numeric values, then the\natom will have its chunk ID set to 0 if it is outside the bounds of\nany bin.  Note that in this case, it is possible that the first or\nlast bin extends beyond the numeric bounds settings, depending on\nthe specified origin.  If this is the case, the chunk ID of the atom\nis only set to 0 if it is outside the first or last bin, not if it is\nsimply outside the numeric bounds setting.\nFor the bin/sphere style the details are as follows.  If discard\nis set to yes, an out-of-domain atom will have its chunk ID set to\n0.  If discard is set to no or mixed, the atom will have its\nchunk ID set to the first or last bin, i.e. the innermost or outermost\nspherical shell.  If the distance of the atom from the origin is less\nthan rmin, it will be assigned to the first bin.  If the distance of\nthe atom from the origin is greater than rmax, it will be assigned\nto the last bin.\nFor the bin/cylinder style the details are as follows.  If discard\nis set to yes, an out-of-domain atom will have its chunk ID set to\n0.  If discard is set to no, the atom will have its chunk ID set\nto the first or last bin in both the radial and axis dimensions.  If\ndiscard is set to mixed, which is the default, the radial\ndimension is treated the same as for discard = no.  But for the axis\ndimension, it will only have its chunk ID set to the first or last\nbin if bins extend to the simulation box boundary in the axis\ndimension.  This is the case if the bound keyword settings are\nlower and upper, which is the default.  If the bound keyword\nsettings are numeric values, then the atom will have its chunk ID set\nto 0 if it is outside the bounds of any bin.  Note that in this case,\nit is possible that the first or last bin extends beyond the numeric\nbounds settings, depending on the specified origin.  If this is\nthe case, the chunk ID of the atom is only set to 0 if it is outside\nthe first or last bin, not if it is simply outside the numeric\nbounds setting.\nIf discard is set to no or mixed, the atom will have its\nchunk ID set to the first or last bin, i.e. the innermost or outermost\nspherical shell.  If the distance of the atom from the origin is less\nthan rmin, it will be assigned to the first bin.  If the distance of\nthe atom from the origin is greater than rmax, it will be assigned\nto the last bin.\n\nThe bound keyword only applies to the bin/1d, bin/2d, bin/3d\nstyles and to the axis dimension of the bin/cylinder style;\notherwise it is ignored.  It can be used one or more times to limit\nthe extent of bin coverage in a specified dimension, i.e. to only bin\na portion of the box.  If the lo setting is lower or the hi\nsetting is upper, the bin extent in that direction extends to the\nbox boundary.  If a numeric value is used for lo and/or hi, then\nthe bin extent in the lo or hi direction extends only to that\nvalue, which is assumed to be inside (or at least near) the simulation\nbox boundaries, though LAMMPS does not check for this.  Note that\nusing the bound keyword typically reduces the total number of bins\nand thus the number of chunks Nchunk.\nThe pbc keyword only applies to the bin/sphere and bin/cylinder\nstyles.  If set to yes, the distance an atom is from the sphere\norigin or cylinder axis is calculated in a minimum image sense with\nrespect to periodic dimensions, when determining which bin the atom is\nin.  I.e. if x is a periodic dimension and the distance between the\natom and the sphere center in the x dimension is greater than 0.5 *\nsimulation box length in x, then a box length is subtracted to give a\ndistance < 0.5 * simulation box length.  This allosws the sphere or\ncylinder center to be near a box edge, and atoms on the other side of\nthe periodic box will still be close to the center point/axis.  Note\nthat with a setting of yes, the outer sphere or cylinder radius must\nalso be <= 0.5 * simulation box length in any periodic dimension\nexcept for the cylinder axis dimension, or an error is generated.\nThe units keyword only applies to the binning styles; otherwise it\nis ignored.  For the bin/1d, bin/2d, bin/3d styles, it\ndetermines the meaning of the distance units used for the bin sizes\ndelta and for origin and bounds values if they are coordinate\nvalues.  For the bin/sphere style it determines the meaning of the\ndistance units used for xorig,yorig,zorig and the radii srmin\nand srmax.  For the bin/cylinder style it determines the meaning\nof the distance units used for delta,c1,c2 and the radii crmin\nand crmax.\nFor orthogonal simulation boxes, any of the 3 options may\nbe used.  For non-orthogonal (triclinic) simulation boxes, only the\nreduced option may be used.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacing.  A reduced value means normalized\nunitless values between 0 and 1, which represent the lower and upper\nfaces of the simulation box respectively.  Thus an origin value of\n0.5 means the center of the box in any dimension.  A delta value of\n0.1 means 10 bins span the box in that dimension.\nNote that for the bin/sphere style, the radii srmin and srmax are\nscaled by the lattice spacing or reduced value of the x dimension.\nNote that for the bin/cylinder style, the radii crmin and crmax\nare scaled by the lattice spacing or reduced value of the 1st\ndimension perpendicular to the cylinder axis.  E.g. y for an x-axis\ncylinder, x for a y-axis cylinder, and x for a z-axis cylinder.\n\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values are unitless chunk IDs, ranging from 1 to\nNchunk (inclusive) for atoms assigned to chunks, and 0 for atoms not\nbelonging to a chunk.",
    "syntax": "compute ID group-ID chunk/atom style args keyword values ...",
    "parameters": " * ID, group-ID are documented in compute command\n * chunk/atom = style name of this compute command\n * style = bin/1d or bin/2d or bin/3d or bin/sphere or type or molecule or c_ID, c_ID[I], f_ID, f_ID[I], v_name\n *   bin/1d args = dim origin delta\n *     dim = x or y or z\n *     origin = lower or center or upper or coordinate value (distance units)\n *     delta = thickness of spatial bins in dim (distance units)\n *   bin/2d args = dim origin delta dim origin delta\n *     dim = x or y or z\n *     origin = lower or center or upper or coordinate value (distance units)\n *     delta = thickness of spatial bins in dim (distance units)\n *   bin/3d args = dim origin delta dim origin delta dim origin delta\n *     dim = x or y or z\n *     origin = lower or center or upper or coordinate value (distance units)\n *     delta = thickness of spatial bins in dim (distance units)\n *   bin/sphere args = xorig yorig zorig rmin rmax nsbin\n *     xorig,yorig,zorig = center point of sphere\n *     srmin,srmax = bin from sphere radius rmin to rmax\n *     nsbin = # of spherical shell bins between rmin and rmax\n *   bin/cylinder args = dim origin delta c1 c2 rmin rmax ncbin\n *     dim = x or y or z = axis of cylinder axis\n *     origin = lower or center or upper or coordinate value (distance units)\n *     delta = thickness of spatial bins in dim (distance units)\n *     c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n *     crmin,crmax = bin from cylinder radius rmin to rmax (distance units)\n *     ncbin = # of concentric circle bins between rmin and rmax\n *   type args = none\n *   molecule args = none\n *   c_ID, c_ID[I], f_ID, f_ID[I], v_name args = none\n *     c_ID = per-atom vector calculated by a compute with ID\n *     c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n *     f_ID = per-atom vector calculated by a fix with ID\n *     f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n *     v_name = per-atom vector calculated by an atom-style variable with name\n * zero or more keyword/values pairs may be appended\n * keyword = region or nchunk or static or compress or bound or discard or pbc or units\n * region value = region-ID\n *   region-ID = ID of region atoms must be in to be part of a chunk\n * nchunk value = once or every\n *   once = only compute the number of chunks once\n *   every = re-compute the number of chunks whenever invoked\n * limit values = 0 or Nc max or Nc exact\n *   0 = no limit on the number of chunks\n *   Nc max = limit number of chunks to be <= Nc\n *   Nc exact = set number of chunks to exactly Nc\n * ids value = once or nfreq or every\n *   once = assign chunk IDs to atoms only once, they persist thereafter\n *   nfreq = assign chunk IDs to atoms only once every Nfreq steps (if invoked by fix ave/chunk which sets Nfreq)\n *   every = assign chunk IDs to atoms whenever invoked\n * compress value = yes or no\n *   yes = compress chunk IDs to eliminate IDs with no atoms\n *   no = do not compress chunk IDs even if some IDs have no atoms\n * discard value = yes or no or mixed\n *   yes = discard atoms with out-of-range chunk IDs by assigning a chunk ID = 0\n *   no = keep atoms with out-of-range chunk IDs by assigning a valid chunk ID\n *   mixed = keep or discard such atoms according to spatial binning rule\n * bound values = x/y/z lo hi\n *   x/y/z = x or y or z to bound sptial bins in this dimension\n *   lo = lower or coordinate value (distance units)\n *   hi = upper or coordinate value (distance units)\n * pbc value = no or yes\n *   yes = use periodic distance for bin/sphere and bin/cylinder styles\n * units value = box or lattice or reduced",
    "examples": "compute 1 all chunk/atom type\ncompute 1 all chunk/atom bin/1d z lower 0.02 units reduced\ncompute 1 all chunk/atom bin/2d z lower 1.0 y 0.0 2.5\ncompute 1 all chunk/atom molecule region sphere nchunk once ids once compress yes\ncompute 1 all chunk/atom bin/sphere 5 5 5 2.0 5.0 5 discard yes\ncompute 1 all chunk/atom bin/cylinder z lower 2 10 10 2.0 5.0 3 discard yes\ncompute 1 all chunk/atom c_cluster",
    "restrictions": "Even if the nchunk keyword is set to once, the chunk IDs assigned\nto each atom are not stored in a restart files.  This means you cannot\nexpect those assignments to persist in a restarted simulation.\nInstead you must re-specify this command and assign atoms to chunks when\nthe restarted simulation begins."
},
{
    "command": "compute chunk/spread/atom",
    "html_filename": "compute_chunk_spread_atom.html",
    "short_description": "Define a calculation that “spreads” one or more per-chunk values to each atom in the chunk",
    "description": "Define a calculation that “spreads” one or more per-chunk values to\neach atom in the chunk.  This can be useful in several scenarios:\n\nFor creating a dump file where each atom lists info about\nthe chunk it is in, e.g. for post-processing purposes.\nTo access chunk value in atom-style variables that\nneed info about the chunk each atom is in.\nTo use the fix ave/chunk command to spatially\naverage per-chunk values calculated by a per-chunk compute.\n\nExamples are given below.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nFor inputs that are computes, they must be a compute that calculates\nper-chunk values.  These are computes whose style names end in\n“/chunk”.\nFor inputs that are fixes, they should be a fix that calculates\nper-chunk values.  For example, fix ave/chunk or\nfix ave/time (assuming it is time-averaging\nper-chunk data).\nFor each atom, this compute accesses its chunk ID from the specified\nchunkID compute, then accesses the per-chunk value in each input.\nThose values are copied to this compute to become the output for that\natom.\nThe values generated by this compute will be 0.0 for atoms not in the\nspecified compute group group-ID.  They will also be 0.0 if the atom\nis not in a chunk, as assigned by the chunkID compute.  They will\nalso be 0.0 if the current chunk ID for the atom is out-of-bounds with\nrespect to the number of chunks stored by a particular input compute\nor fix.\n\nNote\nLAMMPS does not check that a compute or fix which calculates\nper-chunk values uses the same definition of chunks as this compute.\nIt’s up to you to be consistent.  Likewise, for a fix input, LAMMPS\ndoes not check that it is per-chunk data.  It only checks that the fix\nproduces a global vector or array.\n\n\nEach listed input is operated on independently.\nIf a bracketed index I is used, it can be specified using a wildcard\nasterisk with the index to effectively specify multiple values.  This\ntakes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\ncolumns in the array, then an asterisk with no numeric values means\nall indices from 1 to N.  A leading asterisk means all indices from 1\nto n (inclusive).  A trailing asterisk means all indices from n to N\n(inclusive).  A middle asterisk means all indices from m to n\n(inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 compute chunk/spread/atom\ncommands are equivalent, since the compute com/chunk command creates a per-atom array\nwith 3 columns:\ncompute com all com/chunk mychunk\ncompute 10 all chunk/spread/atom mychunk c_com[*]\ncompute 10 all chunk/spread/atom mychunk c_com[1] c_com[2] c_com[3]\n\n\n\nHere is an example of writing a dump file the with the center-of-mass\n(COM) for the chunk each atom is in.  The commands below can be added\nto the bench/in.chain script.\ncompute         cmol all chunk/atom molecule\ncompute         com all com/chunk cmol\ncompute         comchunk all chunk/spread/atom cmol c_com[*]\ndump            1 all custom 50 tmp.dump id mol type x y z c_comchunk[*]\ndump_modify     1 sort id\n\n\nThe same per-chunk data for each atom could be used to define per-atom\nforces for the fix addforce command.  In this\nexample the forces act to pull atoms of an extended polymer chain\ntowards its COM in an attractive manner.\ncompute         prop all property/atom xu yu zu\nvariable        k equal 0.1\nvariable        fx atom v_k*(c_comchunk[1]-c_prop[1])\nvariable        fy atom v_k*(c_comchunk[2]-c_prop[2])\nvariable        fz atom v_k*(c_comchunk[3]-c_prop[3])\nfix             3 all addforce v_fx v_fy v_fz\nNote that compute property/atom is used\nto generate unwrapped coordinates for use in the per-atom force\ncalculation, so that the effect of periodic boundaries is accounted\nfor properly.\nOver time this applied force could shrink each polymer chain’s radius\nof gyration in a polymer mixture simulation.  Here is output from the\nbench/in.chain script.  Thermo output is shown for 1000 steps, where\nthe last column is the average radius of gyration over all 320 chains\nin the 32000 atom system:\ncompute         gyr all gyration/chunk cmol\nvariable        ave equal ave(c_gyr)\nthermo_style    custom step etotal press v_ave\n\n       0    22.394765    4.6721833     5.128278\n     100    22.445002    4.8166709    5.0348372\n     200    22.500128    4.8790392    4.9364875\n     300    22.534686    4.9183766    4.8590693\n     400    22.557196    4.9492211    4.7937849\n     500    22.571017    4.9161853    4.7412008\n     600    22.573944    5.0229708    4.6931243\n     700    22.581804    5.0541301    4.6440647\n     800    22.584683    4.9691734    4.6000016\n     900     22.59128    5.0247538    4.5611513\n    1000    22.586832      4.94697    4.5238362\n\n\n\nHere is an example for using one set of chunks, defined for molecules,\nto compute the dipole moment vector for each chunk.  E.g. for water\nmolecules. Then spreading those values to each atom in each chunk.\nThen defining a second set of chunks based on spatial bins.  And\nfinally, using the fix ave/chunk command to\ncalculate an average dipole moment vector per spatial bin.\ncompute       cmol all chunk/atom molecule\ncompute       dipole all dipole/chunk cmol\ncompute       spread all chunk/spread/atom cmol c_dipole[1] c_dipole[2] c_dipole[3]\ncompute       cspatial all chunk/atom bin/1d z lower 0.1 units reduced\nfix           ave all ave/chunk 100 10 1000 cspatial c_spread[*]\nNote that the fix ave/chunk command requires\nper-atom values as input.  That is why the compute chunk/spread/atom\ncommand is used to assign per-chunk values to each atom in the chunk.\nIf a molecule straddles bin boundaries, each of its atoms contributes\nin a weighted manner to the average dipole moment of the spatial bin\nit is in.\n\nOutput info:\nThis compute calculates a per-atom vector or array, which can be\naccessed by any command that uses per-atom values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe output is a per-atom vector if a single input value is specified,\notherwise a per-atom array is output.  The number of columns in the\narray is the number of inputs provided.  The per-atom values for the\nvector or each column of the array will be in whatever\nunits the corresponding input value is in.\nThe vector or array values are “intensive”.",
    "syntax": "compute ID group-ID chunk/spread/atom chunkID input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * chunk/spread/atom = style name of this compute command\n * chunkID = ID of compute chunk/atom command\n * one or more inputs can be listed\n * input = c_ID, c_ID[N], f_ID, f_ID[N]\n * c_ID = global vector calculated by a compute with ID\n * c_ID[I] = Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = global vector calculated by a fix with ID\n * f_ID[I] = Ith column of global array calculated by a fix with ID, I can include wildcard (see below)",
    "examples": "compute 1 all chunk/spread/atom mychunk c_com[*] c_gyration",
    "restrictions": "\nnone"
},
{
    "command": "compute cluster/atom",
    "html_filename": "compute_cluster_atom.html",
    "short_description": "Define a computation that assigns each atom a cluster, fragment, or aggregate ID",
    "description": "Define a computation that assigns each atom a cluster, fragment,\nor aggregate ID.\nA cluster is defined as a set of atoms, each of which is within the\ncutoff distance from one or more other atoms in the cluster.  If an\natom has no neighbors within the cutoff distance, then it is a 1-atom\ncluster.\nA fragment is similarly defined as a set of atoms, each of\nwhich has an explicit bond (i.e. defined via a data file,\nthe create_bonds command, or through fixes like\nfix bond/create, fix bond/swap,\nor fix bond/break).  The cluster ID or fragment ID\nof every atom in the cluster will be set to the smallest atom ID of any atom\nin the cluster or fragment, respectively.\nAn aggregate is defined by combining the rules for clusters and\nfragments, i.e. a set of atoms, where each of it is within the cutoff\ndistance from one or more atoms within a fragment that is part of\nthe same cluster. This measure can be used to track molecular assemblies\nlike micelles.\nOnly atoms in the compute group are clustered and assigned cluster\nIDs. Atoms not in the compute group are assigned a cluster ID = 0.\nFor fragments, only bonds where both atoms of the bond are included\nin the compute group are assigned to fragments, so that only fragments\nare detected where all atoms are in the compute group. Thus atoms\nmay be included in the compute group, yes still have a fragment ID of 0.\nFor computes cluster/atom and aggregate/atom the neighbor list needed\nto compute this quantity is constructed each time the calculation is\nperformed (i.e. each time a snapshot of atoms is dumped).  Thus it can be\ninefficient to compute/dump this quantity too frequently or to have\nmultiple compute/dump commands, each of a cluster/atom or\naggregate/atom style.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses the neighbor list, it also means\nthose pairs will not be included when computing the clusters. This\ndoes not apply when using long-range coulomb (coul/long, coul/msm,\ncoul/wolf or similar.  One way to get around this would be to set\nspecial_bond scaling factors to very tiny numbers that are not exactly\nzero (e.g. 1.0e-50). Another workaround is to write a dump file, and\nuse the rerun command to compute the clusters for\nsnapshots in the dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be an ID > 0, as explained above.",
    "syntax": "compute ID group-ID cluster/atom cutoff",
    "parameters": " * compute ID group-ID fragment/atom\n * compute ID group-ID aggregate/atom cutoff\n * ID, group-ID are documented in compute command\n * cluster/atom or fragment/atom or aggregate/atom = style name of this compute command\n * cutoff = distance within which to label atoms as part of same cluster (distance units)",
    "examples": "compute 1 all cluster/atom 3.5\ncompute 1 all fragment/atom\n\ncompute 1 all aggregate/atom 3.5",
    "restrictions": "\nnone"
},
{
    "command": "compute cna/atom",
    "html_filename": "compute_cna_atom.html",
    "short_description": "Define a computation that calculates the CNA (Common Neighbor Analysis) pattern for each atom in the group",
    "description": "Define a computation that calculates the CNA (Common Neighbor\nAnalysis) pattern for each atom in the group.  In solid-state systems\nthe CNA pattern is a useful measure of the local crystal structure\naround an atom.  The CNA methodology is described in (Faken)\nand (Tsuzuki).\nCurrently, there are five kinds of CNA patterns LAMMPS recognizes:\n\nfcc = 1\nhcp = 2\nbcc = 3\nicosahedral = 4\nunknown = 5\n\nThe value of the CNA pattern will be 0 for atoms not in the specified\ncompute group.  Note that normally a CNA calculation should only be\nperformed on mono-component systems.\nThe CNA calculation can be sensitive to the specified cutoff value.\nYou should insure the appropriate nearest neighbors of an atom are\nfound within the cutoff distance for the presumed crystal structure.\nE.g. 12 nearest neighbor for perfect FCC and HCP crystals, 14 nearest\nneighbors for perfect BCC crystals.  These formulas can be used to\nobtain a good cutoff distance:\n\n\\[\\begin{split}r_{c}^{fcc} = & \\frac{1}{2} \\left(\\frac{\\sqrt{2}}{2} + 1\\right) \\mathrm{a} \\simeq 0.8536 \\:\\mathrm{a} \\\\\nr_{c}^{bcc} = & \\frac{1}{2}(\\sqrt{2} + 1) \\mathrm{a} \\simeq 1.207 \\:\\mathrm{a} \\\\\nr_{c}^{hcp} = & \\frac{1}{2}\\left(1+\\sqrt{\\frac{4+2x^{2}}{3}}\\right) \\mathrm{a}\\end{split}\\]\nwhere a is the lattice constant for the crystal structure concerned\nand in the HCP case, x = (c/a) / 1.633, where 1.633 is the ideal c/a\nfor HCP crystals.\nAlso note that since the CNA calculation in LAMMPS uses the neighbors\nof an owned atom to find the nearest neighbors of a ghost atom, the\nfollowing relation should also be satisfied:\n\n\\[r_c + r_s > 2*{\\rm cutoff}\\]\nwhere \\(r_c\\) is the cutoff distance of the potential, \\(r_s\\)\nis the skin\ndistance as specified by the neighbor command, and\ncutoff is the argument used with the compute cna/atom command.  LAMMPS\nwill issue a warning if this is not the case.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (e.g. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each with a\ncna/atom style.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be a number from 0 to 5, as explained\nabove.",
    "syntax": "compute ID group-ID cna/atom cutoff",
    "parameters": " * ID, group-ID are documented in compute command\n * cna/atom = style name of this compute command\n * cutoff = cutoff distance for nearest neighbors (distance units)",
    "examples": "compute 1 all cna/atom 3.08",
    "restrictions": "\nnone"
},
{
    "command": "compute cnp/atom",
    "html_filename": "compute_cnp_atom.html",
    "short_description": "Define a computation that calculates the Common Neighborhood Parameter (CNP) for each atom in the group",
    "description": "Define a computation that calculates the Common Neighborhood\nParameter (CNP) for each atom in the group.  In solid-state systems\nthe CNP is a useful measure of the local crystal structure\naround an atom and can be used to characterize whether the\natom is part of a perfect lattice, a local defect (e.g. a dislocation\nor stacking fault), or at a surface.\nThe value of the CNP parameter will be 0.0 for atoms not in the\nspecified compute group.  Note that normally a CNP calculation should\nonly be performed on single component systems.\nThis parameter is computed using the following formula from\n(Tsuzuki)\n\n\\[Q_{i} = \\frac{1}{n_i}\\sum_{j = 1}^{n_i} | \\sum_{k = 1}^{n_{ij}}  \\vec{R}_{ik} + \\vec{R}_{jk} |^2\\]\nwhere the index j goes over the \\(n_i\\) nearest neighbors of atom\ni, and the index k goes over the \\(n_{ij}\\) common nearest neighbors\nbetween atom i and atom j. \\(\\vec{R}_{ik}\\) and\n\\(\\vec{R}_{jk}\\) are the vectors connecting atom k to atoms i\nand j.  The quantity in the double sum is computed\nfor each atom.\nThe CNP calculation is sensitive to the specified cutoff value.\nYou should ensure that the appropriate nearest neighbors of an atom are\nfound within the cutoff distance for the presumed crystal structure.\nE.g. 12 nearest neighbor for perfect FCC and HCP crystals, 14 nearest\nneighbors for perfect BCC crystals.  These formulas can be used to\nobtain a good cutoff distance:\n\n\\[\\begin{split}r_{c}^{fcc} = & \\frac{1}{2} \\left(\\frac{\\sqrt{2}}{2} + 1\\right) \\mathrm{a} \\simeq 0.8536 \\:\\mathrm{a} \\\\\nr_{c}^{bcc} = & \\frac{1}{2}(\\sqrt{2} + 1) \\mathrm{a} \\simeq 1.207 \\:\\mathrm{a} \\\\\nr_{c}^{hcp} = & \\frac{1}{2}\\left(1+\\sqrt{\\frac{4+2x^{2}}{3}}\\right) \\mathrm{a}\\end{split}\\]\nwhere a is the lattice constant for the crystal structure concerned\nand in the HCP case, x = (c/a) / 1.633, where 1.633 is the ideal c/a\nfor HCP crystals.\nAlso note that since the CNP calculation in LAMMPS uses the neighbors\nof an owned atom to find the nearest neighbors of a ghost atom, the\nfollowing relation should also be satisfied:\n\n\\[r_c + r_s > 2*{\\rm cutoff}\\]\nwhere \\(r_c\\) is the cutoff distance of the potential, \\(r_s\\) is\nthe skin\ndistance as specified by the neighbor command, and\ncutoff is the argument used with the compute cnp/atom command.  LAMMPS\nwill issue a warning if this is not the case.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (e.g. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each with a\ncnp/atom style.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be real positive numbers. Some typical CNP\nvalues:\nFCC lattice = 0.0\nBCC lattice = 0.0\nHCP lattice = 4.4\n\nFCC (111) surface ~ 13.0\nFCC (100) surface ~ 26.5\nFCC dislocation core ~ 11",
    "syntax": "compute ID group-ID cnp/atom cutoff",
    "parameters": " * ID, group-ID are documented in compute command\n * cnp/atom = style name of this compute command\n * cutoff = cutoff distance for nearest neighbors (distance units)",
    "examples": "compute 1 all cnp/atom 3.08",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute com",
    "html_filename": "compute_com.html",
    "short_description": "Define a computation that calculates the center-of-mass of the group of atoms, including all effects due to atoms passing through periodic boundaries",
    "description": "Define a computation that calculates the center-of-mass of the group\nof atoms, including all effects due to atoms passing through periodic\nboundaries.\nA vector of three quantities is calculated by this compute, which\nare the x,y,z coordinates of the center of mass.\n\nNote\nThe coordinates of an atom contribute to the center-of-mass in\n“unwrapped” form, by using the image flags associated with each atom.\nSee the dump custom command for a discussion of\n“unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nOutput info:\nThis compute calculates a global vector of length 3, which can be\naccessed by indices 1-3 by any command that uses global vector values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe vector values are “intensive”.  The vector values will be in\ndistance units.",
    "syntax": "compute ID group-ID com",
    "parameters": " * ID, group-ID are documented in compute command\n * com = style name of this compute command",
    "examples": "compute 1 all com",
    "restrictions": "\nnone"
},
{
    "command": "compute com/chunk",
    "html_filename": "compute_com_chunk.html",
    "short_description": "Define a computation that calculates the center-of-mass for multiple chunks of atoms",
    "description": "Define a computation that calculates the center-of-mass for multiple\nchunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the x,y,z coordinates of the center-of-mass\nfor each chunk, which includes all effects due to atoms passing through\nperiodic boundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s\ncenter-of-mass in “unwrapped” form, by using the image flags\nassociated with each atom.  See the dump custom command\nfor a discussion of “unwrapped” coordinates.  See the Atoms section of\nthe read_data command for a discussion of image flags\nand how they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute com/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all com/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n3 for the x,y,z center-of-mass coordinates of each chunk.  These\nvalues can be accessed by any command that uses global array values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe array values are “intensive”.  The array values will be in\ndistance units.",
    "syntax": "compute ID group-ID com/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * com/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid com/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute contact/atom",
    "html_filename": "compute_contact_atom.html",
    "short_description": "Define a computation that calculates the number of contacts for each atom in a group",
    "description": "Define a computation that calculates the number of contacts\nfor each atom in a group.\nThe contact number is defined for finite-size spherical particles as\nthe number of neighbor atoms which overlap the central particle,\nmeaning that their distance of separation is less than or equal to the\nsum of the radii of the two particles.\nThe value of the contact number will be 0.0 for atoms not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-atom vector, whose values can be\naccessed by any command that uses per-atom values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe per-atom vector values will be a number >= 0.0, as explained\nabove.",
    "syntax": "compute ID group-ID contact/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * contact/atom = style name of this compute command",
    "examples": "compute 1 all contact/atom",
    "restrictions": "This compute requires that atoms store a radius as defined by the\natom_style sphere command."
},
{
    "command": "compute coord/atom",
    "html_filename": "compute_coord_atom.html",
    "short_description": "This compute performs calculations between neighboring atoms to determine a coordination value",
    "description": "This compute performs calculations between neighboring atoms to\ndetermine a coordination value.  The specific calculation and the\nmeaning of the resulting value depend on the cstyle keyword used.\nThe cutoff cstyle calculates one or more traditional coordination\nnumbers for each atom.  A coordination number is defined as the number\nof neighbor atoms with specified atom type(s), and optionally within\nthe specified group, that are within the specified cutoff distance from\nthe central atom. The compute group selects only the central atoms; all\nneighboring atoms, unless selected by type, type range, or group option,\nare included in the coordination number tally.\nThe optional group keyword allows to specify from which group atoms\ncontribute to the coordination number. Default setting is group ‘all’.\nThe typeN keywords allow specification of which atom types\ncontribute to each coordination number.  One coordination number is\ncomputed for each of the typeN keywords listed.  If no typeN\nkeywords are listed, a single coordination number is calculated, which\nincludes atoms of all types (same as the “*” format, see below).\nThe typeN keywords can be specified in one of two ways.  An explicit\nnumeric value can be used, as in the 2nd example above.  Or a\nwild-card asterisk can be used to specify a range of atom types.  This\ntakes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\natom types, then an asterisk with no numeric values means all types\nfrom 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nThe orientorder cstyle calculates the number of “connected” neighbor\natoms J around each central atom I.  For this cstyle, connected is\ndefined by the orientational order parameter calculated by the\ncompute orientorder/atom command.\nThis cstyle thus allows one to apply the ten Wolde’s criterion to\nidentify crystal-like atoms in a system, as discussed in ten Wolde.\nThe ID of the previously specified compute orientorder/atom command is specified as\norientorderID.  The compute must invoke its components option to\ncalculate components of the Ybar_lm vector for each atoms, as\ndescribed in its documentation.  Note that orientorder/atom compute\ndefines its own criteria for identifying neighboring atoms.  If the\nscalar product (Ybar_lm(i),*Ybar_lm(j)*), calculated by the\norientorder/atom compute is larger than the specified threshold,\nthen I and J are connected, and the coordination value of I is\nincremented by one.\nFor all cstyle settings, all coordination values will be 0.0 for\natoms not in the specified compute group.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses the neighbor list, it also means\nthose pairs will not be included in the coordination count.  One way\nto get around this, is to write a dump file, and use the\nrerun command to compute the coordination for snapshots\nin the dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\nOutput info:\nFor cstyle cutoff, this compute can calculate a per-atom vector or\narray.  If single type1 keyword is specified (or if none are\nspecified), this compute calculates a per-atom vector.  If multiple\ntypeN keywords are specified, this compute calculates a per-atom\narray, with N columns.\nFor cstyle orientorder, this compute calculates a per-atom vector.\nThese values can be accessed by any command that uses per-atom values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe per-atom vector or array values will be a number >= 0.0, as\nexplained above.",
    "syntax": "compute ID group-ID coord/atom cstyle args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * coord/atom = style name of this compute command\n * cstyle = cutoff or orientorder\n * cutoff args = cutoff [group group2-ID] typeN\n *   cutoff = distance within which to count coordination neighbors (distance units)\n *   group group2-ID = select group-ID to restrict which atoms to consider for coordination number (optional)\n *   typeN = atom type for Nth coordination count (see asterisk form below)\n * orientorder args = orientorderID threshold\n *   orientorderID = ID of an orientorder/atom compute\n *   threshold = minimum value of the product of two \"connected\" atoms",
    "examples": "compute 1 all coord/atom cutoff 2.0\ncompute 1 all coord/atom cutoff 6.0 1 2\ncompute 1 all coord/atom cutoff 6.0 2*4 5*8 *\ncompute 1 solute coord/atom cutoff 2.0 group solvent\ncompute 1 all coord/atom orientorder 2 0.5",
    "restrictions": "\nnone"
},
{
    "command": "compute damage/atom",
    "html_filename": "compute_damage_atom.html",
    "short_description": "Define a computation that calculates the per-atom damage for each atom in a group",
    "description": "Define a computation that calculates the per-atom damage for each atom\nin a group.  This is a quantity relevant for Peridynamics models.  See this document\nfor an overview of LAMMPS commands for Peridynamics modeling.\nThe “damage” of a Peridynamics particles is based on the bond breakage\nbetween the particle and its neighbors.  If all the bonds are broken\nthe particle is considered to be fully damaged.\nSee the PDLAMMPS user guide for a formal\ndefinition of “damage” and more details about Peridynamics as it is\nimplemented in LAMMPS.\nThis command can be used with all the Peridynamic pair styles.\nThe damage value will be 0.0 for atoms not in the specified compute\ngroup.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values are unitless numbers (damage) >= 0.0.",
    "syntax": "compute ID group-ID damage/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * damage/atom = style name of this compute command",
    "examples": "compute 1 all damage/atom",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute dihedral",
    "html_filename": "compute_dihedral.html",
    "short_description": "Define a computation that extracts the dihedral energy calculated by each of the dihedral sub-styles used in the dihedral_style hybrid command",
    "description": "Define a computation that extracts the dihedral energy calculated by\neach of the dihedral sub-styles used in the dihedral_style hybrid command.  These values are made\naccessible for output or further processing by other commands.  The\ngroup specified for this command is ignored.\nThis compute is useful when using dihedral_style hybrid if you want to know the portion of the\ntotal energy contributed by one or more of the hybrid sub-styles.\nOutput info:\nThis compute calculates a global vector of length N where N is the\nnumber of sub_styles defined by the dihedral_style hybrid command.  which can be accessed by indices\n1-N.  These values can be used by any command that uses global scalar\nor vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values are “extensive” and will be in energy\nunits.",
    "syntax": "compute ID group-ID dihedral",
    "parameters": " * ID, group-ID are documented in compute command\n * dihedral = style name of this compute command",
    "examples": "compute 1 all dihedral",
    "restrictions": "\nnone"
},
{
    "command": "compute dihedral/local",
    "html_filename": "compute_dihedral_local.html",
    "short_description": "Define a computation that calculates properties of individual dihedral interactions",
    "description": "Define a computation that calculates properties of individual dihedral\ninteractions.  The number of datums generated, aggregated across all\nprocessors, equals the number of dihedral angles in the system, modified\nby the group parameter as explained below.\nThe value phi is the dihedral angle, as defined in the diagram on\nthe dihedral_style doc page.\nThe value v_name can be used together with the set keyword to\ncompute a user-specified function of the dihedral angle phi.  The\nname specified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\nvariable which will store the angle phi.  This other variable must\nbe an internal-style variable defined in the input\nscript; its initial numeric value can be anything.  It must be an\ninternal-style variable, because this command resets its value\ndirectly.  The set keyword is used to identify the name of this\nother variable associated with phi.\nNote that the value of phi for each angle which stored in the internal\nvariable is in radians, not degrees.\nAs an example, these commands can be added to the bench/in.rhodo\nscript to compute the cosine and cosine^2 of every dihedral angle in\nthe system and output the statistics in various ways:\nvariable p internal 0.0\nvariable cos equal cos(v_p)\nvariable cossq equal cos(v_p)*cos(v_p)\n\ncompute 1 all property/local datom1 datom2 datom3 datom4 dtype\ncompute 2 all dihedral/local phi v_cos v_cossq set phi p\ndump 1 all local 100 tmp.dump c_1[*] c_2[*]\n\ncompute 3 all reduce ave c_2[*]\nthermo_style custom step temp press c_3[*]\n\nfix 10 all ave/histo 10 10 100 -1 1 20 c_2[2] mode vector file tmp.histo\nThe dump local command will output the angle,\ncosine(angle), cosine^2(angle) for every dihedral in the system.  The\nthermo_style command will print the average of\nthose quantities via the compute reduce command\nwith thermo output.  And the fix ave/histo\ncommand will histogram the cosine(angle) values and write them to a\nfile.\n\nThe local data stored by this command is generated by looping over all\nthe atoms owned on a processor and their dihedrals.  A dihedral will\nonly be included if all 4 atoms in the dihedral are in the specified\ncompute group.\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, dihedral output from the compute property/local command can be combined\nwith data from this command and output by the dump local\ncommand in a consistent way.\nHere is an example of how to do this:\ncompute 1 all property/local dtype datom1 datom2 datom3 datom4\ncompute 2 all dihedral/local phi\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_2[1]\n\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of values.  The length of the vector or number of rows in the\narray is the number of dihedrals.  If a single value is specified, a\nlocal vector is produced.  If two or more values are specified, a\nlocal array is produced where the number of columns = the number of\nvalues.  The vector or array can be accessed by any command that uses\nlocal values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe output for phi will be in degrees.",
    "syntax": "compute ID group-ID dihedral/local value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * dihedral/local = style name of this compute command\n * one or more values may be appended\n * value = phi or v_name\n * phi = tabulate dihedral angles\n * v_name = equal-style variable with name (see below)\n * zero or more keyword/args pairs may be appended\n * keyword = set\n * set args = phi name\n *   phi = only currently allowed arg\n *   name = name of variable to set with phi",
    "examples": "compute 1 all dihedral/local phi\n\ncompute 1 all dihedral/local phi v_cos set phi p",
    "restrictions": "\nnone"
},
{
    "command": "compute dilatation/atom",
    "html_filename": "compute_dilatation_atom.html",
    "short_description": "Define a computation that calculates the per-atom dilatation for each atom in a group",
    "description": "Define a computation that calculates the per-atom dilatation for each\natom in a group.  This is a quantity relevant for Peridynamics models.  See this document\nfor an overview of LAMMPS commands for Peridynamics modeling.\nFor small deformation, dilatation of is the measure of the volumetric\nstrain.\nThe dilatation “theta” for each peridynamic particle I is calculated\nas a sum over its neighbors with unbroken bonds, where the\ncontribution of the IJ pair is a function of the change in bond length\n(versus the initial length in the reference state), the volume\nfraction of the particles and an influence function.  See the\nPDLAMMPS user guide for a formal\ndefinition of dilatation.\nThis command can only be used with a subset of the Peridynamic pair styles: peri/lps, peri/ves and peri/eps.\nThe dilatation value will be 0.0 for atoms not in the specified\ncompute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values are unitless numbers (theta) >= 0.0.",
    "syntax": "compute ID group-ID dilatation/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * dilation/atom = style name of this compute command",
    "examples": "compute 1 all dilatation/atom",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute dipole/chunk",
    "html_filename": "compute_dipole_chunk.html",
    "short_description": "Define a computation that calculates the dipole vector and total dipole for multiple chunks of atoms",
    "description": "Define a computation that calculates the dipole vector and total dipole\nfor multiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the x,y,z coordinates of the dipole vector\nand the total dipole moment for each chunk, which includes all effects\ndue to atoms passing through periodic boundaries. For chunks with a net\ncharge the resulting dipole is made position independent by subtracting\nthe position vector of the center of mass or geometric center times the\nnet charge from the computed dipole vector.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s\ndipole in “unwrapped” form, by using the image flags\nassociated with each atom.  See the dump custom command\nfor a discussion of “unwrapped” coordinates.  See the Atoms section of\nthe read_data command for a discussion of image flags\nand how they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute com/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all dipole/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n4 for the x,y,z dipole vector components and the total dipole of each\nchunk. These values can be accessed by any command that uses global\narray values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array values are “intensive”.  The array values will be in\ndipole units, i.e. charge units times distance units.",
    "syntax": "compute ID group-ID dipole/chunk chunkID charge-correction",
    "parameters": " * ID, group-ID are documented in compute command\n * dipole/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command\n * charge-correction = mass or geometry, use COM or geometric center for charged chunk correction (optional)",
    "examples": "compute 1 fluid dipole/chunk molchunk\ncompute dw water dipole/chunk 1 geometry",
    "restrictions": "\nnone"
},
{
    "command": "compute displace/atom",
    "html_filename": "compute_displace_atom.html",
    "short_description": "Define a computation that calculates the current displacement of each atom in the group from its original (reference) coordinates, including all effects due to atoms passing through periodic boundaries",
    "description": "Define a computation that calculates the current displacement of each\natom in the group from its original (reference) coordinates, including\nall effects due to atoms passing through periodic boundaries.\nA vector of four quantities per atom is calculated by this compute.\nThe first 3 elements of the vector are the dx,dy,dz displacements.\nThe 4th component is the total displacement, i.e. sqrt(dx*dx + dy*dy +\ndz*dz).\nThe displacement of an atom is from its original position at the time\nthe compute command was issued.  The value of the displacement will be\n0.0 for atoms not in the specified compute group.\n\nNote\nInitial coordinates are stored in “unwrapped” form, by using the\nimage flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\nSee the Atoms section of the read_data command for a\ndiscussion of image flags and how they are set for each atom.  You can\nreset the image flags (e.g. to 0) before invoking this compute by\nusing the set image command.\n\n\nNote\nIf you want the quantities calculated by this compute to be\ncontinuous when running from a restart file, then\nyou should use the same ID for this compute, as in the original run.\nThis is so that the fix this compute creates to store per-atom\nquantities will also have the same ID, and thus be initialized\ncorrectly with time=0 atom coordinates from the restart file.\n\n\nThe refresh option can be used in conjunction with the “dump_modify\nrefresh” command to generate incremental dump files.\nThe definition and motivation of an incremental dump file is as\nfollows.  Instead of outputting all atoms at each snapshot (with some\nassociated values), you may only wish to output the subset of atoms\nwith a value that has changed in some way compared to the value the\nlast time that atom was output.  In some scenarios this can result in\na dramatically smaller dump file.  If desired, by post-processing the\nsequence of snapshots, the values for all atoms at all timesteps can\nbe inferred.\nA concrete example using this compute, is a simulation of atom\ndiffusion in a solid, represented as atoms on a lattice.  Diffusive\nhops are rare.  Imagine that when a hop occurs an atom moves more than\na distance Dhop.  For any snapshot we only want to output atoms that\nhave hopped since the last snapshot.  This can be accomplished with\nsomething like the following commands:\nwrite_dump      all custom tmp.dump id type x y z    # see comment below\n\nvariable        Dhop equal 0.6\nvariable        check atom \"c_dsp[4] > v_Dhop\"\ncompute         dsp all displace/atom refresh check\ndump            1 all custom 100 tmp.dump id type x y z\ndump_modify     1 append yes thresh c_dsp[4] > ${Dhop} &\n                refresh c_dsp delay 100\n\n\nThe dump_modify thresh command will only output\natoms that have displaced more than 0.6 Angstroms on each snapshot\n(assuming metal units).  The dump_modify refresh option triggers a\ncall to this compute at the end of every dump.\nThe refresh argument for this compute is the ID of an atom-style variable which calculates a Boolean value (0 or 1)\nbased on the same criterion used by dump_modify thresh.  This compute\nevaluates the atom-style variable.  For each atom that returns 1\n(true), the original (reference) coordinates of the atom (stored by\nthis compute) are updated.\nThe effect of these commands is that a particular atom will only be\noutput in the dump file on the snapshot after it makes a diffusive\nhop.  It will not be output again until it makes another hop.\nNote that in the first snapshot of a subsequent run, no atoms will be\ntypically be output.  That is because the initial displacement for all\natoms is 0.0.  If an initial dump snapshot is desired, containing the\ninitial reference positions of all atoms, one way to do this is\nillustrated above.  An initial write_dump command can be used before\nthe first run.  It will contain the positions of all the atoms,\nOptions in the dump_modify command above will\nappend new output to that same file and delay the output until a later\ntimestep.  The delay setting avoids a second time = 0 snapshot which\nwould be empty.\n\nOutput info:\nThis compute calculates a per-atom array with 4 columns, which can be\naccessed by indices 1-4 by any command that uses per-atom values from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe per-atom array values will be in distance units.\nThis compute supports the refresh option as explained above, for use\nin conjunction with dump_modify refresh to generate\nincremental dump files.",
    "syntax": "compute ID group-ID displace/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * displace/atom = style name of this compute command\n * zero or more keyword/arg pairs may be appended\n * keyword = refresh\n * replace arg = name of per-atom variable",
    "examples": "compute 1 all displace/atom\ncompute 1 all displace/atom refresh myVar",
    "restrictions": "\nnone"
},
{
    "command": "compute dpd",
    "html_filename": "compute_dpd.html",
    "short_description": "Define a computation that accumulates the total internal conductive energy (\\(U^{cond}\\)), the total internal mechanical energy (\\(U^{mech}\\)), the total chemical energy (\\(U^{chem}\\)) and the harmonic average of the internal temperature (\\(\\theta_{avg}\\)) for the entire system of particles",
    "description": "Define a computation that accumulates the total internal conductive\nenergy (\\(U^{cond}\\)), the total internal mechanical energy\n(\\(U^{mech}\\)), the total chemical energy (\\(U^{chem}\\))\nand the harmonic average of the internal temperature (\\(\\theta_{avg}\\))\nfor the entire system of particles.  See the\ncompute dpd/atom command if you want\nper-particle internal energies and internal temperatures.\nThe system internal properties are computed according to the following\nrelations:\n\n\\[\\begin{split}U^{cond} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{cond} \\\\\nU^{mech} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{mech} \\\\\nU^{chem} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{chem} \\\\\n       U = & \\displaystyle\\sum_{i=1}^{N} (u_{i}^{cond} + u_{i}^{mech} + u_{i}^{chem}) \\\\\n\\theta_{avg} = & (\\frac{1}{N}\\displaystyle\\sum_{i=1}^{N} \\frac{1}{\\theta_{i}})^{-1} \\\\\\end{split}\\]\nwhere \\(N\\) is the number of particles in the system\n\nOutput info:\nThis compute calculates a global vector of length 5 (\\(U^{cond}\\),\n\\(U^{mech}\\), \\(U^{chem}\\), \\(\\theta_{avg}\\), \\(N\\)),\nwhich can be accessed by indices 1-5.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe vector values will be in energy and temperature units.",
    "syntax": "compute ID group-ID dpd",
    "parameters": " * ID, group-ID are documented in compute command\n * dpd = style name of this compute command",
    "examples": "compute 1 all dpd",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand."
},
{
    "command": "compute dpd/atom",
    "html_filename": "compute_dpd_atom.html",
    "short_description": "Define a computation that accesses the per-particle internal conductive energy (\\(u^{cond}\\)), internal mechanical energy (\\(u^{mech}\\)), internal chemical energy (\\(u^{chem}\\)) and internal temperatures (\\(\\theta\\)) for each particle in a group",
    "description": "Define a computation that accesses the per-particle internal\nconductive energy (\\(u^{cond}\\)), internal mechanical\nenergy (\\(u^{mech}\\)), internal chemical energy (\\(u^{chem}\\))\nand internal temperatures (\\(\\theta\\)) for each particle in a group.\nSee the compute dpd command if you want the total\ninternal conductive energy, the total internal mechanical energy, the\ntotal chemical energy and\naverage internal temperature of the entire system or group of dpd\nparticles.\nOutput info:\nThis compute calculates a per-particle array with 4 columns (\\(u^{cond}\\),\n\\(u^{mech}\\), \\(u^{chem}\\), \\(\\theta\\)), which can be accessed\nby indices 1-4 by any\ncommand that uses per-particle values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle array values will be in energy (\\(u^{cond}\\),\n\\(u^{mech}\\), \\(u^{chem}\\))\nand temperature (\\(theta\\)) units.",
    "syntax": "compute ID group-ID dpd/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * dpd/atom = style name of this compute command",
    "examples": "compute 1 all dpd/atom",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis command also requires use of the atom_style dpd\ncommand."
},
{
    "command": "compute edpd/temp/atom",
    "html_filename": "compute_edpd_temp_atom.html",
    "short_description": "Define a computation that calculates the per-atom temperature for each eDPD particle in a group",
    "description": "Define a computation that calculates the per-atom temperature\nfor each eDPD particle in a group.\nThe temperature is a local temperature derived from the internal energy\nof each eDPD particle based on the local equilibrium hypothesis.\nFor more details please see (Espanol1997) and\n(Li2014).\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input. See the\nHowto output doc page for an overview of LAMMPS\noutput options.\nThe per-atom vector values will be in temperature units.",
    "syntax": "compute ID group-ID edpd/temp/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * edpd/temp/atom = style name of this compute command",
    "examples": "compute 1 all edpd/temp/atom",
    "restrictions": "This compute is part of the USER-MESO package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute erotate/asphere",
    "html_filename": "compute_erotate_asphere.html",
    "short_description": "Define a computation that calculates the rotational kinetic energy of a group of aspherical particles",
    "description": "Define a computation that calculates the rotational kinetic energy of\na group of aspherical particles.  The aspherical particles can be\nellipsoids, or line segments, or triangles.  See the\natom_style and read_data commands\nfor descriptions of these options.\nFor all 3 types of particles, the rotational kinetic energy is\ncomputed as 1/2 I w^2, where I is the inertia tensor for the\naspherical particle and w is its angular velocity, which is computed\nfrom its angular momentum if needed.\n\nNote\nFor 2d models, ellipsoidal particles are\ntreated as ellipsoids, not ellipses, meaning their moments of inertia\nwill be the same as in 3d.\n\nOutput info:\nThis compute calculates a global scalar (the KE).  This value can be\nused by any command that uses a global scalar value from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID erotate/asphere",
    "parameters": " * ID, group-ID are documented in compute command\n * erotate/asphere = style name of this compute command",
    "examples": "compute 1 all erotate/asphere",
    "restrictions": "This compute requires that ellipsoidal particles atoms store a shape\nand quaternion orientation and angular momentum as defined by the\natom_style ellipsoid command.\nThis compute requires that line segment particles atoms store a length\nand orientation and angular velocity as defined by the atom_style line command.\nThis compute requires that triangular particles atoms store a size and\nshape and quaternion orientation and angular momentum as defined by\nthe atom_style tri command.\nAll particles in the group must be finite-size.  They cannot be point\nparticles.\nRelated commands: none\ncompute erotate/sphere\nDefault: none"
},
{
    "command": "compute erotate/rigid",
    "html_filename": "compute_erotate_rigid.html",
    "short_description": "Define a computation that calculates the rotational kinetic energy of a collection of rigid bodies, as defined by one of the fix rigid command variants",
    "description": "Define a computation that calculates the rotational kinetic energy of\na collection of rigid bodies, as defined by one of the fix rigid command variants.\nThe rotational energy of each rigid body is computed as 1/2 I Wbody^2,\nwhere I is the inertia tensor for the rigid body, and Wbody is its\nangular velocity vector.  Both I and Wbody are in the frame of\nreference of the rigid body, i.e. I is diagonalized.\nThe fix-ID should be the ID of one of the fix rigid\ncommands which defines the rigid bodies.  The group specified in the\ncompute command is ignored.  The rotational energy of all the rigid\nbodies defined by the fix rigid command in included in the\ncalculation.\nOutput info:\nThis compute calculates a global scalar (the summed rotational energy\nof all the rigid bodies).  This value can be used by any command that\nuses a global scalar value from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID erotate/rigid fix-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * erotate/rigid = style name of this compute command\n * fix-ID = ID of rigid body fix",
    "examples": "compute 1 all erotate/rigid myRigid",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute erotate/sphere",
    "html_filename": "compute_erotate_sphere.html",
    "short_description": "Define a computation that calculates the rotational kinetic energy of a group of spherical particles",
    "description": "Define a computation that calculates the rotational kinetic energy of\na group of spherical particles.\nThe rotational energy is computed as 1/2 I w^2, where I is the moment\nof inertia for a sphere and w is the particle’s angular velocity.\n\nNote\nFor 2d models, particles are treated as\nspheres, not disks, meaning their moment of inertia will be the same\nas in 3d.\n\nOutput info:\nThis compute calculates a global scalar (the KE).  This value can be\nused by any command that uses a global scalar value from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID erotate/sphere",
    "parameters": " * ID, group-ID are documented in compute command\n * erotate/sphere = style name of this compute command",
    "examples": "compute 1 all erotate/sphere",
    "restrictions": "This compute requires that atoms store a radius and angular velocity\n(omega) as defined by the atom_style sphere command.\nAll particles in the group must be finite-size spheres or point\nparticles.  They cannot be aspherical.  Point particles will not\ncontribute to the rotational energy."
},
{
    "command": "compute erotate/sphere/atom",
    "html_filename": "compute_erotate_sphere_atom.html",
    "short_description": "Define a computation that calculates the rotational kinetic energy for each particle in a group",
    "description": "Define a computation that calculates the rotational kinetic energy for\neach particle in a group.\nThe rotational energy is computed as 1/2 I w^2, where I is the moment\nof inertia for a sphere and w is the particle’s angular velocity.\n\nNote\nFor 2d models, particles are treated as\nspheres, not disks, meaning their moment of inertia will be the same\nas in 3d.\n\nThe value of the rotational kinetic energy will be 0.0 for atoms not\nin the specified compute group or for point particles with a radius =\n0.0.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in energy units.",
    "syntax": "compute ID group-ID erotate/sphere/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * erotate/sphere/atom = style name of this compute command",
    "examples": "compute 1 all erotate/sphere/atom",
    "restrictions": "\nnone"
},
{
    "command": "compute event/displace",
    "html_filename": "compute_event_displace.html",
    "short_description": "Define a computation that flags an “event” if any particle in the group has moved a distance greater than the specified threshold distance when compared to a previously stored reference state (i",
    "description": "Define a computation that flags an “event” if any particle in the\ngroup has moved a distance greater than the specified threshold\ndistance when compared to a previously stored reference state\n(i.e. the previous event).  This compute is typically used in\nconjunction with the prd and tad commands,\nto detect if a transition\nto a new minimum energy basin has occurred.\nThis value calculated by the compute is equal to 0 if no particle has\nmoved far enough, and equal to 1 if one or more particles have moved\nfurther than the threshold distance.\n\nNote\nIf the system is undergoing significant center-of-mass motion,\ndue to thermal motion, an external force, or an initial net momentum,\nthen this compute will not be able to distinguish that motion from\nlocal atom displacements and may generate “false positives.”\n\nOutput info:\nThis compute calculates a global scalar (the flag).  This value can be\nused by any command that uses a global scalar value from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe scalar value calculated by this compute is “intensive”.  The\nscalar value will be a 0 or 1 as explained above.",
    "syntax": "compute ID group-ID event/displace threshold",
    "parameters": " * ID, group-ID are documented in compute command\n * event/displace = style name of this compute command\n * threshold = minimum distance any particle must move to trigger an event (distance units)",
    "examples": "compute 1 all event/displace 0.5",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "compute fep",
    "html_filename": "compute_fep.html",
    "short_description": "Apply a perturbation to parameters of the interaction potential and recalculate the pair potential energy without changing the atomic coordinates from those of the reference, unperturbed system",
    "description": "Apply a perturbation to parameters of the interaction potential and\nrecalculate the pair potential energy without changing the atomic\ncoordinates from those of the reference, unperturbed system. This\ncompute can be used to calculate free energy differences using several\nmethods, such as free-energy perturbation (FEP), finite-difference\nthermodynamic integration (FDTI) or Bennet’s acceptance ratio method\n(BAR).\nThe potential energy of the system is decomposed in three terms: a\nbackground term corresponding to interaction sites whose parameters\nremain constant, a reference term \\(U_0\\) corresponding to the\ninitial interactions of the atoms that will undergo perturbation, and\na term \\(U_1\\) corresponding to the final interactions of\nthese atoms:\n\n\\[U(\\lambda) = U_{\\mathrm{bg}} + U_1(\\lambda) + U_0(\\lambda)\\]\nA coupling parameter \\(\\lambda\\) varying from 0 to 1 connects the\nreference and perturbed systems:\n\n\\[\\begin{split}\\lambda &= 0 \\quad\\Rightarrow\\quad U = U_{\\mathrm{bg}} + U_0 \\\\\n\\lambda &= 1 \\quad\\Rightarrow\\quad U = U_{\\mathrm{bg}} + U_1\\end{split}\\]\nIt is possible but not necessary that the coupling parameter (or a\nfunction thereof) appears as a multiplication factor of the potential\nenergy. Therefore, this compute can apply perturbations to interaction\nparameters that are not directly proportional to the potential energy\n(e.g. \\(\\sigma\\) in Lennard-Jones potentials).\nThis command can be combined with fix adapt to\nperform multistage free-energy perturbation calculations along\nstepwise alchemical transformations during a simulation run:\n\n\\[\\Delta_0^1 A = \\sum_{i=0}^{n-1} \\Delta_{\\lambda_i}^{\\lambda_{i+1}} A = - kT\n\\sum_{i=0}^{n-1} \\ln \\left< \\exp \\left( - \\frac{U(\\lambda_{i+1}) -\nU(\\lambda_i)}{kT} \\right) \\right>_{\\lambda_i}\\]\nThis compute is suitable for the finite-difference thermodynamic\nintegration (FDTI) method (Mezei), which is based on an\nevaluation of the numerical derivative of the free energy by a\nperturbation method using a very small \\(\\delta\\):\n\n\\[\\Delta_0^1 A = \\int_{\\lambda=0}^{\\lambda=1} \\left( \\frac{\\partial\nA(\\lambda)}{\\partial\\lambda} \\right)_\\lambda \\mathrm{d}\\lambda \\approx\n\\sum_{i=0}^{n-1} w_i \\frac{A(\\lambda_{i} + \\delta) - A(\\lambda_i)}{\\delta}\\]\nwhere \\(w_i\\) are weights of a numerical quadrature. The fix adapt command can be used to define the stages of\n\\(\\lambda\\) at which the derivative is calculated and averaged.\nThe compute fep calculates the exponential Boltzmann term and also the\npotential energy difference \\(U_1 -U_0\\). By\nchoosing a very small perturbation \\(\\delta\\) the thermodynamic\nintegration method can be implemented using a numerical evaluation of\nthe derivative of the potential energy with respect to \\(\\lambda\\):\n\n\\[\\Delta_0^1 A = \\int_{\\lambda=0}^{\\lambda=1} \\left< \\frac{\\partial\nU(\\lambda)}{\\partial\\lambda} \\right>_\\lambda \\mathrm{d}\\lambda \\approx\n\\sum_{i=0}^{n-1} w_i \\left< \\frac{U(\\lambda_{i} + \\delta) -\nU(\\lambda_i)}{\\delta} \\right>_{\\lambda_i}\\]\nAnother technique to calculate free energy differences is the\nacceptance ratio method (Bennet), which can be implemented\nby calculating the potential energy differences with \\(\\delta\\) = 1.0 on\nboth the forward and reverse routes:\n\n\\[\\left< \\frac{1}{1 + \\exp\\left[\\left(U_1 - U_0 - \\Delta_0^1A \\right) /kT\n\\right]} \\right>_0 = \\left< \\frac{1}{1 + \\exp\\left[\\left(U_0 - U_1 +\n\\Delta_0^1A \\right) /kT \\right]} \\right>_1\\]\nThe value of the free energy difference is determined by numerical\nroot finding to establish the equality.\nConcerning the choice of how the atomic parameters are perturbed in\norder to setup an alchemical transformation route, several strategies\nare available, such as single-topology or double-topology strategies\n(Pearlman). The latter does not require modification of\nbond lengths, angles or other internal coordinates.\nNOTES: This compute command does not take kinetic energy into account,\ntherefore the masses of the particles should not be modified between\nthe reference and perturbed states, or along the alchemical\ntransformation route.  This compute command does not change bond\nlengths or other internal coordinates (Boresch, Karplus).\n\nThe pair attribute enables various parameters of potentials defined\nby the pair_style and pair_coeff\ncommands to be changed, if the pair style supports it.\nThe pstyle argument is the name of the pair style. For example,\npstyle could be specified as “lj/cut”.  The pparam argument is the\nname of the parameter to change.  This is a list of\npair styles and parameters that can be used with this compute.  See\nthe doc pages for individual pair styles and their energy formulas for\nthe meaning of these parameters:\n\n\n\n\n\n\n\nborn\na,b,c\ntype pairs\n\nbuck\na,c\ntype pairs\n\nbuck/mdf\na,c\ntype pairs\n\ncoul/cut\nscale\ntype pairs\n\ncoul/cut/soft\nlambda\ntype pairs\n\ncoul/long, coul/msm\nscale\ntype pairs\n\ncoul/long/soft\nscale, lambda\ntype pairs\n\neam\nscale\ntype pairs\n\ngauss\na\ntype pairs\n\nlennard/mdf\na,b\ntype pairs\n\nlj/class2\nepsilon,sigma\ntype pairs\n\nlj/class2/coul/cut, lj/class2/coul/long\nepsilon,sigma\ntype pairs\n\nlj/cut\nepsilon,sigma\ntype pairs\n\nlj/cut/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\nepsilon,sigma\ntype pairs\n\nlj/cut/coul/cut/soft, lj/cut/coul/long/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/cut/tip4p/cut, lj/cut/tip4p/long\nepsilon,sigma\ntype pairs\n\nlj/cut/tip4p/long/soft\nepsilon,sigma,lambda\ntype pairs\n\nlj/expand\nepsilon,sigma,delta\ntype pairs\n\nlj/mdf\nepsilon,sigma\ntype pairs\n\nlj/sf/dipole/sf\nepsilon,sigma,scale\ntype pairs\n\nmie/cut\nepsilon,sigma,gamR,gamA\ntype pairs\n\nmorse, morse/smooth/linear\nd0,r0,alpha\ntype pairs\n\nmorse/soft\nd0,r0,alpha,lambda\ntype pairs\n\nnm/cut\ne0,r0,nn,mm\ntype pairs\n\nnm/cut/coul/cut, nm/cut/coul/long\ne0,r0,nn,mm\ntype pairs\n\nufm\nepsilon,sigma,scale\ntype pairs\n\nsoft\na\ntype pairs\n\n\n\nNote that it is easy to add new potentials and their parameters to\nthis list.  All it typically takes is adding an extract() method to\nthe pair_*.cpp file associated with the potential.\nSimilar to the pair_coeff command, I and J can be\nspecified in one of two ways.  Explicit numeric values can be used for\neach, as in the 1st example above.  I <= J is required.  LAMMPS sets\nthe coefficients for the symmetric J,I interaction to the same\nvalues. A wild-card asterisk can be used in place of or in conjunction\nwith the I,J arguments to set the coefficients for multiple pairs of\natom types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N =\nthe number of atom types, then an asterisk with no numeric values\nmeans all types from 1 to N.  A leading asterisk means all types from\n1 to n (inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).  Note that only type pairs with I <= J are considered; if\nasterisks imply type pairs where J < I, they are ignored.\nIf pair_style hybrid or hybrid/overlay is being\nused, then the pstyle will be a sub-style name.  You must specify\nI,J arguments that correspond to type pair values defined (via the\npair_coeff command) for that sub-style.\nThe v_name argument for keyword pair is the name of an\nequal-style variable which will be evaluated each time\nthis compute is invoked.  It should be specified as v_name, where name\nis the variable name.\n\nThe atom attribute enables atom properties to be changed.  The\naparam argument is the name of the parameter to change.  This is the\ncurrent list of atom parameters that can be used with this compute:\n\ncharge = charge on particle\n\nThe v_name argument for keyword pair is the name of an\nequal-style variable which will be evaluated each time\nthis compute is invoked.  It should be specified as v_name, where name\nis the variable name.\n\nThe tail keyword controls the calculation of the tail correction to\n“van der Waals” pair energies beyond the cutoff, if this has been\nactivated via the pair_modify command. If the\nperturbation is small, the tail contribution to the energy difference\nbetween the reference and perturbed systems should be negligible.\nIf the keyword volume = yes, then the Boltzmann term is multiplied\nby the volume so that correct ensemble averaging can be performed over\ntrajectories during which the volume fluctuates or changes (Allen and Tildesley):\n\n\\[\\Delta_0^1 A = - kT \\sum_{i=0}^{n-1} \\ln \\frac{\\left< V \\exp \\left( -\n\\frac{U(\\lambda_{i+1}) - U(\\lambda_i)}{kT} \\right)\n\\right>_{\\lambda_i}}{\\left< V \\right>_{\\lambda_i}}\\]\n\nOutput info:\nThis compute calculates a global vector of length 3 which contains the\nenergy difference ( \\(U_1-U_0\\) ) as c_ID[1], the\nBoltzmann factor \\(\\exp(-(U_1-U_0)/kT)\\), or\n\\(V \\exp(-(U_1-U_0)/kT)\\), as c_ID[2] and the\nvolume of the simulation box \\(V\\) as c_ID[3]. \\(U_1\\) is the\npair potential energy obtained with the perturbed parameters and\n\\(U_0\\) is the pair potential energy obtained with the\nunperturbed parameters. The energies include kspace terms if these\nare used in the simulation.\nThese output results can be used by any command that uses a global\nscalar or vector from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions. For example, the computed values can be averaged using fix ave/time.\nThe values calculated by this compute are “extensive”.",
    "syntax": "compute ID group-ID fep temp attribute args ... keyword value ...",
    "parameters": " * ID, group-ID are documented in the compute command\n * fep = name of this compute command\n * temp = external temperature (as specified for constant-temperature run)\n * one or more attributes with args may be appended\n * attribute = pair or atom\n * pair args = pstyle pparam I J v_delta\n *   pstyle = pair style name, e.g. lj/cut\n *   pparam = parameter to perturb\n *   I,J = type pair(s) to set parameter for\n *   v_delta = variable with perturbation to apply (in the units of the parameter)\n * atom args = aparam I v_delta\n *   aparam = parameter to perturb\n *   I = type to set parameter for\n *   v_delta = variable with perturbation to apply (in the units of the parameter)\n * zero or more keyword/value pairs may be appended\n * keyword = tail or volume\n * tail value = no or yes\n *   no = ignore tail correction to pair energies (usually small in fep)\n *   yes = include tail correction to pair energies\n * volume value = no or yes\n *   no = ignore volume changes (e.g. in NVE or NVT trajectories)\n *   yes = include volume changes (e.g. in NpT trajectories)",
    "examples": "compute 1 all fep 298 pair lj/cut epsilon 1 * v_delta pair lj/cut sigma 1 * v_delta volume yes\ncompute 1 all fep 300 atom charge 2 v_delta",
    "restrictions": "This compute is distributed as the USER-FEP package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute global/atom",
    "html_filename": "compute_global_atom.html",
    "short_description": "Define a calculation that assigns global values to each atom from vectors or arrays of global values",
    "description": "Define a calculation that assigns global values to each atom from\nvectors or arrays of global values.  The specified index parameter\nis used to determine which global value is assigned to each atom.\nThe index parameter must reference a per-atom vector or array from a\ncompute or fix or the evaluation of an\natom-style variable.  Each input value must\nreference a global vector or array from a compute or\nfix or the evaluation of an vector-style\nvariable.  Details are given below.\nThe index value for an atom is used as a index I (from 1 to N) into\nthe vector associated with each of the input values.  The Ith value\nfrom the input vector becomes one output value for that atom.  If the\natom is not in the specified group, or the index I < 1 or I > M, where\nM is the actual length of the input vector, then an output value of\n0.0 is assigned to the atom.\nAn example of how this command is useful, is in the context of\n“chunks” which are static or dynamic subsets of atoms.  The compute chunk/atom command assigns unique chunk IDs\nto each atom.  It’s output can be used as the index parameter for\nthis command.  Various other computes with “chunk” in their style\nname, such as compute com/chunk or compute msd/chunk, calculate properties for each\nchunk.  The output of these commands are global vectors or arrays,\nwith one or more values per chunk, and can be used as input values for\nthis command.  This command will then assign the global chunk value to\neach atom in the chunk, producing a per-atom vector or per-atom array\nas output.  The per-atom values can then be output to a dump file or\nused by any command that uses per-atom values from a compute as input,\nas discussed on the Howto output doc page.\nAs a concrete example, these commands will calculate the displacement\nof each atom from the center-of-mass of the molecule it is in, and\ndump those values to a dump file.  In this case, each molecule is a\nchunk.\ncompute cc1 all chunk/atom molecule\ncompute myChunk all com/chunk cc1\ncompute prop all property/atom xu yu zu\ncompute glob all global/atom c_cc1 c_myChunk[*]\nvariable dx atom c_prop[1]-c_glob[1]\nvariable dy atom c_prop[2]-c_glob[2]\nvariable dz atom c_prop[3]-c_glob[3]\nvariable dist atom sqrt(v_dx*v_dx+v_dy*v_dy+v_dz*v_dz)\ndump 1 all custom 100 tmp.dump id xu yu zu c_glob[1] c_glob[2] c_glob[3] &\n     v_dx v_dy v_dz v_dist\ndump_modify 1 sort id\nYou can add these commands to the bench/in.chain script to see how\nthey work.\n\nNote that for input values from a compute or fix, the bracketed index\nI can be specified using a wildcard asterisk with the index to\neffectively specify multiple values.  This takes the form “*” or “*n”\nor “n*” or “m*n”.  If N = the size of the vector (for mode = scalar)\nor the number of columns in the array (for mode = vector), then an\nasterisk with no numeric values means all indices from 1 to N.  A\nleading asterisk means all indices from 1 to n (inclusive).  A\ntrailing asterisk means all indices from n to N (inclusive).  A middle\nasterisk means all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 compute global/atom commands\nare equivalent, since the compute com/chunk\ncommand creates a global array with 3 columns:\ncompute cc1 all chunk/atom molecule\ncompute com all com/chunk cc1\ncompute 1 all global/atom c_cc1 c_com[1] c_com[2] c_com[3]\ncompute 1 all global/atom c_cc1 c_com[*]\n\nThis section explains the index parameter.  Note that it must\nreference per-atom values, as contrasted with the input values which\nmust reference global values.\nNote that all of these options generate floating point values.  When\nthey are used as an index into the specified input vectors, they\nsimple rounded down to convert the value to integer indices.  The\nfinal values should range from 1 to N (inclusive), since they are used\nto access values from N-length vectors.\nIf index begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  The compute must generate\nper-atom quantities.  See the individual compute doc\npage for details.  If no bracketed integer is appended, the per-atom\nvector calculated by the compute is used.  If a bracketed integer is\nappended, the Ith column of the per-atom array calculated by the\ncompute is used.  Users can also write code for their own compute\nstyles and add them to LAMMPS.  See the\ndiscussion above for how I can be specified with a wildcard asterisk\nto effectively specify multiple values.\nIf index begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  The Fix must generate\nper-atom quantities.  See the individual fix doc page for\ndetails.  Note that some fixes only produce their values on certain\ntimesteps, which must be compatible with when compute global/atom\nreferences the values, else an error results.  If no bracketed integer\nis appended, the per-atom vector calculated by the fix is used.  If a\nbracketed integer is appended, the Ith column of the per-atom array\ncalculated by the fix is used.  Users can also write code for their\nown fix style and add them to LAMMPS.  See the\ndiscussion above for how I can be specified with a wildcard asterisk\nto effectively specify multiple values.\nIf index begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  It must be an\natom-style variable.  Atom-style variables can\nreference thermodynamic keywords and various per-atom attributes, or\ninvoke other computes, fixes, or variables when they are evaluated, so\nthis is a very general means of generating per-atom quantities to use\nas index.\n\nThis section explains the kinds of input values that can be used.\nNote that inputs reference global values, as contrasted with the\nindex parameter which must reference per-atom values.\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  The compute must generate a\nglobal vector or array.  See the individual compute doc\npage for details.  If no bracketed integer is appended, the vector\ncalculated by the compute is used.  If a bracketed integer is\nappended, the Ith column of the array calculated by the compute is\nused.  Users can also write code for their own compute styles and add them to LAMMPS.  See the discussion above for how\nI can be specified with a wildcard asterisk to effectively specify\nmultiple values.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  The fix must generate a\nglobal vector or array.  See the individual fix doc page\nfor details.  Note that some fixes only produce their values on\ncertain timesteps, which must be compatible with when compute\nglobal/atom references the values, else an error results.  If no\nbracketed integer is appended, the vector calculated by the fix is\nused.  If a bracketed integer is appended, the Ith column of the array\ncalculated by the fix is used.  Users can also write code for their\nown fix style and add them to LAMMPS.  See the\ndiscussion above for how I can be specified with a wildcard asterisk\nto effectively specify multiple values.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  It must be a\nvector-style variable.  Vector-style variables can\nreference thermodynamic keywords and various other attributes of\natoms, or invoke other computes, fixes, or variables when they are\nevaluated, so this is a very general means of generating a vector of\nglobal quantities which the index parameter will reference for\nassignment of global values to atoms.\n\nOutput info:\nIf a single input is specified this compute produces a per-atom\nvector.  If multiple inputs are specified, this compute produces a\nper-atom array values, where the number of columns is equal to the\nnumber of inputs specified.  These values can be used by any command\nthat uses per-atom vector or array values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector or array values will be in whatever units the\ncorresponding input values are in.",
    "syntax": "compute ID group-ID style index input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * global/atom = style name of this compute command\n * index = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n * v_name = per-atom vector calculated by an atom-style variable with name\n * one or more inputs can be listed\n * input = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * c_ID = global vector calculated by a compute with ID\n * c_ID[I] = Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = global vector calculated by a fix with ID\n * f_ID[I] = Ith column of global array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = global vector calculated by a vector-style variable with name",
    "examples": "compute 1 all global/atom c_chunk c_com[1] c_com[2] c_com[3]\ncompute 1 all global/atom c_chunk c_com[*]",
    "restrictions": "\nnone"
},
{
    "command": "compute group/group",
    "html_filename": "compute_group_group.html",
    "short_description": "Define a computation that calculates the total energy and force interaction between two groups of atoms: the compute group and the specified group2",
    "description": "Define a computation that calculates the total energy and force\ninteraction between two groups of atoms: the compute group and the\nspecified group2.  The two groups can be the same.\nIf the pair keyword is set to yes, which is the default, then the\nthe interaction energy will include a pair component which is defined\nas the pairwise energy between all pairs of atoms where one atom in\nthe pair is in the first group and the other is in the second group.\nLikewise, the interaction force calculated by this compute will\ninclude the force on the compute group atoms due to pairwise\ninteractions with atoms in the specified group2.\n\nNote\nThe energies computed by the pair keyword do not include tail\ncorrections, even if they are enabled via the\npair_modify command.\n\nIf the molecule keyword is set to inter or intra than an\nadditional check is made based on the molecule IDs of the two atoms in\neach pair before including their pairwise interaction energy and\nforce.  For the inter setting, the two atoms must be in different\nmolecules.  For the intra setting, the two atoms must be in the same\nmolecule.\nIf the kspace keyword is set to yes, which is not the default, and\nif a kspace_style is defined, then the interaction\nenergy will include a Kspace component which is the long-range\nCoulombic energy between all the atoms in the first group and all the\natoms in the 2nd group.  Likewise, the interaction force calculated by\nthis compute will include the force on the compute group atoms due to\nlong-range Coulombic interactions with atoms in the specified group2.\nNormally the long-range Coulombic energy converges only when the net\ncharge of the unit cell is zero.  However, one can assume the net\ncharge of the system is neutralized by a uniform background plasma,\nand a correction to the system energy can be applied to reduce\nartifacts. For more information see (Bogusz).  If the\nboundary keyword is set to yes, which is the default, and kspace\ncontributions are included, then this energy correction term will be\nadded to the total group-group energy.  This correction term does not\naffect the force calculation and will be zero if one or both of the\ngroups are charge neutral.  This energy correction term is the same as\nthat included in the regular Ewald and PPPM routines.\n\nNote\nThe molecule setting only affects the group/group\ncontributions calculated by the pair keyword.  It does not affect\nthe group/group contributions calculated by the kspace keyword.\n\nThis compute does not calculate any bond or angle or dihedral or\nimproper interactions between atoms in the two groups.\n\nThe pairwise contributions to the group-group interactions are\ncalculated by looping over a neighbor list.  The Kspace contribution\nto the group-group interactions require essentially the same amount of\nwork (FFTs, Ewald summation) as computing long-range forces for the\nentire system.  Thus it can be costly to invoke this compute too\nfrequently.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this compute uses a neighbor list, it also\nmeans those pairs will not be included in the group/group interaction.\nThis does not apply when using long-range coulomb interactions\n(coul/long, coul/msm, coul/wolf or similar.  One way to get\naround this would be to set special_bond scaling factors to very tiny\nnumbers that are not exactly zero (e.g. 1.0e-50). Another workaround\nis to write a dump file, and use the rerun command to\ncompute the group/group interactions for snapshots in the dump file.\nThe rerun script can use a special_bonds command\nthat includes all pairs in the neighbor list.\n\nIf you desire a breakdown of the interactions into a pairwise and\nKspace component, simply invoke the compute twice with the appropriate\nyes/no settings for the pair and kspace keywords.  This is no more\ncostly than using a single compute with both keywords set to yes.\nThe individual contributions can be summed in a\nvariable if desired.\nThis document describes how the long-range\ngroup-group calculations are performed.\n\nOutput info:\nThis compute calculates a global scalar (the energy) and a global\nvector of length 3 (force), which can be accessed by indices 1-3.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nBoth the scalar and vector values calculated by this compute are\n“extensive”.  The scalar value will be in energy units.\nThe vector values will be in force units.",
    "syntax": "compute ID group-ID group/group group2-ID keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * group/group = style name of this compute command\n * group2-ID = group ID of second (or same) group\n * zero or more keyword/value pairs may be appended\n * keyword = pair or kspace or boundary or molecule\n * pair value = yes or no\n * kspace value = yes or no\n * boundary value = yes or no\n * molecule value = off or inter or intra",
    "examples": "compute 1 lower group/group upper\ncompute 1 lower group/group upper kspace yes\ncompute mine fluid group/group wall",
    "restrictions": "Not all pair styles can be evaluated in a pairwise mode as required by\nthis compute.  For example, 3-body and other many-body potentials,\nsuch as Tersoff and\nStillinger-Weber cannot be used.  EAM\npotentials will re-use previously computed embedding term contributions,\nso the computed pairwise forces and energies are based on the whole\nsystem and not valid if particles have been moved since.\nNot all Kspace styles support the calculation of\ngroup/group interactions. The regular ewald and pppm styles do.\nRelated commands: none"
},
{
    "command": "compute gyration",
    "html_filename": "compute_gyration.html",
    "short_description": "Define a computation that calculates the radius of gyration Rg of the group of atoms, including all effects due to atoms passing through periodic boundaries",
    "description": "Define a computation that calculates the radius of gyration Rg of the\ngroup of atoms, including all effects due to atoms passing through\nperiodic boundaries.\nRg is a measure of the size of the group of atoms, and is computed as\nthe square root of the Rg^2 value in this formula\n\n\\[{R_g}^2 = \\frac{1}{M} \\sum_i m_i (r_i - r_{cm})^2\\]\nwhere \\(M\\) is the total mass of the group, \\(r_{cm}\\) is the\ncenter-of-mass position of the group, and the sum is over all atoms in\nthe group.\nA \\({R_g}^2\\) tensor, stored as a 6-element vector, is also calculated\nby this compute.  The formula for the components of the tensor is the\nsame as the above formula, except that \\((r_i - r_{cm})^2\\) is replaced\nby \\((r_{i,x} - r_{cm,x}) \\cdot (r_{i,y} - r_{cm,y})\\) for the xy component,\nand so on.  The 6 components of the vector are ordered xx, yy, zz, xy, xz, yz.\nNote that unlike the scalar \\(R_g\\), each of the 6 values of the tensor\nis effectively a “squared” value, since the cross-terms may be negative\nand taking a sqrt() would be invalid.\n\nNote\nThe coordinates of an atom contribute to \\(R_g\\) in “unwrapped” form,\nby using the image flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\nSee the Atoms section of the read_data command for a\ndiscussion of image flags and how they are set for each atom.  You can\nreset the image flags (e.g. to 0) before invoking this compute by\nusing the set image command.\n\nOutput info:\nThis compute calculates a global scalar (\\(R_g\\)) and a global vector of\nlength 6 (\\({R_g}^2\\) tensor), which can be accessed by indices 1-6.  These\nvalues can be used by any command that uses a global scalar value or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar and vector values calculated by this compute are\n“intensive”.  The scalar and vector values will be in distance and\ndistance^2 units respectively.",
    "syntax": "compute ID group-ID gyration",
    "parameters": " * ID, group-ID are documented in compute command\n * gyration = style name of this compute command",
    "examples": "compute 1 molecule gyration",
    "restrictions": "\nnone"
},
{
    "command": "compute gyration/chunk",
    "html_filename": "compute_gyration_chunk.html",
    "short_description": "Define a computation that calculates the radius of gyration Rg for multiple chunks of atoms",
    "description": "Define a computation that calculates the radius of gyration Rg for\nmultiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the radius of gyration Rg for each chunk,\nwhich includes all effects due to atoms passing through periodic\nboundaries.\nRg is a measure of the size of a chunk, and is computed by this\nformula\n\n\\[{R_g}^2 = \\frac{1}{M} \\sum_i m_i (r_i - r_{cm})^2\\]\nwhere \\(M\\) is the total mass of the chunk, \\(r_{cm}\\) is\nthe center-of-mass position of the chunk, and the sum is over all atoms in the\nchunk.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\nIf the tensor keyword is specified, then the scalar Rg value is not\ncalculated, but an Rg tensor is instead calculated for each chunk.\nThe formula for the components of the tensor is the same as the above\nformula, except that \\((r_i - r_{cm})^2\\) is replaced by\n\\((r_{i,x} - r_{cm,x}) \\cdot (r_{i,y} - r_{cm,y})\\) for the xy\ncomponent, and so on.  The 6 components of the tensor are\nordered xx, yy, zz, xy, xz, yz.\n\nNote\nThe coordinates of an atom contribute to \\(R_g\\) in “unwrapped” form,\nby using the image flags associated with each atom.  See the dump custom\ncommand for a discussion of “unwrapped” coordinates.\nSee the Atoms section of the read_data command for a\ndiscussion of image flags and how they are set for each atom.  You can\nreset the image flags (e.g. to 0) before invoking this compute by\nusing the set image command.\n\nThe simplest way to output the results of the compute gyration/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all gyration/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk file tmp.out mode vector\n\n\nOutput info:\nThis compute calculates a global vector if the tensor keyword is not\nspecified and a global array if it is.  The length of the vector or\nnumber of rows in the array = the number of chunks Nchunk as\ncalculated by the specified compute chunk/atom command.  If the tensor keyword\nis specified, the global array has 6 columns.  The vector or array can\nbe accessed by any command that uses global values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nAll the vector or array values calculated by this compute are\n“intensive”.  The vector or array values will be in distance\nunits, since they are the square root of values\nrepresented by the formula above.",
    "syntax": "compute ID group-ID gyration/chunk chunkID keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * gyration/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command\n * zero or more keyword/value pairs may be appended\n * keyword = tensor\n * tensor value = none",
    "examples": "compute 1 molecule gyration/chunk molchunk\ncompute 2 molecule gyration/chunk molchunk tensor",
    "restrictions": "\nnone\n\nRelated commands: none\ncompute gyration\nDefault: none"
},
{
    "command": "compute gyration/shape",
    "html_filename": "compute_gyration_shape.html",
    "short_description": "Define a computation that calculates the eigenvalues of the gyration tensor of a group of atoms and three shape parameters",
    "description": "Define a computation that calculates the eigenvalues of the gyration tensor of a\ngroup of atoms and three shape parameters. The computation includes all effects\ndue to atoms passing through periodic boundaries.\nThe three computed shape parameters are the asphericity, b, the acylindricity, c,\nand the relative shape anisotropy, k:\n\n\\[\\begin{split}c = & l_z - 0.5(l_y+l_x) \\\\\nb = & l_y - l_x \\\\\nk = & \\frac{3}{2} \\frac{l_x^2+l_y^2+l_z^2}{(l_x+l_y+l_z)^2} - \\frac{1}{2}\\end{split}\\]\nwhere \\(l_x\\) <= \\(l_y\\) <= \\(l_z\\) are the three eigenvalues of the gyration tensor. A general description\nof these parameters is provided in (Mattice) while an application to polymer systems\ncan be found in (Theodorou).\nThe asphericity  is always non-negative and zero only when the three principal\nmoments are equal. This zero condition is met when the distribution of particles\nis spherically symmetric (hence the name asphericity) but also whenever the particle\ndistribution is symmetric with respect to the three coordinate axes, e.g.,\nwhen the particles are distributed uniformly on a cube, tetrahedron or other Platonic\nsolid. The acylindricity is always non-negative and zero only when the two principal\nmoments are equal. This zero condition is met when the distribution of particles is\ncylindrically symmetric (hence the name, acylindricity), but also whenever the particle\ndistribution is symmetric with respect to the two coordinate axes, e.g., when the\nparticles are distributed uniformly on a regular prism. the relative shape anisotropy\nis bounded between zero (if all points are spherically symmetric) and one\n(if all points lie on a line).\n\nNote\nThe coordinates of an atom contribute to the gyration tensor in\n“unwrapped” form, by using the image flags associated with each atom.\nSee the dump custom command for a discussion of “unwrapped”\ncoordinates. See the Atoms section of the read_data\ncommand for a discussion of image flags and how they are set for each\natom.  You can reset the image flags (e.g. to 0) before invoking this\ncompute by using the set image command.\n\nOutput info:\nThis compute calculates a global vector of\nlength 6, which can be accessed by indices 1-6. The first three values are the\neigenvalues of the gyration tensor followed by the asphericity, the acylindricity\nand the relative shape anisotropy.  The computed values can be used by any command\nthat uses global  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values calculated by this compute are\n“intensive”.  The first five vector values will be in\ndistance^2 units while the sixth one is dimensionless.",
    "syntax": "compute ID group-ID gyration/shape compute-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * gyration/shape = style name of this compute command\n * compute-ID = ID of compute gyration command",
    "examples": "compute 1 molecule gyration/shape pe",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute gyration/shape/chunk",
    "html_filename": "compute_gyration_shape_chunk.html",
    "short_description": "Define a computation that calculates the eigenvalues of the gyration tensor and three shape parameters of multiple chunks of atoms",
    "description": "Define a computation that calculates the eigenvalues of the gyration tensor and\nthree shape parameters of multiple chunks of atoms. The computation includes\nall effects due to atoms passing through periodic boundaries.\nThe three computed shape parameters are the asphericity, b, the acylindricity, c,\nand the relative shape anisotropy, k:\n\n\\[\\begin{split}c = & l_z - 0.5(l_y+l_x) \\\\\nb = & l_y - l_x \\\\\nk = & \\frac{3}{2} \\frac{l_x^2+l_y^2+l_z^2}{(l_x+l_y+l_z)^2} - \\frac{1}{2}\\end{split}\\]\nwhere \\(l_x\\) <= \\(l_y\\) <= :math`l_z` are the three eigenvalues of the gyration tensor. A general description\nof these parameters is provided in (Mattice) while an application to polymer systems\ncan be found in (Theodorou). The asphericity  is always non-negative and zero\nonly when the three principal moments are equal. This zero condition is met when the distribution\nof particles is spherically symmetric (hence the name asphericity) but also whenever the particle\ndistribution is symmetric with respect to the three coordinate axes, e.g.,\nwhen the particles are distributed uniformly on a cube, tetrahedron or other Platonic\nsolid. The acylindricity is always non-negative and zero only when the two principal\nmoments are equal. This zero condition is met when the distribution of particles is\ncylindrically symmetric (hence the name, acylindricity), but also whenever the particle\ndistribution is symmetric with respect to the two coordinate axes, e.g., when the\nparticles are distributed uniformly on a regular prism. the relative shape anisotropy\nis bounded between zero (if all points are spherically symmetric) and one\n(if all points lie on a line).\nThe tensor keyword must be specified in the compute gyration/chunk command.\n\nNote\nThe coordinates of an atom contribute to the gyration tensor in\n“unwrapped” form, by using the image flags associated with each atom.\nSee the dump custom command for a discussion of “unwrapped”\ncoordinates. See the Atoms section of the read_data\ncommand for a discussion of image flags and how they are set for each\natom.  You can reset the image flags (e.g. to 0) before invoking this\ncompute by using the set image command.\n\nOutput info:\nThis compute calculates a global array with six columns,\nwhich can be accessed by indices 1-6. The first three columns are the\neigenvalues of the gyration tensor followed by the asphericity, the acylindricity\nand the relative shape anisotropy.  The computed values can be used by any command\nthat uses global array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array calculated by this compute is\n“intensive”.  The first five columns will be in\ndistance^2 units while the sixth one is dimensionless.",
    "syntax": "compute ID group-ID gyration/shape/chunk compute-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * gyration/shape/chunk = style name of this compute command\n * compute-ID = ID of compute gyration/chunk command",
    "examples": "compute 1 molecule gyration/shape/chunk pe",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute heat/flux",
    "html_filename": "compute_heat_flux.html",
    "short_description": "Define a computation that calculates the heat flux vector based on contributions from atoms in the specified group",
    "description": "Define a computation that calculates the heat flux vector based on\ncontributions from atoms in the specified group.  This can be used by\nitself to measure the heat flux through a set of atoms (e.g. a region\nbetween two thermostatted reservoirs held at different temperatures),\nor to calculate a thermal conductivity using the equilibrium\nGreen-Kubo formalism.\nFor other non-equilibrium ways to compute a thermal conductivity, see\nthe Howto kappa doc page..  These include use of\nthe fix thermal/conductivity command\nfor the Muller-Plathe method.  Or the fix heat command\nwhich can add or subtract heat from groups of atoms.\nThe compute takes three arguments which are IDs of other\ncomputes.  One calculates per-atom kinetic energy\n(ke-ID), one calculates per-atom potential energy (pe-ID), and the\nthird calculates per-atom stress (stress-ID).\n\nNote\nThese other computes should provide values for all the atoms in\nthe group this compute specifies.  That means the other computes could\nuse the same group as this compute, or they can just use group “all”\n(or any group whose atoms are superset of the atoms in this compute’s\ngroup).  LAMMPS does not check for this.\n\nIn case of two-body interactions, the heat flux is defined as:\n\n\\[\\begin{split}\\mathbf{J} &= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i - \\sum_{i} \\mathbf{S}_{i} \\mathbf{v}_i \\right] \\\\\n&= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i + \\sum_{i<j} \\left( \\mathbf{F}_{ij} \\cdot \\mathbf{v}_j \\right) \\mathbf{r}_{ij} \\right] \\\\\n&= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i + \\frac{1}{2} \\sum_{i<j} \\left( \\mathbf{F}_{ij} \\cdot \\left(\\mathbf{v}_i + \\mathbf{v}_j \\right)  \\right) \\mathbf{r}_{ij} \\right]\\end{split}\\]\n\\(e_i\\) in the first term of the equation\nis the per-atom energy (potential and kinetic).\nThis is calculated by the computes ke-ID\nand pe-ID. \\(\\mathbf{S}_i\\) in the second term is the\nper-atom stress tensor calculated by the compute stress-ID.\nSee compute stress/atom\nand compute centroid/stress/atom\nfor possible definitions of atomic stress \\(\\mathbf{S}_i\\)\nin the case of bonded and many-body interactions.\nThe tensor multiplies \\(\\mathbf{v}_i\\) as a 3x3 matrix-vector multiply\nto yield a vector.\nNote that as discussed below, the 1/\\({V}\\) scaling factor in the\nequation for \\(\\mathbf{J}\\) is NOT included in the calculation performed by\nthese computes; you need to add it for a volume appropriate to the atoms\nincluded in the calculation.\n\nNote\nThe compute pe/atom and\ncompute stress/atom\ncommands have options for which\nterms to include in their calculation (pair, bond, etc).  The heat\nflux calculation will thus include exactly the same terms. Normally\nyou should use compute stress/atom virial\nor compute centroid/stress/atom virial\nso as not to include a kinetic energy term in the heat flux.\n\n\nWarning\nThe compute heat/flux has been reported to produce unphysical\nvalues for angle, dihedral and improper contributions\nwhen used with compute stress/atom,\nas discussed in (Surblys) and (Boone).\nYou are strongly advised to\nuse compute centroid/stress/atom,\nwhich has been implemented specifically for such cases.\n\nThe Green-Kubo formulas relate the ensemble average of the\nauto-correlation of the heat flux \\(\\mathbf{J}\\)\nto the thermal conductivity \\(\\kappa\\):\n\n\\[\\kappa  = \\frac{V}{k_B T^2} \\int_0^\\infty \\langle J_x(0)  J_x(t) \\rangle \\, \\mathrm{d} t = \\frac{V}{3 k_B T^2} \\int_0^\\infty \\langle \\mathbf{J}(0) \\cdot  \\mathbf{J}(t)  \\rangle \\, \\mathrm{d}t\\]\n\nThe heat flux can be output every so many timesteps (e.g. via the\nthermo_style custom command).  Then as a\npost-processing operation, an auto-correlation can be performed, its\nintegral estimated, and the Green-Kubo formula above evaluated.\nThe fix ave/correlate command can calculate\nthe auto-correlation.  The trap() function in the\nvariable command can calculate the integral.\nAn example LAMMPS input script for solid Ar is appended below.  The\nresult should be: average conductivity ~0.29 in W/mK.\n\nOutput info:\nThis compute calculates a global vector of length 6.\nThe first 3 components are the \\(x\\), \\(y\\), \\(z\\)\ncomponents of the full heat flux vector,\ni.e. (\\(J_x\\), \\(J_y\\), \\(J_z\\)).\nThe next 3 components are the \\(x\\), \\(y\\), \\(z\\) components\nof just the convective portion of the flux, i.e. the\nfirst term in the equation for \\(\\mathbf{J}\\).\nEach component can be\naccessed by indices 1-6. These values can be used by any command that\nuses global vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values calculated by this compute are “extensive”, meaning\nthey scale with the number of atoms in the simulation.  They can be\ndivided by the appropriate volume to get a flux, which would then be\nan “intensive” value, meaning independent of the number of atoms in\nthe simulation.  Note that if the compute is “all”, then the\nappropriate volume to divide by is the simulation box volume.\nHowever, if a sub-group is used, it should be the volume containing\nthose atoms.\nThe vector values will be in energy*velocity units.  Once\ndivided by a volume the units will be that of flux, namely\nenergy/area/time units",
    "syntax": "compute ID group-ID heat/flux ke-ID pe-ID stress-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * heat/flux = style name of this compute command\n * ke-ID = ID of a compute that calculates per-atom kinetic energy\n * pe-ID = ID of a compute that calculates per-atom potential energy\n * stress-ID = ID of a compute that calculates per-atom stress",
    "examples": "compute myFlux all heat/flux myKE myPE myStress",
    "restrictions": "\nnone"
},
{
    "command": "compute hexorder/atom",
    "html_filename": "compute_hexorder_atom.html",
    "short_description": "Define a computation that calculates \\(q_n\\) the bond-orientational order parameter for each atom in a group",
    "description": "Define a computation that calculates \\(q_n\\) the bond-orientational\norder parameter for each atom in a group. The hexatic (n = 6) order\nparameter was introduced by Nelson and Halperin as a way to detect\nhexagonal symmetry in two-dimensional systems. For each atom, \\(q_n\\)\nis a complex number (stored as two real numbers) defined as follows:\n\n\\[q_n = \\frac{1}{nnn}\\sum_{j = 1}^{nnn} e^{n i \\theta({\\bf r}_{ij})}\\]\nwhere the sum is over the nnn nearest neighbors\nof the central atom. The angle \\(\\theta\\)\nis formed by the bond vector \\(r_{ij}\\) and the x axis.\n\\(\\theta\\) is calculated only using the x and y components,\nwhereas the distance from the\ncentral atom is calculated using all three\nx, y, and z components of the bond vector.\nNeighbor atoms not in the group\nare included in the order parameter of atoms in the group.\nThe optional keyword cutoff defines the distance cutoff\nused when searching for neighbors. The default value, also\nthe maximum allowable value, is the cutoff specified\nby the pair style.\nThe optional keyword nnn defines the number of nearest\nneighbors used to calculate \\(q_n\\). The default value is 6.\nIf the value is NULL, then all neighbors up to the\ndistance cutoff are used.\nThe optional keyword degree sets the degree n of the order parameter.\nThe default value is 6. For a perfect hexagonal lattice with\nnnn = 6,\n\\(q_6 = e^{6 i \\phi}\\) for all atoms, where the constant \\(0 < \\phi < \\frac{\\pi}{3}\\)\ndepends only on the orientation of the lattice relative to the x axis.\nIn an isotropic liquid, local neighborhoods may still exhibit\nweak hexagonal symmetry, but because the orientational correlation\ndecays quickly with distance, the value of \\(\\phi\\) will be different for\ndifferent atoms, and so when \\(q_6\\) is averaged over all the atoms\nin the system, \\(| \\left< q_6 \\right> | << 1\\).\nThe value of \\(q_n\\) is set to zero for atoms not in the\nspecified compute group, as well as for atoms that have less than\nnnn neighbors within the distance cutoff.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses the neighbor list, it also means\nthose pairs will not be included in the order parameter.  This\ndifficulty can be circumvented by writing a dump file, and using the\nrerun command to compute the order parameter for\nsnapshots in the dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\nOutput info:\nThis compute calculates a per-atom array with 2 columns, giving the\nreal and imaginary parts \\(q_n\\), a complex number restricted to the\nunit disk of the complex plane i.e. \\(Re(q_n)^2 + Im(q_n)^2 <= 1\\).\nThese values can be accessed by any command that uses per-atom values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.",
    "syntax": "compute ID group-ID hexorder/atom keyword values ...",
    "parameters": " * ID, group-ID are documented in compute command\n * hexorder/atom = style name of this compute command\n * one or more keyword/value pairs may be appended\n * keyword = degree or nnn or cutoff\n *   cutoff value = distance cutoff\n *   nnn value = number of nearest neighbors\n *   degree value = degree n of order parameter",
    "examples": "compute 1 all hexorder/atom\ncompute 1 all hexorder/atom degree 4 nnn 4 cutoff 1.2",
    "restrictions": "\nnone"
},
{
    "command": "compute hma",
    "html_filename": "compute_hma.html",
    "short_description": "Define a computation that calculates the properties of a solid (potential energy, pressure or heat capacity), using the harmonically-mapped averaging (HMA) method",
    "description": "Define a computation that calculates the properties of a solid (potential\nenergy, pressure or heat capacity), using the harmonically-mapped averaging\n(HMA) method.\nThis command yields much higher precision than the equivalent compute commands\n(compute pe, compute pressure, etc.)\ncommands during a canonical simulation of an atomic crystal. Specifically,\nnear melting HMA can yield averages of a given precision an order of magnitude\nfaster than conventional methods, and this only improves as the temperatures is\nlowered.  This is particularly important for evaluating the free energy by\nthermodynamic integration, where the low-temperature contributions are the\ngreatest source of statistical uncertainty.  Moreover, HMA has other\nadvantages, including smaller potential-truncation effects, finite-size\neffects, smaller timestep inaccuracy, faster equilibration and shorter\ndecorrelation time.\nHMA should not be used if atoms are expected to diffuse.  It is also\nrestricted to simulations in the NVT ensemble.  While this compute may\nbe used with any potential in LAMMPS, it will provide inaccurate results\nfor potentials that do not go to 0 at the truncation distance;\npair_style lj/smooth/linear and Ewald\nsummation should work fine, while pair_style lj/cut\nwill perform poorly unless the potential is shifted (via\npair_modify shift) or the cutoff is large.\nFurthermore, computation of the heat capacity with this compute is\nrestricted to those that implement the single_hessian method in Pair.\nImplementing single_hessian in additional pair styles is simple.\nPlease contact Andrew Schultz (ajs42 at buffalo.edu) and David Kofke\n(kofke at buffalo.edu) if your desired pair style does not have this\nmethod.  This is the list of pair styles that currently implement\nsingle_hessian:\n\npair_style lj/smooth/linear\n\nIn this method, the analytically known harmonic behavior of a crystal is removed from the traditional ensemble\naverages, which leads to an accurate and precise measurement of the anharmonic contributions without contamination\nby noise produced by the already-known harmonic behavior.\nA detailed description of this method can be found in (Moustafa). The potential energy is computed by the formula:\n\n\\[\\left< U\\right>_{HMA} = \\frac{d}{2} (N-1) k_B T  + \\left< U + \\frac{1}{2} F\\bullet\\Delta r \\right>\\]\nwhere \\(N\\) is the number of atoms in the system, \\(k_B\\) is Boltzmann’s\nconstant, \\(T\\) is the temperature, \\(d\\) is the\ndimensionality of the system (2 or 3 for 2d/3d), \\(F\\bullet\\Delta r\\) is the sum of dot products of the\natomic force vectors and displacement (from lattice sites) vectors, and \\(U\\) is the sum of\npair, bond, angle, dihedral, improper, kspace (long-range), and fix energies.\nThe pressure is computed by the formula:\n\n\\[\\left< P\\right>_{HMA} = \\Delta \\hat P + \\left< P_{vir} + \\frac{\\beta \\Delta \\hat P - \\rho}{d(N-1)} F\\bullet\\Delta r \\right>\\]\nwhere \\(\\rho\\) is the number density of the system, \\(\\Delta \\hat P\\) is the\ndifference between the harmonic and lattice pressure, \\(P_{vir}\\) is\nthe virial pressure computed as the sum of pair, bond, angle, dihedral,\nimproper, kspace (long-range), and fix contributions to the force on each\natom, and \\(k_B=1/k_B T\\).  Although the method will work for any value of \\(\\Delta \\hat P\\)\nspecified (use pressure units), the precision of the resultant\npressure is sensitive to \\(\\Delta \\hat P\\); the precision tends to be\nbest when \\(\\Delta \\hat P\\) is the actual the difference between the lattice\npressure and harmonic pressure.\n\n\\[\\left<C_V \\right>_{HMA} = \\frac{d}{2} (N-1) k_B + \\frac{1}{k_B T^2} \\left( \\left<\nU_{HMA}^2 \\right> - \\left<U_{HMA}\\right>^2 \\right) + \\frac{1}{4 T}\n\\left< F\\bullet\\Delta r + \\Delta r \\bullet \\Phi \\bullet \\Delta r \\right>\\]\nwhere \\(\\Phi\\) is the Hessian matrix. The compute hma command\ncomputes the full expression for \\(C_V\\) except for the\n\\(\\left<U_{HMA}^2\\right>^2\\) in the variance term, which can be obtained by\npassing the u keyword; you must add this extra contribution to the \\(C_V\\)\nvalue reported by this compute.  The variance term can cause significant\nround-off error when computing \\(C_V\\).  To address this, the anharmonic\nkeyword can be passed and/or the output format can be specified with more\ndigits.\nthermo_modify format float '%22.15e'\n\n\nThe anharmonic keyword will instruct the compute to return anharmonic\nproperties rather than the full properties, which include lattice, harmonic\nand anharmonic contributions.\nWhen using this keyword, the compute must be first active (it must be included\nvia a thermo_style custom command) while the atoms are\nstill at their lattice sites (before equilibration).\nThe temp-ID specified with compute hma command should be same as the fix-ID of Nose-Hoover (fix nvt) or\nBerendsen (fix temp/berendsen) thermostat used for the simulation. While using this command, Langevin thermostat\n(fix langevin)\nshould be avoided as its extra forces interfere with the HMA implementation.\n\nNote\nCompute hma command should be used right after the energy minimization, when the atoms are at their lattice sites.\nThe simulation should not be started before this command has been used in the input script.\n\nThe following example illustrates the placement of this command in the input script:\nmin_style cg\nminimize 1e-35 1e-15 50000 500000\ncompute 1 all hma thermostatid u\nfix thermostatid all nvt temp 600.0 600.0 100.0\n\n\n\nNote\nCompute hma should be used when the atoms of the solid do not diffuse. Diffusion will reduce the precision in the potential energy computation.\n\n\nNote\nThe fix_modify energy yes command must also be specified if a fix is to contribute potential energy to this command.\n\nAn example input script that uses this compute is included in\nexamples/USER/hma/ along with corresponding LAMMPS output showing that the HMA\nproperties fluctuate less than the corresponding conventional properties.\nOutput info:\nThis compute calculates a global vector that includes the n properties\nrequested as arguments to the command (the potential energy, pressure and/or heat\ncapacity).  The elements of the vector can be accessed by indices 1-n by any\ncommand that uses global vector values as input.  See the Howto output doc page for an overview of LAMMPS output options.\nThe vector values calculated by this compute are “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID hma temp-ID keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * hma = style name of this compute command\n * temp-ID = ID of fix that specifies the set temperature during canonical simulation\n * keyword = anharmonic u p Pharm cv\n * anharmonic = compute will return anharmonic property values\n * u = compute will return potential energy\n * p = compute will return pressure.  the following keyword must be the difference between the harmonic pressure and lattice pressure as described below\n * cv = compute will return the heat capacity",
    "examples": "compute 2 all hma 1 u\ncompute 2 all hma 1 anharmonic u p 0.9\ncompute 2 all hma 1 u cv",
    "restrictions": "This compute is part of the USER-MISC package.  It is enabled only\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nUsage restricted to canonical (NVT) ensemble simulation only."
},
{
    "command": "compute improper",
    "html_filename": "compute_improper.html",
    "short_description": "Define a computation that extracts the improper energy calculated by each of the improper sub-styles used in the improper_style hybrid command",
    "description": "Define a computation that extracts the improper energy calculated by\neach of the improper sub-styles used in the improper_style hybrid command.  These values are made\naccessible for output or further processing by other commands.  The\ngroup specified for this command is ignored.\nThis compute is useful when using improper_style hybrid if you want to know the portion of the\ntotal energy contributed by one or more of the hybrid sub-styles.\nOutput info:\nThis compute calculates a global vector of length N where N is the\nnumber of sub_styles defined by the improper_style hybrid command.  which can be accessed by indices\n1-N.  These values can be used by any command that uses global scalar\nor vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector values are “extensive” and will be in energy\nunits.",
    "syntax": "compute ID group-ID improper",
    "parameters": " * ID, group-ID are documented in compute command\n * improper = style name of this compute command",
    "examples": "compute 1 all improper",
    "restrictions": "\nnone"
},
{
    "command": "compute improper/local",
    "html_filename": "compute_improper_local.html",
    "short_description": "Define a computation that calculates properties of individual improper interactions",
    "description": "Define a computation that calculates properties of individual improper\ninteractions.  The number of datums generated, aggregated across all\nprocessors, equals the number of impropers in the system, modified by\nthe group parameter as explained below.\nThe value chi is the improper angle, as defined in the doc pages for\nthe individual improper styles listed on\nimproper_style doc page.\nThe local data stored by this command is generated by looping over all\nthe atoms owned on a processor and their impropers.  An improper will\nonly be included if all 4 atoms in the improper are in the specified\ncompute group.\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, improper output from the compute property/local command can be combined\nwith data from this command and output by the dump local\ncommand in a consistent way.\nHere is an example of how to do this:\ncompute 1 all property/local itype iatom1 iatom2 iatom3 iatom4\ncompute 2 all improper/local chi\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_2[1]\n\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of keywords.  The length of the vector or number of rows in the\narray is the number of impropers.  If a single keyword is specified, a\nlocal vector is produced.  If two or more keywords are specified, a\nlocal array is produced where the number of columns = the number of\nkeywords.  The vector or array can be accessed by any command that\nuses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe output for chi will be in degrees.",
    "syntax": "compute ID group-ID improper/local value1 value2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * improper/local = style name of this compute command\n * one or more values may be appended\n * value = chi\n * chi = tabulate improper angles",
    "examples": "compute 1 all improper/local chi",
    "restrictions": "\nnone"
},
{
    "command": "compute inertia/chunk",
    "html_filename": "compute_inertia_chunk.html",
    "short_description": "Define a computation that calculates the inertia tensor for multiple chunks of atoms",
    "description": "Define a computation that calculates the inertia tensor for multiple\nchunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the 6 components of the symmetric inertia\ntensor for each chunk, ordered Ixx,Iyy,Izz,Ixy,Iyz,Ixz.  The\ncalculation includes all effects due to atoms passing through periodic\nboundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s inertia\ntensor in “unwrapped” form, by using the image flags associated with\neach atom.  See the dump custom command for a discussion\nof “unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute inertia/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all inertia/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n6 for the 6 components of the inertia tensor for each chunk, ordered\nas listed above.  These values can be accessed by any command that\nuses global array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array values are “intensive”.  The array values will be in\nmass*distance^2 units.",
    "syntax": "compute ID group-ID inertia/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * inertia/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid inertia/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute ke",
    "html_filename": "compute_ke.html",
    "short_description": "Define a computation that calculates the translational kinetic energy of a group of particles",
    "description": "Define a computation that calculates the translational kinetic energy\nof a group of particles.\nThe kinetic energy of each particle is computed as \\(\\frac{1}{2} m\nv^2\\), where m and v are the mass and velocity of the particle.\nThere is a subtle difference between the quantity calculated by this\ncompute and the kinetic energy calculated by the ke or etotal\nkeyword used in thermodynamic output, as specified by the\nthermo_style command.  For this compute, kinetic\nenergy is “translational” kinetic energy, calculated by the simple\nformula above.  For thermodynamic output, the ke keyword infers\nkinetic energy from the temperature of the system with\n\\(\\frac{1}{2} k_B T\\) of energy for each degree of freedom.  For the\ndefault temperature computation via the compute temp command, these are the same.  But different computes\nthat calculate temperature can subtract out different non-thermal\ncomponents of velocity and/or include different degrees of freedom\n(translational, rotational, etc).\nOutput info:\nThis compute calculates a global scalar (the summed KE).  This value\ncan be used by any command that uses a global scalar value from a\ncompute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID ke",
    "parameters": " * ID, group-ID are documented in compute command\n * ke = style name of this compute command",
    "examples": "compute 1 all ke",
    "restrictions": "\nnone"
},
{
    "command": "compute ke/atom",
    "html_filename": "compute_ke_atom.html",
    "short_description": "Define a computation that calculates the per-atom translational kinetic energy for each atom in a group",
    "description": "Define a computation that calculates the per-atom translational\nkinetic energy for each atom in a group.\nThe kinetic energy is simply 1/2 m v^2, where m is the mass and v is\nthe velocity of each atom.\nThe value of the kinetic energy will be 0.0 for atoms not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in energy units.",
    "syntax": "compute ID group-ID ke/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * ke/atom = style name of this compute command",
    "examples": "compute 1 all ke/atom",
    "restrictions": "\nnone"
},
{
    "command": "compute ke/atom/eff",
    "html_filename": "compute_ke_atom_eff.html",
    "short_description": "Define a computation that calculates the per-atom translational (nuclei and electrons) and radial kinetic energy (electron only) in a group",
    "description": "Define a computation that calculates the per-atom translational\n(nuclei and electrons) and radial kinetic energy (electron only) in a\ngroup.  The particles are assumed to be nuclei and electrons modeled\nwith the electronic force field.\nThe kinetic energy for each nucleus is computed as \\(\\frac{1}{2} m\nv^2\\), where m corresponds to the corresponding nuclear mass, and the\nkinetic energy for each electron is computed as \\(\\frac{1}{2} (m_e\nv^2 + \\frac{3}{4} m_e s^2)\\), where \\(m_e\\) and v correspond to the mass\nand translational velocity of each electron, and s to its radial\nvelocity, respectively.\nThere is a subtle difference between the quantity calculated by this\ncompute and the kinetic energy calculated by the ke or etotal\nkeyword used in thermodynamic output, as specified by the\nthermo_style command. For this compute, kinetic\nenergy is “translational” plus electronic “radial” kinetic energy,\ncalculated by the simple formula above. For thermodynamic output, the\nke keyword infers kinetic energy from the temperature of the system\nwith \\(\\frac{1}{2} k_B T\\) of energy for each (nuclear-only) degree\nof freedom in eFF.\n\nNote\nThe temperature in eFF should be monitored via the compute temp/eff command, which can be printed with\nthermodynamic output by using the thermo_modify\ncommand, as shown in the following example:\n\ncompute         effTemp all temp/eff\nthermo_style    custom step etotal pe ke temp press\nthermo_modify   temp effTemp\n\n\nThe value of the kinetic energy will be 0.0 for atoms (nuclei or\nelectrons) not in the specified compute group.\nOutput info:\nThis compute calculates a scalar quantity for each atom, which can be\naccessed by any command that uses per-atom computes as input.  See the\nHowto output doc page for an overview of LAMMPS\noutput options.\nThe per-atom vector values will be in energy units.",
    "syntax": "compute ID group-ID ke/atom/eff",
    "parameters": " * ID, group-ID are documented in compute command\n * ke/atom/eff = style name of this compute command",
    "examples": "compute 1 all ke/atom/eff",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute ke/eff",
    "html_filename": "compute_ke_eff.html",
    "short_description": "Define a computation that calculates the kinetic energy of motion of a group of eFF particles (nuclei and electrons), as modeled with the electronic force field",
    "description": "Define a computation that calculates the kinetic energy of motion of a\ngroup of eFF particles (nuclei and electrons), as modeled with the\nelectronic force field.\nThe kinetic energy for each nucleus is computed as \\(\\frac{1}{2} m\nv^2\\) and the kinetic energy for each electron is computed as\n\\(\\frac{1}{2}(m_e v^2 + \\frac{3}{4} m_e s^2)\\), where m\ncorresponds to the nuclear mass, \\(m_e\\) to the electron mass, v\nto the translational velocity of each particle, and s to the radial\nvelocity of the electron, respectively.\nThere is a subtle difference between the quantity calculated by this\ncompute and the kinetic energy calculated by the ke or etotal\nkeyword used in thermodynamic output, as specified by the\nthermo_style command.  For this compute, kinetic\nenergy is “translational” and “radial” (only for electrons) kinetic\nenergy, calculated by the simple formula above.  For thermodynamic\noutput, the ke keyword infers kinetic energy from the temperature of\nthe system with \\(\\frac{1}{2} k_B T\\) of energy for each degree of\nfreedom.  For the eFF temperature computation via the compute\ntemp_eff command, these are the same.  But\ndifferent computes that calculate temperature can subtract out different\nnon-thermal components of velocity and/or include other degrees of\nfreedom.\n\nWarning\nThe temperature in eFF models should be monitored via\nthe compute temp/eff command, which can be\nprinted with thermodynamic output by using the\nthermo_modify command, as shown in the following\nexample:\n\ncompute         effTemp all temp/eff\nthermo_style    custom step etotal pe ke temp press\nthermo_modify   temp effTemp\n\n\nSee compute temp/eff.\nOutput info:\nThis compute calculates a global scalar (the KE).  This value can be\nused by any command that uses a global scalar value from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID ke/eff",
    "parameters": " * ID, group-ID are documented in compute command\n * ke/eff = style name of this compute command",
    "examples": "compute 1 all ke/eff",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nRelated commands: none\nDefault: none"
},
{
    "command": "compute ke/rigid",
    "html_filename": "compute_ke_rigid.html",
    "short_description": "Define a computation that calculates the translational kinetic energy of a collection of rigid bodies, as defined by one of the fix rigid command variants",
    "description": "Define a computation that calculates the translational kinetic energy\nof a collection of rigid bodies, as defined by one of the fix rigid command variants.\nThe kinetic energy of each rigid body is computed as 1/2 M Vcm^2,\nwhere M is the total mass of the rigid body, and Vcm is its\ncenter-of-mass velocity.\nThe fix-ID should be the ID of one of the fix rigid\ncommands which defines the rigid bodies.  The group specified in the\ncompute command is ignored.  The kinetic energy of all the rigid\nbodies defined by the fix rigid command in included in the\ncalculation.\nOutput info:\nThis compute calculates a global scalar (the summed KE of all the\nrigid bodies).  This value can be used by any command that uses a\nglobal scalar value from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID ke/rigid fix-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * ke = style name of this compute command\n * fix-ID = ID of rigid body fix",
    "examples": "compute 1 all ke/rigid myRigid",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute meso/e/atom",
    "html_filename": "compute_meso_e_atom.html",
    "short_description": "Define a computation that calculates the per-atom internal energy for each atom in a group",
    "description": "Define a computation that calculates the per-atom internal energy\nfor each atom in a group.\nThe internal energy is the energy associated with the internal degrees\nof freedom of a mesoscopic particles, e.g. a Smooth-Particle\nHydrodynamics particle.\nSee this PDF guide to using SPH in\nLAMMPS.\nThe value of the internal energy will be 0.0 for atoms not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in energy units.",
    "syntax": "compute ID group-ID meso/e/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * meso/e/atom = style name of this compute command",
    "examples": "compute 1 all meso/e/atom",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute meso/rho/atom",
    "html_filename": "compute_meso_rho_atom.html",
    "short_description": "Define a computation that calculates the per-atom mesoscopic density for each atom in a group",
    "description": "Define a computation that calculates the per-atom mesoscopic density\nfor each atom in a group.\nThe mesoscopic density is the mass density of a mesoscopic particle,\ncalculated by kernel function interpolation using “pair style\nsph/rhosum”.\nSee this PDF guide to using SPH in\nLAMMPS.\nThe value of the mesoscopic density will be 0.0 for atoms not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in mass/volume units.",
    "syntax": "compute ID group-ID meso/rho/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * meso/rho/atom = style name of this compute command",
    "examples": "compute 1 all meso/rho/atom",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute meso/t/atom",
    "html_filename": "compute_meso_t_atom.html",
    "short_description": "Define a computation that calculates the per-atom internal temperature for each atom in a group",
    "description": "Define a computation that calculates the per-atom internal temperature\nfor each atom in a group.\nThe internal temperature is the ratio of internal energy over the heat\ncapacity associated with the internal degrees of freedom of a mesoscopic\nparticles, e.g. a Smooth-Particle Hydrodynamics particle.\nT_int = E_int / C_V, int\nSee this PDF guide to using SPH in\nLAMMPS.\nThe value of the internal energy will be 0.0 for atoms not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in temperature units.",
    "syntax": "compute ID group-ID meso/t/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * meso/t/atom = style name of this compute command",
    "examples": "compute 1 all meso/t/atom",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute_modify",
    "html_filename": "compute_modify.html",
    "short_description": "Modify one or more parameters of a previously defined compute",
    "description": "Modify one or more parameters of a previously defined compute.  Not\nall compute styles support all parameters.\nThe extra/dof or extra keyword refers to how many\ndegrees-of-freedom are subtracted (typically from 3N) as a normalizing\nfactor in a temperature computation.  Only computes that compute a\ntemperature use this option.  The default is 2 or 3 for 2d or 3d systems which is a correction factor for an ensemble\nof velocities with zero total linear momentum. For compute\ntemp/partial, if one or more velocity components are excluded, the\nvalue used for extra is scaled accordingly. You can use a negative\nnumber for the extra parameter if you need to add\ndegrees-of-freedom.  See the compute temp/asphere command for an example.\nThe dynamic/dof or dynamic keyword determines whether the number\nof atoms N in the compute group and their associated degrees of\nfreedom are re-computed each time a temperature is computed.  Only\ncompute styles that calculate a temperature use this option.  By\ndefault, N and their DOF are assumed to be constant.  If you are\nadding atoms or molecules to the system (see the fix pour, fix deposit, and fix gcmc commands) or expect atoms or molecules to be lost\n(e.g. due to exiting the simulation box or via fix evaporate), then this option should be used to\ninsure the temperature is correctly normalized.\n\nNote\nThe extra and dynamic keywords should not be used as they\nare deprecated (March 2017) and will eventually be disabled.  Instead,\nuse the equivalent extra/dof and dynamic/dof keywords.",
    "syntax": "compute_modify compute-ID keyword value ...",
    "parameters": " * compute-ID = ID of the compute to modify\n * one or more keyword/value pairs may be listed\n * keyword = extra/dof or extra or dynamic/dof or dynamic\n * extra/dof value = N\n *   N = # of extra degrees of freedom to subtract\n * extra syntax is identical to extra/dof, will be disabled at some point\n * dynamic/dof value = yes or no\n *   yes/no = do or do not re-compute the number of degrees of freedom (DOF) contributing to the temperature\n * dynamic syntax is identical to dynamic/dof, will be disabled at some point",
    "examples": "compute_modify myTemp extra/dof 0\ncompute_modify newtemp dynamic/dof yes extra/dof 600",
    "restrictions": "\nnone"
},
{
    "command": "compute momentum",
    "html_filename": "compute_momentum.html",
    "short_description": "Define a computation that calculates the translational momentum of a group of particles",
    "description": "Define a computation that calculates the translational momentum\nof a group of particles.\nThe momentum of each particles is computed as m v, where m and v are\nthe mass and velocity of the particle.\nOutput info:\nThis compute calculates a global vector (the summed momentum) of\nlength 3. This value can be used by any command that uses a global\nvector value from a compute as input. See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector value calculated by this compute is “extensive”. The vector\nvalue will be in mass*velocity units.",
    "syntax": "compute ID group-ID momentum",
    "parameters": " * ID, group-ID are documented in compute command\n * momentum = style name of this compute command",
    "examples": "compute 1 all momentum",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute msd",
    "html_filename": "compute_msd.html",
    "short_description": "Define a computation that calculates the mean-squared displacement (MSD) of the group of atoms, including all effects due to atoms passing through periodic boundaries",
    "description": "Define a computation that calculates the mean-squared displacement\n(MSD) of the group of atoms, including all effects due to atoms\npassing through periodic boundaries.  For computation of the non-Gaussian\nparameter of mean-squared displacement, see the compute msd/nongauss command.\nA vector of four quantities is calculated by this compute.  The first 3\nelements of the vector are the squared dx,dy,dz displacements, summed\nand averaged over atoms in the group.  The 4th element is the total\nsquared displacement, i.e. (dx*dx + dy*dy + dz*dz), summed and\naveraged over atoms in the group.\nThe slope of the mean-squared displacement (MSD) versus time is\nproportional to the diffusion coefficient of the diffusing atoms.\nThe displacement of an atom is from its reference position. This is\nnormally the original position at the time\nthe compute command was issued, unless the average keyword is set to yes.\nThe value of the displacement will be\n0.0 for atoms not in the specified compute group.\nIf the com option is set to yes then the effect of any drift in\nthe center-of-mass of the group of atoms is subtracted out before the\ndisplacement of each atom is calculated.\nIf the average option is set to yes then the reference position of\nan atom is based on the average position of that atom, corrected for\ncenter-of-mass motion if requested.  The average position is a running\naverage over all previous calls to the compute, including the current\ncall. So on the first call it is current position, on the second call\nit is the arithmetic average of the current position and the position\non the first call, and so on.  Note that when using this option, the\nprecise value of the mean square displacement will depend on the\nnumber of times the compute is called. So, for example, changing the\nfrequency of thermo output may change the computed displacement. Also,\nthe precise values will be changed if a single simulation is broken up\ninto two parts, using either multiple run commands or a restart\nfile. It only makes sense to use this option if the atoms are not\ndiffusing, so that their average positions relative to the center of\nmass of the system are stationary. The most common case is crystalline\nsolids undergoing thermal motion.\n\nNote\nInitial coordinates are stored in “unwrapped” form, by using the\nimage flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\nSee the Atoms section of the read_data command for a\ndiscussion of image flags and how they are set for each atom.  You can\nreset the image flags (e.g. to 0) before invoking this compute by\nusing the set image command.\n\n\nNote\nIf you want the quantities calculated by this compute to be\ncontinuous when running from a restart file, then\nyou should use the same ID for this compute, as in the original run.\nThis is so that the fix this compute creates to store per-atom\nquantities will also have the same ID, and thus be initialized\ncorrectly with atom reference positions from the restart file.  When\naverage is set to yes, then the atom reference positions are\nrestored correctly, but not the number of samples used obtain them. As\na result, the reference positions from the restart file are combined\nwith subsequent positions as if they were from a single sample,\ninstead of many, which will change the values of msd somewhat.\n\nOutput info:\nThis compute calculates a global vector of length 4, which can be\naccessed by indices 1-4 by any command that uses global vector values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe vector values are “intensive”.  The vector values will be in\ndistance^2 units.",
    "syntax": "compute ID group-ID msd keyword values ...",
    "parameters": " * ID, group-ID are documented in compute command\n * msd = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = com or average\n * com value = yes or no\n * average value = yes or no",
    "examples": "compute 1 all msd\ncompute 1 upper msd com yes average yes",
    "restrictions": "\nnone"
},
{
    "command": "compute msd/chunk",
    "html_filename": "compute_msd_chunk.html",
    "short_description": "Define a computation that calculates the mean-squared displacement (MSD) for multiple chunks of atoms",
    "description": "Define a computation that calculates the mean-squared displacement\n(MSD) for multiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nFour quantities are calculated by this compute for each chunk.  The\nfirst 3 quantities are the squared dx,dy,dz displacements of the\ncenter-of-mass.  The 4th component is the total squared displacement,\ni.e. (dx*dx + dy*dy + dz*dz) of the center-of-mass.  These\ncalculations include all effects due to atoms passing through periodic\nboundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\nThe slope of the mean-squared displacement (MSD) versus time is\nproportional to the diffusion coefficient of the diffusing chunks.\nThe displacement of the center-of-mass of the chunk is from its\noriginal center-of-mass position, calculated on the timestep this\ncompute command was first invoked.\n\nNote\nThe number of chunks Nchunk calculated by the compute chunk/atom command must remain constant each\ntime this compute is invoked, so that the displacement for each chunk\nfrom its original position can be computed consistently.  If Nchunk\ndoes not remain constant, an error will be generated.  If needed, you\ncan enforce a constant Nchunk by using the nchunk once or ids\nonce options when specifying the compute chunk/atom command.\n\n\nNote\nThis compute stores the original position (of the\ncenter-of-mass) of each chunk.  When a displacement is calculated on a\nlater timestep, it is assumed that the same atoms are assigned to the\nsame chunk ID.  However LAMMPS has no simple way to insure this is the\ncase, though you can use the ids once option when specifying the\ncompute chunk/atom command.  Note that if\nthis is not the case, the MSD calculation does not have a sensible\nmeaning.\n\n\nNote\nThe initial coordinates of the atoms in each chunk are stored in\n“unwrapped” form, by using the image flags associated with each atom.\nSee the dump custom command for a discussion of\n“unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\n\nNote\nIf you want the quantities calculated by this compute to be\ncontinuous when running from a restart file, then\nyou should use the same ID for this compute, as in the original run.\nThis is so that the fix this compute creates to store per-chunk\nquantities will also have the same ID, and thus be initialized\ncorrectly with chunk reference positions from the restart file.\n\nThe simplest way to output the results of the compute msd/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all msd/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n4 for dx,dy,dz and the total displacement.  These values can be\naccessed by any command that uses global array values from a compute\nas input.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe array values are “intensive”.  The array values will be in\ndistance^2 units.",
    "syntax": "compute ID group-ID msd/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * msd/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 all msd/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute msd/nongauss",
    "html_filename": "compute_msd_nongauss.html",
    "short_description": "Define a computation that calculates the mean-squared displacement (MSD) and non-Gaussian parameter (NGP) of the group of atoms, including all effects due to atoms passing through periodic boundaries",
    "description": "Define a computation that calculates the mean-squared displacement\n(MSD) and non-Gaussian parameter (NGP) of the group of atoms,\nincluding all effects due to atoms passing through periodic boundaries.\nA vector of three quantities is calculated by this compute.  The first\nelement of the vector is the total squared dx,dy,dz displacements\ndrsquared = (dx*dx + dy*dy + dz*dz) of atoms, and the second is the\nfourth power of these displacements drfourth = (dx*dx + dy*dy +\ndz*dz)*(dx*dx + dy*dy + dz*dz), summed and averaged over atoms in the\ngroup.  The 3rd component is the nonGaussian diffusion parameter NGP =\n3*drfourth/(5*drsquared*drsquared), i.e.\n\n\\[NGP(t) = 3<(r(t)-r(0))^4>/(5<(r(t)-r(0))^2>^2) - 1\\]\nThe NGP is a commonly used quantity in studies of dynamical\nheterogeneity.  Its minimum theoretical value (-0.4) occurs when all\natoms have the same displacement magnitude.  NGP=0 for Brownian\ndiffusion, while NGP > 0 when some mobile atoms move faster than\nothers.\nIf the com option is set to yes then the effect of any drift in\nthe center-of-mass of the group of atoms is subtracted out before the\ndisplacement of each atom is calculated.\nSee the compute msd doc page for further important\nNOTEs, which also apply to this compute.\nOutput info:\nThis compute calculates a global vector of length 3, which can be\naccessed by indices 1-3 by any command that uses global vector values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe vector values are “intensive”.  The first vector value will be in\ndistance^2 units, the second is in distance^4 units, and\nthe 3rd is dimensionless.",
    "syntax": "compute ID group-ID msd/nongauss keyword values ...",
    "parameters": " * ID, group-ID are documented in compute command\n * msd/nongauss = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = com\n * com value = yes or no",
    "examples": "compute 1 all msd/nongauss\ncompute 1 upper msd/nongauss com yes",
    "restrictions": "This compute is part of the MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute omega/chunk",
    "html_filename": "compute_omega_chunk.html",
    "short_description": "Define a computation that calculates the angular velocity (omega) of multiple chunks of atoms",
    "description": "Define a computation that calculates the angular velocity (omega) of\nmultiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the 3 components of the angular velocity\nvector for each chunk, via the formula L = Iw where L is the angular\nmomentum vector of the chunk, I is its moment of inertia tensor, and w\nis omega = angular velocity of the chunk.  The calculation includes\nall effects due to atoms passing through periodic boundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s angular\nvelocity in “unwrapped” form, by using the image flags associated with\neach atom.  See the dump custom command for a discussion\nof “unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute omega/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all omega/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n3 for the 3 xyz components of the angular velocity for each chunk.\nThese values can be accessed by any command that uses global array\nvalues from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array values are “intensive”.  The array values will be in\nvelocity/distance units.",
    "syntax": "compute ID group-ID omega/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * omega/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid omega/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute orientorder/atom",
    "html_filename": "compute_orientorder_atom.html",
    "short_description": "Define a computation that calculates a set of bond-orientational order parameters \\(Q_l\\) for each atom in a group",
    "description": "Define a computation that calculates a set of bond-orientational\norder parameters \\(Q_l\\) for each atom in a group. These order parameters\nwere introduced by Steinhardt et al. as a way to\ncharacterize the local orientational order in atomic structures.\nFor each atom, \\(Q_l\\) is a real number defined as follows:\n\n\\[\\begin{split}\\bar{Y}_{lm} = & \\frac{1}{nnn}\\sum_{j = 1}^{nnn} Y_{lm}( \\theta( {\\bf r}_{ij} ), \\phi( {\\bf r}_{ij} ) ) \\\\\nQ_l = & \\sqrt{\\frac{4 \\pi}{2 l + 1} \\sum_{m = -l}^{m = l} \\bar{Y}_{lm} \\bar{Y}^*_{lm}}\\end{split}\\]\nThe first equation defines the spherical harmonic order parameters.\nThese are complex number components of the 3D analog of the 2D order\nparameter \\(q_n\\), which is implemented as LAMMPS compute\nhexorder/atom.\nThe summation is over the nnn nearest\nneighbors of the central atom.\nThe angles theta and phi are the standard spherical polar angles\ndefining the direction of the bond vector \\(r_{ij}\\).\nThe second equation defines \\(Q_l\\), which is a\nrotationally invariant non-negative amplitude obtained by summing\nover all the components of degree l.\nThe optional keyword cutoff defines the distance cutoff\nused when searching for neighbors. The default value, also\nthe maximum allowable value, is the cutoff specified\nby the pair style.\nThe optional keyword nnn defines the number of nearest\nneighbors used to calculate \\(Q_l\\). The default value is 12.\nIf the value is NULL, then all neighbors up to the\nspecified distance cutoff are used.\nThe optional keyword degrees defines the list of order parameters to\nbe computed.  The first argument nlvalues is the number of order\nparameters. This is followed by that number of non-negative integers giving the\ndegree of each order parameter. Because \\(Q_2\\) and all odd-degree order\nparameters are zero for atoms in cubic crystals (see\nSteinhardt), the default order parameters are \\(Q_4\\),\n\\(Q_6\\), \\(Q_8\\), \\(Q_{10}\\), and \\(Q_{12}\\). For the FCC\ncrystal with nnn =12, \\(Q_4 = \\sqrt{\\frac{7}{192}} = 0.19094...\\).\nThe numerical values of all order\nparameters up to \\(Q_12\\) for a range of commonly encountered\nhigh-symmetry structures are given in Table I of Mickel et al.,\nand these can be reproduced with this compute.\nThe optional keyword wl will output the third-order invariants \\(W_l\\)\n(see Eq. 1.4 in Steinhardt) for the same degrees as\nfor the \\(Q_l\\) parameters. For the FCC crystal with nnn =12,\n\\(W_4\\) = -sqrt(14/143).(49/4096)/Pi^1.5 = -0.0006722136…\nThe optional keyword wl/hat will output the normalized third-order\ninvariants \\(\\hat{W}_l\\) (see Eq. 2.2 in Steinhardt)\nfor the same degrees as for the \\(Q_l\\) parameters. For the FCC crystal\nwith nnn =12, \\(\\hat{W}_4 = -\\frac{7}{3} \\sqrt{\\frac{2}{429}} = -0.159317...\\)\nThe numerical\nvalues of \\(\\hat{W}_l\\) for a range of commonly encountered high-symmetry\nstructures are given in Table I of Steinhardt, and these\ncan be reproduced with this keyword.\nThe optional keyword components will output the components of the\nnormalized complex vector \\(\\bar{Y}_{lm}\\) of degree ldegree, which must be\nexplicitly included in the keyword degrees. This option can be used\nin conjunction with compute coord_atom to\ncalculate the ten Wolde’s criterion to identify crystal-like\nparticles, as discussed in ten Wolde.\nThe value of \\(Q_l\\) is set to zero for atoms not in the\nspecified compute group, as well as for atoms that have less than\nnnn neighbors within the distance cutoff, unless nnn is NULL.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses the neighbor list, it also means\nthose pairs will not be included in the order parameter.  This\ndifficulty can be circumvented by writing a dump file, and using the\nrerun command to compute the order parameter for\nsnapshots in the dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\nOutput info:\nThis compute calculates a per-atom array with nlvalues columns,\ngiving the \\(Q_l\\) values for each atom, which are real numbers on the\nrange \\(0 <= Q_l <= 1\\).\nIf the keyword wl is set to yes, then the \\(W_l\\) values for each\natom will be added to the output array, which are real numbers.\nIf the keyword wl/hat is set to yes, then the \\(\\hat{W}_l\\)\nvalues for each atom will be added to the output array, which are real numbers.\nIf the keyword components is set, then the real and imaginary parts\nof each component of (normalized) \\(\\bar{Y}_{lm}\\) will be added to the\noutput array in the following order: \\(Re(\\bar{Y}_{-m}) Im(\\bar{Y}_{-m})\nRe(\\bar{Y}_{-m+1}) Im(\\bar{Y}_{-m+1}) ... Re(\\bar{Y}_m) Im(\\bar{Y}_m)\\).  This\nway, the per-atom array will have a total of nlvalues+2*(2l+1)\ncolumns.\nThese values can be accessed by any command that uses per-atom values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.",
    "syntax": "compute ID group-ID orientorder/atom keyword values ...",
    "parameters": " * ID, group-ID are documented in compute command\n * orientorder/atom = style name of this compute command\n * one or more keyword/value pairs may be appended\n * keyword = cutoff or nnn or degrees or components\n *   cutoff value = distance cutoff\n *   nnn value = number of nearest neighbors\n *   degrees values = nlvalues, l1, l2,...\n *   wl value = yes or no\n *   wl/hat value = yes or no\n *   components value = ldegree",
    "examples": "compute 1 all orientorder/atom\ncompute 1 all orientorder/atom degrees 5 4 6 8 10 12 nnn NULL cutoff 1.5\ncompute 1 all orientorder/atom wl/hat yes\ncompute 1 all orientorder/atom components 6",
    "restrictions": "\nnone"
},
{
    "command": "compute pair",
    "html_filename": "compute_pair.html",
    "short_description": "Define a computation that extracts additional values calculated by a pair style, and makes them accessible for output or further processing by other commands",
    "description": "Define a computation that extracts additional values calculated by a\npair style, and makes them accessible for output or further processing\nby other commands.\n\nNote\nThe group specified for this command is ignored.\n\nThe specified pstyle must be a pair style used in your simulation\neither by itself or as a sub-style in a pair_style hybrid or hybrid/overlay command. If the sub-style is\nused more than once, an additional number nsub has to be specified\nin order to choose which instance of the sub-style will be used by\nthe compute. Not specifying the number in this case will cause the\ncompute to fail.\nThe evalue setting is optional.  All\npair styles tally a potential energy epair which may be broken into\ntwo parts: evdwl and ecoul such that epair = evdwl + ecoul.\nIf the pair style calculates Coulombic interactions, their energy will\nbe tallied in ecoul.  Everything else (whether it is a Lennard-Jones\nstyle van der Waals interaction or not) is tallied in evdwl.  If\nevalue is blank or specified as epair, then epair is stored\nas a global scalar by this compute.  This is useful when using\npair_style hybrid if you want to know the portion\nof the total energy contributed by one sub-style.  If evalue is\nspecified as evdwl or ecoul, then just that portion of the energy\nis stored as a global scalar.\n\nNote\nThe energy returned by the evdwl keyword does not include tail\ncorrections, even if they are enabled via the\npair_modify command.\n\nSome pair styles tally additional quantities, e.g. a breakdown of\npotential energy into 14 components is tallied by the pair_style reax/c command.  These values (1 or more)\nare stored as a global vector by this compute.  See the doc page for\nindividual pair styles for info on these values.\nOutput info:\nThis compute calculates a global scalar which is epair or evdwl or\necoul.  If the pair style supports it, it also calculates a global\nvector of length >= 1, as determined by the pair style.  These values\ncan be used by any command that uses global scalar or vector values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe scalar and vector values calculated by this compute are\n“extensive”.\nThe scalar value will be in energy units.  The vector\nvalues will typically also be in energy units, but see\nthe doc page for the pair style for details.",
    "syntax": "compute ID group-ID pair pstyle [nstyle] [evalue]",
    "parameters": " * ID, group-ID are documented in compute command\n * pair = style name of this compute command\n * pstyle = style name of a pair style that calculates additional values\n * nsub = n-instance of a sub-style, if a pair style is used multiple times in a hybrid style\n * evalue = epair or evdwl or ecoul or blank (optional)",
    "examples": "compute 1 all pair gauss\ncompute 1 all pair lj/cut/coul/cut ecoul\ncompute 1 all pair tersoff 2 epair\ncompute 1 all pair reax/c",
    "restrictions": "\nnone"
},
{
    "command": "compute pair/local",
    "html_filename": "compute_pair_local.html",
    "short_description": "Define a computation that calculates properties of individual pairwise interactions",
    "description": "Define a computation that calculates properties of individual pairwise\ninteractions.  The number of datums generated, aggregated across all\nprocessors, equals the number of pairwise interactions in the system.\nThe local data stored by this command is generated by looping over the\npairwise neighbor list.  Info about an individual pairwise interaction\nwill only be included if both atoms in the pair are in the specified\ncompute group, and if the current pairwise distance is less than the\nforce cutoff distance for that interaction, as defined by the\npair_style and pair_coeff\ncommands.\nThe value dist is the distance between the pair of atoms.\nThe value eng is the interaction energy for the pair of atoms.\nThe value force is the force acting between the pair of atoms, which\nis positive for a repulsive force and negative for an attractive\nforce.  The values fx, fy, and fz are the xyz components of\nforce on atom I.\nA pair style may define additional pairwise quantities which can be\naccessed as p1 to pN, where N is defined by the pair style.  Most\npair styles do not define any additional quantities, so N = 0.  An\nexample of ones that do are the granular pair styles\nwhich calculate the tangential force between two particles and return\nits components and magnitude acting on atom I for N = 1,2,3,4.  See\nindividual pair styles for details.\nWhen using pN with pair style hybrid, the output will be the Nth\nquantity from the sub-style that computes the pairwise interaction\n(based on atom types).  If that sub-style does not define a pN,\nthe output will be 0.0.  The maximum allowed N is the maximum number\nof quantities provided by any sub-style.\nWhen using pN with pair style hybrid/overlay the quantities\nfrom all sub-styles that provide them are concatenated together\ninto one long list. For example, if there are 3 sub-styles and\n2 of them have additional output (with 3 and 4 quantities,\nrespectively), then 7 values (p1 up to p7) are defined.\nThe values p1 to p3 refer to quantities defined by the first\nof the two sub-styles.  Values p4 to p7 refer to quantities\nfrom the second of the two sub-styles.  If the referenced pN\nis not computed for the specific pairwise interaction (based on\natom types), then the output will be 0.0.\nThe value dist will be in distance units.  The value\neng will be in energy units.  The values force, fx,\nfy, and fz will be in force units.  The values pN\nwill be in whatever units the pair style defines.\nThe optional cutoff keyword determines how the force cutoff distance\nfor an interaction is determined.  For the default setting of type,\nthe pairwise cutoff defined by the pair_style\ncommand for the types of the two atoms is used.  For the radius\nsetting, the sum of the radii of the two particles is used as a\ncutoff.  For example, this is appropriate for granular particles which\nonly interact when they are overlapping, as computed by granular pair styles.  Note that if a granular model defines atom\ntypes such that all particles of a specific type are monodisperse\n(same diameter), then the two settings are effectively identical.\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, pair output from the compute property/local command can be combined\nwith data from this command and output by the dump local\ncommand in a consistent way.\nHere is an example of how to do this:\ncompute 1 all property/local patom1 patom2\ncompute 2 all pair/local dist eng force\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_2[1] c_2[2] c_2[3]\n\n\n\nNote\nFor pairs, if two atoms I,J are involved in 1-2, 1-3, 1-4\ninteractions within the molecular topology, their pairwise interaction\nmay be turned off, and thus they may not appear in the neighbor list,\nand will not be part of the local data created by this command.  More\nspecifically, this will be true of I,J pairs with a weighting factor\nof 0.0; pairs with a non-zero weighting factor are included.  The\nweighting factors for 1-2, 1-3, and 1-4 pairwise interactions are set\nby the special_bonds command.  An exception is if\nlong-range Coulombics are being computed via the\nkspace_style command, then atom pairs with\nweighting factors of zero are still included in the neighbor list, so\nthat a portion of the long-range interaction contribution can be\ncomputed in the pair style.  Hence in that case, those atom pairs will\nbe part of the local data created by this command.\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of keywords.  The length of the vector or number of rows in the\narray is the number of pairs.  If a single keyword is specified, a\nlocal vector is produced.  If two or more keywords are specified, a\nlocal array is produced where the number of columns = the number of\nkeywords.  The vector or array can be accessed by any command that\nuses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe output for dist will be in distance units.  The\noutput for eng will be in energy units.  The output for\nforce, fx, fy, and fz will be in force units.\nThe output for pN will be in whatever units the pair style defines.",
    "syntax": "compute ID group-ID pair/local value1 value2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * pair/local = style name of this compute command\n * one or more values may be appended\n * value = dist or eng or force or fx or fy or fz or pN\n * dist = pairwise distance\n * eng = pairwise energy\n * force = pairwise force\n * fx,fy,fz = components of pairwise force\n * pN = pair style specific quantities for allowed N values\n * zero or more keyword/arg pairs may be appended\n * keyword = cutoff\n * cutoff arg = type or radius",
    "examples": "compute 1 all pair/local eng\ncompute 1 all pair/local dist eng force\ncompute 1 all pair/local dist eng fx fy fz\ncompute 1 all pair/local dist fx fy fz p1 p2 p3",
    "restrictions": "\nnone"
},
{
    "command": "compute pe",
    "html_filename": "compute_pe.html",
    "short_description": "Define a computation that calculates the potential energy of the entire system of atoms",
    "description": "Define a computation that calculates the potential energy of the\nentire system of atoms.  The specified group must be “all”.  See the\ncompute pe/atom command if you want per-atom\nenergies.  These per-atom values could be summed for a group of atoms\nvia the compute reduce command.\nThe energy is calculated by the various pair, bond, etc potentials\ndefined for the simulation.  If no extra keywords are listed, then the\npotential energy is the sum of pair, bond, angle, dihedral, improper,\nkspace (long-range), and fix energy.  I.e. it is as if all the\nkeywords were listed.  If any extra keywords are listed, then only\nthose components are summed to compute the potential energy.\nThe Kspace contribution requires 1 extra FFT each timestep the energy\nis calculated, if using the PPPM solver via the kspace_style pppm command.  Thus it can increase the cost of the\nPPPM calculation if it is needed on a large fraction of the simulation\ntimesteps.\nVarious fixes can contribute to the total potential energy of the\nsystem if the fix contribution is included.  See the doc pages for\nindividual fixes for details of which ones compute a\npotential energy.\n\nNote\nThe fix_modify energy yes command must also be\nspecified if a fix is to contribute potential energy to this command.\n\nA compute of this style with the ID of “thermo_pe” is created when\nLAMMPS starts up, as if this command were in the input script:\ncompute thermo_pe all pe\n\n\nSee the “thermo_style” command for more details.\n\nOutput info:\nThis compute calculates a global scalar (the potential energy).  This\nvalue can be used by any command that uses a global scalar value from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.  The\nscalar value will be in energy units.",
    "syntax": "compute ID group-ID pe keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * pe = style name of this compute command\n * zero or more keywords may be appended\n * keyword = pair or bond or angle or dihedral or improper or kspace or fix",
    "examples": "compute 1 all pe\ncompute molPE all pe bond angle dihedral improper",
    "restrictions": "\nnone"
},
{
    "command": "compute pe/atom",
    "html_filename": "compute_pe_atom.html",
    "short_description": "Define a computation that computes the per-atom potential energy for each atom in a group",
    "description": "Define a computation that computes the per-atom potential energy for\neach atom in a group.  See the compute pe command if\nyou want the potential energy of the entire system.\nThe per-atom energy is calculated by the various pair, bond, etc\npotentials defined for the simulation.  If no extra keywords are\nlisted, then the potential energy is the sum of pair, bond, angle,\ndihedral,improper, kspace (long-range), and fix energy.  I.e. it is as\nif all the keywords were listed.  If any extra keywords are listed,\nthen only those components are summed to compute the potential energy.\nNote that the energy of each atom is due to its interaction with all\nother atoms in the simulation, not just with other atoms in the group.\nFor an energy contribution produced by a small set of atoms (e.g. 4\natoms in a dihedral or 3 atoms in a Tersoff 3-body interaction), that\nenergy is assigned in equal portions to each atom in the set.\nE.g. 1/4 of the dihedral energy to each of the 4 atoms.\nThe dihedral_style charmm style calculates\npairwise interactions between 1-4 atoms.  The energy contribution of\nthese terms is included in the pair energy, not the dihedral energy.\nThe KSpace contribution is calculated using the method in\n(Heyes) for the Ewald method and a related method for PPPM,\nas specified by the kspace_style pppm command.\nFor PPPM, the calculation requires 1 extra FFT each timestep that\nper-atom energy is calculated.  This document\ndescribes how the long-range per-atom energy calculation is performed.\nVarious fixes can contribute to the per-atom potential energy of the\nsystem if the fix contribution is included.  See the doc pages for\nindividual fixes for details of which ones compute a\nper-atom potential energy.\n\nNote\nThe fix_modify energy yes command must also be\nspecified if a fix is to contribute per-atom potential energy to this\ncommand.\n\nAs an example of per-atom potential energy compared to total potential\nenergy, these lines in an input script should yield the same result\nin the last 2 columns of thermo output:\ncompute        peratom all pe/atom\ncompute        pe all reduce sum c_peratom\nthermo_style   custom step temp etotal press pe c_pe\n\n\n\nNote\nThe per-atom energy does not include any Lennard-Jones tail\ncorrections to the energy added by the pair_modify tail yes command, since those are contributions to the\nglobal system energy.\n\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values will be in energy units.",
    "syntax": "compute ID group-ID pe/atom keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * pe/atom = style name of this compute command\n * zero or more keywords may be appended\n * keyword = pair or bond or angle or dihedral or improper or kspace or fix",
    "examples": "compute 1 all pe/atom\ncompute 1 all pe/atom pair\ncompute 1 all pe/atom pair bond",
    "restrictions": ""
},
{
    "command": "compute plasticity/atom",
    "html_filename": "compute_plasticity_atom.html",
    "short_description": "Define a computation that calculates the per-atom plasticity for each atom in a group",
    "description": "Define a computation that calculates the per-atom plasticity for each\natom in a group.  This is a quantity relevant for Peridynamics models.  See this document\nfor an overview of LAMMPS commands for Peridynamics modeling.\nThe plasticity for a Peridynamic particle is the so-called consistency\nparameter (lambda).  For elastic deformation lambda = 0, otherwise\nlambda > 0 for plastic deformation.  For details, see\n(Mitchell) and the PDF doc included in the LAMMPS\ndistribution in doc/PDF/PDLammps_EPS.pdf.\nThis command can be invoked for one of the Peridynamic pair styles: peri/eps.\nThe plasticity value will be 0.0 for atoms not in the specified\ncompute group.\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe per-atom vector values are unitless numbers (lambda) >= 0.0.",
    "syntax": "compute ID group-ID plasticity/atom",
    "parameters": " * ID, group-ID are documented in compute command\n * plasticity/atom = style name of this compute command",
    "examples": "compute 1 all plasticity/atom",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute pressure",
    "html_filename": "compute_pressure.html",
    "short_description": "Define a computation that calculates the pressure of the entire system of atoms",
    "description": "Define a computation that calculates the pressure of the entire system\nof atoms.  The specified group must be “all”.  See the compute stress/atom command if you want per-atom\npressure (stress).  These per-atom values could be summed for a group\nof atoms via the compute reduce command.\nThe pressure is computed by the formula\n\n\\[P = \\frac{N k_B T}{V} + \\frac{\\sum_{i}^{N'} r_i \\bullet f_i}{dV}\\]\nwhere N is the number of atoms in the system (see discussion of DOF\nbelow), \\(k_B\\) is the Boltzmann constant, T is the temperature, d\nis the dimensionality of the system (2 or 3 for 2d/3d), and V is the\nsystem volume (or area in 2d).  The second term is the virial, equal to\n-dU/dV, computed for all pairwise as well as 2-body, 3-body, 4-body,\nmany-body, and long-range interactions, where \\(r_i\\) and\n\\(f_i\\) are the position and force vector of atom i, and the black\ndot indicates a dot product.  When periodic boundary conditions are\nused, N’ necessarily includes periodic image (ghost) atoms outside the\ncentral box, and the position and force vectors of ghost atoms are thus\nincluded in the summation.  When periodic boundary conditions are not\nused, N’ = N = the number of atoms in the system.  Fixes\nthat impose constraints (e.g. the fix shake command)\nalso contribute to the virial term.\nA symmetric pressure tensor, stored as a 6-element vector, is also\ncalculated by this compute.  The 6 components of the vector are\nordered xx, yy, zz, xy, xz, yz.  The equation for the I,J components\n(where I and J = x,y,z) is similar to the above formula, except that\nthe first term uses components of the kinetic energy tensor and the\nsecond term uses components of the virial tensor:\n\n\\[P_{IJ} = \\frac{\\sum_{k}^{N} m_k v_{k_I} v_{k_J}}{V} +\n\\frac{\\sum_{k}^{N'} r_{k_I} f_{k_J}}{V}\\]\nIf no extra keywords are listed, the entire equations above are\ncalculated.  This includes a kinetic energy (temperature) term and the\nvirial as the sum of pair, bond, angle, dihedral, improper, kspace\n(long-range), and fix contributions to the force on each atom.  If any\nextra keywords are listed, then only those components are summed to\ncompute temperature or ke and/or the virial.  The virial keyword\nmeans include all terms except the kinetic energy ke.\nThe pair/hybrid keyword means to only include contribution\nfrom a sub-style in a hybrid or hybrid/overlay pair style.\nDetails of how LAMMPS computes the virial efficiently for the entire\nsystem, including for many-body potentials and accounting for the\neffects of periodic boundary conditions are discussed in\n(Thompson).\nThe temperature and kinetic energy tensor is not calculated by this\ncompute, but rather by the temperature compute specified with the\ncommand.  If the kinetic energy is not included in the pressure, than\nthe temperature compute is not used and can be specified as NULL.\nNormally the temperature compute used by compute pressure should\ncalculate the temperature of all atoms for consistency with the virial\nterm, but any compute style that calculates temperature can be used,\ne.g. one that excludes frozen atoms or other degrees of freedom.\nNote that if desired the specified temperature compute can be one that\nsubtracts off a bias to calculate a temperature using only the thermal\nvelocity of the atoms, e.g. by subtracting a background streaming\nvelocity.  See the doc pages for individual compute commands to determine which ones include a bias.\nAlso note that the N in the first formula above is really\ndegrees-of-freedom divided by d = dimensionality, where the DOF value\nis calculated by the temperature compute.  See the various compute temperature styles for details.\nA compute of this style with the ID of “thermo_press” is created when\nLAMMPS starts up, as if this command were in the input script:\ncompute thermo_press all pressure thermo_temp\n\n\nwhere “thermo_temp” is the ID of a similarly defined compute of style\n“temp”.  See the “thermo_style” command for more details.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nOutput info:\nThis compute calculates a global scalar (the pressure) and a global\nvector of length 6 (pressure tensor), which can be accessed by indices\n1-6.  These values can be used by any command that uses global scalar\nor vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar and vector values calculated by this compute are\n“intensive”.  The scalar and vector values will be in pressure\nunits.",
    "syntax": "compute ID group-ID pressure temp-ID keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * pressure = style name of this compute command\n * temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n * zero or more keywords may be appended\n * keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial or pair/hybrid",
    "examples": "compute 1 all pressure thermo_temp\ncompute 1 all pressure NULL pair bond\ncompute 1 all pressure NULL pair/hybrid lj/cut",
    "restrictions": "\nnone"
},
{
    "command": "compute pressure/cylinder",
    "html_filename": "compute_pressure_cylinder.html",
    "short_description": "Define a computation that calculates the pressure tensor of a system in cylindrical coordinates, as discussed in (Addington)",
    "description": "Define a computation that calculates the pressure tensor of a system in\ncylindrical coordinates, as discussed in (Addington).\nThis is useful for systems with a single axis of rotational symmetry,\nsuch as cylindrical micelles or carbon nanotubes. The compute splits the\nsystem into radial, cylindrical-shell-type bins of width bin_width,\ncentered at x=0,y=0, and calculates the radial (P_rhorho), azimuthal\n(P_phiphi), and axial (P_zz) components of the configurational pressure\ntensor. The local density is also calculated for each bin, so that the\ntrue pressure can be recovered as P_kin+P_conf=density*k*T+P_conf.  The\noutput is a global array with 5 columns; one each for bin radius, local\nnumber density, P_rhorho, P_phiphi, and P_zz. The number of rows is\ngoverned by the values of Rmax and bin_width. Pressure tensor values are\noutput in pressure units.\nOutput info:\nThis compute calculates a global array with 5 columns and Rmax/bin_width\nrows. The output columns are: R (distance units), number density (inverse\nvolume units), configurational radial pressure (pressure units),\nconfigurational azimuthal pressure (pressure units), and configurational\naxial pressure (pressure units).\nThe values calculated by this compute are\n“intensive”.  The pressure values will be in pressure\nunits. The number density values will be in\ninverse volume units.",
    "syntax": "compute ID group-ID pressure/cylinder zlo zhi Rmax bin_width",
    "parameters": " * ID, group-ID are documented in compute command\n * pressure/cylinder = style name of this compute command\n * zlo = minimum z-boundary for cylinder\n * zhi = maximum z-boundary for cylinder\n * Rmax = maximum radius to perform calculation to\n * bin_width = width of radial bins to use for calculation",
    "examples": "compute 1 all pressure/cylinder -10.0 10.0 15.0 0.25",
    "restrictions": "This compute currently calculates the pressure tensor contributions\nfor pair styles only (i.e. no bond, angle, dihedral, etc. contributions\nand in the presence of bonded interactions, the result will be incorrect\ndue to exclusions for special bonds)  and requires pair-wise force\ncalculations not available for most many-body pair styles. K-space\ncalculations are also excluded. Note that this pressure compute outputs\nthe configurational terms only; the kinetic contribution is not included\nand may be calculated from the number density output by P_kin=density*k*T.\nThis compute is part of the USER-MISC package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute pressure/uef",
    "html_filename": "compute_pressure_uef.html",
    "short_description": "This command is used to compute the pressure tensor in the reference frame of the applied flow field when fix nvt/uef or fix npt/uef is used",
    "description": "This command is used to compute the pressure tensor in\nthe reference frame of the applied flow field when\nfix nvt/uef or\nfix npt/uef is used.\nIt is not necessary to use this command to compute the scalar\nvalue of the pressure. A compute pressure\nmay be used for that purpose.\nThe keywords and output information are documented in\ncompute_pressure.",
    "syntax": "compute ID group-ID pressure/uef temp-ID keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * pressure/uef = style name of this compute command\n * temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n * zero or more keywords may be appended\n * keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial",
    "examples": "compute 1 all pressure/uef my_temp_uef\ncompute 2 all pressure/uef my_temp_uef virial",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\nwas built with that package. See the Build package doc page for more info.\nThis command can only be used when fix nvt/uef\nor fix npt/uef is active.\nThe kinetic contribution to the pressure tensor\nwill be accurate only when\nthe compute specified by temp-ID is a\ncompute temp/uef."
},
{
    "command": "compute property/atom",
    "html_filename": "compute_property_atom.html",
    "short_description": "Define a computation that simply stores atom attributes for each atom in the group",
    "description": "Define a computation that simply stores atom attributes for each atom\nin the group.  This is useful so that the values can be used by other\noutput commands that take computes as inputs.  See\nfor example, the compute reduce, fix ave/atom, fix ave/histo, fix ave/chunk, and atom-style variable\ncommands.\nThe list of possible attributes is the same as that used by the dump custom command, which describes their meaning, with some\nadditional quantities that are only defined for certain atom styles.  Basically, this augmented list gives an\ninput script access to any per-atom quantity stored by LAMMPS.\nThe values are stored in a per-atom vector or array as discussed\nbelow.  Zeroes are stored for atoms not in the specified group or for\nquantities that are not defined for a particular particle in the group\n(e.g. shapex if the particle is not an ellipsoid).\nThe additional quantities only accessible via this command, and not\ndirectly via the dump custom command, are as follows.\nShapex, shapey, and shapez are defined for ellipsoidal particles\nand define the 3d shape of each particle.\nQuatw, quati, quatj, and quatk are defined for ellipsoidal\nparticles and body particles and store the 4-vector quaternion\nrepresenting the orientation of each particle.  See the set\ncommand for an explanation of the quaternion vector.\nEnd1x, end1y, end1z, end2x, end2y, end2z, are defined for\nline segment particles and define the end points of each line segment.\nCorner1x, corner1y, corner1z, corner2x, corner2y,\ncorner2z, corner3x, corner3y, corner3z, are defined for\ntriangular particles and define the corner points of each triangle.\nNbonds is available for all molecular atom styles and refers to the\nnumber of explicit bonds assigned to an atom.  Note that if the\nnewton bond command is set to on, which is the\ndefault, then every bond in the system is assigned to only one of the\ntwo atoms in the bond.  Thus a bond between atoms I,J may be tallied\nfor either atom I or atom J.  If newton bond off is set,\nit will be tallied with both atom I and atom J.\nThe i_name and d_name attributes refer to custom integer and\nfloating-point properties that have been added to each atom via the\nfix property/atom command.  When that command\nis used specific names are given to each attribute which are what is\nspecified as the “name” portion of i_name or d_name.\nOutput info:\nThis compute calculates a per-atom vector or per-atom array depending\non the number of input values.  If a single input is specified, a\nper-atom vector is produced.  If two or more inputs are specified, a\nper-atom array is produced where the number of columns = the number of\ninputs.  The vector or array can be accessed by any command that uses\nper-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector or array values will be in whatever units the\ncorresponding attribute is in, e.g. velocity units for vx, charge\nunits for q, etc.\nFor the spin quantities, sp is in the units of the Bohr magneton, spx,\nspy, and spz are unitless quantities, and fmx, fmy and fmz are given\nin rad/THz.",
    "syntax": "compute ID group-ID property/atom input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * property/atom = style name of this compute command\n * input = one or more atom attributes\n * possible attributes = id, mol, proc, type, mass,\n *                       x, y, z, xs, ys, zs, xu, yu, zu, ix, iy, iz,\n *                       vx, vy, vz, fx, fy, fz,\n *                       q, mux, muy, muz, mu,\n *                       sp, spx, spy, spz, fmx, fmy, fmz,\n *                       radius, diameter, omegax, omegay, omegaz,\n *                       angmomx, angmomy, angmomz,\n *                       shapex,shapey, shapez,\n *                       quatw, quati, quatj, quatk, tqx, tqy, tqz,\n *                       end1x, end1y, end1z, end2x, end2y, end2z,\n *                       corner1x, corner1y, corner1z,\n *                       corner2x, corner2y, corner2z,\n *                       corner3x, corner3y, corner3z,\n *                       nbonds,\n *                       vfrac, s0,\n *                       spin, eradius, ervel, erforce,\n *                       rho, drho, e, de, cv,\n *                       i_name, d_name\n * id = atom ID\n * mol = molecule ID\n * proc = ID of processor that owns atom\n * type = atom type\n * mass = atom mass\n * x,y,z = unscaled atom coordinates\n * xs,ys,zs = scaled atom coordinates\n * xu,yu,zu = unwrapped atom coordinates\n * ix,iy,iz = box image that the atom is in\n * vx,vy,vz = atom velocities\n * fx,fy,fz = forces on atoms\n * q = atom charge\n * mux,muy,muz = orientation of dipole moment of atom\n * mu = magnitude of dipole moment of atom\n * sp = atomic magnetic spin moment\n * spx, spy, spz = direction of the atomic magnetic spin\n * fmx, fmy, fmz = magnetic force\n * radius,diameter = radius,diameter of spherical particle\n * omegax,omegay,omegaz = angular velocity of spherical particle\n * angmomx,angmomy,angmomz = angular momentum of aspherical particle\n * shapex,shapey,shapez = 3 diameters of aspherical particle\n * quatw,quati,quatj,quatk = quaternion components for aspherical or body particles\n * tqx,tqy,tqz = torque on finite-size particles\n * end12x, end12y, end12z = end points of line segment\n * corner123x, corner123y, corner123z = corner points of triangle\n * nbonds = number of bonds assigned to an atom\n * PERI package per-atom properties:\n * vfrac = ???\n * s0 = ???\n * USER-EFF and USER-AWPMD package per-atom properties:\n * spin = electron spin\n * eradius = electron radius\n * ervel = electron radial velocity\n * erforce = electron radial force\n * USER-SPH package per-atom properties:\n * rho = ???\n * drho = ???\n * e = ???\n * de = ???\n * cv = ???\n * fix property/atom per-atom properties:\n * i_name = custom integer vector with name\n * d_name = custom integer vector with name",
    "examples": "compute 1 all property/atom xs vx fx mux\ncompute 2 all property/atom type\ncompute 1 all property/atom ix iy iz\ncompute 3 all property/atom sp spx spy spz",
    "restrictions": "\nnone"
},
{
    "command": "compute property/chunk",
    "html_filename": "compute_property_chunk.html",
    "short_description": "Define a computation that stores the specified attributes of chunks of atoms",
    "description": "Define a computation that stores the specified attributes of chunks of\natoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates and stores the specified attributes of chunks\nas global data so they can be accessed by other output commands and used in conjunction with other\ncommands that generate per-chunk data, such as compute com/chunk or compute msd/chunk.\nNote that only atoms in the specified group contribute to the\ncalculation of the count attribute.  The compute chunk/atom command defines its own group;\natoms will have a chunk ID = 0 if they are not in that group,\nsignifying they are not assigned to a chunk, and will thus also not\ncontribute to this calculation.  You can specify the “all” group for\nthis command if you simply want to include atoms with non-zero chunk\nIDs.\nThe count attribute is the number of atoms in the chunk.\nThe id attribute stores the original chunk ID for each chunk.  It\ncan only be used if the compress keyword was set to yes for the\ncompute chunk/atom command referenced by\nchunkID.  This means that the original chunk IDs (e.g. molecule IDs)\nwill have been compressed to remove chunk IDs with no atoms assigned\nto them.  Thus a compressed chunk ID of 3 may correspond to an original\nchunk ID (molecule ID in this case) of 415.  The id attribute will\nthen be 415 for the 3rd chunk.\nThe coordN attributes can only be used if a binning style was used\nin the compute chunk/atom command referenced\nby chunkID.  For bin/1d, bin/2d, and bin/3d styles the attribute\nis the center point of the bin in the corresponding dimension.  Style\nbin/1d only defines a coord1 attribute.  Style bin/2d adds a\ncoord2 attribute.  Style bin/3d adds a coord3 attribute.\nNote that if the value of the units keyword used in the compute chunk/atom command is box or lattice, the\ncoordN attributes will be in distance units.  If the\nvalue of the units keyword is reduced, the coordN attributes\nwill be in unitless reduced units (0-1).\nThe simplest way to output the results of the compute property/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk1 all property/chunk cc1 count\ncompute myChunk2 all com/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk1 c_myChunk2[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global vector or global array depending on\nthe number of input values.  The length of the vector or number of\nrows in the array is the number of chunks.\nThis compute calculates a global vector or global array where the\nnumber of rows = the number of chunks Nchunk as calculated by the\nspecified compute chunk/atom command.  If a\nsingle input is specified, a global vector is produced.  If two or\nmore inputs are specified, a global array is produced where the number\nof columns = the number of inputs.  The vector or array can be\naccessed by any command that uses global values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe vector or array values are “intensive”.  The values will be\nunitless or in the units discussed above.",
    "syntax": "compute ID group-ID property/chunk chunkID input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * property/chunk = style name of this compute command\n * input = one or more attributes\n * attributes = count, id, coord1, coord2, coord3\n *   count = # of atoms in chunk\n *   id = original chunk IDs before compression by compute chunk/atom\n *   coord123 = coordinates for spatial bins calculated by compute chunk/atom",
    "examples": "compute 1 all property/chunk count\ncompute 1 all property/chunk ID coord1",
    "restrictions": "\nnone"
},
{
    "command": "compute property/local",
    "html_filename": "compute_property_local.html",
    "short_description": "Define a computation that stores the specified attributes as local data so it can be accessed by other output commands",
    "description": "Define a computation that stores the specified attributes as local\ndata so it can be accessed by other output commands.  If the input attributes refer to bond\ninformation, then the number of datums generated, aggregated across\nall processors, equals the number of bonds in the system.  Ditto for\npairs, angles, etc.\nIf multiple attributes are specified then they must all generate the\nsame amount of information, so that the resulting local array has the\nsame number of rows for each column.  This means that only bond\nattributes can be specified together, or angle attributes, etc.  Bond\nand angle attributes can not be mixed in the same compute\nproperty/local command.\nIf the inputs are pair attributes, the local data is generated by\nlooping over the pairwise neighbor list.  Info about an individual\npairwise interaction will only be included if both atoms in the pair\nare in the specified compute group.  For natom1 and natom2, all\natom pairs in the neighbor list are considered (out to the neighbor\ncutoff = force cutoff + neighbor skin).  For patom1\nand patom2, the distance between the atoms must be less than the\nforce cutoff distance for that pair to be included, as defined by the\npair_style and pair_coeff\ncommands.\nThe optional cutoff keyword determines how the force cutoff distance\nfor an interaction is determined for the patom1 and patom2\nattributes.  For the default setting of type, the pairwise cutoff\ndefined by the pair_style command for the types of\nthe two atoms is used.  For the radius setting, the sum of the radii\nof the two particles is used as a cutoff.  For example, this is\nappropriate for granular particles which only interact when they are\noverlapping, as computed by granular pair styles.\nNote that if a granular model defines atom types such that all\nparticles of a specific type are monodisperse (same diameter), then\nthe two settings are effectively identical.\nIf the inputs are bond, angle, etc attributes, the local data is\ngenerated by looping over all the atoms owned on a processor and\nextracting bond, angle, etc info.  For bonds, info about an individual\nbond will only be included if both atoms in the bond are in the\nspecified compute group.  Likewise for angles, dihedrals, etc.\nFor bonds and angles, a bonds/angles that have been broken by setting\ntheir bond/angle type to 0 will not be included.  Bonds/angles that\nhave been turned off (see the fix shake or\ndelete_bonds commands) by setting their bond/angle\ntype negative are written into the file.  This is consistent with the\ncompute bond/local and compute angle/local commands\nNote that as atoms migrate from processor to processor, there will be\nno consistent ordering of the entries within the local vector or array\nfrom one timestep to the next.  The only consistency that is\nguaranteed is that the ordering on a particular timestep will be the\nsame for local vectors or arrays generated by other compute commands.\nFor example, output from the compute bond/local command can be combined with bond\natom indices from this command and output by the dump local command in a consistent way.\nThe natom1 and natom2, or patom1 and patom2 attributes refer\nto the atom IDs of the 2 atoms in each pairwise interaction computed\nby the pair_style command.  The ntype1 and\nntype2, or ptype1 and ptype2 attributes refer to the atom types\nof the 2 atoms in each pairwise interaction.\n\nNote\nFor pairs, if two atoms I,J are involved in 1-2, 1-3, 1-4\ninteractions within the molecular topology, their pairwise interaction\nmay be turned off, and thus they may not appear in the neighbor list,\nand will not be part of the local data created by this command.  More\nspecifically, this may be true of I,J pairs with a weighting factor of\n0.0; pairs with a non-zero weighting factor are included.  The\nweighting factors for 1-2, 1-3, and 1-4 pairwise interactions are set\nby the special_bonds command.\n\nThe batom1 and batom2 attributes refer to the atom IDs of the 2\natoms in each bond.  The btype attribute refers to\nthe type of the bond, from 1 to Nbtypes = # of bond types.  The number\nof bond types is defined in the data file read by the\nread_data command.\nThe attributes that start with “a”, “d”, “i”, refer to similar values\nfor angles, dihedrals, and\nimpropers.\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of input values.  The length of the vector or number of rows in\nthe array is the number of bonds, angles, etc.  If a single input is\nspecified, a local vector is produced.  If two or more inputs are\nspecified, a local array is produced where the number of columns = the\nnumber of inputs.  The vector or array can be accessed by any command\nthat uses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector or array values will be integers that correspond to the\nspecified attribute.",
    "syntax": "compute ID group-ID property/local attribute1 attribute2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * property/local = style name of this compute command\n * one or more attributes may be appended\n * possible attributes = natom1 natom2 ntype1 ntype2\n *                       patom1 patom2 ptype1 ptype2\n *                       batom1 batom2 btype\n *                       aatom1 aatom2 aatom3 atype\n *                       datom1 datom2 datom3 datom4 dtype\n *                       iatom1 iatom2 iatom3 iatom4 itype\n * natom1, natom2 = IDs of 2 atoms in each pair (within neighbor cutoff)\n * ntype1, ntype2 = type of 2 atoms in each pair (within neighbor cutoff)\n * patom1, patom2 = IDs of 2 atoms in each pair (within force cutoff)\n * ptype1, ptype2 = type of 2 atoms in each pair (within force cutoff)\n * batom1, batom2 = IDs of 2 atoms in each bond\n * btype = bond type of each bond\n * aatom1, aatom2, aatom3 = IDs of 3 atoms in each angle\n * atype = angle type of each angle\n * datom1, datom2, datom3, datom4 = IDs of 4 atoms in each dihedral\n * dtype = dihedral type of each dihedral\n * iatom1, iatom2, iatom3, iatom4 = IDs of 4 atoms in each improper\n * itype = improper type of each improper\n * zero or more keyword/arg pairs may be appended\n * keyword = cutoff\n * cutoff arg = type or radius",
    "examples": "compute 1 all property/local btype batom1 batom2\ncompute 1 all property/local atype aatom2",
    "restrictions": "\nnone"
},
{
    "command": "compute ptm/atom",
    "html_filename": "compute_ptm_atom.html",
    "short_description": "Define a computation that determines the local lattice structure around an atom using the PTM (Polyhedral Template Matching) method",
    "description": "Define a computation that determines the local lattice structure\naround an atom using the PTM (Polyhedral Template Matching) method.\nThe PTM method is described in (Larsen).\nCurrently, there are seven lattice structures PTM recognizes:\n\nfcc = 1\nhcp = 2\nbcc = 3\nico (icosahedral) = 4\nsc (simple cubic) = 5\ndcub (diamond cubic) = 6\ndhex (diamond hexagonal) = 7\ngraphene = 8\n\nThe value of the PTM structure will be 0 for unknown types and -1 for atoms not in the specified\ncompute group.  The choice of structures to search for can be specified using the “structures”\nargument, which is a hyphen-separated list of structure keywords.\nTwo convenient pre-set options are provided:\n\ndefault: fcc-hcp-bcc-ico\nall: fcc-hcp-bcc-ico-sc-dcub-dhex-graphene\n\nThe ‘default’ setting detects the same structures as the Common Neighbor Analysis method.\nThe ‘all’ setting searches for all structure types.  A performance penalty is\nincurred for the diamond and graphene structures, so it is not recommended to use this option if\nit is known that the simulation does not contain these structures.\nPTM identifies structures using two steps.  First, a graph isomorphism test is used\nto identify potential structure matches.  Next, the deviation is computed between the\nlocal structure (in the simulation) and a template of the ideal lattice structure.\nThe deviation is calculated as:\n\n\\[\\text{RMSD}(\\mathbf{u}, \\mathbf{v}) = \\min_{s, \\mathbf{Q}} \\sqrt{\\frac{1}{N} \\sum\\limits_{i=1}^{N}\n{\\left|\\left| s[\\vec{u_i} - \\overline{\\mathbf{u}}] - \\mathbf{Q} \\vec{v_i} \\right|\\right|}^2}\\]\nHere, u and v contain the coordinates of the local and ideal structures respectively,\ns is a scale factor, and Q is a rotation.  The best match is identified by the\nlowest RMSD value, using the optimal scaling, rotation, and correspondence between the\npoints.\nThe ‘threshold’ keyword sets an upper limit on the maximum permitted deviation before\na local structure is identified as disordered.  Typical values are in the range 0.1-0.15,\nbut larger values may be desirable at higher temperatures.\nA value of 0 is equivalent to infinity and can be used if no threshold is desired.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (e.g. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently or to have multiple compute/dump commands, each with a\nptm/atom style. By default the compute processes all neighbors\nunless the optional group2-ID argument is given, then only members\nof that group are considered as neighbors.\nOutput info:\nThis compute calculates a per-atom array, which can be accessed by\nany command that uses per-atom values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nResults are stored in the per-atom array in the following order:\n\ntype\nrmsd\ninteratomic distance\nqw\nqx\nqy\nqz\n\nThe type is a number from -1 to 8.  The rmsd is a positive real number.\nThe interatomic distance is computed from the scale factor in the RMSD equation.\nThe (qw,qx,qy,qz) parameters represent the orientation of the local structure\nin quaternion form.  The reference coordinates for each template (from which the\norientation is determined) can be found in the ptm_constants.h file in the PTM source directory.\nFor atoms that are not within the compute group-ID, all values are set to zero.",
    "syntax": "compute ID group-ID ptm/atom structures threshold group2-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * ptm/atom = style name of this compute command\n * structures = structure types to search for\n * threshold = lattice distortion threshold (RMSD)\n * group2-ID determines which group is used for neighbor selection (optional, default “all”)",
    "examples": "compute 1 all ptm/atom default 0.1 all\ncompute 1 all ptm/atom fcc-hcp-dcub-dhex 0.15 all\ncompute 1 all ptm/atom all 0",
    "restrictions": "This fix is part of the USER-PTM package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute rdf",
    "html_filename": "compute_rdf.html",
    "short_description": "Define a computation that calculates the radial distribution function (RDF), also called g(r), and the coordination number for a group of particles",
    "description": "Define a computation that calculates the radial distribution function\n(RDF), also called g(r), and the coordination number for a group of\nparticles.  Both are calculated in histogram form by binning pairwise\ndistances into Nbin bins from 0.0 to the maximum force cutoff\ndefined by the pair_style command or the cutoff\ndistance Rcut specified via the cutoff keyword.  The bins are of\nuniform size in radial distance.  Thus a single bin encompasses a thin\nshell of distances in 3d and a thin ring of distances in 2d.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses a neighbor list, it also means\nthose pairs will not be included in the RDF. This does not apply when\nusing long-range coulomb interactions (coul/long, coul/msm,\ncoul/wolf or similar.  One way to get around this would be to set\nspecial_bond scaling factors to very tiny numbers that are not exactly\nzero (e.g. 1.0e-50). Another workaround is to write a dump file, and\nuse the rerun command to compute the RDF for snapshots in\nthe dump file.  The rerun script can use a\nspecial_bonds command that includes all pairs in\nthe neighbor list.\n\nBy default the RDF is computed out to the maximum force cutoff defined\nby the pair_style command.  If the cutoff keyword\nis used, then the RDF is computed accurately out to the Rcut > 0.0\ndistance specified.\n\nNote\nNormally, you should only use the cutoff keyword if no pair\nstyle is defined, e.g. the rerun command is being used to\npost-process a dump file of snapshots.  Or if you really want the RDF\nfor distances beyond the pair_style force cutoff and cannot easily\npost-process a dump file to calculate it.  This is because using the\ncutoff keyword incurs extra computation and possibly communication,\nwhich may slow down your simulation.  If you specify a Rcut <= force\ncutoff, you will force an additional neighbor list to be built at\nevery timestep this command is invoked (or every reneighboring\ntimestep, whichever is less frequent), which is inefficient.  LAMMPS\nwill warn you if this is the case.  If you specify a Rcut > force\ncutoff, you must insure ghost atom information out to Rcut + skin\nis communicated, via the comm_modify cutoff\ncommand, else the RDF computation cannot be performed, and LAMMPS will\ngive an error message.  The skin value is what is specified with the\nneighbor command.  In this case, you are forcing a\nlarge neighbor list to be built just for the RDF computation, and\nextra communication to be performed every timestep.\n\nThe itypeN and jtypeN arguments are optional.  These arguments\nmust come in pairs.  If no pairs are listed, then a single histogram\nis computed for g(r) between all atom types.  If one or more pairs are\nlisted, then a separate histogram is generated for each\nitype,jtype pair.\nThe itypeN and jtypeN settings can be specified in one of two\nways.  An explicit numeric value can be used, as in the 4th example\nabove.  Or a wild-card asterisk can be used to specify a range of atom\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nIf both itypeN and jtypeN are single values, as in the 4th example\nabove, this means that a g(r) is computed where atoms of type itypeN\nare the central atom, and atoms of type jtypeN are the distribution\natom.  If either itypeN and jtypeN represent a range of values via\nthe wild-card asterisk, as in the 5th example above, this means that a\ng(r) is computed where atoms of any of the range of types represented\nby itypeN are the central atom, and atoms of any of the range of\ntypes represented by jtypeN are the distribution atom.\nPairwise distances are generated by looping over a pairwise neighbor\nlist, just as they would be in a pair_style\ncomputation.  The distance between two atoms I and J is included in a\nspecific histogram if the following criteria are met:\n\natoms I,J are both in the specified compute group\nthe distance between atoms I,J is less than the maximum force cutoff\nthe type of the I atom matches itypeN (one or a range of types)\nthe type of the J atom matches jtypeN (one or a range of types)\n\nIt is OK if a particular pairwise distance is included in more than\none individual histogram, due to the way the itypeN and jtypeN\narguments are specified.\nThe g(r) value for a bin is calculated from the histogram count by\nscaling it by the idealized number of how many counts there would be\nif atoms of type jtypeN were uniformly distributed.  Thus it\ninvolves the count of itypeN atoms, the count of jtypeN atoms, the\nvolume of the entire simulation box, and the volume of the bin’s thin\nshell in 3d (or the area of the bin’s thin ring in 2d).\nA coordination number coord(r) is also calculated, which is the number\nof atoms of type jtypeN within the current bin or closer, averaged\nover atoms of type itypeN.  This is calculated as the area- or\nvolume-weighted sum of g(r) values over all bins up to and including\nthe current bin, multiplied by the global average volume density of\natoms of type jtypeN.\nThe simplest way to output the results of the compute rdf calculation\nto a file is to use the fix ave/time command, for\nexample:\ncompute myRDF all rdf 50\nfix 1 all ave/time 100 1 100 c_myRDF[*] file tmp.rdf mode vector\nOutput info:\nThis compute calculates a global array with the number of rows =\nNbins, and the number of columns = 1 + 2*Npairs, where Npairs is the\nnumber of I,J pairings specified.  The first column has the bin\ncoordinate (center of the bin), Each successive set of 2 columns has\nthe g(r) and coord(r) values for a specific set of itypeN versus\njtypeN interactions, as described above.  These values can be used\nby any command that uses a global values from a compute as input.  See\nthe Howto output doc page for an overview of\nLAMMPS output options.\nThe array values calculated by this compute are all “intensive”.\nThe first column of array values will be in distance\nunits.  The g(r) columns of array values are normalized\nnumbers >= 0.0.  The coordination number columns of array values are\nalso numbers >= 0.0.",
    "syntax": "compute ID group-ID rdf Nbin itype1 jtype1 itype2 jtype2 ... keyword/value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * rdf = style name of this compute command\n * Nbin = number of RDF bins\n * itypeN = central atom type for Nth RDF histogram (see asterisk form below)\n * jtypeN = distribution atom type for Nth RDF histogram (see asterisk form below)\n * zero or more keyword/value pairs may be appended\n * keyword = cutoff\n * cutoff value = Rcut\n *   Rcut = cutoff distance for RDF computation (distance units)",
    "examples": "compute 1 all rdf 100\ncompute 1 all rdf 100 1 1\ncompute 1 all rdf 100 * 3 cutoff 5.0\ncompute 1 fluid rdf 500 1 1 1 2 2 1 2 2\ncompute 1 fluid rdf 500 1*3 2 5 *10 cutoff 3.5",
    "restrictions": "The RDF is not computed for distances longer than the force cutoff,\nsince processors (in parallel) don’t know about atom coordinates for\natoms further away than that distance.  If you want an RDF for larger\ndistances, you can use the rerun command to post-process\na dump file and set the cutoff for the potential to be longer in the\nrerun script.  Note that in the rerun context, the force cutoff is\narbitrary, since you aren’t running dynamics and thus are not changing\nyour model.  The definition of g(r) used by LAMMPS is only appropriate\nfor characterizing atoms that are uniformly distributed throughout the\nsimulation cell. In such cases, the coordination number is still\ncorrect and meaningful.  As an example, if a large simulation cell\ncontains only one atom of type itypeN and one of jtypeN, then g(r)\nwill register an arbitrarily large spike at whatever distance they\nhappen to be at, and zero everywhere else.  Coord(r) will show a step\nchange from zero to one at the location of the spike in g(r).\n\nNote\ncompute rdf can handle dynamic groups and systems where atoms\nare added or removed, but this causes that certain normalization\nparameters need to be re-computed in every step and include collective\ncommunication operations. This will reduce performance and limit\nparallel efficiency and scaling. For systems, where only the type\nof atoms changes (e.g. when using fix atom/swap),\nyou need to explicitly request the dynamic normalization updates\nvia compute_modify dynamic yes"
},
{
    "command": "compute reduce",
    "html_filename": "compute_reduce.html",
    "short_description": "Define a calculation that “reduces” one or more vector inputs into scalar values, one per listed input",
    "description": "Define a calculation that “reduces” one or more vector inputs into\nscalar values, one per listed input.  The inputs can be per-atom or\nlocal quantities; they cannot be global quantities.  Atom attributes\nare per-atom quantities, computes and fixes\nmay generate any of the three kinds of quantities, and atom-style variables generate per-atom quantities.  See the\nvariable command and its special functions which can\nperform the same operations as the compute reduce command on global\nvectors.\nThe reduction operation is specified by the mode setting.  The sum\noption adds the values in the vector into a global total.  The min\nor max options find the minimum or maximum value across all vector\nvalues.  The ave setting adds the vector values into a global total,\nthen divides by the number of values in the vector.  The sumsq\noption sums the square of the values in the vector into a global\ntotal.  The avesq setting does the same as sumsq, then divides the\nsum of squares by the number of values.  The last two options can be\nuseful for calculating the variance of some quantity, e.g. variance =\nsumsq - ave^2.\nEach listed input is operated on independently.  For per-atom inputs,\nthe group specified with this command means only atoms within the\ngroup contribute to the result.  For per-atom inputs, if the compute\nreduce/region command is used, the atoms must also currently be within\nthe region.  Note that an input that produces per-atom quantities may\ndefine its own group which affects the quantities it returns.  For\nexample, if a compute is used as an input which generates a per-atom\nvector, it will generate values of 0.0 for atoms that are not in the\ngroup specified for that compute.\nEach listed input can be an atom attribute (position, velocity, force\ncomponent) or can be the result of a compute or\nfix or the evaluation of an atom-style\nvariable.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 compute reduce commands are\nequivalent, since the compute stress/atom\ncommand creates a per-atom array with 6 columns:\ncompute myPress all stress/atom NULL\ncompute 2 all reduce min c_myPress[*]\ncompute 2 all reduce min c_myPress[1] c_myPress[2] c_myPress[3] &\n                         c_myPress[4] c_myPress[5] c_myPress[6]\n\nThe atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\nself-explanatory.  Note that other atom attributes can be used as\ninputs to this fix by using the compute property/atom command and then specifying\nan input value from that compute.\nIf a value begins with “c_”, a compute ID must follow which has been\npreviously defined in the input script.  Computes can generate\nper-atom or local quantities.  See the individual\ncompute doc page for details.  If no bracketed integer\nis appended, the vector calculated by the compute is used.  If a\nbracketed integer is appended, the Ith column of the array calculated\nby the compute is used.  Users can also write code for their own\ncompute styles and add them to LAMMPS.  See the\ndiscussion above for how I can be specified with a wildcard asterisk\nto effectively specify multiple values.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script.  Fixes can generate per-atom\nor local quantities.  See the individual fix doc page for\ndetails.  Note that some fixes only produce their values on certain\ntimesteps, which must be compatible with when compute reduce\nreferences the values, else an error results.  If no bracketed integer\nis appended, the vector calculated by the fix is used.  If a bracketed\ninteger is appended, the Ith column of the array calculated by the fix\nis used.  Users can also write code for their own fix style and add them to LAMMPS.  See the discussion above for how I can\nbe specified with a wildcard asterisk to effectively specify multiple\nvalues.\nIf a value begins with “v_”, a variable name must follow which has\nbeen previously defined in the input script.  It must be an\natom-style variable.  Atom-style variables can\nreference thermodynamic keywords and various per-atom attributes, or\ninvoke other computes, fixes, or variables when they are evaluated, so\nthis is a very general means of generating per-atom quantities to\nreduce.\n\nIf the replace keyword is used, two indices vec1 and vec2 are\nspecified, where each index ranges from 1 to the # of input values.\nThe replace keyword can only be used if the mode is min or max.\nIt works as follows.  A min/max is computed as usual on the vec2\ninput vector.  The index N of that value within vec2 is also stored.\nThen, instead of performing a min/max on the vec1 input vector, the\nstored index is used to select the Nth element of the vec1 vector.\nThus, for example, if you wish to use this compute to find the bond\nwith maximum stretch, you can do it as follows:\ncompute 1 all property/local batom1 batom2\ncompute 2 all bond/local dist\ncompute 3 all reduce max c_1[1] c_1[2] c_2 replace 1 3 replace 2 3\nthermo_style custom step temp c_3[1] c_3[2] c_3[3]\n\n\nThe first two input values in the compute reduce command are vectors\nwith the IDs of the 2 atoms in each bond, using the compute property/local command.  The last input\nvalue is bond distance, using the compute bond/local command.  Instead of taking the\nmax of the two atom ID vectors, which does not yield useful\ninformation in this context, the replace keywords will extract the\natom IDs for the two atoms in the bond of maximum stretch.  These atom\nIDs and the bond stretch will be printed with thermodynamic output.\n\nIf a single input is specified this compute produces a global scalar\nvalue.  If multiple inputs are specified, this compute produces a\nglobal vector of values, the length of which is equal to the number of\ninputs specified.\nAs discussed below, for the sum and sumsq modes, the value(s)\nproduced by this compute are all “extensive”, meaning their value\nscales linearly with the number of atoms involved.  If normalized\nvalues are desired, this compute can be accessed by the thermo_style custom command with thermo_modify norm yes set as an option.  Or it can be accessed by a\nvariable that divides by the appropriate atom count.\n\nOutput info:\nThis compute calculates a global scalar if a single input value is\nspecified or a global vector of length N where N is the number of\ninputs, and which can be accessed by indices 1 to N.  These values can\nbe used by any command that uses global scalar or vector values from a\ncompute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nAll the scalar or vector values calculated by this compute are\n“intensive”, except when the sum or sumsq modes are used on\nper-atom or local vectors, in which case the calculated values are\n“extensive”.\nThe scalar or vector values will be in whatever units the\nquantities being reduced are in.",
    "syntax": "compute ID group-ID style arg mode input1 input2 ... keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * style = reduce or reduce/region\n * reduce arg = none\n * reduce/region arg = region-ID\n *   region-ID = ID of region to use for choosing atoms\n * mode = sum or min or max or ave or sumsq or avesq\n * one or more inputs can be listed\n * input = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n * c_ID = per-atom or local vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom or local array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = per-atom or local vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom or local array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = per-atom vector calculated by an atom-style variable with name\n * zero or more keyword/args pairs may be appended\n * keyword = replace\n * replace args = vec1 vec2\n *   vec1 = reduced value from this input vector will be replaced\n *   vec2 = replace it with vec1[N] where N is index of max/min value from vec2",
    "examples": "compute 1 all reduce sum c_force\ncompute 1 all reduce/region subbox sum c_force\ncompute 2 all reduce min c_press[2] f_ave v_myKE\ncompute 2 all reduce min c_press[*] f_ave v_myKE\ncompute 3 fluid reduce max c_index[1] c_index[2] c_dist replace 1 3 replace 2 3",
    "restrictions": "\nnone"
},
{
    "command": "compute reduce/chunk",
    "html_filename": "compute_reduce_chunk.html",
    "short_description": "Define a calculation that reduces one or more per-atom vectors into per-chunk values",
    "description": "Define a calculation that reduces one or more per-atom vectors into\nper-chunk values.  This can be useful for diagnostic output.  Or when\nused in conjunction with the compute chunk/spread/atom command it can be\nused ot create per-atom values that induce a new set of chunks with a\nsecond compute chunk/atom command.  An\nexample is given below.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nFor each atom, this compute accesses its chunk ID from the specified\nchunkID compute.  The per-atom value from an input contributes\nto a per-chunk value corresponding the the chunk ID.\nThe reduction operation is specified by the mode setting and is\nperformed over all the per-atom values from the atoms in each chunk.\nThe sum option adds the pre-atom values to a per-chunk total.  The\nmin or max options find the minimum or maximum value of the\nper-atom values for each chunk.\nNote that only atoms in the specified group contribute to the\nreduction operation.  If the chunkID compute returns a 0 for the\nchunk ID of an atom (i.e. the atom is not in a chunk defined by the\ncompute chunk/atom command), that atom will\nalso not contribute to the reduction operation.  An input that is a\ncompute or fix may define its own group which affects the quantities\nit returns.  For example, a compute with return a zero value for atoms\nthat are not in the group specified for that compute.\nEach listed input is operated on independently.  Each input can be the\nresult of a compute or fix or the evaluation\nof an atom-style variable.\nNote that for values from a compute or fix, the bracketed index I can\nbe specified using a wildcard asterisk with the index to effectively\nspecify multiple values.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the size of the vector (for mode = scalar) or the\nnumber of columns in the array (for mode = vector), then an asterisk\nwith no numeric values means all indices from 1 to N.  A leading\nasterisk means all indices from 1 to n (inclusive).  A trailing\nasterisk means all indices from n to N (inclusive).  A middle asterisk\nmeans all indices from m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 compute reduce/chunk\ncommands are equivalent, since the compute property/chunk command creates a per-atom\narray with 3 columns:\ncompute prop all property/atom vx vy vz\ncompute 10 all reduce/chunk mychunk max c_prop[*]\ncompute 10 all reduce/chunk mychunk max c_prop[1] c_prop[2] c_prop[3]\n\nHere is an example of using this compute, in conjunction with the\ncompute chunk/spread/atom command to identify self-assembled micelles.\nThe commands below can be added to the examples/in.micelle script.\nImagine a collection of polymer chains or small molecules with\nhydrophobic end groups.  All the hydrophobic (HP) atoms are assigned\nto a group called “phobic”.\nThese commands will assign a unique cluster ID to all HP atoms within\na specified distance of each other.  A cluster will contain all HP\natoms in a single molecule, but also the HP atoms in nearby molecules,\ne.g. molecules that have clumped to form a micelle due to the\nattraction induced by the hydrophobicity.  The output of the\nchunk/reduce command will be a cluster ID per chunk (molecule).\nMolecules with the same cluster ID are in the same micelle.\ngroup phobic type 4     # specific to in.micelle model\ncompute cluster phobic cluster/atom 2.0\ncompute cmol all chunk/atom molecule\ncompute reduce phobic reduce/chunk cmol min c_cluster\n\n\nThis per-chunk info could be output in at least two ways:\nfix 10 all ave/time 1000 1 1000 c_reduce file tmp.phobic mode vector\n\ncompute spread all chunk/spread/atom cmol c_reduce\ndump 1 all custom 1000 tmp.dump id type mol x y z c_cluster c_spread\ndump_modify 1 sort id\n\n\nIn the first case, each snapshot in the tmp.phobic file will contain\none line per molecule.  Molecules with the same value are in the same\nmicelle.  In the second case each dump snapshot contains all atoms,\neach with a final field with the cluster ID of the micelle that the HP\natoms of that atom’s molecule belong to.\nThe result from compute chunk/spread/atom can be used to define a new\nset of chunks, where all the atoms in all the molecules in the same\nmicelle are assigned to the same chunk, i.e. one chunk per micelle.\ncompute micelle all chunk/atom c_spread compress yes\n\n\nFurther analysis on a per-micelle basis can now be performed using any\nof the per-chunk computes listed on the Howto chunk\ndoc page.  E.g. count the number of atoms in each micelle, calculate\nits center or mass, shape (moments of inertia), radius of gyration,\netc.\ncompute prop all property/chunk micelle count\nfix 20 all ave/time 1000 1 1000 c_prop file tmp.micelle mode vector\n\n\nEach snapshot in the tmp.micelle file will have one line per micelle\nwith its count of atoms, plus a first line for a chunk with all the\nsolvent atoms.  By the time 50000 steps have elapsed there are a\nhandful of large micelles.\n\nOutput info:\nThis compute calculates a global vector if a single input value is\nspecified, otherwise a global array is output.  The number of columns\nin the array is the number of inputs provided.  The length of the\nvector or the number of vector elements or array rows = the number of\nchunks Nchunk as calculated by the specified compute chunk/atom command.  The vector or array can\nbe accessed by any command that uses global values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options.\nThe per-atom values for the vector or each column of the array will be\nin whatever units the corresponding input value is in.\nThe vector or array values are “intensive”.",
    "syntax": "compute ID group-ID reduce/chunk chunkID mode input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * reduce/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command\n * mode = sum or min or max\n * one or more inputs can be listed\n * input = c_ID, c_ID[N], f_ID, f_ID[N], v_ID\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = per-atom vector calculated by an atom-style variable with name",
    "examples": "compute 1 all reduce/chunk/atom mychunk min c_cluster",
    "restrictions": "\nnone"
},
{
    "command": "compute rigid/local",
    "html_filename": "compute_rigid_local.html",
    "short_description": "Define a computation that simply stores rigid body attributes for rigid bodies defined by the fix rigid/small command or one of its NVE, NVT, NPT, NPH variants",
    "description": "Define a computation that simply stores rigid body attributes for\nrigid bodies defined by the fix rigid/small command\nor one of its NVE, NVT, NPT, NPH variants.  The data is stored as\nlocal data so it can be accessed by other output commands that process local data, such as the\ncompute reduce or dump local\ncommands.\nNote that this command only works with the fix rigid/small command or its variants, not the fix rigid\ncommand and its variants.  The ID of the fix rigid/small command used to define rigid bodies must\nbe specified as rigidID.  The fix rigid command is\ntypically used to define a handful of (potentially very large) rigid\nbodies.  It outputs similar per-body information as this command\ndirectly from the fix as global data; see the fix rigid doc page for details\nThe local data stored by this command is generated by looping over all\nthe atoms owned on a processor.  If the atom is not in the specified\ngroup-ID or is not part of a rigid body it is skipped.  If it is not\nthe atom within a body that is assigned to store the body information\nit is skipped (only one atom per body is so assigned).  If it is the\nassigned atom, then the info for that body is output.  This means that\ninformation for N bodies is generated.  N may be less than the # of\nbodies defined by the fix rigid command, if the atoms in some bodies\nare not in the group-ID.\n\nNote\nWhich atom in a body owns the body info is determined internal\nto LAMMPS; it’s the one nearest the geometric center of the body.\nTypically you should avoid this complication, by defining the group\nassociated with this fix to include/exclude entire bodies.\n\nNote that as atoms and bodies migrate from processor to processor,\nthere will be no consistent ordering of the entries within the local\nvector or array from one timestep to the next.\nHere is an example of how to use this compute to dump rigid body info\nto a file:\ncompute 1 all rigid/local myRigid mol x y z fx fy fz\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_1[6] c_1[7]\n\n\n\nThis section explains the rigid body attributes that can be specified.\nThe id attribute is the atom-ID of the atom which owns the rigid body, which is\nassigned by the fix rigid/small command.\nThe mol attribute is the molecule ID of the rigid body.  It should\nbe the molecule ID which all of the atoms in the body belong to, since\nthat is how the fix rigid/small command defines its\nrigid bodies.\nThe mass attribute is the total mass of the rigid body.\nThere are two options for outputting the coordinates of the center of\nmass (COM) of the body.  The x, y, z attributes write the COM\n“unscaled”, in the appropriate distance units (Angstroms,\nsigma, etc).  Use xu, yu, zu if you want the COM “unwrapped” by\nthe image flags for each body.  Unwrapped means that if the body\nCOM has passed through a periodic boundary one or more times, the value\nis generated what the COM coordinate would be if it had not been\nwrapped back into the periodic box.\nThe image flags for the body can be generated directly using the ix,\niy, iz attributes.  For periodic dimensions, they specify which\nimage of the simulation box the COM is considered to be in.  An image\nof 0 means it is inside the box as defined.  A value of 2 means add 2\nbox lengths to get the true value.  A value of -1 means subtract 1 box\nlength to get the true value.  LAMMPS updates these flags as the rigid\nbody COMs cross periodic boundaries during the simulation.\nThe vx, vy, vz, fx, fy, fz attributes are components of\nthe COM velocity and force on the COM of the body.\nThe omegax, omegay, and omegaz attributes are the angular\nvelocity components of the body around its COM.\nThe angmomx, angmomy, and angmomz attributes are the angular\nmomentum components of the body around its COM.\nThe quatw, quati, quatj, and quatk attributes are the\ncomponents of the 4-vector quaternion representing the orientation of\nthe rigid body.  See the set command for an explanation of\nthe quaternion vector.\nThe angmomx, angmomy, and angmomz attributes are the angular\nmomentum components of the body around its COM.\nThe tqx, tqy, tqz attributes are components of the torque acting\non the body around its COM.\nThe inertiax, inertiay, inertiaz attributes are components of\ndiagonalized inertia tensor for the body, i.e the 3 moments of inertia\nfor the body around its principal axes, as computed internally by\nLAMMPS.\n\nOutput info:\nThis compute calculates a local vector or local array depending on the\nnumber of keywords.  The length of the vector or number of rows in the\narray is the number of rigid bodies.  If a single keyword is\nspecified, a local vector is produced.  If two or more keywords are\nspecified, a local array is produced where the number of columns = the\nnumber of keywords.  The vector or array can be accessed by any\ncommand that uses local values from a compute as input.  See the\nHowto output doc page for an overview of LAMMPS\noutput options.\nThe vector or array values will be in whatever units the\ncorresponding attribute is in:\n\nid,mol = unitless\nmass = mass units\nx,y,z and xy,yu,zu = distance units\nvx,vy,vz = velocity units\nfx,fy,fz = force units\nomegax,omegay,omegaz = radians/time units\nangmomx,angmomy,angmomz = mass*distance^2/time units\nquatw,quati,quatj,quatk = unitless\ntqx,tqy,tqz = torque units\ninertiax,inertiay,inertiaz = mass*distance^2 units",
    "syntax": "compute ID group-ID rigid/local rigidID input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * rigid/local = style name of this compute command\n * rigidID = ID of fix rigid/small command or one of its variants\n * input = one or more rigid body attributes\n * possible attributes = id, mol, mass,\n *                       x, y, z, xu, yu, zu, ix, iy, iz\n *                       vx, vy, vz, fx, fy, fz,\n *                       omegax, omegay, omegaz,\n *                       angmomx, angmomy, angmomz,\n *                       quatw, quati, quatj, quatk,\n *                       tqx, tqy, tqz,\n *                       inertiax, inertiay, inertiaz\n *     id = atom ID of atom within body which owns body properties\n *     mol = molecule ID used to define body in fix rigid/small command\n *     mass = total mass of body\n *     x,y,z = center of mass coords of body\n *     xu,yu,zu = unwrapped center of mass coords of body\n *     ix,iy,iz = box image that the center of mass is in\n *     vx,vy,vz = center of mass velocities\n *     fx,fy,fz = force of center of mass\n *     omegax,omegay,omegaz = angular velocity of body\n *     angmomx,angmomy,angmomz = angular momentum of body\n *     quatw,quati,quatj,quatk = quaternion components for body\n *     tqx,tqy,tqz = torque on body\n *     inertiax,inertiay,inertiaz = diagonalized moments of inertia of body",
    "examples": "compute 1 all rigid/local myRigid mol x y z",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute saed",
    "html_filename": "compute_saed.html",
    "short_description": "Define a computation that calculates electron diffraction intensity as described in (Coleman) on a mesh of reciprocal lattice nodes defined by the entire simulation domain (or manually) using simulated radiation of wavelength lambda",
    "description": "Define a computation that calculates electron diffraction intensity as\ndescribed in (Coleman) on a mesh of reciprocal lattice nodes\ndefined by the entire simulation domain (or manually) using simulated\nradiation of wavelength lambda.\nThe electron diffraction intensity I at each reciprocal lattice point\nis computed from the structure factor F using the equations:\n\n\\[\\begin{split}I = & \\frac{F^{*}F}{N} \\\\\nF(\\mathbf{k}) = & \\sum_{j=1}^{N}f_j(\\theta)exp(2\\pi i \\mathbf{k} \\cdot \\mathbf{r}_j)\\end{split}\\]\nHere, K is the location of the reciprocal lattice node, \\(r_j\\) is the\nposition of each atom, \\(f_j\\) are atomic scattering factors.\nDiffraction intensities are calculated on a three-dimensional mesh of\nreciprocal lattice nodes. The mesh spacing is defined either (a)  by\nthe entire simulation domain or (b) manually using selected values as\nshown in the 2D diagram below.\n\nFor a mesh defined by the simulation domain, a rectilinear grid is\nconstructed with spacing c*inv(A) along each reciprocal lattice\naxis. Where A are the vectors corresponding to the edges of the\nsimulation cell. If one or two directions has non-periodic boundary\nconditions, then the spacing in these directions is defined from the\naverage of the (inversed) box lengths with periodic boundary conditions.\nMeshes defined by the simulation domain must contain at least one periodic\nboundary.\nIf the manual flag is included, the mesh of reciprocal lattice nodes\nwill defined using the c values for the spacing along each reciprocal\nlattice axis. Note that manual mapping of the reciprocal space mesh is\ngood for comparing diffraction results from  multiple simulations; however\nit can reduce the likelihood that Bragg reflections will be satisfied\nunless small spacing parameters <0.05 Angstrom^(-1) are implemented.\nMeshes with manual spacing do not require a periodic boundary.\nThe limits of the reciprocal lattice mesh are determined by the use of\nthe Kmax, Zone, and dR_Ewald parameters.  The rectilinear mesh\ncreated about the origin of reciprocal space is terminated at the\nboundary of a sphere of radius Kmax centered at the origin.  If\nZone parameters z1=z2=z3=0 are used, diffraction intensities are\ncomputed throughout the entire spherical volume - note this can\ngreatly increase the cost of computation.  Otherwise, Zone\nparameters will denote the z1=h, z2=k, and z3=l (in a global since)\nzone axis of an intersecting Ewald sphere.  Diffraction intensities\nwill only be computed at the intersection of the reciprocal lattice\nmesh and a dR_Ewald thick surface of the Ewald sphere.  See the\nexample 3D intensity data and the intersection of a [010] zone axis\nin the below image.\n\nThe atomic scattering factors, fj, accounts for the reduction in\ndiffraction intensity due to Compton scattering.  Compute saed uses\nanalytical approximations of the atomic scattering factors that vary\nfor each atom type (type1 type2 … typeN) and angle of diffraction.\nThe analytic approximation is computed using the formula\n(Brown):\n\n\\[f_j\\left ( \\frac{sin(\\theta)}{\\lambda} \\right )=\\sum_{i}^{5}\na_i exp\\left ( -b_i \\frac{sin^{2}(\\theta)}{\\lambda^{2}} \\right )\\]\nCoefficients parameterized by (Fox) are assigned for each\natom type designating the chemical symbol and charge of each atom\ntype. Valid chemical symbols for compute saed are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nH\nHe\nLi\nBe\nB\nC\nN\nO\nF\nNe\nNa\nMg\nAl\nSi\nP\nS\nCl\nAr\nK\nCa\n\nSc\nTi\nV\nCr\nMn\nFe\nCo\nNi\nCu\nZn\nGa\nGe\nAs\nSe\nBr\nKr\nRb\nSr\nY\nZr\n\nNb\nMo\nTc\nRu\nRh\nPd\nAg\nCd\nIn\nSn\nSb\nTe\nI\nXe\nCs\nBa\nLa\nCe\nPr\nNd\n\nPm\nSm\nEu\nGd\nTb\nDy\nHo\nEr\nTm\nYb\nLu\nHf\nTa\nW\nRe\nOs\nIr\nPt\nAu\nHg\n\nTl\nPb\nBi\nPo\nAt\nRn\nFr\nRa\nAc\nTh\nPa\nU\nNp\nPu\nAm\nCm\nBk\nCf\n\n\n\n\n\nIf the echo keyword is specified, compute saed will provide extra\nreporting information to the screen.\nOutput info:\nThis compute calculates a global vector.  The length of the vector is\nthe number of reciprocal lattice nodes that are explored by the mesh.\nThe entries of the global vector are the computed diffraction\nintensities as described above.\nThe vector can be accessed by any command that uses global values from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nAll array values calculated by this compute are “intensive”.",
    "syntax": "compute ID group-ID saed lambda type1 type2 ... typeN keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * saed = style name of this compute command\n * lambda = wavelength of incident radiation (length units)\n * type1 type2 … typeN = chemical symbol of each atom type (see valid options below)\n * zero or more keyword/value pairs may be appended\n * keyword = Kmax or Zone or dR_Ewald or c or manual or echo\n * Kmax value = Maximum distance explored from reciprocal space origin\n *                (inverse length units)\n * Zone values = z1 z2 z3\n *   z1,z2,z3 = Zone axis of incident radiation. If z1=z2=z3=0 all\n *              reciprocal space will be meshed up to Kmax\n * dR_Ewald value = Thickness of Ewald sphere slice intercepting\n *                    reciprocal space (inverse length units)\n * c values = c1 c2 c3\n *   c1,c2,c3 = parameters to adjust the spacing of the reciprocal\n *              lattice nodes in the h, k, and l directions respectively\n * manual = flag to use manual spacing of reciprocal lattice points\n *            based on the values of the c parameters\n * echo = flag to provide extra output for debugging purposes",
    "examples": "compute 1 all saed 0.0251 Al O Kmax 1.70 Zone 0 0 1 dR_Ewald 0.01 c 0.5 0.5 0.5\ncompute 2 all saed 0.0251 Ni Kmax 1.70 Zone 0 0 0 c 0.05 0.05 0.05 manual echo\n\nfix saed/vtk 1 1 1 c_1 file Al2O3_001.saed\nfix saed/vtk 1 1 1 c_2 file Ni_000.saed",
    "restrictions": "This compute is part of the USER-DIFFRACTION package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThe compute_saed command does not work for triclinic cells."
},
{
    "command": "compute slice",
    "html_filename": "compute_slice.html",
    "short_description": "Define a calculation that “slices” one or more vector inputs into smaller vectors, one per listed input",
    "description": "Define a calculation that “slices” one or more vector inputs into\nsmaller vectors, one per listed input.  The inputs can be global\nquantities; they cannot be per-atom or local quantities.\nComputes and fixes and vector-style\nvariables can generate such global quantities.  The\ngroup specified with this command is ignored.\nThe values extracted from the input vector(s) are determined by the\nNstart, Nstop, and Nskip parameters.  The elements of an input\nvector of length N are indexed from 1 to N.  Starting at element\nNstart, every Mth element is extracted, where M = Nskip, until\nelement Nstop is reached.  The extracted quantities are stored as a\nvector, which is typically shorter than the input vector.\nEach listed input is operated on independently to produce one output\nvector.  Each listed input must be a global vector or column of a\nglobal array calculated by another compute or\nfix.\nIf an input value begins with “c_”, a compute ID must follow which has\nbeen previously defined in the input script and which generates a\nglobal vector or array.  See the individual compute doc\npage for details.  If no bracketed integer is appended, the vector\ncalculated by the compute is used.  If a bracketed integer is\nappended, the Ith column of the array calculated by the compute is\nused.  Users can also write code for their own compute styles and add them to LAMMPS.\nIf a value begins with “f_”, a fix ID must follow which has been\npreviously defined in the input script and which generates a global\nvector or array.  See the individual fix doc page for\ndetails.  Note that some fixes only produce their values on certain\ntimesteps, which must be compatible with when compute slice references\nthe values, else an error results.  If no bracketed integer is\nappended, the vector calculated by the fix is used.  If a bracketed\ninteger is appended, the Ith column of the array calculated by the fix\nis used.  Users can also write code for their own fix style and add them to LAMMPS.\nIf an input value begins with “v_”, a variable name must follow which\nhas been previously defined in the input script.  Only vector-style\nvariables can be referenced.  See the variable command\nfor details.  Note that variables of style vector define a formula\nwhich can reference individual atom properties or thermodynamic\nkeywords, or they can invoke other computes, fixes, or variables when\nthey are evaluated, so this is a very general means of specifying\nquantities to slice.\nIf a single input is specified this compute produces a global vector,\neven if the length of the vector is 1.  If multiple inputs are\nspecified, then a global array of values is produced, with the number\nof columns equal to the number of inputs specified.\n\nOutput info:\nThis compute calculates a global vector if a single input value is\nspecified or a global array with N columns where N is the number of\ninputs.  The length of the vector or the number of rows in the array\nis equal to the number of values extracted from each input vector.\nThese values can be used by any command that uses global vector or\narray values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe vector or array values calculated by this compute are simply\ncopies of values generated by computes or fixes or variables that are\ninput vectors to this compute.  If there is a single input vector of\nintensive and/or extensive values, then each value in the vector of\nvalues calculated by this compute will be “intensive” or “extensive”,\ndepending on the corresponding input value.  If there are multiple\ninput vectors, and all the values in them are intensive, then the\narray values calculated by this compute are “intensive”.  If there are\nmultiple input vectors, and any value in them is extensive, then the\narray values calculated by this compute are “extensive”.  Values\nproduced by a variable are treated as intensive.\nThe vector or array values will be in whatever units the\ninput quantities are in.",
    "syntax": "compute ID group-ID slice Nstart Nstop Nskip input1 input2 ...",
    "parameters": " * ID, group-ID are documented in compute command\n * slice = style name of this compute command\n * Nstart = starting index within input vector(s)\n * Nstop = stopping index within input vector(s)\n * Nskip = extract every Nskip elements from input vector(s)\n * input = c_ID, c_ID[N], f_ID, f_ID[N]\n * c_ID = global vector calculated by a compute with ID\n * c_ID[I] = Ith column of global array calculated by a compute with ID\n * f_ID = global vector calculated by a fix with ID\n * f_ID[I] = Ith column of global array calculated by a fix with ID\n * v_name = vector calculated by an vector-style variable with name",
    "examples": "compute 1 all slice 1 100 10 c_msdmol[4]\ncompute 1 all slice 301 400 1 c_msdmol[4] v_myVec",
    "restrictions": "\nnone"
},
{
    "command": "compute smd/contact/radius",
    "html_filename": "compute_smd_contact_radius.html",
    "short_description": "Define a computation which outputs the contact radius, i",
    "description": "Define a computation which outputs the contact radius, i.e., the\nradius used to prevent particles from penetrating each other.  The\ncontact radius is used only to prevent particles belonging to\ndifferent physical bodies from penetrating each other. It is used by\nthe contact pair styles, e.g., smd/hertz and smd/tri_surface.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nThe value of the contact radius will be 0.0 for particles not in the\nspecified compute group.\nOutput info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle vector values will be in distance units.",
    "syntax": "compute ID group-ID smd/contact/radius",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/contact/radius = style name of this compute command",
    "examples": "compute 1 all smd/contact/radius",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute smd/damage",
    "html_filename": "compute_smd_damage.html",
    "short_description": "Define a computation that calculates the damage status of SPH particles according to the damage model which is defined via the SMD SPH pair styles, e",
    "description": "Define a computation that calculates the damage status of SPH particles\naccording to the damage model which is defined via the SMD SPH pair styles, e.g., the maximum plastic strain failure criterion.\nSee this PDF guide to use Smooth Mach Dynamics in LAMMPS.\nOutput Info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values are dimensionless an in the range of zero to one.",
    "syntax": "compute ID group-ID smd/damage",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/damage = style name of this compute command",
    "examples": "compute 1 all smd/damage",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the “Build"
},
{
    "command": "compute smd/hourglass/error",
    "html_filename": "compute_smd_hourglass_error.html",
    "short_description": "Define a computation which outputs the error of the approximated relative separation with respect to the actual relative separation of the particles i and j",
    "description": "Define a computation which outputs the error of the approximated\nrelative separation with respect to the actual relative separation of\nthe particles i and j. Ideally, if the deformation gradient is exact,\nand there exists a unique mapping between all particles’ positions\nwithin the neighborhood of the central node and the deformation\ngradient, the approximated relative separation will coincide with the\nactual relative separation of the particles i and j in the deformed\nconfiguration.  This compute is only really useful for debugging the\nhourglass control mechanism which is part of the Total-Lagrangian SPH\npair style.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput Info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle vector values will are dimensionless. See\nunits.",
    "syntax": "compute ID group-ID smd/hourglass/error",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/hourglass/error = style name of this compute command",
    "examples": "compute 1 all smd/hourglass/error",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\ntlsph pair style.\nRelated Commands:\nsmd/tlsph_defgrad"
},
{
    "command": "compute smd/internal/energy",
    "html_filename": "compute_smd_internal_energy.html",
    "short_description": "Define a computation which outputs the per-particle enthalpy, i",
    "description": "Define a computation which outputs the per-particle enthalpy, i.e.,\nthe sum of potential energy and heat.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput Info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle vector values will be given in units of energy.",
    "syntax": "compute ID group-ID smd/internal/energy",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/smd/internal/energy = style name of this compute command",
    "examples": "compute 1 all smd/internal/energy",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info. This compute can\nonly be used for particles which interact via the updated Lagrangian\nor total Lagrangian SPH pair styles.\nRelated Commands:"
},
{
    "command": "compute smd/plastic/strain",
    "html_filename": "compute_smd_plastic_strain.html",
    "short_description": "Define a computation that outputs the equivalent plastic strain per particle",
    "description": "Define a computation that outputs the equivalent plastic strain per\nparticle.  This command is only meaningful if a material model with\nplasticity is defined.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput Info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values will be given dimensionless. See units.",
    "syntax": "compute ID group-ID smd/plastic/strain",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/plastic/strain = style name of this compute command",
    "examples": "compute 1 all smd/plastic/strain",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info. This compute can\nonly be used for particles which interact via the updated Lagrangian\nor total Lagrangian SPH pair styles."
},
{
    "command": "compute smd/plastic/strain/rate",
    "html_filename": "compute_smd_plastic_strain_rate.html",
    "short_description": "Define a computation that outputs the time rate of the equivalent plastic strain",
    "description": "Define a computation that outputs the time rate of the equivalent\nplastic strain.  This command is only meaningful if a material model\nwith plasticity is defined.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput Info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values will be given in units of one over time.",
    "syntax": "compute ID group-ID smd/plastic/strain/rate",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/plastic/strain/rate = style name of this compute command",
    "examples": "compute 1 all smd/plastic/strain/rate",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info. This compute can\nonly be used for particles which interact via the updated Lagrangian\nor total Lagrangian SPH pair styles."
},
{
    "command": "compute smd/rho",
    "html_filename": "compute_smd_rho.html",
    "short_description": "Define a computation that calculates the per-particle mass density",
    "description": "Define a computation that calculates the per-particle mass density.\nThe mass density is the mass of a particle which is constant during\nthe course of a simulation, divided by its volume, which can change\ndue to mechanical deformation.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values will be in units of mass over volume.",
    "syntax": "compute ID group-ID smd/rho",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/rho = style name of this compute command",
    "examples": "compute 1 all smd/rho",
    "restrictions": "This compute is part of the USER-SMD package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "compute smd/tlsph/defgrad",
    "html_filename": "compute_smd_tlsph_defgrad.html",
    "short_description": "Define a computation that calculates the deformation gradient",
    "description": "Define a computation that calculates the deformation gradient.  It is\nonly meaningful for particles which interact according to the\nTotal-Lagrangian SPH pair style.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute outputs a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input. See the Howto output doc\npage for an overview of LAMMPS output options.\nThe per-particle vector values will be given dimensionless. See\nunits.  The per-particle vector has 10 entries. The first\nnine entries correspond to the xx, xy, xz, yx, yy, yz, zx, zy, zz\ncomponents of the asymmetric deformation gradient tensor. The tenth\nentry is the determinant of the deformation gradient.",
    "syntax": "compute ID group-ID smd/tlsph/defgrad",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/defgrad = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/defgrad",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info. TThis compute can\nonly be used for particles which interact via the total Lagrangian SPH\npair style."
},
{
    "command": "compute smd/tlsph/dt",
    "html_filename": "compute_smd_tlsph_dt.html",
    "short_description": "Define a computation that outputs the CFL-stable time increment per particle",
    "description": "Define a computation that outputs the CFL-stable time increment per\nparticle.  This time increment is essentially given by the speed of\nsound, divided by the SPH smoothing length.  Because both the speed of\nsound and the smoothing length typically change during the course of a\nsimulation, the stable time increment needs to be re-computed every\ntime step.  This calculation is performed automatically in the\nrelevant SPH pair styles and this compute only serves to make the\nstable time increment accessible for output purposes.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values will be given in units of time.",
    "syntax": "compute ID group-ID smd/tlsph/dt",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/dt = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/dt",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis compute can only be used for particles interacting with the\nTotal-Lagrangian SPH pair style."
},
{
    "command": "compute smd/tlsph/num/neighs",
    "html_filename": "compute_smd_tlsph_num_neighs.html",
    "short_description": "Define a computation that calculates the number of particles inside of the smoothing kernel radius for particles interacting via the Total-Lagrangian SPH pair style",
    "description": "Define a computation that calculates the number of particles inside of\nthe smoothing kernel radius for particles interacting via the\nTotal-Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values are dimensionless. See units.",
    "syntax": "compute ID group-ID smd/tlsph/num/neighs",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/num/neighs = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/num/neighs",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\nthe Total-Lagrangian pair style."
},
{
    "command": "compute smd/tlsph/shape",
    "html_filename": "compute_smd_tlsph_shape.html",
    "short_description": "Define a computation that outputs the current shape of the volume associated with a particle as a rotated ellipsoid",
    "description": "Define a computation that outputs the current shape of the volume\nassociated with a particle as a rotated ellipsoid.  It is only\nmeaningful for particles which interact according to the\nTotal-Lagrangian SPH pair style.\nSee this PDF guide to use Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors, which can be\naccessed by any command that uses per-particle values from a compute\nas input. See the Howto output doc page for an\noverview of LAMMPS output options.\nThe per-particle vector has 7 entries. The first three entries\ncorrespond to the lengths of the ellipsoid’s axes and have units of\nlength.  These axis values are computed as the contact radius times the\nxx, yy, or zz components of the Green-Lagrange strain tensor\nassociated with the particle.  The next 4 values are quaternions\n(order: q, x, y, z) which describe the spatial rotation of the\nparticle relative to its initial state.",
    "syntax": "compute ID group-ID smd/tlsph/shape",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/shape = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/shape",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\nthe Total-Lagrangian SPH pair style."
},
{
    "command": "compute smd/tlsph/strain",
    "html_filename": "compute_smd_tlsph_strain.html",
    "short_description": "Define a computation that calculates the Green-Lagrange strain tensor for particles interacting via the Total-Lagrangian SPH pair style",
    "description": "Define a computation that calculates the Green-Lagrange strain tensor\nfor particles interacting via the Total-Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe per-particle tensor values will be given dimensionless. See\nunits.\nThe per-particle vector has 6 entries, corresponding to the xx, yy,\nzz, xy, xz, yz components of the symmetric strain tensor.",
    "syntax": "compute ID group-ID smd/tlsph/strain",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/strain = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/strain",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\nthe Total-Lagrangian SPH pair style."
},
{
    "command": "compute smd/tlsph/strain/rate",
    "html_filename": "compute_smd_tlsph_strain_rate.html",
    "short_description": "Define a computation that calculates the rate of the strain tensor for particles interacting via the Total-Lagrangian SPH pair style",
    "description": "Define a computation that calculates the rate of the strain tensor for\nparticles interacting via the Total-Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input. See the Howto output doc\npage for an overview of LAMMPS output options.\nThe values will be given in units of one over time.\nThe per-particle vector has 6 entries, corresponding to the xx, yy,\nzz, xy, xz, yz components of the symmetric strain rate tensor.",
    "syntax": "compute ID group-ID smd/tlsph/strain/rate",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/strain/rate = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/strain/rate",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\nTotal-Lagrangian SPH pair style."
},
{
    "command": "compute smd/tlsph/stress",
    "html_filename": "compute_smd_tlsph_stress.html",
    "short_description": "Define a computation that outputs the Cauchy stress tensor for particles interacting via the Total-Lagrangian SPH pair style",
    "description": "Define a computation that outputs the Cauchy stress tensor for\nparticles interacting via the Total-Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input. See the Howto output doc\npage for an overview of LAMMPS output options.\nThe values will be given in units of pressure.\nThe per-particle vector has 7 entries. The first six entries\ncorrespond to the xx, yy, zz, xy, xz and yz components of the\nsymmetric Cauchy stress tensor. The seventh entry is the second\ninvariant of the stress tensor, i.e., the von Mises equivalent stress.",
    "syntax": "compute ID group-ID smd/tlsph/stress",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/tlsph/stress = style name of this compute command",
    "examples": "compute 1 all smd/tlsph/stress",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis quantity will be computed only for particles which interact with\nthe Total-Lagrangian SPH pair style."
},
{
    "command": "compute smd/triangle/vertices",
    "html_filename": "compute_smd_triangle_vertices.html",
    "short_description": "Define a computation that returns the coordinates of the vertices corresponding to the triangle-elements of a mesh created by the fix smd/wall_surface",
    "description": "Define a computation that returns the coordinates of the vertices\ncorresponding to the triangle-elements of a mesh created by the fix smd/wall_surface.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute returns a per-particle vector of vectors, which can be\naccessed by any command that uses per-particle values from a compute\nas input. See the Howto output doc page for an\noverview of LAMMPS output options.\nThe per-particle vector has nine entries, (x1/y1/z1), (x2/y2/z2), and\n(x3/y3/z3) corresponding to the first, second, and third vertex of\neach triangle.\nIt is only meaningful to use this compute for a group of particles\nwhich is created via the fix smd/wall_surface command.\nThe output of this compute can be used with the dump2vtk_tris tool to\ngenerate a VTK representation of the smd/wall_surface mesh for\nvisualization purposes.\nThe values will be given in units of distance.",
    "syntax": "compute ID group-ID smd/triangle/vertices",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/triangle/vertices = style name of this compute command",
    "examples": "compute 1 all smd/triangle/mesh/vertices",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute smd/ulsph/num/neighs",
    "html_filename": "compute_smd_ulsph_num_neighs.html",
    "short_description": "Define a computation that returns the number of neighbor particles inside of the smoothing kernel radius for particles interacting via the updated Lagrangian SPH pair style",
    "description": "Define a computation that returns the number of neighbor particles\ninside of the smoothing kernel radius for particles interacting via\nthe updated Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute returns a per-particle vector, which can be accessed by\nany command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle values will be given dimensionless, see units.",
    "syntax": "compute ID group-ID smd/ulsph/num/neighs",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/ulsph/num/neighs = style name of this compute command",
    "examples": "compute 1 all smd/ulsph/num/neighs",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.  This compute can\nonly be used for particles which interact with the updated Lagrangian\nSPH pair style."
},
{
    "command": "compute smd/ulsph/strain",
    "html_filename": "compute_smd_ulsph_strain.html",
    "short_description": "Define a computation that outputs the logarithmic strain tensor",
    "description": "Define a computation that outputs the logarithmic strain tensor.  for\nparticles interacting via the updated Lagrangian SPH pair style.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle tensor, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle vector has 6 entries, corresponding to the xx, yy,\nzz, xy, xz, yz components of the symmetric strain rate tensor.\nThe per-particle tensor values will be given dimensionless, see\nunits.",
    "syntax": "compute ID group-ID smd/ulsph/strain",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/ulsph/strain = style name of this compute command",
    "examples": "compute 1 all smd/ulsph/strain",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info. This compute can\nonly be used for particles which interact with the updated Lagrangian\nSPH pair style."
},
{
    "command": "compute smd/ulsph/strain/rate",
    "html_filename": "compute_smd_ulsph_strain_rate.html",
    "short_description": "Define a computation that outputs the rate of the logarithmic strain tensor for particles interacting via the updated Lagrangian SPH pair style",
    "description": "Define a computation that outputs the rate of the logarithmic strain\ntensor for particles interacting via the updated Lagrangian SPH pair\nstyle.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input. See the Howto output doc\npage for an overview of LAMMPS output options.\nThe values will be given in units of one over time.\nThe per-particle vector has 6 entries, corresponding to the xx, yy,\nzz, xy, xz, yz components of the symmetric strain rate tensor.",
    "syntax": "compute ID group-ID smd/ulsph/strain/rate",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/ulsph/strain/rate = style name of this compute command",
    "examples": "compute 1 all smd/ulsph/strain/rate",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis compute can only be used for particles which interact with the\nupdated Lagrangian SPH pair style."
},
{
    "command": "compute smd/ulsph/stress",
    "html_filename": "compute_smd_ulsph_stress.html",
    "short_description": "Define a computation that outputs the Cauchy stress tensor",
    "description": "Define a computation that outputs the Cauchy stress tensor.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector of vectors (tensors),\nwhich can be accessed by any command that uses per-particle values\nfrom a compute as input. See the Howto output doc\npage for an overview of LAMMPS output options.\nThe values will be given in units of pressure.\nThe per-particle vector has 7 entries. The first six entries\ncorrespond to the xx, yy, zz, xy, xz, yz components of the symmetric\nCauchy stress tensor. The seventh entry is the second invariant of the\nstress tensor, i.e., the von Mises equivalent stress.",
    "syntax": "compute ID group-ID smd/ulsph/stress",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/ulsph/stress = style name of this compute command",
    "examples": "compute 1 all smd/ulsph/stress",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info. This compute can\nonly be used for particles which interact with the updated Lagrangian\nSPH pair style."
},
{
    "command": "compute smd/vol",
    "html_filename": "compute_smd_vol.html",
    "short_description": "Define a computation that provides the per-particle volume and the sum of the per-particle volumes of the group for which the fix is defined",
    "description": "Define a computation that provides the per-particle volume and the sum\nof the per-particle volumes of the group for which the fix is defined.\nSee this PDF guide to using Smooth\nMach Dynamics in LAMMPS.\nOutput info:\nThis compute calculates a per-particle vector, which can be accessed\nby any command that uses per-particle values from a compute as input.\nSee the Howto output doc page for an overview of\nLAMMPS output options.\nThe per-particle vector values will be given in units of\nvolume.\nAdditionally, the compute returns a scalar, which is the sum of the\nper-particle volumes of the group for which the fix is defined.",
    "syntax": "compute ID group-ID smd/vol",
    "parameters": " * ID, group-ID are documented in compute command\n * smd/vol = style name of this compute command",
    "examples": "compute 1 all smd/vol",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info."
},
{
    "command": "compute sna/atom",
    "html_filename": "compute_sna_atom.html",
    "short_description": "Define a computation that calculates a set of quantities related to the bispectrum components of the atoms in a group",
    "description": "Define a computation that calculates a set of quantities related to the\nbispectrum components of the atoms in a group. These computes are\nused primarily for calculating the dependence of energy, force, and\nstress components on the linear coefficients in the\nsnap pair_style, which is useful when training a\nSNAP potential to match target data.\nBispectrum components of an atom are order parameters characterizing\nthe radial and angular distribution of neighbor atoms. The detailed\nmathematical definition is given in the paper by Thompson et\nal. (Thompson)\nThe position of a neighbor atom i’ relative to a central atom i is\na point within the 3D ball of radius R_ii’ = rcutfac*(R_i + R_i’)\nBartok et al. (Bartok), proposed mapping this 3D ball\nonto the 3-sphere, the surface of the unit ball in a four-dimensional\nspace.  The radial distance r within R_ii’ is mapped on to a third\npolar angle theta0 defined by,\n\n\\[\\theta_0 = {\\tt rfac0} \\frac{r-r_{min0}}{R_{ii'}-r_{min0}} \\pi\\]\nIn this way, all possible neighbor positions are mapped on to a subset\nof the 3-sphere.  Points south of the latitude theta0max=rfac0*Pi\nare excluded.\nThe natural basis for functions on the 3-sphere is formed by the 4D\nhyperspherical harmonics U^j_m,m’(theta, phi, theta0).  These\nfunctions are better known as D^j_m,m’, the elements of the Wigner\nD-matrices (Meremianin,\nVarshalovich).\nThe density of neighbors on the 3-sphere can be written as a sum of\nDirac-delta functions, one for each neighbor, weighted by species and\nradial distance. Expanding this density function as a generalized\nFourier series in the basis functions, we can write each Fourier\ncoefficient as\n\n\\[u^j_{m,m'} = U^j_{m,m'}(0,0,0) + \\sum_{r_{ii'} < R_{ii'}}{f_c(r_{ii'}) w_{i'} U^j_{m,m'}(\\theta_0,\\theta,\\phi)}\\]\nThe w_i’ neighbor weights are dimensionless numbers that are chosen\nto distinguish atoms of different types, while the central atom is\narbitrarily assigned a unit weight.  The function fc(r) ensures that\nthe contribution of each neighbor atom goes smoothly to zero at\nR_ii’:\n\n\\[\\begin{split}f_c(r)   = & \\frac{1}{2}(\\cos(\\pi \\frac{r-r_{min0}}{R_{ii'}-r_{min0}}) + 1), r \\leq R_{ii'} \\\\\n         = & 0,  r > R_{ii'}\\end{split}\\]\nThe expansion coefficients u^j_m,m’ are complex-valued and they are\nnot directly useful as descriptors, because they are not invariant\nunder rotation of the polar coordinate frame. However, the following\nscalar triple products of expansion coefficients can be shown to be\nreal-valued and invariant under rotation (Bartok).\n\n\\[\\begin{split}B_{j_1,j_2,j}  =\n\\sum_{m_1,m'_1=-j_1}^{j_1}\\sum_{m_2,m'_2=-j_2}^{j_2}\\sum_{m,m'=-j}^{j} (u^j_{m,m'})^*\nH {\\scriptscriptstyle \\begin{array}{l} {j} {m} {m'} \\\\\n     {j_1} {m_1} {m'_1} \\\\\n     {j_2} {m_2} {m'_2} \\end{array}}\n     u^{j_1}_{m_1,m'_1} u^{j_2}_{m_2,m'_2}\\end{split}\\]\nThe constants H^jmm’_j1m1m1’_j2m2m2’ are coupling coefficients,\nanalogous to Clebsch-Gordan coefficients for rotations on the\n2-sphere. These invariants are the components of the bispectrum and\nthese are the quantities calculated by the compute sna/atom. They\ncharacterize the strength of density correlations at three points on\nthe 3-sphere. The j2=0 subset form the power spectrum, which\ncharacterizes the correlations of two points. The lowest-order\ncomponents describe the coarsest features of the density function,\nwhile higher-order components reflect finer detail.  Note that the\ncentral atom is included in the expansion, so three point-correlations\ncan be either due to three neighbors, or two neighbors and the central\natom.\nCompute snad/atom calculates the derivative of the bispectrum components\nsummed separately for each atom type:\n\n\\[-\\sum_{i' \\in I} \\frac{\\partial {B^{i'}_{j_1,j_2,j}  }}{\\partial {\\bf r}_i}\\]\nThe sum is over all atoms i’ of atom type I.  For each atom i,\nthis compute evaluates the above expression for each direction, each\natom type, and each bispectrum component.  See section below on output\nfor a detailed explanation.\nCompute snav/atom calculates the virial contribution due to the\nderivatives:\n\n\\[-{\\bf r}_i \\otimes \\sum_{i' \\in I} \\frac{\\partial {B^{i'}_{j_1,j_2,j}}}{\\partial {\\bf r}_i}\\]\nAgain, the sum is over all atoms i’ of atom type I.  For each atom\ni, this compute evaluates the above expression for each of the six\nvirial components, each atom type, and each bispectrum component.  See\nsection below on output for a detailed explanation.\nCompute snap calculates a global array contains information related\nto all three of the above per-atom computes sna/atom, snad/atom,\nand snav/atom. The first row of the array contains the summation of\nsna/atom over all atoms, but broken out by type. The last six rows\nof the array contain the summation of snav/atom over all atoms, broken\nout by type. In between these are 3*N rows containing the same values\ncomputed by snad/atom (these are already summed over all atoms and\nbroken out by type). The element in the last column of each row contains\nthe potential energy, force, or stress, according to the row.\nThese quantities correspond to the user-specified reference potential\nthat must be subtracted from the target data when fitting SNAP.\nThe potential energy calculation uses the built in compute thermo_pe.\nThe stress calculation uses a compute called snap_press that is\nautomatically created behind the scenes, according to the following\ncommand:\ncompute snap_press all pressure NULL virial\n\n\nSee section below on output for a detailed explanation of the data\nlayout in the global array.\nThe value of all bispectrum components will be zero for atoms not in\nthe group. Neighbor atoms not in the group do not contribute to the\nbispectrum of atoms in the group.\nThe neighbor list needed to compute this quantity is constructed each\ntime the calculation is performed (i.e. each time a snapshot of atoms\nis dumped).  Thus it can be inefficient to compute/dump this quantity\ntoo frequently.\nThe argument rcutfac is a scale factor that controls the ratio of\natomic radius to radial cutoff distance.\nThe argument rfac0 and the optional keyword rmin0 define the\nlinear mapping from radial distance to polar angle theta0 on the\n3-sphere.\nThe argument twojmax defines which\nbispectrum components are generated. See section below on output for a\ndetailed explanation of the number of bispectrum components and the\nordered in which they are listed.\nThe keyword switchflag can be used to turn off the switching\nfunction.\nThe keyword bzeroflag determines whether or not B0, the bispectrum\ncomponents of an atom with no neighbors, are subtracted from\nthe calculated bispectrum components. This optional keyword\nnormally only affects compute sna/atom. However, when\nquadraticflag is on, it also affects snad/atom and snav/atom.\nThe keyword quadraticflag determines whether or not the\nquadratic analogs to the bispectrum quantities are generated.\nThese are formed by taking the outer product of the vector\nof bispectrum components with itself.\nSee section below on output for a\ndetailed explanation of the number of quadratic terms and the\nordered in which they are listed.\n\nNote\nIf you have a bonded system, then the settings of\nspecial_bonds command can remove pairwise\ninteractions between atoms in the same bond, angle, or dihedral.  This\nis the default setting for the special_bonds\ncommand, and means those pairwise interactions do not appear in the\nneighbor list.  Because this fix uses the neighbor list, it also means\nthose pairs will not be included in the calculation.  One way to get\naround this, is to write a dump file, and use the rerun\ncommand to compute the bispectrum components for snapshots in the dump\nfile.  The rerun script can use a special_bonds\ncommand that includes all pairs in the neighbor list.\n\n\nOutput info:\nCompute sna/atom calculates a per-atom array, each column\ncorresponding to a particular bispectrum component.  The total number\nof columns and the identity of the bispectrum component contained in\neach column depend of the value of twojmax, as\ndescribed by the following piece of python code:\nfor j1 in range(0,twojmax+1):\n    for j2 in range(0,j1+1):\n        for j in range(j1-j2,min(twojmax,j1+j2)+1,2):\n            if (j>=j1): print j1/2.,j2/2.,j/2.\n\n\n\nNote\nthe diagonal keyword allowing other possible choices\nfor the number of bispectrum components was removed in 2019,\nsince all potentials use the value of 3, corresponding to the\nabove set of bispectrum components.\n\nCompute snad/atom evaluates a per-atom array. The columns are\narranged into ntypes blocks, listed in order of atom type I.  Each\nblock contains three sub-blocks corresponding to the x, y, and z\ncomponents of the atom position.  Each of these sub-blocks contains\none column for each bispectrum component, the same as for compute\nsna/atom\nCompute snav/atom evaluates a per-atom array. The columns are\narranged into ntypes blocks, listed in order of atom type I.  Each\nblock contains six sub-blocks corresponding to the xx, yy, zz,\nyz, xz, and xy components of the virial tensor in Voigt\nnotation.  Each of these sub-blocks contains one column for each\nbispectrum component, the same as for compute sna/atom\nCompute snap evaluates a global array.\nThe columns are arranged into\nntypes blocks, listed in order of atom type I. Each block\ncontains one column for each bispectrum component, the same as for compute\nsna/atom. A final column contains the corresponding energy, force component\non an atom, or virial stress component. The rows of the array appear\nin the following order:\n\n1 row: sna/atom quantities summed for all atoms of type I\n3*N rows: snad/atom quantities, with derivatives w.r.t. x, y, and z coordinate of atom i appearing in consecutive rows. The atoms are sorted based on atom ID.\n6 rows: snav/atom quantities summed for all atoms of type I\n\nFor example, if K =30 and ntypes=1, the number of columns in the per-atom\narrays generated by sna/atom, snad/atom, and snav/atom\nare 30, 90, and 180, respectively. With quadratic value=1,\nthe numbers of columns are 930, 2790, and 5580, respectively.\nThe number of columns in the global array generated by snap\nare 31, and 931, respectively, while the number of rows is\n1+3*N+6, where N is the total number of atoms.\nIf the quadratic keyword value is set to 1, then additional\ncolumns are generated, corresponding to\nthe products of all distinct pairs of  bispectrum components. If the\nnumber of bispectrum components is K, then the number of distinct pairs\nis  K(K+1)/2.\nFor compute sna/atom these columns are appended to existing K columns.\nThe ordering of quadratic terms is upper-triangular,\n(1,1),(1,2)…(1,K),(2,1)…(K-1,K-1),(K-1,K),(K,K).\nFor computes snad/atom and snav/atom each set of K(K+1)/2\nadditional columns is inserted directly after each of sub-block\nof linear terms i.e. linear and quadratic terms are contiguous.\nSo the nesting order from inside to outside is bispectrum component,\nlinear then quadratic, vector/tensor component, type.\nThese values can be accessed by any command that uses per-atom values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.",
    "syntax": "compute ID group-ID sna/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...",
    "parameters": " * compute ID group-ID snad/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n * compute ID group-ID snav/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n * compute ID group-ID snap rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n * ID, group-ID are documented in compute command\n * sna/atom = style name of this compute command\n * rcutfac = scale factor applied to all cutoff radii (positive real)\n * rfac0 = parameter in distance to angle conversion (0 < rcutfac < 1)\n * twojmax = band limit for bispectrum components (non-negative integer)\n * R_1, R_2,… = list of cutoff radii, one for each type (distance units)\n * w_1, w_2,… = list of neighbor weights, one for each type\n * zero or more keyword/value pairs may be appended\n * keyword = rmin0 or switchflag or bzeroflag or quadraticflag\n * rmin0 value = parameter in distance to angle conversion (distance units)\n * switchflag value = 0 or 1\n *    0 = do not use switching function\n *    1 = use switching function\n * bzeroflag value = 0 or 1\n *    0 = do not subtract B0\n *    1 = subtract B0\n * quadraticflag value = 0 or 1\n *    0 = do not generate quadratic terms\n *    1 = generate quadratic terms",
    "examples": "compute b all sna/atom 1.4 0.99363 6 2.0 2.4 0.75 1.0 rmin0 0.0\ncompute db all sna/atom 1.4 0.95 6 2.0 1.0\ncompute vb all sna/atom 1.4 0.95 6 2.0 1.0\ncompute snap all snap 1.4 0.95 6 2.0 1.0",
    "restrictions": "These computes are part of the SNAP package.  They are only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute spin",
    "html_filename": "compute_spin.html",
    "short_description": "Define a computation that calculates magnetic quantities for a system of atoms having spins",
    "description": "Define a computation that calculates magnetic quantities for a system\nof atoms having spins.\nThis compute calculates the following 6 magnetic quantities:\n\nthe three first quantities are the x,y and z coordinates of the total\nmagnetization,\nthe fourth quantity is the norm of the total magnetization,\nThe fifth quantity is the magnetic energy (in eV),\nThe sixth one is referred to as the spin temperature, according\nto the work of (Nurdin).\n\nThe simplest way to output the results of the compute spin calculation\nis to define some of the quantities as variables, and to use the thermo and\nthermo_style commands, for example:\ncompute out_mag         all spin\n\nvariable mag_z          equal c_out_mag[3]\nvariable mag_norm       equal c_out_mag[4]\nvariable temp_mag       equal c_out_mag[6]\n\nthermo                  10\nthermo_style            custom step v_mag_z v_mag_norm v_temp_mag\n\n\nThis series of commands evaluates the total magnetization along z, the norm of\nthe total magnetization, and the magnetic temperature. Three variables are\nassigned to those quantities. The thermo and thermo_style commands print them\nevery 10 timesteps.\nOutput info:\nThe array values are “intensive”.  The array values will be in\nmetal units (units).",
    "syntax": "compute ID group-ID spin",
    "parameters": " * ID, group-ID are documented in compute command\n * spin = style name of this compute command",
    "examples": "compute out_mag all spin",
    "restrictions": "The spin compute is part of the SPIN package.  This compute is only\nenabled if LAMMPS was built with this package.  See the Build package doc page for more info.  The atom_style\nhas to be “spin” for this compute to be valid.\nRelated commands:\nnone\nDefault:\nnone\n\n(Nurdin) Nurdin and Schotte Phys Rev E, 61(4), 3579 (2000)"
},
{
    "command": "compute stress/atom",
    "html_filename": "compute_stress_atom.html",
    "short_description": "Define a computation that computes per-atom stress tensor for each atom in a group",
    "description": "Define a computation that computes per-atom stress\ntensor for each atom in a group.  In case of compute stress/atom,\nthe tensor for each atom is symmetric with 6\ncomponents and is stored as a 6-element vector in the following order:\n\\(xx\\), \\(yy\\), \\(zz\\), \\(xy\\), \\(xz\\), \\(yz\\).\nIn case of compute centroid/stress/atom,\nthe tensor for each atom is asymmetric with 9 components\nand is stored as a 9-element vector in the following order:\n\\(xx\\), \\(yy\\), \\(zz\\), \\(xy\\), \\(xz\\), \\(yz\\),\n\\(yx\\), \\(zx\\), \\(zy\\).\nSee the compute pressure command if you want the stress tensor\n(pressure) of the entire system.\nThe stress tensor for atom \\(I\\) is given by the following formula,\nwhere \\(a\\) and \\(b\\) take on values \\(x\\), \\(y\\), \\(z\\)\nto generate the components of the tensor:\n\n\\[S_{ab}  =  - m v_a v_b - W_{ab}\\]\nThe first term is a kinetic energy contribution for atom \\(I\\).  See\ndetails below on how the specified temp-ID can affect the velocities\nused in this calculation. The second term is the virial\ncontribution due to intra and intermolecular interactions,\nwhere the exact computation details are determined by the compute style.\nIn case of compute stress/atom, the virial contribution is:\n\n\\[\\begin{split} W_{ab} & = \\frac{1}{2} \\sum_{n = 1}^{N_p} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b}) + \\frac{1}{2} \\sum_{n = 1}^{N_b} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b})  \\\\\n& + \\frac{1}{3} \\sum_{n = 1}^{N_a} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b}) + \\frac{1}{4} \\sum_{n = 1}^{N_d} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b} + r_{4_a} F_{4_b}) \\\\\n& + \\frac{1}{4} \\sum_{n = 1}^{N_i} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b} + r_{4_a} F_{4_b}) + {\\rm Kspace}(r_{i_a},F_{i_b}) + \\sum_{n = 1}^{N_f} r_{i_a} F_{i_b}\\end{split}\\]\nThe first term is a pairwise energy\ncontribution where \\(n\\) loops over the \\(N_p\\)\nneighbors of atom \\(I\\), \\(\\mathbf{r}_1\\) and \\(\\mathbf{r}_2\\)\nare the positions of the 2 atoms in the pairwise interaction,\nand \\(\\mathbf{F}_1\\) and \\(\\mathbf{F}_2\\) are the forces\non the 2 atoms resulting from the pairwise interaction.\nThe second term is a bond contribution of\nsimilar form for the \\(N_b\\) bonds which atom \\(I\\) is part of.\nThere are similar terms for the \\(N_a\\) angle, \\(N_d\\) dihedral,\nand \\(N_i\\) improper interactions atom \\(I\\) is part of.\nThere is also a term for the KSpace\ncontribution from long-range Coulombic interactions, if defined.\nFinally, there is a term for the \\(N_f\\) fixes that apply\ninternal constraint forces to atom \\(I\\). Currently, only the\nfix shake and fix rigid commands\ncontribute to this term.\nAs the coefficients in the formula imply, a virial contribution\nproduced by a small set of atoms (e.g. 4 atoms in a dihedral or 3\natoms in a Tersoff 3-body interaction) is assigned in equal portions\nto each atom in the set.  E.g. 1/4 of the dihedral virial to each of\nthe 4 atoms, or 1/3 of the fix virial due to SHAKE constraints applied\nto atoms in a water molecule via the fix shake\ncommand.\nIn case of compute centroid/stress/atom, the virial contribution is:\n\n\\[\\begin{split} W_{ab} & = \\sum_{n = 1}^{N_p} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_b} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_a} r_{I0_a}  F_{I_b} + \\sum_{n = 1}^{N_d} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_i} r_{I0_a} F_{I_b} \\\\\n& + {\\rm Kspace}(r_{i_a},F_{i_b}) + \\sum_{n = 1}^{N_f} r_{i_a} F_{i_b}\\end{split}\\]\nAs with compute stress/atom, the first, second, third, fourth and fifth terms\nare pairwise, bond, angle, dihedral and improper contributions,\nbut instead of assigning the virial contribution equally to each atom,\nonly the force \\(\\mathbf{F}_I\\) acting on atom \\(I\\)\ndue to the interaction and the relative\nposition \\(\\mathbf{r}_{I0}\\) of the atom \\(I\\) to the geometric center\nof the interacting atoms, i.e. centroid, is used.\nAs the geometric center is different\nfor each interaction, the \\(\\mathbf{r}_{I0}\\) also differs.\nThe sixth and seventh terms, Kspace and fix contribution\nrespectively, are computed identical to compute stress/atom.\nAlthough the total system virial is the same as compute stress/atom,\ncompute centroid/stress/atom is know to result in more consistent\nheat flux values for angle, dihedrals and improper contributions\nwhen computed via compute heat/flux.\nIf no extra keywords are listed, the kinetic contribution\nall of the virial contribution terms are\nincluded in the per-atom stress tensor.  If any extra keywords are\nlisted, only those terms are summed to compute the tensor.  The\nvirial keyword means include all terms except the kinetic energy\nke.\nNote that the stress for each atom is due to its interaction with all\nother atoms in the simulation, not just with other atoms in the group.\nDetails of how compute stress/atom obtains the virial for individual atoms for\neither pairwise or many-body potentials, and including the effects of\nperiodic boundary conditions is discussed in (Thompson).\nThe basic idea for many-body potentials is to treat each component of\nthe force computation between a small cluster of atoms in the same\nmanner as in the formula above for bond, angle, dihedral, etc\ninteractions.  Namely the quantity \\(\\mathbf{r} \\cdot \\mathbf{F}\\)\nis summed over the atoms in\nthe interaction, with the \\(r\\) vectors unwrapped by periodic boundaries\nso that the cluster of atoms is close together.  The total\ncontribution for the cluster interaction is divided evenly among those\natoms. Details of how compute centroid/stress/atom obtains\nthe virial for individual atoms\nis given in (Surblys),\nwhere the idea is that the virial of the atom \\(I\\)\nis the result of only the force \\(\\mathbf{F}_I\\) on the atom due\nto the interaction\nand its positional vector \\(\\mathbf{r}_{I0}\\),\nrelative to the geometric center of the\ninteracting atoms, regardless of the number of participating atoms.\nThe periodic boundary treatment is identical to\nthat of compute stress/atom, and both of them reduce to identical\nexpressions for two-body interactions,\ni.e. computed values for contributions from bonds and two-body pair styles,\nsuch as Lennard-Jones, will be the same,\nwhile contributions from angles, dihedrals and impropers will be different.\nThe dihedral_style charmm style calculates\npairwise interactions between 1-4 atoms.  The virial contribution of\nthese terms is included in the pair virial, not the dihedral virial.\nThe KSpace contribution is calculated using the method in\n(Heyes) for the Ewald method and by the methodology described\nin (Sirk) for PPPM.  The choice of KSpace solver is specified\nby the kspace_style pppm command.  Note that for\nPPPM, the calculation requires 6 extra FFTs each timestep that\nper-atom stress is calculated.  Thus it can significantly increase the\ncost of the PPPM calculation if it is needed on a large fraction of\nthe simulation timesteps.\nThe temp-ID argument can be used to affect the per-atom velocities\nused in the kinetic energy contribution to the total stress.  If the\nkinetic energy is not included in the stress, than the temperature\ncompute is not used and can be specified as NULL.  If the kinetic\nenergy is included and you wish to use atom velocities as-is, then\ntemp-ID can also be specified as NULL.  If desired, the specified\ntemperature compute can be one that subtracts off a bias to leave each\natom with only a thermal velocity to use in the formula above, e.g. by\nsubtracting a background streaming velocity.  See the doc pages for\nindividual compute commands to determine which ones\ninclude a bias.\n\nNote that as defined in the formula, per-atom stress is the negative\nof the per-atom pressure tensor.  It is also really a stress*volume\nformulation, meaning the computed quantity is in units of\npressure*volume.  It would need to be divided by a per-atom volume to\nhave units of stress (pressure), but an individual atom’s volume is\nnot well defined or easy to compute in a deformed solid or a liquid.\nSee the compute voronoi/atom command for\none possible way to estimate a per-atom volume.\nThus, if the diagonal components of the per-atom stress tensor are\nsummed for all atoms in the system and the sum is divided by \\(dV\\), where\n\\(d\\) = dimension and \\(V\\) is the volume of the system,\nthe result should be \\(-P\\), where \\(P\\)\nis the total pressure of the system.\nThese lines in an input script for a 3d system should yield that\nresult. I.e. the last 2 columns of thermo output will be the same:\ncompute        peratom all stress/atom NULL\ncompute        p all reduce sum c_peratom[1] c_peratom[2] c_peratom[3]\nvariable       press equal -(c_p[1]+c_p[2]+c_p[3])/(3*vol)\nthermo_style   custom step temp etotal press v_press\n\nNote\nThe per-atom stress does not include any Lennard-Jones tail\ncorrections to the pressure added by the pair_modify tail yes command, since those are contributions to the\nglobal system pressure.\n\nOutput info:\nThis compute stress/atom calculates a per-atom array with 6 columns, which can be\naccessed by indices 1-6 by any command that uses per-atom values from\na compute as input.\nThe compute centroid/stress/atom produces a per-atom array with 9 columns,\nbut otherwise can be used in an identical manner to compute stress/atom.\nSee the Howto output doc page\nfor an overview of LAMMPS output options.\nThe per-atom array values will be in pressure*volume\nunits as discussed above.",
    "syntax": "compute ID group-ID style temp-ID keyword ...",
    "parameters": " * ID, group-ID are documented in compute command\n * style = stress/atom or centroid/stress/atom\n * temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n * zero or more keywords may be appended\n * keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial",
    "examples": "compute 1 mobile stress/atom NULL\ncompute 1 mobile stress/atom myRamp\ncompute 1 all stress/atom NULL pair bond\ncompute 1 all centroid/stress/atom NULL bond dihedral improper",
    "restrictions": "Currently, compute centroid/stress/atom does not support\npair styles with many-body interactions,\nsuch as Tersoff,\nand LAMMPS will generate an error in such cases.\nIn principal, equivalent formulation\nto that of angle, dihedral and improper contributions\nin the virial \\(W_{ab}\\) formula\ncan also be applied to the many-body pair styles,\nand is planned in the future."
},
{
    "command": "compute stress/mop",
    "html_filename": "compute_stress_mop.html",
    "short_description": "Compute stress/mop and compute stress/mop/profile define computations that calculate components of the local stress tensor using the method of planes (Todd)",
    "description": "Compute stress/mop and compute stress/mop/profile define computations that\ncalculate components of the local stress tensor using the method of\nplanes (Todd).  Specifically in compute stress/mop calculates 3\ncomponents are computed in directions dir,x; dir,y; and\ndir,z; where dir is the direction normal to the plane, while\nin compute stress/mop/profile the profile of the stress is computed.\nContrary to methods based on histograms of atomic stress (i.e. using\ncompute stress/atom), the method of planes is\ncompatible with mechanical balance in heterogeneous systems and at\ninterfaces (Todd).\nThe stress tensor is the sum of a kinetic term and a configurational\nterm, which are given respectively by Eq. (21) and Eq. (16) in\n(Todd). For the kinetic part, the algorithm considers that\natoms have crossed the plane if their positions at times t-dt and t are\none on either side of the plane, and uses the velocity at time t-dt/2\ngiven by the velocity-Verlet algorithm.\nBetween one and three keywords can be used to indicate which\ncontributions to the stress must be computed: kinetic stress (kin),\nconfigurational stress (conf), and/or total stress (total).\nNOTE 1: The configurational stress is computed considering all pairs of atoms where at least one atom belongs to group group-ID.\nNOTE 2: The local stress does not include any Lennard-Jones tail\ncorrections to the pressure added by the pair_modify tail yes command, since those are contributions to the global system pressure.\nOutput info:\nCompute stress/mop calculates a global vector (indices starting at 1), with 3\nvalues for each declared keyword (in the order the keywords have been\ndeclared). For each keyword, the stress tensor components are ordered as\nfollows: stress_dir,x, stress_dir,y, and stress_dir,z.\nCompute stress/mop/profile instead calculates a global array, with 1 column\ngiving the position of the planes where the stress tensor was computed,\nand with 3 columns of values for each declared keyword (in the order the\nkeywords have been declared). For each keyword, the profiles of stress\ntensor components are ordered as follows: stress_dir,x; stress_dir,y;\nand stress_dir,z.\nThe values are in pressure units.\nThe values produced by this compute can be accessed by various output commands. For instance, the results can be written to a file using the fix ave/time command. Please see the example in the examples/USER/mop folder.",
    "syntax": "compute ID group-ID style dir args keywords ...",
    "parameters": " * ID, group-ID are documented in compute command\n * style = stress/mop or stress/mop/profile\n * dir = x or y or z is the direction normal to the plane\n * args = argument specific to the compute style\n * keywords = kin or conf or total (one of more can be specified)\n *   stress/mop args = pos\n *     pos = lower or center or upper or coordinate value (distance units) is the position of the plane\n *   stress/mop/profile args = origin delta\n *     origin = lower or center or upper or coordinate value (distance units) is the position of the first plane\n *     delta = value (distance units) is the distance between planes\n * compute 1 all stress/mop x lower total\n * compute 1 liquid stress/mop z 0.0 kin conf\n * fix 1 all ave/time 10 1000 10000 c_1[*] file mop.time\n * fix 1 all ave/time 10 1000 10000 c_1[2] file mop.time\n * compute 1 all stress/mop/profile x lower 0.1 total\n * compute 1 liquid stress/mop/profile z 0.0 0.25 kin conf\n * fix 1 all ave/time 500 20 10000 c_1[*] ave running overwrite file mopp.time mode vector",
    "examples": "compute 1 mobile stress/atom NULL\ncompute 1 mobile stress/atom myRamp\ncompute 1 all stress/atom NULL pair bond\ncompute 1 all centroid/stress/atom NULL bond dihedral improper",
    "restrictions": "These styles are part of the USER-MISC package. They are only enabled if\nLAMMPS is built with that package. See the Build package\ndoc page on for more info.\nThe method is only implemented for 3d orthogonal simulation boxes whose\nsize does not change in time, and axis-aligned planes.\nThe method only works with two-body pair interactions, because it\nrequires the class method pair->single() to be implemented. In\nparticular, it does not work with more than two-body pair interactions,\nintra-molecular interactions, and long range (kspace) interactions."
},
{
    "command": "compute force/tally",
    "html_filename": "compute_tally.html",
    "short_description": "Define a computation that calculates properties between two groups of atoms by accumulating them from pairwise non-bonded computations",
    "description": "Define a computation that calculates properties between two groups of\natoms by accumulating them from pairwise non-bonded computations.  The\ntwo groups can be the same. This is similar to compute group/group only that the data is\naccumulated directly during the non-bonded force computation. The\ncomputes force/tally, pe/tally, stress/tally, and\nheat/flux/tally are primarily provided as example how to program\nadditional, more sophisticated computes using the tally callback\nmechanism. Compute pe/mol/tally is one such style, that can\n- through using this mechanism - separately tally intermolecular\nand intramolecular energies. Something that would otherwise be\nimpossible without integrating this as a core functionality into\nthe based classes of LAMMPS.\n\nThe pairwise contributions are computing via a callback that the\ncompute registers with the non-bonded pairwise force computation.\nThis limits the use to systems that have no bonds, no Kspace, and no\nmany-body interactions. On the other hand, the computation does not\nhave to compute forces or energies a second time and thus can be much\nmore efficient. The callback mechanism allows to write more complex\npairwise property computations.\n\nOutput info:\nCompute pe/tally calculates a global scalar (the energy) and a per\natom scalar (the contributions of the single atom to the global\nscalar). Compute pe/mol/tally calculates a global 4-element vector\ncontaining (in this order): evdwl and ecoul for intramolecular pairs\nand evdwl and ecoul for intermolecular pairs. Since molecules are\nidentified by their molecule IDs, the partitioning does not have to be\nrelated to molecules, but the energies are tallied into the respective\nslots depending on whether the molecule IDs of a pair are the same or\ndifferent. Compute force/tally calculates a global scalar (the force\nmagnitude) and a per atom 3-element vector (force contribution from\neach atom).  Compute stress/tally calculates a global scalar\n(average of the diagonal elements of the stress tensor) and a per atom\nvector (the 6 elements of stress tensor contributions from the\nindividual atom).\nBoth the scalar and vector values calculated by this compute are\n“extensive”.",
    "syntax": "compute ID group-ID style group2-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * style = force/tally or pe/tally or pe/mol/tally or stress/tally\n * group2-ID = group ID of second (or same) group",
    "examples": "compute 1 lower force/tally upper\ncompute 1 left pe/tally right\ncompute 1 lower stress/tally lower",
    "restrictions": "This compute is part of the USER-TALLY package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nNot all pair styles can be evaluated in a pairwise mode as required by\nthis compute.  For example, 3-body and other many-body potentials,\nsuch as Tersoff and\nStillinger-Weber cannot be used.  EAM\npotentials only include the pair potential portion of the EAM\ninteraction when used by this compute, not the embedding term.  Also\nbonded or Kspace interactions do not contribute to this compute.\nThe computes in this package are not compatible with dynamic groups."
},
{
    "command": "compute tdpd/cc/atom",
    "html_filename": "compute_tdpd_cc_atom.html",
    "short_description": "Define a computation that calculates the per-atom chemical concentration of a specified species for each tDPD particle in a group",
    "description": "Define a computation that calculates the per-atom chemical\nconcentration of a specified species for each tDPD particle in a\ngroup.\nThe chemical concentration of each species is defined as the number of\nmolecules carried by a tDPD particle for dilute solution.  For more\ndetails see (Li2015).\nOutput info:\nThis compute calculates a per-atom vector, which can be accessed by\nany command that uses per-atom values from a compute as input. See the\nHowto output doc page for an overview of LAMMPS\noutput options.\nThe per-atom vector values will be in the units of chemical species\nper unit mass.",
    "syntax": "compute ID group-ID tdpd/cc/atom index",
    "parameters": " * ID, group-ID are documented in compute command\n * tdpd/cc/atom = style name of this compute command\n * index = index of chemical species (1 to Nspecies)",
    "examples": "compute 1 all tdpd/cc/atom 2",
    "restrictions": "This compute is part of the USER-MESO package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute temp",
    "html_filename": "compute_temp.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms",
    "description": "Define a computation that calculates the temperature of a group of\natoms.  A compute of this style can be used by any command that\ncomputes a temperature, e.g. thermo_modify, fix temp/rescale, fix npt, etc.\nThe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = 2 or 3 = dimensionality of the simulation, N = number of atoms\nin the group, k = Boltzmann constant, and T = temperature.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nA compute of this style with the ID of “thermo_temp” is created when\nLAMMPS starts up, as if this command were in the input script:\ncompute thermo_temp all temp\n\n\nSee the “thermo_style” command for more details.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp",
    "parameters": " * ID, group-ID are documented in compute command\n * temp = style name of this compute command",
    "examples": "compute 1 all temp\ncompute myTemp mobile temp",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/asphere",
    "html_filename": "compute_temp_asphere.html",
    "short_description": "Define a computation that calculates the temperature of a group of aspherical particles, including a contribution from both their translational and rotational kinetic energy",
    "description": "Define a computation that calculates the temperature of a group of\naspherical particles, including a contribution from both their\ntranslational and rotational kinetic energy.  This differs from the\nusual compute temp command, which assumes point\nparticles with only translational kinetic energy.\nOnly finite-size particles (aspherical or spherical) can be included\nin the group.  For 3d finite-size particles, each has 6 degrees of\nfreedom (3 translational, 3 rotational).  For 2d finite-size\nparticles, each has 3 degrees of freedom (2 translational, 1\nrotational).\n\nNote\nThis choice for degrees of freedom (dof) assumes that all\nfinite-size aspherical or spherical particles in your model will\nfreely rotate, sampling all their rotational dof.  It is possible to\nuse a combination of interaction potentials and fixes that induce no\ntorque or otherwise constrain some of all of your particles so that\nthis is not the case.  Then there are less dof and you should use the\ncompute_modify extra command to adjust the dof\naccordingly.\n\nFor example, an aspherical particle with all three of its shape\nparameters the same is a sphere.  If it does not rotate, then it\nshould have 3 dof instead of 6 in 3d (or 2 instead of 3 in 2d).  A\nuniaxial aspherical particle has two of its three shape parameters the\nsame.  If it does not rotate around the axis perpendicular to its\ncircular cross section, then it should have 5 dof instead of 6 in 3d.\nThe latter is the case for uniaxial ellipsoids in a GayBerne model since there is no induced torque around the\noptical axis.  It will also be the case for bi-axial ellipsoids when\nexactly two of the semiaxes have the same length and the corresponding\nrelative well depths are equal.\nThe translational kinetic energy is computed the same as is described\nby the compute temp command.  The rotational\nkinetic energy is computed as 1/2 I w^2, where I is the inertia tensor\nfor the aspherical particle and w is its angular velocity, which is\ncomputed from its angular momentum.\n\nNote\nFor 2d models, particles are treated as\nellipsoids, not ellipses, meaning their moments of inertia will be the\nsame as in 3d.\n\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute.  The formula for the components of the\ntensor is the same as the above formula, except that v^2 and w^2 are\nreplaced by vx*vy and wx*wy for the xy component, and the appropriate\nelements of the inertia tensor are used.  The 6 components of the\nvector are ordered xx, yy, zz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThis compute subtracts out translational degrees-of-freedom due to\nfixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\ntemperature of groups of atoms that include these constraints will be\ncomputed correctly.  If needed, the subtracted degrees-of-freedom can\nbe altered using the extra option of the\ncompute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nThe keyword/value option pairs are used in the following ways.\nFor the bias keyword, bias-ID refers to the ID of a temperature\ncompute that removes a “bias” velocity from each atom.  This allows\ncompute temp/sphere to compute its thermal temperature after the\ntranslational kinetic energy components have been altered in a\nprescribed way, e.g. to remove a flow velocity profile.  Thermostats\nthat use this compute will work with this bias term.  See the doc\npages for individual computes that calculate a temperature and the doc\npages for fixes that perform thermostatting for more details.\nFor the dof keyword, a setting of all calculates a temperature\nthat includes both translational and rotational degrees of freedom.  A\nsetting of rotate calculates a temperature that includes only\nrotational degrees of freedom.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/asphere keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/asphere = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = bias or dof\n * bias value = bias-ID\n *   bias-ID = ID of a temperature compute that removes a velocity bias\n * dof value = all or rotate\n *   all = compute temperature of translational and rotational degrees of freedom\n *   rotate = compute temperature of just rotational degrees of freedom",
    "examples": "compute 1 all temp/asphere\ncompute myTemp mobile temp/asphere bias tempCOM\ncompute myTemp mobile temp/asphere dof rotate",
    "restrictions": "This compute is part of the ASPHERE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis compute requires that atoms store angular momentum and a\nquaternion as defined by the atom_style ellipsoid\ncommand.\nAll particles in the group must be finite-size.  They cannot be point\nparticles, but they can be aspherical or spherical as defined by their\nshape attribute."
},
{
    "command": "compute temp/body",
    "html_filename": "compute_temp_body.html",
    "short_description": "Define a computation that calculates the temperature of a group of body particles, including a contribution from both their translational and rotational kinetic energy",
    "description": "Define a computation that calculates the temperature of a group of\nbody particles, including a contribution from both their\ntranslational and rotational kinetic energy.  This differs from the\nusual compute temp command, which assumes point\nparticles with only translational kinetic energy.\nOnly body particles can be included in the group.  For 3d particles,\neach has 6 degrees of freedom (3 translational, 3 rotational).  For 2d\nbody particles, each has 3 degrees of freedom (2 translational, 1\nrotational).\n\nNote\nThis choice for degrees of freedom (dof) assumes that all body\nparticles in your model will freely rotate, sampling all their\nrotational dof.  It is possible to use a combination of interaction\npotentials and fixes that induce no torque or otherwise constrain some\nof all of your particles so that this is not the case.  Then there are\nless dof and you should use the compute_modify extra command to adjust the dof accordingly.\n\nThe translational kinetic energy is computed the same as is described\nby the compute temp command.  The rotational\nkinetic energy is computed as 1/2 I w^2, where I is the inertia tensor\nfor the aspherical particle and w is its angular velocity, which is\ncomputed from its angular momentum.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute.  The formula for the components of the\ntensor is the same as the above formula, except that v^2 and w^2 are\nreplaced by vx*vy and wx*wy for the xy component, and the appropriate\nelements of the inertia tensor are used.  The 6 components of the\nvector are ordered xx, yy, zz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThis compute subtracts out translational degrees-of-freedom due to\nfixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\ntemperature of groups of atoms that include these constraints will be\ncomputed correctly.  If needed, the subtracted degrees-of-freedom can\nbe altered using the extra option of the\ncompute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nThe keyword/value option pairs are used in the following ways.\nFor the bias keyword, bias-ID refers to the ID of a temperature\ncompute that removes a “bias” velocity from each atom.  This allows\ncompute temp/sphere to compute its thermal temperature after the\ntranslational kinetic energy components have been altered in a\nprescribed way, e.g. to remove a flow velocity profile.  Thermostats\nthat use this compute will work with this bias term.  See the doc\npages for individual computes that calculate a temperature and the doc\npages for fixes that perform thermostatting for more details.\nFor the dof keyword, a setting of all calculates a temperature\nthat includes both translational and rotational degrees of freedom.  A\nsetting of rotate calculates a temperature that includes only\nrotational degrees of freedom.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/body keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/body = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = bias or dof\n * bias value = bias-ID\n *   bias-ID = ID of a temperature compute that removes a velocity bias\n * dof value = all or rotate\n *   all = compute temperature of translational and rotational degrees of freedom\n *   rotate = compute temperature of just rotational degrees of freedom",
    "examples": "compute 1 all temp/body\ncompute myTemp mobile temp/body bias tempCOM\ncompute myTemp mobile temp/body dof rotate",
    "restrictions": "This compute is part of the BODY package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis compute requires that atoms store angular momentum and a\nquaternion as defined by the atom_style body\ncommand."
},
{
    "command": "compute temp/chunk",
    "html_filename": "compute_temp_chunk.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms that are also in chunks, after optionally subtracting out the center-of-mass velocity of each chunk",
    "description": "Define a computation that calculates the temperature of a group of\natoms that are also in chunks, after optionally subtracting out the\ncenter-of-mass velocity of each chunk.  By specifying optional values,\nit can also calculate the per-chunk temperature or energies of the\nmultiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThe temperature is calculated by the formula KE = DOF/2 k T, where KE =\ntotal kinetic energy of all atoms assigned to chunks (sum of 1/2 m\nv^2), DOF = the total number of degrees of freedom for those atoms, k\n= Boltzmann constant, and T = temperature.\nThe DOF is calculated as N*adof + Nchunk*cdof, where N = number of\natoms contributing to the KE, adof = degrees of freedom per atom, and\ncdof = degrees of freedom per chunk.  By default adof = 2 or 3 =\ndimensionality of system, as set via the dimension\ncommand, and cdof = 0.0.  This gives the usual formula for\ntemperature.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nNote that the number of atoms contributing to the temperature is\ncalculated each time the temperature is evaluated since it is assumed\nthe atoms may be dynamically assigned to chunks.  Thus there is no\nneed to use the dynamic option of the\ncompute_modify command for this compute style.\nIf any optional values are specified, then per-chunk quantities are\nalso calculated and stored in a global array, as described below.\nThe temp value calculates the temperature for each chunk by the\nformula KE = DOF/2 k T, where KE = total kinetic energy of the chunk\nof atoms (sum of 1/2 m v^2), DOF = the total number of degrees of\nfreedom for all atoms in the chunk, k = Boltzmann constant, and T =\ntemperature.\nThe DOF in this case is calculated as N*adof + cdof, where N = number\nof atoms in the chunk, adof = degrees of freedom per atom, and cdof =\ndegrees of freedom per chunk.  By default adof = 2 or 3 =\ndimensionality of system, as set via the dimension\ncommand, and cdof = 0.0.  This gives the usual formula for\ntemperature.\nThe kecom value calculates the kinetic energy of each chunk as if\nall its atoms were moving with the velocity of the center-of-mass of\nthe chunk.\nThe internal value calculates the internal kinetic energy of each\nchunk.  The interal KE is summed over the atoms in the chunk using an\ninternal “thermal” velocity for each atom, which is its velocity minus\nthe center-of-mass velocity of the chunk.\n\nNote that currently the global and per-chunk temperatures calculated\nby this compute only include translational degrees of freedom for each\natom.  No rotational degrees of freedom are included for finite-size\nparticles.  Also no degrees of freedom are subtracted for any velocity\nbias or constraints that are applied, such as compute temp/partial, or fix shake\nor fix rigid.  This is because those degrees of\nfreedom (e.g. a constrained bond) could apply to sets of atoms that\nare both included and excluded from a specific chunk, and hence the\nconcept is somewhat ill-defined.  In some cases, you can use the\nadof and cdof keywords to adjust the calculated degrees of freedom\nappropriately, as explained below.\nNote that the per-chunk temperature calculated by this compute and the\nfix ave/chunk temp command can be different.\nThis compute calculates the temperature for each chunk for a single\nsnapshot.  Fix ave/chunk can do that but can also time average those\nvalues over many snapshots, or it can compute a temperature as if the\natoms in the chunk on different timesteps were collected together as\none set of atoms to calculate their temperature.  This compute allows\nthe center-of-mass velocity of each chunk to be subtracted before\ncalculating the temperature; fix ave/chunk does not.\n\nNote\nOnly atoms in the specified group contribute to the calculations\nperformed by this compute.  The compute chunk/atom command defines its own group;\natoms will have a chunk ID = 0 if they are not in that group,\nsignifying they are not assigned to a chunk, and will thus also not\ncontribute to this calculation.  You can specify the “all” group for\nthis command if you simply want to include atoms with non-zero chunk\nIDs.\n\nThe simplest way to output the per-chunk results of the compute\ntemp/chunk calculation to a file is to use the fix ave/time command, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all temp/chunk cc1 temp\nfix 1 all ave/time 100 1 100 c_myChunk file tmp.out mode vector\n\n\n\nThe keyword/value option pairs are used in the following ways.\nThe com keyword can be used with a value of yes to subtract the\nvelocity of the center-of-mass for each chunk from the velocity of the\natoms in that chunk, before calculating either the global or per-chunk\ntemperature.  This can be useful if the atoms are streaming or\notherwise moving collectively, and you wish to calculate only the\nthermal temperature.\nFor the bias keyword, bias-ID refers to the ID of a temperature\ncompute that removes a “bias” velocity from each atom.  This also\nallows calculation of the global or per-chunk temperature using only\nthe thermal temperature of atoms in each chunk after the translational\nkinetic energy components have been altered in a prescribed way,\ne.g. to remove a velocity profile.  It also applies to the calculation\nof the other per-chunk values, such as kecom or internal, which\ninvolve the center-of-mass velocity of each chunk, which is calculated\nafter the velocity bias is removed from each atom.  Note that the\ntemperature compute will apply its bias globally to the entire system,\nnot on a per-chunk basis.\nThe adof and cdof keywords define the values used in the degree of\nfreedom (DOF) formulas used for the global or per-chunk temperature,\nas described above.  They can be used to calculate a more appropriate\ntemperature for some kinds of chunks.  Here are 3 examples:\nIf spatially binned chunks contain some number of water molecules and\nfix shake is used to make each molecule rigid, then\nyou could calculate a temperature with 6 degrees of freedom (DOF) (3\ntranslational, 3 rotational) per molecule by setting adof to 2.0.\nIf compute temp/partial is used with the\nbias keyword to only allow the x component of velocity to contribute\nto the temperature, then adof = 1.0 would be appropriate.\nIf each chunk consists of a large molecule, with some number of its\nbonds constrained by fix shake or the entire molecule\nby fix rigid/small, adof = 0.0 and cdof could be\nset to the remaining degrees of freedom for the entire molecule\n(entire chunk in this case), e.g. 6 for 3d, or 3 for 2d, for a rigid\nmolecule.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThis compute also optionally calculates a global array, if one or more\nof the optional values are specified.  The number of rows in the array\n= the number of chunks Nchunk as calculated by the specified\ncompute chunk/atom command.  The number of\ncolumns is the number of specified values (1 or more).  These values\ncan be accessed by any command that uses global array values from a\ncompute as input.  Again, see the Howto output doc\npage for an overview of LAMMPS output options.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.  The array values are “intensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.  The array values\nwill be in temperature units for the temp value, and in\nenergy units for the kecom and internal values.",
    "syntax": "compute ID group-ID temp/chunk chunkID value1 value2 ... keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command\n * zero or more values can be listed as value1,value2,etc\n * value = temp or kecom or internal\n * temp = temperature of each chunk\n * kecom = kinetic energy of each chunk based on velocity of center of mass\n * internal = internal kinetic energy of each chunk\n * zero or more keyword/value pairs may be appended\n * keyword = com or bias or adof or cdof\n * com value = yes or no\n *   yes = subtract center-of-mass velocity from each chunk before calculating temperature\n *   no = do not subtract center-of-mass velocity\n * bias value = bias-ID\n *   bias-ID = ID of a temperature compute that removes a velocity bias\n * adof value = dof_per_atom\n *   dof_per_atom = define this many degrees-of-freedom per atom\n * cdof value = dof_per_chunk\n *   dof_per_chunk = define this many degrees-of-freedom per chunk",
    "examples": "compute 1 fluid temp/chunk molchunk\ncompute 1 fluid temp/chunk molchunk temp internal\ncompute 1 fluid temp/chunk molchunk bias tpartial adof 2.0",
    "restrictions": "The com and bias keywords cannot be used together."
},
{
    "command": "compute temp/com",
    "html_filename": "compute_temp_com.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after subtracting out the center-of-mass velocity of the group",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after subtracting out the center-of-mass velocity of the group.\nThis is useful if the group is expected to have a non-zero net\nvelocity for some reason.  A compute of this style can be used by any\ncommand that computes a temperature,\ne.g. thermo_modify, fix temp/rescale, fix npt, etc.\nAfter the center-of-mass velocity has been subtracted from each atom,\nthe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = 2 or 3 = dimensionality of the simulation, N = number of atoms\nin the group, k = Boltzmann constant, and T = temperature.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of the center-of-mass velocity by this fix is essentially\ncomputing the temperature after a “bias” has been removed from the\nvelocity of the atoms.  If this compute is used with a fix command\nthat performs thermostatting then this bias will be subtracted from\neach atom, thermostatting of the remaining thermal velocity will be\nperformed, and the bias will be added back in.  Thermostatting fixes\nthat work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/com",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/com = style name of this compute command",
    "examples": "compute 1 all temp/com\ncompute myTemp mobile temp/com",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/cs",
    "html_filename": "compute_temp_cs.html",
    "short_description": "Define a computation that calculates the temperature of a system based on the center-of-mass velocity of atom pairs that are bonded to each other",
    "description": "Define a computation that calculates the temperature of a system based\non the center-of-mass velocity of atom pairs that are bonded to each\nother.  This compute is designed to be used with the adiabatic\ncore/shell model of (Mitchell and Finchham).  See\nthe Howto coreshell doc page for an overview of\nthe model as implemented in LAMMPS.  Specifically, this compute\nenables correct temperature calculation and thermostatting of\ncore/shell pairs where it is desirable for the internal degrees of\nfreedom of the core/shell pairs to not be influenced by a thermostat.\nA compute of this style can be used by any command that computes a\ntemperature via fix_modify e.g. fix temp/rescale, fix npt, etc.\nNote that this compute does not require all ions to be polarized,\nhence defined as core/shell pairs.  One can mix core/shell pairs and\nions without a satellite particle if desired. The compute will\nconsider the non-polarized ions according to the physical system.\nFor this compute, core and shell particles are specified by two\nrespective group IDs, which can be defined using the\ngroup command.  The number of atoms in the two groups\nmust be the same and there should be one bond defined between a pair\nof atoms in the two groups.  Non-polarized ions which might also be\nincluded in the treated system should not be included into either of\nthese groups, they are taken into account by the group-ID (2nd\nargument) of the compute.\nThe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = 2 or 3 = dimensionality of the simulation, N = number of atoms\nin the group, k = Boltzmann constant, and T = temperature.  Note that\nthe velocity of each core or shell atom used in the KE calculation is\nthe velocity of the center-of-mass (COM) of the core/shell pair the\natom is part of.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.  In contrast to the temperature, the velocity of\neach core or shell atom is taken individually.\nThe change this fix makes to core/shell atom velocities is essentially\ncomputing the temperature after a “bias” has been removed from the\nvelocity of the atoms.  This “bias” is the velocity of the atom\nrelative to the COM velocity of the core/shell pair.  If this compute\nis used with a fix command that performs thermostatting then this bias\nwill be subtracted from each atom, thermostatting of the remaining COM\nvelocity will be performed, and the bias will be added back in.  This\nmeans the thermostatting will effectively be performed on the\ncore/shell pairs, instead of on the individual core and shell atoms.\nThermostatting fixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThe internal energy of core/shell pairs can be calculated by the\ncompute temp/chunk command, if chunks are\ndefined as core/shell pairs.  See the Howto coreshell doc page doc page for more discussion\non how to do this.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/cs group1 group2",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/cs = style name of this compute command\n * group1 = group-ID of either cores or shells\n * group2 = group-ID of either shells or cores",
    "examples": "compute oxygen_c-s all temp/cs O_core O_shell\ncompute core_shells all temp/cs cores shells",
    "restrictions": "The number of core/shell pairs contributing to the temperature is\nassumed to be constant for the duration of the run.  No fixes should\nbe used which generate new molecules or atoms during a simulation."
},
{
    "command": "compute temp/deform",
    "html_filename": "compute_temp_deform.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after subtracting out a streaming velocity induced by the simulation box changing size and/or shape, for example in a non-equilibrium MD (NEMD) simulation",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after subtracting out a streaming velocity induced by the\nsimulation box changing size and/or shape, for example in a\nnon-equilibrium MD (NEMD) simulation.  The size/shape change is\ninduced by use of the fix deform command.  A compute\nof this style is created by the fix nvt/sllod\ncommand to compute the thermal temperature of atoms for thermostatting\npurposes.  A compute of this style can also be used by any command\nthat computes a temperature, e.g. thermo_modify,\nfix temp/rescale, fix npt, etc.\nThe deformation fix changes the box size and/or shape over time, so\neach atom in the simulation box can be thought of as having a\n“streaming” velocity.  For example, if the box is being sheared in x,\nrelative to y, then atoms at the bottom of the box (low y) have a\nsmall x velocity, while atoms at the top of the box (hi y) have a\nlarge x velocity.  This position-dependent streaming velocity is\nsubtracted from each atom’s actual velocity to yield a thermal\nvelocity which is used to compute the temperature.\n\nNote\nFix deform has an option for remapping either\natom coordinates or velocities to the changing simulation box.  When\nusing this compute in conjunction with a deforming box, fix deform\nshould NOT remap atom positions, but rather should let atoms respond\nto the changing box by adjusting their own velocities (or let fix deform remap the atom velocities, see it’s remap\noption).  If fix deform does remap atom positions, then they appear to\nmove with the box but their velocity is not changed, and thus they do\nNOT have the streaming velocity assumed by this compute.  LAMMPS will\nwarn you if fix deform is defined and its remap setting is not\nconsistent with this compute.\n\nAfter the streaming velocity has been subtracted from each atom, the\ntemperature is calculated by the formula KE = dim/2 N k T, where KE =\ntotal kinetic energy of the group of atoms (sum of 1/2 m v^2), dim = 2\nor 3 = dimensionality of the simulation, N = number of atoms in the\ngroup, k = Boltzmann constant, and T = temperature.  Note that v in\nthe kinetic energy formula is the atom’s thermal velocity.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of the box deformation velocity component by this fix is\nessentially computing the temperature after a “bias” has been removed\nfrom the velocity of the atoms.  If this compute is used with a fix\ncommand that performs thermostatting then this bias will be subtracted\nfrom each atom, thermostatting of the remaining thermal velocity will\nbe performed, and the bias will be added back in.  Thermostatting\nfixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n\nNote\nThe temperature calculated by this compute is only accurate if\nthe atoms are indeed moving with a stream velocity profile that\nmatches the box deformation.  If not, then the compute will subtract\noff an incorrect stream velocity, yielding a bogus thermal\ntemperature.  You should NOT assume that your atoms are streaming at\nthe same rate the box is deforming.  Rather, you should monitor their\nvelocity profile, e.g. via the fix ave/chunk\ncommand.  And you can compare the results of this compute to compute temp/profile, which actually calculates the\nstream profile before subtracting it.  If the two computes do not give\nroughly the same temperature, then your atoms are not streaming\nconsistent with the box deformation.  See the fix deform command for more details on ways to get atoms\nto stream consistently with the box deformation.\n\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/deform",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/deform = style name of this compute command",
    "examples": "compute myTemp all temp/deform",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/deform/eff",
    "html_filename": "compute_temp_deform_eff.html",
    "short_description": "Define a computation that calculates the temperature of a group of nuclei and electrons in the electron force field model, after subtracting out a streaming velocity induced by the simulation box changing size and/or shape, for example in a non-equilibrium MD (NEMD) simulation",
    "description": "Define a computation that calculates the temperature of a group of\nnuclei and electrons in the electron force field\nmodel, after subtracting out a streaming velocity induced by the\nsimulation box changing size and/or shape, for example in a\nnon-equilibrium MD (NEMD) simulation.  The size/shape change is\ninduced by use of the fix deform command.  A\ncompute of this style is created by the fix nvt/sllod/eff command to compute the thermal\ntemperature of atoms for thermostatting purposes.  A compute of this\nstyle can also be used by any command that computes a temperature,\ne.g. thermo_modify, fix npt/eff,\netc.\nThe calculation performed by this compute is exactly like that\ndescribed by the compute temp/deform\ncommand, except that the formula for the temperature includes the\nradial electron velocity contributions, as discussed by the compute temp/eff command.  Note that only the\ntranslational degrees of freedom for each nuclei or electron are\naffected by the streaming velocity adjustment.  The radial velocity\ncomponent of the electrons is not affected.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/deform/eff",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/deform/eff = style name of this compute command",
    "examples": "compute myTemp all temp/deform/eff",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute temp/drude",
    "html_filename": "compute_temp_drude.html",
    "short_description": "Define a computation that calculates the temperatures of core-Drude pairs",
    "description": "Define a computation that calculates the temperatures of core-Drude\npairs. This compute is designed to be used with the thermalized Drude oscillator model.  Polarizable models in LAMMPS\nare described on the Howto polarizable doc\npage.\nDrude oscillators consist of a core particle and a Drude particle\nconnected by a harmonic bond, and the relative motion of these Drude\noscillators is usually maintained cold by a specific thermostat that\nacts on the relative motion of the core-Drude particle\npairs. Therefore, because LAMMPS considers Drude particles as normal\natoms in its default temperature compute (compute temp command), the reduced temperature of the\ncore-Drude particle pairs is not calculated correctly.\nBy contrast, this compute calculates the temperature of the cores\nusing center-of-mass velocities of the core-Drude pairs, and the\nreduced temperature of the Drude particles using the relative\nvelocities of the Drude particles with respect to their cores.\nNon-polarizable atoms are considered as cores.  Their velocities\ncontribute to the temperature of the cores.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6, which can be accessed by indices 1-6, whose components\nare\n\ntemperature of the centers of mass (temperature units)\ntemperature of the dipoles (temperature units)\nnumber of degrees of freedom of the centers of mass\nnumber of degrees of freedom of the dipoles\nkinetic energy of the centers of mass (energy units)\nkinetic energy of the dipoles (energy units)\n\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nBoth the scalar value and the first two values of the vector\ncalculated by this compute are “intensive”.  The other 4 vector values\nare “extensive”.",
    "syntax": "compute ID group-ID temp/drude",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/drude = style name of this compute command",
    "examples": "compute TDRUDE all temp/drude",
    "restrictions": "The number of degrees of freedom contributing to the temperature is\nassumed to be constant for the duration of the run unless the\nfix_modify command sets the option dynamic yes."
},
{
    "command": "compute temp/eff",
    "html_filename": "compute_temp_eff.html",
    "short_description": "Define a computation that calculates the temperature of a group of nuclei and electrons in the electron force field model",
    "description": "Define a computation that calculates the temperature of a group of\nnuclei and electrons in the electron force field\nmodel.  A compute of this style can be used by commands that compute a\ntemperature, e.g. thermo_modify, fix npt/eff, etc.\nThe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2 for\nnuclei and sum of 1/2 (m v^2 + 3/4 m s^2) for electrons, where s\nincludes the radial electron velocity contributions), dim = 2 or 3 =\ndimensionality of the simulation, N = number of atoms (only total\nnumber of nuclei in the eFF (see the pair_eff\ncommand) in the group, k = Boltzmann constant, and T = temperature.\nThis expression is summed over all nuclear and electronic degrees of\nfreedom, essentially by setting the kinetic contribution to the heat\ncapacity to 3/2k (where only nuclei contribute). This subtlety is\nvalid for temperatures well below the Fermi temperature, which for\ndensities two to five times the density of liquid H2 ranges from\n86,000 to 170,000 K.\n\nNote\nFor eFF models, in order to override the default temperature\nreported by LAMMPS in the thermodynamic quantities reported via the\nthermo command, the user should apply a\nthermo_modify command, as shown in the following\nexample:\n\ncompute         effTemp all temp/eff\nthermo_style    custom step etotal pe ke temp press\nthermo_modify   temp effTemp\n\n\nA 6-component kinetic energy tensor is also calculated by this compute\nfor use in the computation of a pressure tensor.  The formula for the\ncomponents of the tensor is the same as the above formula, except that\nv^2 is replaced by vx * vy for the xy component, etc.  For the eFF,\nagain, the radial electronic velocities are also considered.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThe scalar value calculated by this compute is “intensive”, meaning it\nis independent of the number of atoms in the simulation.  The vector\nvalues are “extensive”, meaning they scale with the number of atoms in\nthe simulation.",
    "syntax": "compute ID group-ID temp/eff",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/eff = style name of this compute command",
    "examples": "compute 1 all temp/eff\ncompute myTemp mobile temp/eff",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute temp/partial",
    "html_filename": "compute_temp_partial.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after excluding one or more velocity components",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after excluding one or more velocity components.  A compute of\nthis style can be used by any command that computes a temperature,\ne.g. thermo_modify, fix temp/rescale, fix npt, etc.\nThe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = dimensionality of the simulation, N = number of atoms in the\ngroup, k = Boltzmann constant, and T = temperature.  The calculation\nof KE excludes the x, y, or z dimensions if xflag, yflag, or zflag =\n0.  The dim parameter is adjusted to give the correct number of\ndegrees of freedom.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the calculation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of velocity components by this fix is essentially\ncomputing the temperature after a “bias” has been removed from the\nvelocity of the atoms.  If this compute is used with a fix command\nthat performs thermostatting then this bias will be subtracted from\neach atom, thermostatting of the remaining thermal velocity will be\nperformed, and the bias will be added back in.  Thermostatting fixes\nthat work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/partial xflag yflag zflag",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/partial = style name of this compute command\n * xflag,yflag,zflag = 0/1 for whether to exclude/include this dimension",
    "examples": "compute newT flow temp/partial 1 1 0",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/profile",
    "html_filename": "compute_temp_profile.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after subtracting out a spatially-averaged center-of-mass velocity field, before computing the kinetic energy",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after subtracting out a spatially-averaged center-of-mass\nvelocity field, before computing the kinetic energy.  This can be\nuseful for thermostatting a collection of atoms undergoing a complex\nflow, e.g. via a profile-unbiased thermostat (PUT) as described in\n(Evans).  A compute of this style can be used by any command\nthat computes a temperature, e.g. thermo_modify,\nfix temp/rescale, fix npt, etc.\nThe xflag, yflag, zflag settings determine which components of\naverage velocity are subtracted out.\nThe binstyle setting and its Nx, Ny, Nz arguments determine\nhow bins are setup to perform spatial averaging.  “Bins” can be 1d\nslabs, 2d pencils, or 3d bricks depending on which binstyle is used.\nThe simulation box is partitioned conceptually into Nx by Ny by\nNz bins.  Depending on the binstyle, you may only specify one or\ntwo of these values; the others are effectively set to 1 (no binning\nin that dimension).  For non-orthogonal (triclinic) simulation boxes,\nthe bins are “tilted” slabs or pencils or bricks that are parallel to\nthe tilted faces of the box.  See the region prism\ncommand for a discussion of the geometry of tilted boxes in LAMMPS.\nWhen a temperature is computed, the center-of-mass velocity for the\nset of atoms that are both in the compute group and in the same\nspatial bin is calculated.  This bias velocity is then subtracted from\nthe velocities of individual atoms in the bin to yield a thermal\nvelocity for each atom.  Note that if there is only one atom in the\nbin, its thermal velocity will thus be 0.0.\nAfter the spatially-averaged velocity field has been subtracted from\neach atom, the temperature is calculated by the formula KE = (dim*N\n- dim*Nx*Ny*Nz) k T/2, where KE = total kinetic energy of the group of\natoms (sum of 1/2 m v^2), dim = 2 or 3 = dimensionality of the\nsimulation, N = number of atoms in the group, k = Boltzmann constant,\nand T = temperature.  The dim*Nx*Ny*Nz term are degrees of freedom\nsubtracted to adjust for the removal of the center-of-mass velocity in\neach of Nx*Ny*Nz bins, as discussed in the (Evans) paper.\nIf the out keyword is used with a tensor value, which is the\ndefault, a kinetic energy tensor, stored as a 6-element vector, is\nalso calculated by this compute for use in the computation of a\npressure tensor.  The formula for the components of the tensor is the\nsame as the above formula, except that v^2 is replaced by vx*vy for\nthe xy component, etc.  The 6 components of the vector are ordered xx,\nyy, zz, xy, xz, yz.\nIf the out keyword is used with a bin value, the count of atoms\nand computed temperature for each bin are stored for output, as an\narray of values, as described below.  The temperature of each bin is\ncalculated as described above, where the bias velocity is subtracted\nand only the remaining thermal velocity of atoms in the bin\ncontributes to the temperature.  See the note below for how the\ntemperature is normalized by the degrees-of-freedom of atoms in the\nbin.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of the spatially-averaged velocity field by this fix is\nessentially computing the temperature after a “bias” has been removed\nfrom the velocity of the atoms.  If this compute is used with a fix\ncommand that performs thermostatting then this bias will be subtracted\nfrom each atom, thermostatting of the remaining thermal velocity will\nbe performed, and the bias will be added back in.  Thermostatting\nfixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\n\nNote\nWhen using the out keyword with a value of bin, the\ncalculated temperature for each bin does not include the\ndegrees-of-freedom adjustment described in the preceding paragraph,\nfor fixes that constrain molecular motion.  It does include the\nadjustment due to the extra option, which is applied to each bin.\n\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.  Using this compute in conjunction with a\nthermostatting fix, as explained there, will effectively implement a\nprofile-unbiased thermostat (PUT), as described in (Evans).\nOutput info:\nThis compute calculates a global scalar (the temperature).  Depending\non the setting of the out keyword, it also calculates a global\nvector or array.  For out = tensor, it calculates a vector of\nlength 6 (KE tensor), which can be accessed by indices 1-6.  For out\n= bin it calculates a global array which has 2 columns and N rows,\nwhere N is the number of bins.  The first column contains the number\nof atoms in that bin.  The second contains the temperature of that\nbin, calculated as described above.  The ordering of rows in the array\nis as follows.  Bins in x vary fastest, then y, then z.  Thus for a\n10x10x10 3d array of bins, there will be 1000 rows.  The bin with\nindices ix,iy,iz = 2,3,4 would map to row M = (iz-1)*10*10 + (iy-1)*10\n+ ix = 322, where the rows are numbered from 1 to 1000 and the bin\nindices are numbered from 1 to 10 in each dimension.\nThese values can be used by any command that uses global scalar or\nvector or array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.  The array values are “intensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.  The first column\nof array values are counts; the values in the second column will be in\ntemperature units.",
    "syntax": "compute ID group-ID temp/profile xflag yflag zflag binstyle args",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/profile = style name of this compute command\n * xflag,yflag,zflag = 0/1 for whether to exclude/include this dimension\n * binstyle = x or y or z or xy or yz or xz or xyz\n * x arg = Nx\n * y arg = Ny\n * z arg = Nz\n * xy args = Nx Ny\n * yz args = Ny Nz\n * xz args = Nx Nz\n * xyz args = Nx Ny Nz\n *   Nx,Ny,Nz = number of velocity bins in x,y,z dimensions\n * zero or more keyword/value pairs may be appended\n * keyword = out\n * out value = tensor or bin",
    "examples": "compute myTemp flow temp/profile 1 1 1 x 10\ncompute myTemp flow temp/profile 1 1 1 x 10 out bin\ncompute myTemp flow temp/profile 0 1 1 xyz 20 20 20",
    "restrictions": "You should not use too large a velocity-binning grid, especially in\n3d.  In the current implementation, the binned velocity averages are\nsummed across all processors, so this will be inefficient if the grid\nis too large, and the operation is performed every timestep, as it\nwill be for most thermostats."
},
{
    "command": "compute temp/ramp",
    "html_filename": "compute_temp_ramp.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after subtracting out an ramped velocity profile before computing the kinetic energy",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after subtracting out an ramped velocity profile before\ncomputing the kinetic energy.  A compute of this style can be used by\nany command that computes a temperature,\ne.g. thermo_modify, fix temp/rescale, fix npt, etc.\nThe meaning of the arguments for this command which define the\nvelocity ramp are the same as for the velocity ramp\ncommand which was presumably used to impose the velocity.\nAfter the ramp velocity has been subtracted from the specified\ndimension for each atom, the temperature is calculated by the formula\nKE = dim/2 N k T, where KE = total kinetic energy of the group of\natoms (sum of 1/2 m v^2), dim = 2 or 3 = dimensionality of the\nsimulation, N = number of atoms in the group, k = Boltzmann constant,\nand T = temperature.\nThe units keyword determines the meaning of the distance units used\nfor coordinates (c1,c2) and velocities (vlo,vhi).  A box value\nselects standard distance units as defined by the units\ncommand, e.g. Angstroms for units = real or metal.  A lattice value\nmeans the distance units are in lattice spacings; e.g. velocity =\nlattice spacings / tau.  The lattice command must have\nbeen previously used to define the lattice spacing.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of the ramped velocity component by this fix is\nessentially computing the temperature after a “bias” has been removed\nfrom the velocity of the atoms.  If this compute is used with a fix\ncommand that performs thermostatting then this bias will be subtracted\nfrom each atom, thermostatting of the remaining thermal velocity will\nbe performed, and the bias will be added back in.  Thermostatting\nfixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/ramp vdim vlo vhi dim clo chi keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/ramp = style name of this compute command\n * vdim = vx or vy or vz\n * vlo,vhi = subtract velocities between vlo and vhi (velocity units)\n * dim = x or y or z\n * clo,chi = lower and upper bound of domain to subtract from (distance units)\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = lattice or box",
    "examples": "compute 2nd middle temp/ramp vx 0 8 y 2 12 units lattice",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/region",
    "html_filename": "compute_temp_region.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms in a geometric region",
    "description": "Define a computation that calculates the temperature of a group of\natoms in a geometric region.  This can be useful for thermostatting\none portion of the simulation box.  E.g. a McDLT simulation where one\nside is cooled, and the other side is heated.  A compute of this style\ncan be used by any command that computes a temperature,\ne.g. thermo_modify, fix temp/rescale, etc.\nNote that a region-style temperature can be used to thermostat with\nfix temp/rescale or fix langevin, but should probably not be used with\nNose/Hoover style fixes (fix nvt, fix npt, or fix nph), if the\ndegrees-of-freedom included in the computed T varies with time.\nThe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = 2 or 3 = dimensionality of the simulation, N = number of atoms\nin both the group and region, k = Boltzmann constant, and T =\ntemperature.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is calculated each\ntime the temperature is evaluated since it is assumed atoms can\nenter/leave the region.  Thus there is no need to use the dynamic\noption of the compute_modify command for this\ncompute style.\nThe removal of atoms outside the region by this fix is essentially\ncomputing the temperature after a “bias” has been removed, which in\nthis case is the velocity of any atoms outside the region.  If this\ncompute is used with a fix command that performs thermostatting then\nthis bias will be subtracted from each atom, thermostatting of the\nremaining thermal velocity will be performed, and the bias will be\nadded back in.  Thermostatting fixes that work in this way include\nfix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.  This means that when this compute\nis used to calculate the temperature for any of the thermostatting\nfixes via the fix modify temp command, the thermostat\nwill operate only on atoms that are currently in the geometric\nregion.\nUnlike other compute styles that calculate temperature, this compute\ndoes not subtract out degrees-of-freedom due to fixes that constrain\nmotion, such as fix shake and fix rigid.  This is because those degrees of freedom\n(e.g. a constrained bond) could apply to sets of atoms that straddle\nthe region boundary, and hence the concept is somewhat ill-defined.\nIf needed the number of subtracted degrees-of-freedom can be set\nexplicitly using the extra option of the\ncompute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/region region-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/region = style name of this compute command\n * region-ID = ID of region to use for choosing atoms",
    "examples": "compute mine flow temp/region boundary",
    "restrictions": "\nnone"
},
{
    "command": "compute temp/region/eff",
    "html_filename": "compute_temp_region_eff.html",
    "short_description": "Define a computation that calculates the temperature of a group of nuclei and electrons in the electron force field model, within a geometric region using the electron force field",
    "description": "Define a computation that calculates the temperature of a group of\nnuclei and electrons in the electron force field\nmodel, within a geometric region using the electron force field.  A\ncompute of this style can be used by commands that compute a\ntemperature, e.g. thermo_modify.\nThe operation of this compute is exactly like that described by the\ncompute temp/region command, except that\nthe formula for the temperature itself includes the radial electron\nvelocity contributions, as discussed by the compute temp/eff command.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/region/eff region-ID",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/region/eff = style name of this compute command\n * region-ID = ID of region to use for choosing atoms",
    "examples": "compute mine flow temp/region/eff boundary",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute temp/rotate",
    "html_filename": "compute_temp_rotate.html",
    "short_description": "Define a computation that calculates the temperature of a group of atoms, after subtracting out the center-of-mass velocity and angular velocity of the group",
    "description": "Define a computation that calculates the temperature of a group of\natoms, after subtracting out the center-of-mass velocity and angular velocity of the group.\nThis is useful if the group is expected to have a non-zero net\nvelocity and/or global rotation motion for some reason.  A compute of this style can be used by any\ncommand that computes a temperature,\ne.g. thermo_modify, fix temp/rescale, fix npt, etc.\nAfter the center-of-mass velocity and angular velocity has been subtracted from each atom,\nthe temperature is calculated by the formula KE = dim/2 N k T, where\nKE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\ndim = 2 or 3 = dimensionality of the simulation, N = number of atoms\nin the group, k = Boltzmann constant, and T = temperature.\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute for use in the computation of a pressure\ntensor.  The formula for the components of the tensor is the same as\nthe above formula, except that v^2 is replaced by vx*vy for the xy\ncomponent, etc.  The 6 components of the vector are ordered xx, yy,\nzz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThe removal of the center-of-mass velocity and angular velocity by this fix is essentially\ncomputing the temperature after a “bias” has been removed from the\nvelocity of the atoms.  If this compute is used with a fix command\nthat performs thermostatting then this bias will be subtracted from\neach atom, thermostatting of the remaining thermal velocity will be\nperformed, and the bias will be added back in.  Thermostatting fixes\nthat work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\nThis compute subtracts out degrees-of-freedom due to fixes that\nconstrain molecular motion, such as fix shake and\nfix rigid.  This means the temperature of groups of\natoms that include these constraints will be computed correctly.  If\nneeded, the subtracted degrees-of-freedom can be altered using the\nextra option of the compute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/rotate",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/rotate = style name of this compute command",
    "examples": "compute Tbead bead temp/rotate",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute temp/sphere",
    "html_filename": "compute_temp_sphere.html",
    "short_description": "Define a computation that calculates the temperature of a group of spherical particles, including a contribution from both their translational and rotational kinetic energy",
    "description": "Define a computation that calculates the temperature of a group of\nspherical particles, including a contribution from both their\ntranslational and rotational kinetic energy.  This differs from the\nusual compute temp command, which assumes point\nparticles with only translational kinetic energy.\nBoth point and finite-size particles can be included in the group.\nPoint particles do not rotate, so they have only 3 translational\ndegrees of freedom.  For 3d spherical particles, each has 6 degrees of\nfreedom (3 translational, 3 rotational).  For 2d spherical particles,\neach has 3 degrees of freedom (2 translational, 1 rotational).\n\nNote\nThis choice for degrees of freedom (dof) assumes that all\nfinite-size spherical particles in your model will freely rotate,\nsampling all their rotational dof.  It is possible to use a\ncombination of interaction potentials and fixes that induce no torque\nor otherwise constrain some of all of your particles so that this is\nnot the case.  Then there are less dof and you should use the\ncompute_modify extra command to adjust the dof\naccordingly.\n\nThe translational kinetic energy is computed the same as is described\nby the compute temp command.  The rotational\nkinetic energy is computed as 1/2 I w^2, where I is the moment of\ninertia for a sphere and w is the particle’s angular velocity.\n\nNote\nFor 2d models, particles are treated as\nspheres, not disks, meaning their moment of inertia will be the same\nas in 3d.\n\nA kinetic energy tensor, stored as a 6-element vector, is also\ncalculated by this compute.  The formula for the components of the\ntensor is the same as the above formulas, except that v^2 and w^2 are\nreplaced by vx*vy and wx*wy for the xy component.  The 6 components of\nthe vector are ordered xx, yy, zz, xy, xz, yz.\nThe number of atoms contributing to the temperature is assumed to be\nconstant for the duration of the run; use the dynamic option of the\ncompute_modify command if this is not the case.\nThis compute subtracts out translational degrees-of-freedom due to\nfixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\ntemperature of groups of atoms that include these constraints will be\ncomputed correctly.  If needed, the subtracted degrees-of-freedom can\nbe altered using the extra option of the\ncompute_modify command.\nSee the Howto thermostat doc page for a\ndiscussion of different ways to compute temperature and perform\nthermostatting.\n\nThe keyword/value option pairs are used in the following ways.\nFor the bias keyword, bias-ID refers to the ID of a temperature\ncompute that removes a “bias” velocity from each atom.  This allows\ncompute temp/sphere to compute its thermal temperature after the\ntranslational kinetic energy components have been altered in a\nprescribed way, e.g. to remove a flow velocity profile.  Thermostats\nthat use this compute will work with this bias term.  See the doc\npages for individual computes that calculate a temperature and the doc\npages for fixes that perform thermostatting for more details.\nFor the dof keyword, a setting of all calculates a temperature\nthat includes both translational and rotational degrees of freedom.  A\nsetting of rotate calculates a temperature that includes only\nrotational degrees of freedom.\n\nOutput info:\nThis compute calculates a global scalar (the temperature) and a global\nvector of length 6 (KE tensor), which can be accessed by indices 1-6.\nThese values can be used by any command that uses global scalar or\nvector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe scalar value calculated by this compute is “intensive”.  The\nvector values are “extensive”.\nThe scalar value will be in temperature units.  The\nvector values will be in energy units.",
    "syntax": "compute ID group-ID temp/sphere keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/sphere = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = bias or dof\n * bias value = bias-ID\n *   bias-ID = ID of a temperature compute that removes a velocity bias\n * dof value = all or rotate\n *   all = compute temperature of translational and rotational degrees of freedom\n *   rotate = compute temperature of just rotational degrees of freedom",
    "examples": "compute 1 all temp/sphere\ncompute myTemp mobile temp/sphere bias tempCOM\ncompute myTemp mobile temp/sphere dof rotate",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\nand a radius as defined by the atom_style sphere\ncommand.\nAll particles in the group must be finite-size spheres, or point\nparticles with radius = 0.0."
},
{
    "command": "compute temp/uef",
    "html_filename": "compute_temp_uef.html",
    "short_description": "This command is used to compute the kinetic energy tensor in the reference frame of the applied flow field when fix nvt/uef or fix npt/uef is used",
    "description": "This command is used to compute the kinetic energy tensor in\nthe reference frame of the applied flow field when\nfix nvt/uef or\nfix npt/uef is used.\nIt is not necessary to use this command to compute the scalar\nvalue of the temperature. A compute temp\nmay be used for that purpose.\nOutput information for this command can be found in the\ndocumentation for compute temp.",
    "syntax": "compute ID group-ID temp/uef",
    "parameters": " * ID, group-ID are documented in compute command\n * temp/uef = style name of this compute command",
    "examples": "compute 1 all temp/uef\ncompute 2 sel temp/uef",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\nwas built with that package. See the Build package doc page for more info.\nThis command can only be used when fix nvt/uef\nor fix npt/uef is active."
},
{
    "command": "compute ti",
    "html_filename": "compute_ti.html",
    "short_description": "Define a computation that calculates the derivative of the interaction potential with respect to lambda, the coupling parameter used in a thermodynamic integration",
    "description": "Define a computation that calculates the derivative of the interaction\npotential with respect to lambda, the coupling parameter used in a\nthermodynamic integration.  This derivative can be used to infer a\nfree energy difference resulting from an alchemical simulation, as\ndescribed in Eike.\nTypically this compute will be used in conjunction with the fix adapt command which can perform alchemical\ntransformations by adjusting the strength of an interaction potential\nas a simulation runs, as defined by one or more\npair_style or kspace_style\ncommands.  This scaling is done via a prefactor on the energy, forces,\nvirial calculated by the pair or K-Space style.  The prefactor is\noften a function of a lambda parameter which may be adjusted from 0\nto 1 (or vice versa) over the course of a run.  The\ntime-dependent adjustment is what the fix adapt\ncommand does.\nAssume that the unscaled energy of a pair_style or kspace_style is\ngiven by U.  Then the scaled energy is\nUs = f(lambda) U\n\n\nwhere f() is some function of lambda.  What this compute calculates is\ndUs / d(lambda) = U df(lambda)/dlambda = Us / f(lambda) df(lambda)/dlambda\n\n\nwhich is the derivative of the system’s scaled potential energy Us\nwith respect to lambda.\nTo perform this calculation, you provide one or more atom types as\natype.  Atype can be specified in one of two ways.  An explicit\nnumeric values can be used, as in the 1st example above.  Or a\nwildcard asterisk can be used in place of or in conjunction with the\natype argument to select multiple atom types.  This takes the form\n“*” or “*n” or “n*” or “m*n”.  If N = the number of atom types, then\nan asterisk with no numeric values means all types from 1 to N.  A\nleading asterisk means all types from 1 to n (inclusive).  A trailing\nasterisk means all types from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).\nYou also specify two functions, as equal-style variables.  The first is specified as v_name1, where\nname1 is the name of the variable, and is f(lambda) in the notation\nabove.  The second is specified as v_name2, where name2 is the\nname of the variable, and is df(lambda) / dlambda in the notation\nabove.  I.e. it is the analytic derivative of f() with respect to\nlambda.  Note that the name1 variable is also typically given as an\nargument to the fix adapt command.\nAn alchemical simulation may use several pair potentials together,\ninvoked via the pair_style hybrid or hybrid/overlay\ncommand.  The total dUs/dlambda for the overall system is calculated\nas the sum of each contributing term as listed by the keywords in the\ncompute ti command.  Individual pair potentials can be listed, which\nwill be sub-styles in the hybrid case.  You can also include a K-space\nterm via the kspace keyword.  You can also include a pairwise\nlong-range tail correction to the energy via the tail keyword.\nFor each term you can specify a different (or the same) scale factor\nby the two variables that you list.  Again, these will typically\ncorrespond toe the scale factors applied to these various potentials\nand the K-Space contribution via the fix adapt\ncommand.\nMore details about the exact functional forms for the computation of\ndu/dl can be found in the paper by Eike.\n\nOutput info:\nThis compute calculates a global scalar, namely dUs/dlambda.  This\nvalue can be used by any command that uses a global scalar value from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe scalar value calculated by this compute is “extensive”.\nThe scalar value will be in energy units.",
    "syntax": "compute ID group ti keyword args ...",
    "parameters": " * ID, group-ID are documented in compute command\n * ti = style name of this compute command\n * one or more attribute/arg pairs may be appended\n * keyword = pair style (lj/cut, gauss, born, etc) or tail or kspace\n * pair style args = atype v_name1 v_name2\n *   atype = atom type (see asterisk form below)\n *   v_name1 = variable with name1 that is energy scale factor and function of lambda\n *   v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda\n * tail args = atype v_name1 v_name2\n *   atype = atom type (see asterisk form below)\n *   v_name1 = variable with name1 that is energy tail correction scale factor and function of lambda\n *   v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda\n * kspace args = atype v_name1 v_name2\n *   atype = atom type (see asterisk form below)\n *   v_name1 = variable with name1 that is K-Space scale factor and function of lambda\n *   v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda",
    "examples": "compute 1 all ti lj/cut 1 v_lj v_dlj coul/long 2 v_c v_dc kspace 1 v_ks v_dks\ncompute 1 all ti lj/cut 1*3 v_lj v_dlj coul/long * v_c v_dc kspace * v_ks v_dks",
    "restrictions": "This compute is part of the MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "compute torque/chunk",
    "html_filename": "compute_torque_chunk.html",
    "short_description": "Define a computation that calculates the torque on multiple chunks of atoms",
    "description": "Define a computation that calculates the torque on multiple chunks of\natoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the 3 components of the torque vector for eqch\nchunk, due to the forces on the individual atoms in the chunk around\nthe center-of-mass of the chunk.  The calculation includes all effects\ndue to atoms passing through periodic boundaries.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\n\nNote\nThe coordinates of an atom contribute to the chunk’s torque in\n“unwrapped” form, by using the image flags associated with each atom.\nSee the dump custom command for a discussion of\n“unwrapped” coordinates.  See the Atoms section of the\nread_data command for a discussion of image flags and\nhow they are set for each atom.  You can reset the image flags\n(e.g. to 0) before invoking this compute by using the set image command.\n\nThe simplest way to output the results of the compute torque/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all torque/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n3 for the 3 xyz components of the torque for each chunk.  These values\ncan be accessed by any command that uses global array values from a\ncompute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nThe array values are “intensive”.  The array values will be in\nforce-distance units.",
    "syntax": "compute ID group-ID torque/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * torque/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid torque/chunk molchunk",
    "restrictions": "\nnone"
},
{
    "command": "compute vacf",
    "html_filename": "compute_vacf.html",
    "short_description": "Define a computation that calculates the velocity auto-correlation function (VACF), averaged over a group of atoms",
    "description": "Define a computation that calculates the velocity auto-correlation\nfunction (VACF), averaged over a group of atoms.  Each atom’s\ncontribution to the VACF is its current velocity vector dotted into\nits initial velocity vector at the time the compute was specified.\nA vector of four quantities is calculated by this compute.  The first 3\nelements of the vector are vx * vx0 (and similarly for the y and z\ncomponents), summed and averaged over atoms in the group.  Vx is the\ncurrent x-component of velocity for the atom, vx0 is the initial\nx-component of velocity for the atom.  The 4th element of the vector\nis the total VACF, i.e. (vx*vx0 + vy*vy0 + vz*vz0), summed and\naveraged over atoms in the group.\nThe integral of the VACF versus time is proportional to the diffusion\ncoefficient of the diffusing atoms.  This can be computed in the\nfollowing manner, using the variable trap() function:\ncompute         2 all vacf\nfix             5 all vector 1 c_2[4]\nvariable        diff equal dt*trap(f_5)\nthermo_style    custom step v_diff\n\nNote\nIf you want the quantities calculated by this compute to be\ncontinuous when running from a restart file, then\nyou should use the same ID for this compute, as in the original run.\nThis is so that the fix this compute creates to store per-atom\nquantities will also have the same ID, and thus be initialized\ncorrectly with time=0 atom velocities from the restart file.\n\nOutput info:\nThis compute calculates a global vector of length 4, which can be\naccessed by indices 1-4 by any command that uses global vector values\nfrom a compute as input.  See the Howto output doc\npage for an overview of LAMMPS output options.\nThe vector values are “intensive”.  The vector values will be in\nvelocity^2 units.",
    "syntax": "compute ID group-ID vacf",
    "parameters": " * ID, group-ID are documented in compute command\n * vacf = style name of this compute command",
    "examples": "compute 1 all vacf\ncompute 1 upper vacf",
    "restrictions": "\nnone"
},
{
    "command": "compute vcm/chunk",
    "html_filename": "compute_vcm_chunk.html",
    "short_description": "Define a computation that calculates the center-of-mass velocity for multiple chunks of atoms",
    "description": "Define a computation that calculates the center-of-mass velocity for\nmultiple chunks of atoms.\nIn LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\nto a single chunk (or no chunk).  The ID for this command is specified\nas chunkID.  For example, a single chunk could be the atoms in a\nmolecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\ndoc pages for details of how chunks can be defined and examples of how\nthey can be used to measure properties of a system.\nThis compute calculates the x,y,z components of the center-of-mass\nvelocity for each chunk.  This is done by summing mass*velocity for\neach atom in the chunk and dividing the sum by the total mass of the\nchunk.\nNote that only atoms in the specified group contribute to the\ncalculation.  The compute chunk/atom command\ndefines its own group; atoms will have a chunk ID = 0 if they are not\nin that group, signifying they are not assigned to a chunk, and will\nthus also not contribute to this calculation.  You can specify the\n“all” group for this command if you simply want to include atoms with\nnon-zero chunk IDs.\nThe simplest way to output the results of the compute vcm/chunk\ncalculation to a file is to use the fix ave/time\ncommand, for example:\ncompute cc1 all chunk/atom molecule\ncompute myChunk all vcm/chunk cc1\nfix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\nOutput info:\nThis compute calculates a global array where the number of rows = the\nnumber of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n3 for the x,y,z center-of-mass velocity coordinates of each chunk.\nThese values can be accessed by any command that uses global array\nvalues from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe array values are “intensive”.  The array values will be in\nvelocity units.",
    "syntax": "compute ID group-ID vcm/chunk chunkID",
    "parameters": " * ID, group-ID are documented in compute command\n * vcm/chunk = style name of this compute command\n * chunkID = ID of compute chunk/atom command",
    "examples": "compute 1 fluid vcm/chunk molchunk",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "compute voronoi/atom",
    "html_filename": "compute_voronoi_atom.html",
    "short_description": "Define a computation that calculates the Voronoi tessellation of the atoms in the simulation box",
    "description": "Define a computation that calculates the Voronoi tessellation of the\natoms in the simulation box.  The tessellation is calculated using all\natoms in the simulation, but non-zero values are only stored for atoms\nin the group.\nBy default two per-atom quantities are calculated by this compute.\nThe first is the volume of the Voronoi cell around each atom.  Any\npoint in an atom’s Voronoi cell is closer to that atom than any other.\nThe second is the number of faces of the Voronoi cell. This is\nequal to the number of nearest neighbors of the central atom,\nplus any exterior faces (see note below). If the peratom keyword\nis set to “no”, the per-atom quantities are still calculated,\nbut they are not accessible.\n\nIf the only_group keyword is specified the tessellation is performed\nonly with respect to the atoms contained in the compute group. This is\nequivalent to deleting all atoms not contained in the group prior to\nevaluating the tessellation.\nIf the surface keyword is specified a third quantity per atom is\ncomputed: the Voronoi cell surface of the given atom. surface takes\na group ID as an argument. If a group other than all is specified,\nonly the Voronoi cell facets facing a neighbor atom from the specified\ngroup are counted towards the surface area.\nIn the example above, a precipitate embedded in a matrix, only atoms\nat the surface of the precipitate will have non-zero surface area, and\nonly the outward facing facets of the Voronoi cells are counted (the\nhull of the precipitate). The total surface area of the precipitate\ncan be obtained by running a “reduce sum” compute on c_2[3]\nIf the radius keyword is specified with an atom style variable as\nthe argument, a poly-disperse Voronoi tessellation is\nperformed. Examples for radius variables are\nvariable r1 atom (type==1)*0.1+(type==2)*0.4\ncompute radius all property/atom radius\nvariable r2 atom c_radius\nHere v_r1 specifies a per-type radius of 0.1 units for type 1 atoms\nand 0.4 units for type 2 atoms, and v_r2 accesses the radius property\npresent in atom_style sphere for granular models.\nThe edge_histo keyword activates the compilation of a histogram of\nnumber of edges on the faces of the Voronoi cells in the compute\ngroup. The argument maxedge of the this keyword is the largest number\nof edges on a single Voronoi cell face expected to occur in the\nsample. This keyword adds the generation of a global vector with\nmaxedge+1 entries. The last entry in the vector contains the number of\nfaces with more than maxedge edges. Since the polygon with the\nsmallest amount of edges is a triangle, entries 1 and 2 of the vector\nwill always be zero.\nThe edge_threshold and face_threshold keywords allow the\nsuppression of edges below a given minimum length and faces below a\ngiven minimum area. Ultra short edges and ultra small faces can occur\nas artifacts of the Voronoi tessellation. These keywords will affect\nthe neighbor count and edge histogram outputs.\nIf the occupation keyword is specified the tessellation is only\nperformed for the first invocation of the compute and then stored.\nFor all following invocations of the compute the number of atoms in\neach Voronoi cell in the stored tessellation is counted. In this mode\nthe compute returns a per-atom array with 2 columns. The first column\nis the number of atoms currently in the Voronoi volume defined by this\natom at the time of the first invocation of the compute (note that the\natom may have moved significantly). The second column contains the\ntotal number of atoms sharing the Voronoi cell of the stored\ntessellation at the location of the current atom. Numbers in column\none can be any positive integer including zero, while column two\nvalues will always be greater than zero. Column one data can be used\nto locate vacancies (the coordinates are given by the atom coordinates\nat the time step when the compute was first invoked), while column two\ndata can be used to identify interstitial atoms.\nIf the neighbors value is set to yes, then this compute creates a\nlocal array with 3 columns. There is one row for each face of each\nVoronoi cell. The 3 columns are the atom ID of the atom that owns the\ncell, the atom ID of the atom in the neighboring cell (or zero if the\nface is external), and the area of the face.  The array can be\naccessed by any command that uses local values from a compute as\ninput.  See the Howto output doc page for an\noverview of LAMMPS output options. More specifically, the array can be\naccessed by a dump local command to write a file\ncontaining all the Voronoi neighbors in a system:\ncompute 6 all voronoi/atom neighbors yes\ndump d2 all local 1 dump.neighbors index c_6[1] c_6[2] c_6[3]\n\n\nIf the face_threshold keyword is used, then only faces\nwith areas greater than the threshold are stored.\n\nThe Voronoi calculation is performed by the freely available Voro++ package, written by Chris Rycroft at UC Berkeley and LBL,\nwhich must be installed on your system when building LAMMPS for use\nwith this compute.  See instructions on obtaining and installing the\nVoro++ software in the src/VORONOI/README file.\n\nNote\nThe calculation of Voronoi volumes is performed by each\nprocessor for the atoms it owns, and includes the effect of ghost\natoms stored by the processor.  This assumes that the Voronoi cells of\nowned atoms are not affected by atoms beyond the ghost atom cut-off\ndistance.  This is usually a good assumption for liquid and solid\nsystems, but may lead to underestimation of Voronoi volumes in low\ndensity systems.  By default, the set of ghost atoms stored by each\nprocessor is determined by the cutoff used for\npair_style interactions.  The cutoff can be set\nexplicitly via the comm_modify cutoff command.  The\nVoronoi cells for atoms adjacent to empty regions will extend into\nthose regions up to the communication cutoff in x, y, or z.  In that\nsituation, an exterior face is created at the cutoff distance normal\nto the x, y, or z direction.  For triclinic systems, the exterior face\nis parallel to the corresponding reciprocal lattice vector.\n\n\nNote\nThe Voro++ package performs its calculation in 3d.  This will\nstill work for a 2d LAMMPS simulation, provided all the atoms have the\nsame z coordinate. The Voronoi cell of each atom will be a columnar\npolyhedron with constant cross-sectional area along the z direction\nand two exterior faces at the top and bottom of the simulation box. If\nthe atoms do not all have the same z coordinate, then the columnar\ncells will be accordingly distorted. The cross-sectional area of each\nVoronoi cell can be obtained by dividing its volume by the z extent of\nthe simulation box.  Note that you define the z extent of the\nsimulation box for 2d simulations when using the\ncreate_box or read_data commands.\n\nOutput info:\nBy default, this compute calculates a per-atom array with 2\ncolumns. In regular dynamic tessellation mode the first column is the\nVoronoi volume, the second is the neighbor count, as described above\n(read above for the output data in case the occupation keyword is\nspecified).  These values can be accessed by any command that uses\nper-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions. If the peratom keyword is set to “no”, the per-atom array\nis still created, but it is not accessible.\nIf the edge_histo keyword is used, then this compute generates a\nglobal vector of length maxedge+1, containing a histogram of the\nnumber of edges per face.\nIf the neighbors value is set to yes, then this compute calculates a\nlocal array with 3 columns. There is one row for each face of each\nVoronoi cell.\n\nNote\nSome LAMMPS commands such as the compute reduce command can accept either a per-atom or\nlocal quantity. If this compute produces both quantities, the command\nmay access the per-atom quantity, even if you want to access the local\nquantity.  This effect can be eliminated by using the peratom\nkeyword to turn off the production of the per-atom quantities.  For\nthe default value yes both quantities are produced.  For the value\nno, only the local array is produced.\n\nThe Voronoi cell volume will be in distance units cubed.\nThe Voronoi face area will be in distance units squared.",
    "syntax": "compute ID group-ID voronoi/atom keyword arg ...",
    "parameters": " * ID, group-ID are documented in compute command\n * voronoi/atom = style name of this compute command\n * zero or more keyword/value pairs may be appended\n * keyword = only_group or surface or radius or edge_histo or edge_threshold\n * or face_threshold or neighbors or peratom\n * only_group = no arg\n * occupation = no arg\n * surface arg = sgroup-ID\n *   sgroup-ID = compute the dividing surface between group-ID and sgroup-ID\n *     this keyword adds a third column to the compute output\n * radius arg = v_r\n *   v_r = radius atom style variable for a poly-disperse Voronoi tessellation\n * edge_histo arg = maxedge\n *   maxedge = maximum number of Voronoi cell edges to be accounted in the histogram\n * edge_threshold arg = minlength\n *   minlength = minimum length for an edge to be counted\n * face_threshold arg = minarea\n *   minarea = minimum area for a face to be counted\n * neighbors value = yes or no = store list of all neighbors or no\n * peratom value = yes or no = per-atom quantities accessible or no",
    "examples": "compute 1 all voronoi/atom\ncompute 2 precipitate voronoi/atom surface matrix\ncompute 3b precipitate voronoi/atom radius v_r\ncompute 4 solute voronoi/atom only_group\ncompute 5 defects voronoi/atom occupation\ncompute 6 all voronoi/atom neighbors yes",
    "restrictions": "This compute is part of the VORONOI package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nIt also requires you have a copy of the Voro++ library built and\ninstalled on your system.  See instructions on obtaining and\ninstalling the Voro++ software in the src/VORONOI/README file."
},
{
    "command": "compute xrd",
    "html_filename": "compute_xrd.html",
    "short_description": "Define a computation that calculates x-ray diffraction intensity as described in (Coleman) on a mesh of reciprocal lattice nodes defined by the entire simulation domain (or manually) using a simulated radiation of wavelength lambda",
    "description": "Define a computation that calculates x-ray diffraction intensity as described\nin (Coleman) on a mesh of reciprocal lattice nodes defined\nby the entire simulation domain (or manually) using a simulated radiation\nof wavelength lambda.\nThe x-ray diffraction intensity, I, at each reciprocal lattice point, k,\nis computed from the structure factor, F, using the equations:\n\n\\[\\begin{split}I =             & Lp(\\theta)\\frac{F^{*}F}{N} \\\\\nF(\\mathbf{k}) = & \\sum_{j=1}^{N}f_j(\\theta)exp(2\\pi i \\mathbf{k}\\cdot \\mathbf{r}_j) \\\\\nLp(\\theta)    = & \\frac{1+cos^{2}(2\\theta)}{cos(\\theta)sin^{2}(\\theta)} \\\\\n\\frac{sin(\\theta)}{\\lambda} = & \\frac{\\left | \\mathbf{k} \\right |}{2}\\end{split}\\]\nHere, K is the location of the reciprocal lattice node, \\(r_j\\) is the\nposition of each atom, \\(f_j\\) are atomic scattering factors, Lp is the\nLorentz-polarization factor, and \\(\\theta\\) is the scattering angle of\ndiffraction.  The Lorentz-polarization factor can be turned off using\nthe optional LP keyword.\nDiffraction intensities are calculated on a three-dimensional mesh of\nreciprocal lattice nodes. The mesh spacing is defined either (a)\nby the entire simulation domain or (b) manually using selected values as\nshown in the 2D diagram below.\n\nFor a mesh defined by the simulation domain, a rectilinear grid is\nconstructed with spacing c*inv(A) along each reciprocal lattice\naxis. Where A are the vectors corresponding to the edges of the\nsimulation cell. If one or two directions has non-periodic boundary\nconditions, then the spacing in these directions is defined from the\naverage of the (inversed) box lengths with periodic boundary conditions.\nMeshes defined by the simulation domain must contain at least one periodic\nboundary.\nIf the manual flag is included, the mesh of reciprocal lattice nodes\nwill defined using the c values for the spacing along each\nreciprocal lattice axis. Note that manual mapping of the reciprocal\nspace mesh is good for comparing diffraction results from multiple\nsimulations; however it can reduce the likelihood that Bragg\nreflections will be satisfied unless small spacing parameters (< 0.05\nAngstrom^(-1)) are implemented.  Meshes with manual spacing do not\nrequire a periodic boundary.\nThe limits of the reciprocal lattice mesh are determined by range of\nscattering angles explored.  The 2Theta parameters allows the user\nto reduce the scattering angle range to only the region of interest\nwhich reduces the cost of the computation.\nThe atomic scattering factors, fj, accounts for the reduction in\ndiffraction intensity due to Compton scattering.  Compute xrd uses\nanalytical approximations of the atomic scattering factors that vary\nfor each atom type (type1 type2 … typeN) and angle of diffraction.\nThe analytic approximation is computed using the formula\n(Colliex):\n\n\\[f_j\\left ( \\frac{sin(\\theta)}{\\lambda} \\right )=\\sum_{i}^{4}\na_i exp\\left ( -b_i \\frac{sin^{2}(\\theta)}{\\lambda^{2}} \\right )+c\\]\nCoefficients parameterized by (Peng) are assigned for each\natom type designating the chemical symbol and charge of each atom\ntype. Valid chemical symbols for compute xrd are:\n\n\n\n\n\n\n\n\n\nH\nHe1-\nHe\nLi\nLi1+\n\nBe\nBe2+\nB\nC\nCval\n\nN\nO\nO1-\nF\nF1-\n\nNe\nNa\nNa1+\nMg\nMg2+\n\nAl\nAl3+\nSi\nSival\nSi4+\n\nP\nS\nCl\nCl1-\nAr\n\nK\nCa\nCa2+\nSc\nSc3+\n\nTi\nTi2+\nTi3+\nTi4+\nV\n\nV2+\nV3+\nV5+\nCr\nCr2+\n\nCr3+\nMn\nMn2+\nMn3+\nMn4+\n\nFe\nFe2+\nFe3+\nCo\nCo2+\n\nCo\nNi\nNi2+\nNi3+\nCu\n\nCu1+\nCu2+\nZn\nZn2+\nGa\n\nGa3+\nGe\nGe4+\nAs\nSe\n\nBr\nBr1-\nKr\nRb\nRb1+\n\nSr\nSr2+\nY\nY3+\nZr\n\nZr4+\nNb\nNb3+\nNb5+\nMo\n\nMo3+\nMo5+\nMo6+\nTc\nRu\n\nRu3+\nRu4+\nRh\nRh3+\nRh4+\n\nPd\nPd2+\nPd4+\nAg\nAg1+\n\nAg2+\nCd\nCd2+\nIn\nIn3+\n\nSn\nSn2+\nSn4+\nSb\nSb3+\n\nSb5+\nTe\nI\nI1-\nXe\n\nCs\nCs1+\nBa\nBa2+\nLa\n\nLa3+\nCe\nCe3+\nCe4+\nPr\n\nPr3+\nPr4+\nNd\nNd3+\nPm\n\nPm3+\nSm\nSm3+\nEu\nEu2+\n\nEu3+\nGd\nGd3+\nTb\nTb3+\n\nDy\nDy3+\nHo\nHo3+\nEr\n\nEr3+\nTm\nTm3+\nYb\nYb2+\n\nYb3+\nLu\nLu3+\nHf\nHf4+\n\nTa\nTa5+\nW\nW6+\nRe\n\nOs\nOs4+\nIr\nIr3+\nIr4+\n\nPt\nPt2+\nPt4+\nAu\nAu1+\n\nAu3+\nHg\nHg1+\nHg2+\nTl\n\nTl1+\nTl3+\nPb\nPb2+\nPb4+\n\nBi\nBi3+\nBi5+\nPo\nAt\n\nRn\nFr\nRa\nRa2+\nAc\n\nAc3+\nTh\nTh4+\nPa\nU\n\nU3+\nU4+\nU6+\nNp\nNp3+\n\nNp4+\nNp6+\nPu\nPu3+\nPu4+\n\nPu6+\nAm\nCm\nBk\nCf\n\n\n\nIf the echo keyword is specified, compute xrd will provide extra\nreporting information to the screen.\nOutput info:\nThis compute calculates a global array.  The number of rows in the\narray is the number of reciprocal lattice nodes that are explored\nwhich by the mesh.  The global array has 2 columns.\nThe first column contains the diffraction angle in the units (radians\nor degrees) provided with the 2Theta values. The second column contains\nthe computed diffraction intensities as described above.\nThe array can be accessed by any command that uses global values from\na compute as input.  See the Howto output doc page\nfor an overview of LAMMPS output options.\nAll array values calculated by this compute are “intensive”.",
    "syntax": "compute ID group-ID xrd lambda type1 type2 ... typeN keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * xrd = style name of this compute command\n * lambda = wavelength of incident radiation (length units)\n * type1 type2 … typeN = chemical symbol of each atom type (see valid options below)\n * zero or more keyword/value pairs may be appended\n * keyword = 2Theta or c or LP or manual or echo\n * 2Theta values = Min2Theta Max2Theta\n *   Min2Theta,Max2Theta = minimum and maximum 2 theta range to explore\n *   (radians or degrees)\n * c values = c1 c2 c3\n *   c1,c2,c3 = parameters to adjust the spacing of the reciprocal\n *              lattice nodes in the h, k, and l directions respectively\n * LP value = switch to apply Lorentz-polarization factor\n *   0/1 = off/on\n * manual = flag to use manual spacing of reciprocal lattice points\n *            based on the values of the c parameters\n * echo = flag to provide extra output for debugging purposes",
    "examples": "compute 1 all xrd 1.541838 Al O 2Theta 0.087 0.87 c 1 1 1 LP 1 echo\ncompute 2 all xrd 1.541838 Al O 2Theta 10 100 c 0.05 0.05 0.05 LP 1 manual\n\nfix 1 all ave/histo/weight 1 1 1 0.087 0.87 250 c_1[1] c_1[2] mode vector file Rad2Theta.xrd\nfix 2 all ave/histo/weight 1 1 1 10 100 250 c_2[1] c_2[2] mode vector file Deg2Theta.xrd",
    "restrictions": "This compute is part of the USER-DIFFRACTION package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThe compute_xrd command does not work for triclinic cells."
},
{
    "command": "fix spring",
    "html_filename": "fix_spring.html",
    "short_description": "Apply a spring force to a group of atoms or between two groups of atoms",
    "description": "Apply a spring force to a group of atoms or between two groups of\natoms.  This is useful for applying an umbrella force to a small\nmolecule or lightly tethering a large group of atoms (e.g. all the\nsolvent or a large molecule) to the center of the simulation box so\nthat it doesn’t wander away over the course of a long simulation.  It\ncan also be used to hold the centers of mass of two groups of atoms at\na given distance or orientation with respect to each other.\nThe tether style attaches a spring between a fixed point x,y,z and\nthe center of mass of the fix group of atoms.  The equilibrium\nposition of the spring is R0.  At each timestep the distance R from\nthe center of mass of the group of atoms to the tethering point is\ncomputed, taking account of wrap-around in a periodic simulation box.\nA restoring force of magnitude K (R - R0) Mi / M is applied to each\natom in the group where K is the spring constant, Mi is the mass of\nthe atom, and M is the total mass of all atoms in the group.  Note\nthat K thus represents the spring constant for the total force on\nthe group of atoms, not for a spring applied to each atom.\nThe couple style links two groups of atoms together.  The first\ngroup is the fix group; the second is specified by group-ID2.  The\ngroups are coupled together by a spring that is at equilibrium when\nthe two groups are displaced by a vector x,y,z with respect to each\nother and at a distance R0 from that displacement.  Note that x,y,z\nis the equilibrium displacement of group-ID2 relative to the fix\ngroup.  Thus (1,1,0) is a different spring than (-1,-1,0).  When the\nrelative positions and distance between the two groups are not in\nequilibrium, the same spring force described above is applied to atoms\nin each of the two groups.\nFor both the tether and couple styles, any of the x,y,z values can\nbe specified as NULL which means do not include that dimension in the\ndistance calculation or force application.\nThe first example above pulls the ligand towards the point (0,0,0).\nThe second example holds the ligand near the surface of a sphere of\nradius 5 around the point (0,0,0).  The third example holds the ligand\na distance 3 away from the z=2 plane (on either side).\nThe fourth example holds 2 bilayers a distance 10 apart in z.  For the\nlast two examples, imagine a pore (a slab of atoms with a cylindrical\nhole cut out) oriented with the pore axis along z, and an ion moving\nwithin the pore.  The fifth example holds the ion a distance of -20\nbelow the z = 0 center plane of the pore (umbrella sampling).  The\nlast example holds the ion a distance 5 away from the pore axis\n(assuming the center-of-mass of the pore in x,y is the pore axis).\n\nNote\nThe center of mass of a group of atoms is calculated in\n“unwrapped” coordinates using atom image flags, which means that the\ngroup can straddle a periodic boundary.  See the dump doc\npage for a discussion of unwrapped coordinates.  It also means that a\nspring connecting two groups or a group and the tether point can cross\na periodic boundary and its length be calculated correctly.\n\nRestart, fix_modify, output, run start/stop, minimize info:\nNo information about this fix is written to binary restart files.\nThe fix_modify energy option is supported by this\nfix to add the energy stored in the spring to the system’s potential\nenergy as part of thermodynamic output.\nThe fix_modify respa option is supported by this\nfix. This allows to set at which level of the r-RESPA\nintegrator the fix is adding its forces. Default is the outermost level.\nThis fix computes a global scalar which can be accessed by various\noutput commands.  The scalar is the spring energy\n= 0.5 * K * r^2.\nThis fix also computes global 4-vector which can be accessed by\nvarious output commands.  The first 3 quantities\nin the vector are xyz components of the total force added to the group\nof atoms by the spring.  In the case of the couple style, it is the\nforce on the fix group (group-ID) or the negative of the force on the\n2nd group (group-ID2).  The 4th quantity in the vector is the\nmagnitude of the force added by the spring, as a positive value if\n(r-R0) > 0 and a negative value if (r-R0) < 0.  This sign convention\ncan be useful when using the spring force to compute a potential of\nmean force (PMF).\nThe scalar and vector values calculated by this fix are “extensive”.\nNo parameter of this fix can be used with the start/stop keywords of\nthe run command.\nThe forces due to this fix are imposed during an energy minimization,\ninvoked by the minimize command.\n\nNote\nIf you want the spring energy to be included in the total\npotential energy of the system (the quantity being minimized), you\nMUST enable the fix_modify energy option for this\nfix.",
    "syntax": "fix ID group-ID spring keyword values",
    "parameters": " * ID, group-ID are documented in fix command\n * spring = style name of this fix command\n * keyword = tether or couple\n * tether values = K x y z R0\n *   K = spring constant (force/distance units)\n *   x,y,z = point to which spring is tethered\n *   R0 = equilibrium distance from tether point (distance units)\n * couple values = group-ID2 K x y z R0\n *   group-ID2 = 2nd group to couple to fix group with a spring\n *   K = spring constant (force/distance units)\n *   x,y,z = direction of spring\n *   R0 = equilibrium distance of spring (distance units)",
    "examples": "fix pull ligand spring tether 50.0 0.0 0.0 0.0 0.0\nfix pull ligand spring tether 50.0 0.0 0.0 0.0 5.0\nfix pull ligand spring tether 50.0 NULL NULL 2.0 3.0\nfix 5 bilayer1 spring couple bilayer2 100.0 NULL NULL 10.0 0.0\nfix longitudinal pore spring couple ion 100.0 NULL NULL -20.0 0.0\nfix radial pore spring couple ion 100.0 0.0 0.0 NULL 5.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style adp",
    "html_filename": "pair_adp.html",
    "short_description": "Style adp computes pairwise interactions for metals and metal alloys using the angular dependent potential (ADP) of (Mishin), which is a generalization of the embedded atom method (EAM) potential",
    "description": "Style adp computes pairwise interactions for metals and metal alloys\nusing the angular dependent potential (ADP) of (Mishin),\nwhich is a generalization of the embedded atom method (EAM) potential.  The LAMMPS implementation is discussed in\n(Singh).  The total energy Ei of an atom I is given by\n\n\\[\\begin{split}E_i            & = F_\\alpha \\left( \\sum_{j\\neq i} \\rho_\\beta (r_{ij}) \\right) + \\frac{1}{2} \\sum_{j\\neq i}\\phi_{\\alpha\\beta}(r_{ij})+ \\frac{1}{2} \\sum_s (\\mu_i^s)^2 + \\frac{1}{2} \\sum_{s,t} (\\lambda_i^{st})^2 - \\frac{1}{6} \\nu_i^2 \\\\\n\\mu_i^s        & = \\sum_{j\\neq i}u_{\\alpha\\beta}(r_{ij})r_{ij}^s\\\\\n\\lambda_i^{st} & = \\sum_{j\\neq i}w_{\\alpha\\beta}(r_{ij})r_{ij}^sr_{ij}^t\\\\\n\\nu_i          & = \\sum_s\\lambda_i^{ss}\\end{split}\\]\nwhere \\(F\\) is the embedding energy which is a function of the atomic\nelectron density \\(\\rho\\), \\(\\phi\\) is a pair potential interaction,\n\\(\\alpha\\) and \\(\\beta\\) are the element types of atoms \\(I\\) and\n\\(J\\), and \\(s\\) and \\(t = 1,2,3\\) and refer to the cartesian\ncoordinates.  The \\(\\mu\\) and \\(\\lambda\\) terms represent the dipole\nand quadruple distortions of the local atomic environment which extend the\noriginal EAM framework by introducing angular forces.\nNote that unlike for other potentials, cutoffs for ADP potentials are\nnot set in the pair_style or pair_coeff command; they are specified in\nthe ADP potential files themselves.  Likewise, the ADP potential files\nlist atomic masses; thus you do not need to use the mass\ncommand to specify them.\nADP potentials are available from:\n\nThe NIST WWW site at http://www.ctcms.nist.gov/potentials.\nNote that ADP potentials obtained from NIST must be converted\ninto the extended DYNAMO setfl format discussed below.\nThe OpenKIM Project at https://openkim.org/browse/models/by-type provides\nADP potentials that can be used directly in LAMMPS with the kim_commands interface.\n\n\nOnly a single pair_coeff command is used with the adp style which\nspecifies an extended DYNAMO setfl file, which contains information\nfor \\(M\\) elements.  These are mapped to LAMMPS atom types by specifying \\(N\\)\nadditional arguments after the filename in the pair_coeff command,\nwhere \\(N\\) is the number of LAMMPS atom types:\n\nfilename\n\\(N\\) element names = mapping of extended setfl elements to atom types\n\nSee the pair_coeff doc page for alternate ways to\nspecify the path for the potential file.\nAs an example, the potentials/AlCu.adp file, included in the\npotentials directory of the LAMMPS distribution, is an extended setfl\nfile which has tabulated ADP values for w elements and their alloy\ninteractions: Cu and Al.  If your LAMMPS simulation has 4 atoms types\nand you want the 1st 3 to be Al, and the 4th to be Cu, you would use\nthe following pair_coeff command:\npair_coeff * * AlCu.adp Al Al Al Cu\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Al arguments map LAMMPS atom types 1,2,3 to the Al\nelement in the extended setfl file.  The final Cu argument maps\nLAMMPS atom type 4 to the Al element in the extended setfl file.\nNote that there is no requirement that your simulation use all the\nelements specified by the extended setfl file.\nIf a mapping value is specified as NULL, the mapping is not performed.\nThis can be used when an adp potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\nAdp files in the potentials directory of the LAMMPS distribution\nhave an “.adp” suffix.  A DYNAMO setfl file extended for ADP is\nformatted as follows.  Basically it is the standard setfl format\nwith additional tabulated functions u and w added to the file after\nthe tabulated pair potentials.  See the pair_eam\ncommand for further details on the setfl format.\n\nlines 1,2,3 = comments (ignored)\nline 4: \\(N_{\\text{elements}}\\) Element1 Element2 … ElementN\nline 5: \\(N_\\rho\\), \\(d_\\rho\\), \\(N_r\\), \\(d_r\\), cutoff\n\nFollowing the 5 header lines are \\(N_{\\text{elements}}\\) sections, one for each\nelement, each with the following format:\n\nline 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\nembedding function \\(F(\\rho)\\) (\\(N_\\rho\\) values)\ndensity function \\(\\rho(r)\\) (\\(N_r\\) values)\n\nFollowing the \\(N_{\\text{elements}}\\) sections, \\(N_r\\) values for each pair potential\n\\(\\phi(r)\\) array are listed for all \\(i,j\\) element pairs in the same format\nas other arrays.  Since these interactions are symmetric (\\(i,j = j,i\\))\nonly \\(\\phi\\) arrays with \\(i \\geq j\\) are listed, in the following order:\n\n\\[i,j = (1,1), (2,1), (2,2), (3,1), (3,2), (3,3), (4,1), ..., (N_{\\text{elements}},N_{\\text{elements}}).\\]\nThe tabulated values for each \\(\\phi\\) function are listed as\n\\(r*\\phi\\) (in units of eV-Angstroms), since they are for atom pairs, the\nsame as for other EAM files.\nAfter the \\(\\phi(r)\\) arrays, each of the \\(u(r)\\) arrays are listed in the\nsame order with the same assumptions of symmetry.  Directly following\nthe \\(u(r)\\), the \\(w(r)\\) arrays are listed.  Note that \\(\\phi(r)\\) is the only\narray tabulated with a scaling by \\(r\\).\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, no special mixing rules are needed, since\nthe ADP potential files specify alloy interactions explicitly.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in tabulated potential files.\nThus, you need to re-specify the pair_style and pair_coeff commands in\nan input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style adp",
    "parameters": " * ",
    "examples": "pair_style adp\npair_coeff * * Ta.adp Ta\npair_coeff * * ../potentials/AlCu.adp Al Al Cu",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package."
},
{
    "command": "pair_style agni",
    "html_filename": "pair_agni.html",
    "short_description": "Style agni style computes the many-body vectorial force components for an atom as  \\[\\begin{split}F_i^u                  & = \\sum_t^{N_t}\\alpha_t \\cdot \\exp\\left[-\\frac{\\left(d_{i,t}^u\\right)^2}{2l^2}\\right] \\\\ d_{i,t}^u              & = \\left|\\left| V_i^u(\\eta) - V_t^u(\\eta) \\right|\\right| \\\\ V_i^u(\\eta)            & = \\sum_{j \\neq i}\\frac{r^u_{ij}}{r_{ij}} \\cdot e^{-\\left(\\frac{r_{ij}}{\\eta} \\right)^2} \\cdot f_d\\left(r_{ij}\\right) \\\\ f_d\\left(r_{ij}\\right) & = \\frac{1}{2} \\left[\\cos\\left(\\frac{\\pi r_{ij}}{R_c}\\right) + 1 \\right]\\end{split}\\] \\(u\\) labels the individual components, i",
    "description": "Style agni style computes the many-body vectorial force components for\nan atom as\n\n\\[\\begin{split}F_i^u                  & = \\sum_t^{N_t}\\alpha_t \\cdot \\exp\\left[-\\frac{\\left(d_{i,t}^u\\right)^2}{2l^2}\\right] \\\\\nd_{i,t}^u              & = \\left|\\left| V_i^u(\\eta) - V_t^u(\\eta) \\right|\\right| \\\\\nV_i^u(\\eta)            & = \\sum_{j \\neq i}\\frac{r^u_{ij}}{r_{ij}} \\cdot e^{-\\left(\\frac{r_{ij}}{\\eta} \\right)^2} \\cdot f_d\\left(r_{ij}\\right) \\\\\nf_d\\left(r_{ij}\\right) & = \\frac{1}{2} \\left[\\cos\\left(\\frac{\\pi r_{ij}}{R_c}\\right) + 1 \\right]\\end{split}\\]\n\\(u\\) labels the individual components, i.e. \\(x\\), \\(y\\) or \\(z\\), and \\(V\\) is the\ncorresponding atomic fingerprint. \\(d\\) is the Euclidean distance between\nany two atomic fingerprints. A total of \\(N_t\\) reference atomic\nenvironments are considered to construct the force field file. \\(\\alpha_t\\)\nand \\(l\\) are the weight coefficients and length scale parameter of the\nnon-linear regression model.\nThe method implements the recently proposed machine learning access to\natomic forces as discussed extensively in the following publications -\n(Botu1) and (Botu2). The premise\nof the method is to map the atomic environment numerically into a\nfingerprint, and use machine learning methods to create a mapping to the\nvectorial atomic forces.\nOnly a single pair_coeff command is used with the agni style which\nspecifies an AGNI potential file containing the parameters of the\nforce field for the needed elements. These are mapped to LAMMPS atom\ntypes by specifying \\(N\\) additional arguments after the filename in the\npair_coeff command, where \\(N\\) is the number of LAMMPS atom types:\n\nfilename\n\\(N\\) element names = mapping of AGNI elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the force field file.\nAn AGNI force field is fully specified by the filename which contains the\nparameters of the force field, i.e., the reference training environments\nused to construct the machine learning force field. Example force field\nand input files are provided in the examples/USER/misc/agni directory.\n\nStyles with omp suffix is functionally the same as the corresponding\nstyle without the suffix. They have been optimized to run faster,\ndepending on your available hardware, as discussed on the Speed packages doc page.  The accelerated style takes\nthe same arguments and should produce the same results, except for\nround-off and precision issues.\nThe accelerated style is part of the USER-OMP.  They are only enabled\nif LAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated style explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style agni",
    "parameters": " * ",
    "examples": "pair_style      agni\npair_coeff      * * Al.agni Al",
    "restrictions": "Currently, only elemental systems are implemented. Also, the method\nonly provides access to the forces and not energies or stresses.\nThe lack of potential energy data makes this pair style incompatible with\nseveral of the minimizer algorthms like cg or sd.\nIt should work with damped dynamics based minimizers like fire or\nquickmin.  However, one can access the energy via thermodynamic\nintegration of the forces as discussed in\n(Botu3).  This pair style is part of the\nUSER-MISC package. It is only enabled if LAMMPS was built with that\npackage. See the Build package doc page for more\ninfo.\nThe AGNI force field files provided with LAMMPS (see the\npotentials directory) are parameterized for metal units.\nYou can use the AGNI potential with any LAMMPS units, but you would need\nto create your own AGNI potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style airebo",
    "html_filename": "pair_airebo.html",
    "short_description": "The airebo pair style computes the Adaptive Intermolecular Reactive Empirical Bond Order (AIREBO) Potential of (Stuart) for a system of carbon and/or hydrogen atoms",
    "description": "The airebo pair style computes the Adaptive Intermolecular Reactive\nEmpirical Bond Order (AIREBO) Potential of (Stuart) for a\nsystem of carbon and/or hydrogen atoms.  Note that this is the initial\nformulation of AIREBO from 2000, not the later formulation.\nThe airebo/morse pair style computes the AIREBO-M potential, which\nis equivalent to AIREBO, but replaces the LJ term with a Morse potential.\nThe Morse potentials are parameterized by high-quality quantum chemistry\n(MP2) calculations and do not diverge as quickly as particle density\nincreases. This allows AIREBO-M to retain accuracy to much higher pressures\nthan AIREBO (up to 40 GPa for Polyethylene). Details for this potential\nand its parameterization are given in (O’Conner).\nThe rebo pair style computes the Reactive Empirical Bond Order (REBO)\nPotential of (Brenner). Note that this is the so-called\n2nd generation REBO from 2002, not the original REBO from 1990.\nAs discussed below, 2nd generation REBO is closely related to the\ninitial AIREBO; it is just a subset of the potential energy terms\nwith a few slightly different parameters\nThe AIREBO potential consists of three terms:\n\n\\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i}\n\\left[ E^{\\text{REBO}}_{ij} + E^{\\text{LJ}}_{ij} +\n \\sum_{k \\neq i,j} \\sum_{l \\neq i,j,k} E^{\\text{TORSION}}_{kijl} \\right] \\\\\\end{split}\\]\nBy default, all three terms are included.  For the airebo style, if\nthe first two optional flag arguments to the pair_style command are\nincluded, the LJ and torsional terms can be turned off.  Note that\nboth or neither of the flags must be included.  If both of the LJ an\ntorsional terms are turned off, it becomes the 2nd-generation REBO\npotential, with a small caveat on the spline fitting procedure\nmentioned below.  This can be specified directly as pair_style rebo\nwith no additional arguments.\nThe detailed formulas for this potential are given in\n(Stuart); here we provide only a brief description.\nThe \\(E^{\\text{REBO}}\\) term has the same functional form as the hydrocarbon REBO\npotential developed in (Brenner).  The coefficients for\n\\(E^{\\text{REBO}}\\) in AIREBO are essentially the same as Brenner’s potential, but\na few fitted spline values are slightly different.  For most cases the\n\\(E^{\\text{REBO}}\\) term in AIREBO will produce the same energies, forces and\nstatistical averages as the original REBO potential from which it was\nderived.  The \\(E^{\\text{REBO}}\\) term in the AIREBO potential gives the model its\nreactive capabilities and only describes short-ranged C-C, C-H and H-H\ninteractions (\\(r < 2\\) Angstroms). These interactions have strong\ncoordination-dependence through a bond order parameter, which adjusts\nthe attraction between the I,J atoms based on the position of other\nnearby atoms and thus has 3- and 4-body dependence.\nThe \\(E^{\\text{LJ}}\\) term adds longer-ranged interactions (\\(2 < r < \\text{cutoff}\\)) using a\nform similar to the standard Lennard Jones potential.\nThe \\(E^{\\text{LJ}}\\) term in AIREBO contains a series of switching functions so\nthat the short-ranged LJ repulsion (\\(1/r^{12}\\)) does not interfere with\nthe energetics captured by the \\(E^{\\text{REBO}}\\) term.  The extent of the \\(E^{\\text{LJ}}\\)\ninteractions is determined by the cutoff argument to the pair_style\ncommand which is a scale factor.  For each type pair (C-C, C-H, H-H)\nthe cutoff is obtained by multiplying the scale factor by the sigma\nvalue defined in the potential file for that type pair.  In the\nstandard AIREBO potential, \\(\\sigma_{CC} = 3.4\\) Angstroms, so with a scale\nfactor of 3.0 (the argument in pair_style), the resulting \\(E^{\\text{LJ}}\\) cutoff\nwould be 10.2 Angstroms.\nBy default, the longer-ranged interaction is smoothly switched off\nbetween 2.16 and 3.0 \\(\\sigma\\). By specifying cutoff_min in addition\nto cutoff, the switching can be configured to take place between\ncutoff_min and cutoff. cutoff_min can only be specified if all\noptional arguments are given.\nThe \\(E^{\\text{TORSION}}\\) term is an explicit 4-body potential that describes\nvarious dihedral angle preferences in hydrocarbon configurations.\n\nOnly a single pair_coeff command is used with the airebo, airebo\nor rebo style which specifies an AIREBO, REBO, or AIREBO-M potential\nfile with parameters for C and H.  Note that as of LAMMPS version\n15 May 2019 the rebo style in LAMMPS uses its own potential\nfile (CH.rebo).  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\n\\(N\\) element names = mapping of AIREBO elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, if your LAMMPS simulation has 4 atom types and you want\nthe 1st 3 to be C, and the 4th to be H, you would use the following\npair_coeff command:\npair_coeff * * CH.airebo C C C H\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three C arguments map LAMMPS atom types 1,2,3 to the C\nelement in the AIREBO file.  The final H argument maps LAMMPS atom\ntype 4 to the H element in the SW file.  If a mapping value is\nspecified as NULL, the mapping is not performed.  This can be used\nwhen a airebo potential is used as part of the hybrid pair style.\nThe NULL values are placeholders for atom types that will be used with\nother potentials.\nThe parameters/coefficients for the AIREBO potentials are listed in\nthe CH.airebo file to agree with the original (Stuart)\npaper.  Thus the parameters are specific to this potential and the way\nit was fit, so modifying the file should be done cautiously.\nSimilarly the parameters/coefficients for the AIREBO-M potentials are\nlisted in the CH.airebo-m file to agree with the (O’Connor)\npaper. Thus the parameters are specific to this potential and the way\nit was fit, so modifying the file should be done cautiously. The\nAIREBO-M Morse potentials were parameterized using a cutoff of\n3.0 (\\(\\sigma\\)). Modifying this cutoff may impact simulation accuracy.\nThis pair style tallies a breakdown of the total AIREBO potential\nenergy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 3.\nThe 3 values correspond to the following sub-categories:\n\n\\(E_{\\text{REBO}}\\) = REBO energy\n\\(E_{\\text{LJ}}\\) = Lennard-Jones energy\n\\(E_{\\text{TORSION}}\\) = Torsion energy\n\nTo print these quantities to the log file (with descriptive column\nheadings) the following commands could be included in an input script:\ncompute 0 all pair airebo\nvariable REBO     equal c_0[1]\nvariable LJ       equal c_0[2]\nvariable TORSION  equal c_0[3]\nthermo_style custom step temp epair v_REBO v_LJ v_TORSION\n\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support the pair_modify\nmix, shift, table, and tail options.\nThese pair styles do not write their information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner , middle, outer keywords.",
    "syntax": "pair_style style cutoff LJ_flag TORSION_flag cutoff_min",
    "parameters": " * style = airebo or airebo/morse or rebo\n * cutoff = LJ or Morse cutoff (\\(\\sigma\\) scale factor) (AIREBO and AIREBO-M only)\n * LJ_flag = 0/1 to turn off/on the LJ or Morse term (AIREBO and AIREBO-M only, optional)\n * TORSION_flag = 0/1 to turn off/on the torsion term (AIREBO and AIREBO-M only, optional)\n * cutoff_min = Start of the transition region of cutoff (\\(\\sigma\\) scale factor) (AIREBO and AIREBO-M only, optional)",
    "examples": "pair_style airebo 3.0\npair_style airebo 2.5 1 0\npair_coeff * * ../potentials/CH.airebo H C\n\npair_style airebo/morse 3.0\npair_coeff * * ../potentials/CH.airebo-m H C\n\npair_style rebo\npair_coeff * * ../potentials/CH.rebo H C",
    "restrictions": "These pair styles are part of the MANYBODY package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair potentials require the newton setting to be\n“on” for pair interactions.\nThe CH.airebo and CH.airebo-m potential files provided with LAMMPS\n(see the potentials directory) are parameterized for metal units.\nYou can use the AIREBO, AIREBO-M or REBO potential with any LAMMPS units,\nbut you would need to create your own AIREBO or AIREBO-M potential file\nwith coefficients listed in the appropriate units, if your simulation\ndoesn’t use “metal” units."
},
{
    "command": "pair_style atm",
    "html_filename": "pair_atm.html",
    "short_description": "The atm style computes a 3-body Axilrod-Teller-Muto potential for the energy E of a system of atoms as  \\[\\begin{split}E & = \\nu\\frac{1+3\\cos\\gamma_1\\cos\\gamma_2\\cos\\gamma_3}{r_{12}^3r_{23}^3r_{31}^3} \\\\\\end{split}\\] where \\(\\nu\\) is the three-body interaction strength",
    "description": "The atm style computes a 3-body Axilrod-Teller-Muto\npotential for the energy E of a system of atoms as\n\n\\[\\begin{split}E & = \\nu\\frac{1+3\\cos\\gamma_1\\cos\\gamma_2\\cos\\gamma_3}{r_{12}^3r_{23}^3r_{31}^3} \\\\\\end{split}\\]\nwhere \\(\\nu\\) is the three-body interaction strength.  The distances\nbetween pairs of atoms \\(r_{12}\\), \\(r_{23}\\), \\(r_{31}\\) and the angles \\(\\gamma_1\\), \\(\\gamma_2\\),\n\\(\\gamma_3\\) are as shown in this diagram:\n\nNote that for the interaction between a triplet of atoms \\(I,J,K\\), there\nis no “central” atom.  The interaction is symmetric with respect to\npermutation of the three atoms. Thus the \\(\\nu\\) value is\nthe same for all those permutations of the atom types of \\(I,J,K\\)\nand needs to be specified only once, as discussed below.\nThe atm potential is typically used in combination with a two-body\npotential using the pair_style hybrid/overlay\ncommand as in the example above.\nThe potential for a triplet of atom is calculated only if all 3 distances\n\\(r_{12}\\), \\(r_{23}\\), \\(r_{31}\\) between the 3 atoms satisfy\n\\(r_{IJ} < \\text{cutoff}\\).  In addition, the product of the 3 distances\n\\(r_{12} r_{23} r_{31}\\) < cutoff_triple \\(^3\\) is required, which\nexcludes from calculation the triplets with small contribution to the\ninteraction.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the restart files read by the\nread_restart commands:\n\n\\(K\\) = atom type of the third atom (1 to \\(N_{\\text{types}}\\))\n\\(\\nu\\) = prefactor (energy/distance^9 units)\n\n\\(K\\) can be specified in one of two ways.  An explicit numeric value can\nbe used, as in the 2nd example above.  \\(J \\leq K\\) is required.  LAMMPS\nsets the coefficients for the other 5 symmetric interactions to the same\nvalues.  E.g. if \\(I = 1\\), \\(J = 2\\), \\(K = 3\\), then these 6\nvalues are set to the specified \\(\\nu\\): \\(\\nu_{123}\\),\n\\(\\nu_{132}\\), \\(\\nu_{213}\\), \\(\\nu_{231}\\), \\(\\nu_{312}\\),\n\\(\\nu_{321}\\).  This enforces the symmetry discussed above.\nA wildcard asterisk can be used for K to set the coefficients for\nmultiple triplets of atom types.  This takes the form “*” or “*n” or\n“n*” or “m*n”.  If \\(N\\) equals the number of atom types, then an asterisk with\nno numeric values means all types from 1 to \\(N\\).  A leading asterisk\nmeans all types from 1 to \\(n\\) (inclusive).  A trailing asterisk means\nall types from \\(n\\) to \\(N\\) (inclusive).  A middle asterisk means all types\nfrom \\(m\\) to \\(n\\) (inclusive).  Note that only type triplets with \\(J \\leq K\\) are\nconsidered; if asterisks imply type triplets where \\(K < J\\), they are\nignored.\nNote that a pair_coeff command can override a previous setting for the\nsame \\(I,J,K\\) triplet.  For example, these commands set \\(\\nu\\) for all \\(I,J.K\\)\ntriplets, then overwrite nu for just the \\(I,J,K = 2,3,4\\) triplet:\npair_coeff * * * 0.25\npair_coeff 2 3 4 0.1\n\n\nNote that for a simulation with a single atom type, only a single\nentry is required, e.g.\npair_coeff 1 1 1 0.25\n\n\nFor a simulation with two atom types, four pair_coeff commands will\nspecify all possible nu values:\npair_coeff 1 1 1 nu1\npair_coeff 1 1 2 nu2\npair_coeff 1 2 2 nu3\npair_coeff 2 2 2 nu4\n\n\nFor a simulation with three atom types, ten pair_coeff commands will\nspecify all possible nu values:\npair_coeff 1 1 1 nu1\npair_coeff 1 1 2 nu2\npair_coeff 1 1 3 nu3\npair_coeff 1 2 2 nu4\npair_coeff 1 2 3 nu5\npair_coeff 1 3 3 nu6\npair_coeff 2 2 2 nu7\npair_coeff 2 2 3 nu8\npair_coeff 2 3 3 nu9\npair_coeff 3 3 3 nu10\n\n\nBy default the \\(\\nu\\) value for all triplets is set to 0.0.  Thus it is\nnot required to provide pair_coeff commands that enumerate triplet\ninteractions for all \\(K\\) types.  If some \\(I,J,K\\) combination is not\nspecified, then there will be no 3-body ATM interactions for that\ncombination and all its permutations.  However, as with all pair\nstyles, it is required to specify a pair_coeff command for all \\(I,J\\)\ncombinations, else an error will result.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair styles do not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need to be specified\nin an input script that reads a restart file.  However, if the atm potential\nis used in combination with other potentials using the pair_style\nhybrid/overlay command then pair_coeff commands need to be\nre-specified in the restart input script.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner , middle , outer keywords.",
    "syntax": "pair_style atm cutoff cutoff_triple",
    "parameters": " * cutoff = cutoff for each pair in 3-body interaction (distance units)\n * cutoff_triple = additional cutoff applied to product of 3 pairwise distances (distance units)",
    "examples": "pair_style atm 4.5 2.5\npair_coeff * * * 0.072\n\npair_style hybrid/overlay lj/cut 6.5 atm 4.5 2.5\npair_coeff * * lj/cut 1.0 1.0\npair_coeff 1 1 atm 1 0.064\npair_coeff 1 1 atm 2 0.080\npair_coeff 1 2 atm 2 0.100\npair_coeff 2 2 atm 2 0.125",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style awpmd/cut",
    "html_filename": "pair_awpmd.html",
    "short_description": "This pair style contains an implementation of the Antisymmetrized Wave Packet Molecular Dynamics (AWPMD) method",
    "description": "This pair style contains an implementation of the Antisymmetrized Wave\nPacket Molecular Dynamics (AWPMD) method.  Need citation here.  Need\nbasic formulas here.  Could be links to other documents.\nRc is the cutoff.\nThe pair_style command allows for several optional keywords\nto be specified.\nThe hartree, dproduct, and uhf keywords specify the form of the\ninitial trial wave function for the system.  If the hartree keyword\nis used, then a Hartree multielectron trial wave function is used.  If\nthe dproduct keyword is used, then a trial function which is a\nproduct of two determinants for each spin type is used.  If the uhf\nkeyword is used, then an unrestricted Hartree-Fock trial wave function\nis used.\nThe free, pbc, and fix keywords specify a width constraint on\nthe electron wave packets.  If the free keyword is specified, then there is no\nconstraint.  If the pbc keyword is used and Plen is specified as\n-1, then the maximum width is half the shortest box length.  If Plen\nis a positive value, then the value is the maximum width.  If the\nfix keyword is used and Flen is specified as -1, then electrons\nhave a constant width that is read from the data file.  If Flen is a\npositive value, then the constant width for all electrons is set to\nFlen.\nThe harm keyword allow oscillations in the width of the\nelectron wave packets.  More details are needed.\nThe ermscale keyword specifies a unitless scaling factor\nbetween the electron masses and the width variable mass.  More\ndetails needed.\nIf the flex_press keyword is used, then a contribution from the\nelectrons is added to the total virial and pressure of the system.\nThis potential is designed to be used with atom_style wavepacket definitions, in order to handle the\ndescription of systems with interacting nuclei and explicit electrons.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutoff (distance units)\n\nFor awpmd/cut, the cutoff coefficient is optional.  If it is not\nused (as in some of the examples above), the default global value\nspecified in the pair_style command is used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe pair_modify mix, shift, table, and tail options\nare not relevant for this pair style.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style awpmd/cut Rc keyword value ...",
    "parameters": " * Rc = global cutoff, -1 means cutoff of half the shortest box length\n * zero or more keyword/value pairs may be appended\n * keyword = hartree or dproduct or uhf or free or pbc or fix or harm or ermscale or flex_press\n * hartree value = none\n * dproduct value = none\n * uhf value = none\n * free value = none\n * pbc value = Plen\n *   Plen = periodic width of electron = -1 or positive value (distance units)\n * fix value = Flen\n *   Flen = fixed width of electron = -1 or positive value (distance units)\n * harm value = width\n *   width = harmonic width constraint\n * ermscale value = factor\n *   factor = scaling between electron mass and width variable mass\n * flex_press value = none",
    "examples": "pair_style awpmd/cut -1\npair_style awpmd/cut 40.0 uhf free\npair_coeff * *\npair_coeff 2 2 20.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style beck",
    "html_filename": "pair_beck.html",
    "short_description": "Style beck computes interactions based on the potential by (Beck), originally designed for simulation of Helium",
    "description": "Style beck computes interactions based on the potential by\n(Beck), originally designed for simulation of Helium.  It\nincludes truncation at a cutoff distance Rc.\n\n\\[\\begin{split}E(r) &= A \\exp\\left[-\\alpha r - \\beta r^6\\right] - \\frac{B}{\\left(r^2+a^2\\right)^3} \\left(1+\\frac{2.709+3a^2}{r^2+a^2}\\right) \\qquad r < R_c \\\\\\end{split}\\]\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands.\n\n\\(A\\) (energy units)\n\\(B\\) (energy-distance^6 units)\n\\(a\\) (distance units)\n\\(\\alpha\\) (1/distance units)\n\\(\\beta\\)  (1/distance^6 units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global cutoff\n\\(R_c\\) is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, coefficients must be specified.\nNo default mixing rules are used.\nThis pair style does not support the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style beck Rc",
    "parameters": " * Rc = cutoff for interactions (distance units)",
    "examples": "pair_style beck 8.0\npair_coeff * * 399.671876712 0.0000867636112694 0.675 4.390 0.0003746\npair_coeff 1 1 399.671876712 0.0000867636112694 0.675 4.390 0.0003746 6.0",
    "restrictions": "none"
},
{
    "command": "pair_style body/nparticle",
    "html_filename": "pair_body_nparticle.html",
    "short_description": "Style body/nparticle is for use with body particles and calculates pairwise body/body interactions as well as interactions between body and point-particles",
    "description": "Style body/nparticle is for use with body particles and calculates\npairwise body/body interactions as well as interactions between body\nand point-particles.  See the Howto body doc page\nfor more details on using body particles.\nThis pair style is designed for use with the “nparticle” body style,\nwhich is specified as an argument to the “atom-style body” command.\nSee the Howto body doc page for more details about\nthe body styles LAMMPS supports.  The “nparticle” style treats a body\nparticle as a rigid body composed of N sub-particles.\nThe coordinates of a body particle are its center-of-mass (COM).  If\nthe COMs of a pair of body particles are within the cutoff (global or\ntype-specific, as specified above), then all interactions between\npairs of sub-particles in the two body particles are computed.\nE.g. if the first body particle has 3 sub-particles, and the second\nhas 10, then 30 interactions are computed and summed to yield the\ntotal force and torque on each body particle.\n\nNote\nIn the example just described, all 30 interactions are computed\neven if the distance between a particular pair of sub-particles is\ngreater than the cutoff.  Likewise, no interaction between two body\nparticles is computed if the two COMs are further apart than the\ncutoff, even if the distance between some pairs of their sub-particles\nis within the cutoff.  Thus care should be used in defining the cutoff\ndistances for body particles, depending on their shape and size.\n\nSimilar rules apply for a body particle interacting with a point\nparticle.  The distance between the two particles is calculated using\nthe COM of the body particle and the position of the point particle.\nIf the distance is within the cutoff and the body particle has N\nsub-particles, then N interactions with the point particle are\ncomputed and summed.  If the distance is not within the cutoff, no\ninteractions between the body and point particle are computed.\nThe interaction between two sub-particles, or a sub-particle and point\nparticle, or between two point particles is computed as a Lennard-Jones\ninteraction, using the standard formula\n\n\\[\\begin{split}E & = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                    \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                    \\qquad r < R_c \\\\\\end{split}\\]\nwhere \\(R_c\\) is the cutoff.  As explained above, an interaction involving\none or two body sub-particles may be computed even for \\(r > R_c\\).\nFor style body, the following coefficients must be defined for each\npair of atoms types via the pair_coeff command as in\nthe examples above, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global cutoff\nis used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of this pair style can be mixed.  The\ndefault mix value is geometric.  See the pair_modify command for\ndetails.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style body/nparticle cutoff",
    "parameters": " * cutoff = global cutoff for interactions (distance units)",
    "examples": "pair_style body/nparticle 3.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.0 1.5 2.5",
    "restrictions": "This style is part of the BODY package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info.\nDefining particles to be bodies so they participate in body/body or\nbody/particle interactions requires the use of the atom_style body command."
},
{
    "command": "pair_style body/rounded/polygon",
    "html_filename": "pair_body_rounded_polygon.html",
    "short_description": "Style body/rounded/polygon is for use with 2d models of body particles of style rounded/polygon",
    "description": "Style body/rounded/polygon is for use with 2d models of body\nparticles of style rounded/polygon.  It calculates pairwise\nbody/body interactions which can include body particles modeled as\n1-vertex circular disks with a specified diameter.  See the\nHowto body doc page for more details on using body\nrounded/polygon particles.\nThis pairwise interaction between rounded polygons is described in\nFraige, where a polygon does not have sharp corners,\nbut is rounded at its vertices by circles centered on each vertex with\na specified diameter.  The edges of the polygon are defined between\npairs of adjacent vertices.  The circle diameter for each polygon is\nspecified in the data file read by the read data\ncommand.  This is a 2d discrete element model (DEM) which allows for\nmultiple contact points.\nNote that when two particles interact, the effective surface of each\npolygon particle is displaced outward from each of its vertices and\nedges by half its circle diameter (as in the diagram below of a gray\nand yellow square particle).  The interaction forces and energies\nbetween two particles are defined with respect to the separation of\ntheir respective rounded surfaces, not by the separation of the\nvertices and edges themselves.\nThis means that the specified cutoff in the pair_style command is the\ncutoff distance, \\(r_c\\), for the surface separation, \\(\\delta_n\\) (see figure\nbelow).  This is the distance at which two particles no longer\ninteract.  If \\(r_c\\) is specified as 0.0, then it is a contact-only\ninteraction.  I.e. the two particles must overlap in order to exert a\nrepulsive force on each other.  If \\(r_c > 0.0\\), then the force between\ntwo particles will be attractive for surface separations from 0 to\n\\(r_c\\), and repulsive once the particles overlap.\nNote that unlike for other pair styles, the specified cutoff is not\nthe distance between the centers of two particles at which they stop\ninteracting.  This center-to-center distance depends on the shape and\nsize of the two particles and their relative orientation.  LAMMPS\ntakes that into account when computing the surface separation distance\nand applying the \\(r_c\\) cutoff.\nThe forces between vertex-vertex, vertex-edge, and edge-edge overlaps\nare given by:\n\n\\[\\begin{split}F_n &= \\begin{cases}\n        k_n \\delta_n - c_n v_n     &  \\delta_n \\le 0 \\\\\n       -k_{na} \\delta_n - c_n v_n  &  0 < \\delta_n \\le r_c \\\\\n       0                           & \\delta_n > r_c \\\\\n       \\end{cases} \\\\\nF_t &= \\begin{cases}\n       \\mu k_n \\delta_n - c_t v_t & \\delta_n \\le 0 \\\\\n       0                          & \\delta_n > 0\n       \\end{cases}\\end{split}\\]\n\nNote that \\(F_n\\) and \\(F_t\\) are functions of the surface separation\n\\(\\delta_n = d - (R_i + R_j)\\).  In this model, when\n\\((R_i + R_j) < d < (R_i + R_j) + r_c\\), that is, \\(0 < \\delta_n < r_c\\),\nthe cohesive region of the two surfaces overlap and the two surfaces are\nattractive to each other.\nIn Fraige, the tangential friction force between two\nparticles that are in contact is modeled differently prior to gross\nsliding (i.e. static friction) and during gross-sliding (kinetic\nfriction).  The latter takes place when the tangential deformation\nexceeds the Coulomb frictional limit.  In the current implementation,\nhowever, we do not take into account frictional history, i.e. we do\nnot keep track of how many time steps the two particles have been in\ncontact nor calculate the tangential deformation.  Instead, we assume\nthat gross sliding takes place as soon as two particles are in\ncontact.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file read by the read_data command:\n\n\\(k_n\\) (energy/distance^2 units)\n\\(k_{na}\\) (energy/distance^2 units)\n\nEffectively, \\(k_n\\) and \\(k_{na}\\) are the slopes of the red lines in the plot\nabove for force versus surface separation, for \\(\\delta_n < 0\\) and\n\\(0 < \\delta_n < r_c\\) respectively.\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style body/rounded/polygon c_n c_t mu delta_ua cutoff",
    "parameters": " * c_n = normal damping coefficient\n * c_t = tangential damping coefficient\n * mu = normal friction coefficient during gross sliding\n * delta_ua = multiple contact scaling factor\n * cutoff = global separation cutoff for interactions (distance units), see below for definition",
    "examples": "pair_style body/rounded/polygon 20.0 5.0 0.0 1.0 0.5\npair_coeff * * 100.0 1.0\npair_coeff 1 1 100.0 1.0",
    "restrictions": "These pair styles are part of the BODY package.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions."
},
{
    "command": "pair_style body/rounded/polyhedron",
    "html_filename": "pair_body_rounded_polyhedron.html",
    "short_description": "Style body/rounded/polygon is for use with 3d models of body particles of style rounded/polyhedron",
    "description": "Style body/rounded/polygon is for use with 3d models of body\nparticles of style rounded/polyhedron.  It calculates pairwise\nbody/body interactions which can include body particles modeled as\n1-vertex spheres with a specified diameter.  See the\nHowto body doc page for more details on using body\nrounded/polyhedron particles.\nThis pairwise interaction between the rounded polyhedra is described\nin Wang, where a polyhedron does not have sharp corners\nand edges, but is rounded at its vertices and edges by spheres\ncentered on each vertex with a specified diameter.  The edges if the\npolyhedron are defined between pairs of adjacent vertices.  Its faces\nare defined by a loop of edges.  The sphere diameter for each polygon\nis specified in the data file read by the read data\ncommand.  This is a discrete element model (DEM) which allows for\nmultiple contact points.\nNote that when two particles interact, the effective surface of each\npolyhedron particle is displaced outward from each of its vertices,\nedges, and faces by half its sphere diameter.  The interaction forces\nand energies between two particles are defined with respect to the\nseparation of their respective rounded surfaces, not by the separation\nof the vertices, edges, and faces themselves.\nThis means that the specified cutoff in the pair_style command is the\ncutoff distance, \\(r_c\\), for the surface separation, \\(\\delta_n\\) (see figure\nbelow).  This is the distance at which two particles no longer\ninteract.  If \\(r_c\\) is specified as 0.0, then it is a contact-only\ninteraction.  I.e. the two particles must overlap in order to exert a\nrepulsive force on each other.  If \\(r_c > 0.0\\), then the force between\ntwo particles will be attractive for surface separations from 0 to\n\\(r_c\\), and repulsive once the particles overlap.\nNote that unlike for other pair styles, the specified cutoff is not\nthe distance between the centers of two particles at which they stop\ninteracting.  This center-to-center distance depends on the shape and\nsize of the two particles and their relative orientation.  LAMMPS\ntakes that into account when computing the surface separation distance\nand applying the \\(r_c\\) cutoff.\nThe forces between vertex-vertex, vertex-edge, vertex-face, edge-edge,\nand edge-face overlaps are given by:\n\n\\[\\begin{split}F_n &= \\begin{cases}\n       k_n \\delta_n - c_n v_n,    & \\delta_n \\le 0 \\\\\n      -k_{na} \\delta_n - c_n v_n  & 0 < \\delta_n \\le r_c \\\\\n       0                          & \\delta_n > r_c \\\\\n       \\end{cases} \\\\\nF_t &= \\begin{cases}\n       \\mu k_n \\delta_n - c_t v_t & \\delta_n \\le 0 \\\\\n       0                          & \\delta_n > 0\n       \\end{cases}\\end{split}\\]\n\nIn Wang, the tangential friction force between two\nparticles that are in contact is modeled differently prior to gross\nsliding (i.e. static friction) and during gross-sliding (kinetic\nfriction).  The latter takes place when the tangential deformation\nexceeds the Coulomb frictional limit.  In the current implementation,\nhowever, we do not take into account frictional history, i.e. we do\nnot keep track of how many time steps the two particles have been in\ncontact nor calculate the tangential deformation.  Instead, we assume\nthat gross sliding takes place as soon as two particles are in\ncontact.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file read by the read_data command:\n\n\\(k_n\\) (energy/distance^2 units)\n\\(k_{na}\\) (energy/distance^2 units)\n\nEffectively, \\(k_n\\) and \\(k_{na}\\) are the slopes of the red lines in the plot\nabove for force versus surface separation, for \\(\\delta_n\\) < 0 and\n\\(0 < \\delta_n < r_c\\) respectively.\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files.\nThus, you need to re-specify the pair_style and pair_coeff\ncommands in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style body/rounded/polyhedron c_n c_t mu delta_ua cutoff",
    "parameters": " * c_n = normal damping coefficient\n * c_t = tangential damping coefficient\n * mu = normal friction coefficient during gross sliding\n * delta_ua = multiple contact scaling factor\n * cutoff = global separation cutoff for interactions (distance units), see below for definition",
    "examples": "pair_style body/rounded/polyhedron 20.0 5.0 0.0 1.0 0.5\npair_coeff * * 100.0 1.0\npair_coeff 1 1 100.0 1.0",
    "restrictions": "These pair styles are part of the BODY package.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions."
},
{
    "command": "pair_style bop",
    "html_filename": "pair_bop.html",
    "short_description": "The bop pair style computes Bond-Order Potentials (BOP) based on quantum mechanical theory incorporating both \\(\\sigma\\) and \\(\\pi\\) bonding",
    "description": "The bop pair style computes Bond-Order Potentials (BOP) based on\nquantum mechanical theory incorporating both \\(\\sigma\\) and \\(\\pi\\) bonding.\nBy analytically deriving the BOP from quantum mechanical theory its\ntransferability to different phases can approach that of quantum\nmechanical methods.  This potential is similar to the original BOP\ndeveloped by Pettifor (Pettifor_1,\nPettifor_2, Pettifor_3) and later updated\nby Murdick, Zhou, and Ward (Murdick, Ward).\nCurrently, BOP potential files for these systems are provided with\nLAMMPS: AlCu, CCu, CdTe, CdTeSe, CdZnTe, CuH, GaAs.  A system with\nonly a subset of these elements, including a single element (e.g. C or\nCu or Al or Ga or Zn or CdZn), can also be modeled by using the\nappropriate alloy file and assigning all atom types to the\nsingle element or subset of elements via the pair_coeff command, as\ndiscussed below.\nThe BOP potential consists of three terms:\n\n\\[E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\phi_{ij} \\left( r_{ij} \\right) - \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\beta_{\\sigma,ij} \\left( r_{ij} \\right) \\cdot \\Theta_{\\sigma,ij} - \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\beta_{\\pi,ij} \\left( r_{ij} \\right) \\cdot \\Theta_{\\pi,ij} + U_{prom}\\]\nwhere \\(\\phi_{ij}(r_{ij})\\) is a short-range two-body function\nrepresenting the repulsion between a pair of ion cores,\n\\(\\beta_{\\sigma,ij}(r_{ij})\\) and \\(\\beta_{\\sigma,ij}(r_{ij})\\)\nare respectively sigma and \\(\\pi\\) bond integrals, \\(\\Theta_{\\sigma,ij}\\)\nand \\(\\Theta_{\\pi,ij}\\) are \\(\\sigma\\) and \\(\\pi\\)\nbond-orders, and U_prom is the promotion energy for sp-valent systems.\nThe detailed formulas for this potential are given in Ward\n(Ward); here we provide only a brief description.\nThe repulsive energy \\(\\phi_{ij}(r_{ij})\\) and the bond integrals\n\\(\\beta_{\\sigma,ij}(r_{ij})\\) and \\(\\beta_{\\phi,ij}(r_{ij})\\) are functions of the\ninteratomic distance \\(r_{ij}\\) between atom i and j.  Each of these\npotentials has a smooth cutoff at a radius of \\(r_{cut,ij}\\).  These\nsmooth cutoffs ensure stable behavior at situations with high sampling\nnear the cutoff such as melts and surfaces.\nThe bond-orders can be viewed as environment-dependent local variables\nthat are ij bond specific.  The maximum value of the \\(\\sigma\\)\nbond-order (\\(\\Theta_{\\sigma}\\) is 1, while that of the \\(\\pi\\)\nbond-order (\\(\\Theta_{\\pi}\\)) is 2, attributing to a maximum value\nof the total bond-order (\\(\\Theta_{\\sigma}+\\Theta_{\\pi}\\)) of 3.\nThe \\(\\sigma\\) and \\(\\pi\\) bond-orders reflect the ubiquitous\nsingle-, double-, and triple- bond behavior of chemistry. Their\nanalytical expressions can be derived from tight- binding theory by\nrecursively expanding an inter-site Green’s function as a continued\nfraction. To accurately represent the bonding with a computationally\nefficient potential formulation suitable for MD simulations, the derived\nBOP only takes (and retains) the first two levels of the recursive\nrepresentations for both the \\(\\sigma\\) and the \\(\\pi\\) bond-orders. Bond-order\nterms can be understood in terms of molecular orbital hopping paths\nbased upon the Cyrot-Lackmann theorem (Pettifor_1).\nThe \\(\\sigma\\) bond-order with a half-full valence shell is used to\ninterpolate the bond-order expression that incorporated explicit valance\nband filling.  This \\(\\pi\\) bond-order expression also contains also contains\na three-member ring term that allows implementation of an asymmetric\ndensity of states, which helps to either stabilize or destabilize\nclose-packed structures.  The \\(\\pi\\) bond-order includes hopping paths of\nlength 4.  This enables the incorporation of dihedral angles effects.\n\nNote\nNote that unlike for other potentials, cutoffs for BOP\npotentials are not set in the pair_style or pair_coeff command; they\nare specified in the BOP potential files themselves.  Likewise, the\nBOP potential files list atomic masses; thus you do not need to use\nthe mass command to specify them.  Note that for BOP\npotentials with hydrogen, you will likely want to set the mass of H\natoms to be 10x or 20x larger to avoid having to use a tiny timestep.\nYou can do this by using the mass command after using the\npair_coeff command to read the BOP potential\nfile.\n\nOne option can be specified as a keyword with the pair_style command.\nThe save keyword gives you the option to calculate in advance and\nstore a set of distances, angles, and derivatives of angles.  The\ndefault is to not do this, but to calculate them on-the-fly each time\nthey are needed.  The former may be faster, but takes more memory.\nThe latter requires less memory, but may be slower.  It is best to\ntest this option to optimize the speed of BOP for your particular\nsystem configuration.\n\nOnly a single pair_coeff command is used with the bop style which\nspecifies a BOP potential file, with parameters for all needed\nelements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of BOP elements to atom types\n\nAs an example, imagine the CdTe.bop file has BOP values for Cd\nand Te.  If your LAMMPS simulation has 4 atoms types and you want the\n1st 3 to be Cd, and the 4th to be Te, you would use the following\npair_coeff command:\npair_coeff * * CdTe Cd Cd Cd Te\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Cd arguments map LAMMPS atom types 1,2,3 to the Cd\nelement in the BOP file.  The final Te argument maps LAMMPS atom type\n4 to the Te element in the BOP file.\nBOP files in the potentials directory of the LAMMPS distribution\nhave a “.bop” suffix.  The potentials are in tabulated form containing\npre-tabulated pair functions for phi_ij(r_ij), beta_(sigma,ij)(r_ij),\nand beta_pi,ij)(r_ij).\nThe parameters/coefficients format for the different kinds of BOP\nfiles are given below with variables matching the formulation of Ward\n(Ward) and Zhou (Zhou). Each header line containing a\n“:” is preceded by a blank line.\n\nNo angular table file format:\nThe parameters/coefficients format for the BOP potentials input file\ncontaining pre-tabulated functions of g is given below with variables\nmatching the formulation of Ward (Ward).  This format also\nassumes the angular functions have the formulation of (Ward).\n\nLine 1: # elements N\n\nThe first line is followed by N lines containing the atomic\nnumber, mass, and element symbol of each element.\nFollowing the definition of the elements several global variables for\nthe tabulated functions are given.\n\nLine 1: nr, nBOt (nr is the number of divisions the radius is broken\ninto for function tables and MUST be a factor of 5; nBOt is the number\nof divisions for the tabulated values of THETA_(S,ij)\nLine 2: delta_1-delta_7 (if all are not used in the particular\nformulation, set unused values to 0.0)\n\nFollowing this N lines for e_1-e_N containing p_pi.\n\nLine 3: p_pi (for e_1)\nLine 4: p_pi (for e_2 and continues to e_N)\n\nThe next section contains several pair constants for the number of\ninteraction types e_i-e_j, with i=1->N, j=i->N\n\nLine 1: r_cut (for e_1-e_1 interactions)\nLine 2: c_sigma, a_sigma, c_pi, a_pi\nLine 3: delta_sigma, delta_pi\nLine 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\nthe previous section but is interaction type dependent)\n\nThe next section contains a line for each three body interaction type\ne_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n\nLine 1: g_(sigma0), g_(sigma1), g_(sigma2) (These are coefficients for\ng_(sigma,jik)(THETA_ijk) for e_1-e_1-e_1 interaction. Ward\ncontains the full expressions for the constants as functions of\nb_(sigma,ijk), p_(sigma,ijk), u_(sigma,ijk))\nLine 2: g_(sigma0), g_(sigma1), g_(sigma2) (for e_1-e_1-e_2)\n\nThe next section contains a block for each interaction type for the\nphi_ij(r_ij).  Each block has nr entries with 5 entries per line.\n\nLine 1: phi(r1), phi(r2), phi(r3), phi(r4), phi(r5) (for the e_1-e_1\ninteraction type)\nLine 2: phi(r6), phi(r7), phi(r8), phi(r9), phi(r10) (this continues\nuntil nr)\n…\nLine nr/5_1: phi(r1), phi(r2), phi(r3), phi(r4), phi(r5), (for the\ne_1-e_1 interaction type)\n\nThe next section contains a block for each interaction type for the\nbeta_(sigma,ij)(r_ij).  Each block has nr entries with 5 entries per\nline.\n\nLine 1: beta_sigma(r1), beta_sigma(r2), beta_sigma(r3), beta_sigma(r4),\nbeta_sigma(r5) (for the e_1-e_1 interaction type)\nLine 2: beta_sigma(r6), beta_sigma(r7), beta_sigma(r8), beta_sigma(r9),\nbeta_sigma(r10) (this continues until nr)\n…\nLine nr/5+1: beta_sigma(r1), beta_sigma(r2), beta_sigma(r3),\nbeta_sigma(r4), beta_sigma(r5) (for the e_1-e_2 interaction type)\n\nThe next section contains a block for each interaction type for\nbeta_(pi,ij)(r_ij).  Each block has nr entries with 5 entries per line.\n\nLine 1: beta_pi(r1), beta_pi(r2), beta_pi(r3), beta_pi(r4), beta_pi(r5)\n(for the e_1-e_1 interaction type)\nLine 2: beta_pi(r6), beta_pi(r7), beta_pi(r8), beta_pi(r9),\nbeta_pi(r10) (this continues until nr)\n…\nLine nr/5+1: beta_pi(r1), beta_pi(r2), beta_pi(r3), beta_pi(r4),\nbeta_pi(r5) (for the e_1-e_2 interaction type)\n\nThe next section contains a block for each interaction type for the\nTHETA_(S,ij)((THETA_(sigma,ij))^(1/2), f_(sigma,ij)).  Each block has\nnBOt entries with 5 entries per line.\n\nLine 1: THETA_(S,ij)(r1), THETA_(S,ij)(r2), THETA_(S,ij)(r3),\nTHETA_(S,ij)(r4), THETA_(S,ij)(r5) (for the e_1-e_2 interaction type)\nLine 2: THETA_(S,ij)(r6), THETA_(S,ij)(r7), THETA_(S,ij)(r8),\nTHETA_(S,ij)(r9), THETA_(S,ij)(r10) (this continues until nBOt)\n…\nLine nBOt/5+1: THETA_(S,ij)(r1), THETA_(S,ij)(r2), THETA_(S,ij)(r3),\nTHETA_(S,ij)(r4), THETA_(S,ij)(r5) (for the e_1-e_2 interaction type)\n\nThe next section contains a block of N lines for e_1-e_N\n\nLine 1: delta^mu (for e_1)\nLine 2: delta^mu (for e_2 and repeats to e_N)\n\nThe last section contains more constants for e_i-e_j interactions with\ni=0->N, j=i->N\n\nLine 1: (A_ij)^(mu*nu) (for e1-e1)\nLine 2: (A_ij)^(mu*nu) (for e1-e2 and repeats as above)\n\n\nAngular spline table file format:\nThe parameters/coefficients format for the BOP potentials input file\ncontaining pre-tabulated functions of g is given below with variables\nmatching the formulation of Ward (Ward).  This format also\nassumes the angular functions have the formulation of (Zhou).\n\nLine 1: # elements N\n\nThe first line is followed by N lines containing the atomic\nnumber, mass, and element symbol of each element.\nFollowing the definition of the elements several global variables for\nthe tabulated functions are given.\n\nLine 1: nr, ntheta, nBOt (nr is the number of divisions the radius is broken\ninto for function tables and MUST be a factor of 5; ntheta is the power of the\npower of the spline used to fit the angular function; nBOt is the number\nof divisions for the tabulated values of THETA_(S,ij)\nLine 2: delta_1-delta_7 (if all are not used in the particular\nformulation, set unused values to 0.0)\n\nFollowing this N lines for e_1-e_N containing p_pi.\n\nLine 3: p_pi (for e_1)\nLine 4: p_pi (for e_2 and continues to e_N)\n\nThe next section contains several pair constants for the number of\ninteraction types e_i-e_j, with i=1->N, j=i->N\n\nLine 1: r_cut (for e_1-e_1 interactions)\nLine 2: c_sigma, a_sigma, c_pi, a_pi\nLine 3: delta_sigma, delta_pi\nLine 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\nthe previous section but is interaction type dependent)\n\nThe next section contains a line for each three body interaction type\ne_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n\nLine 1: g0, g1, g2… (These are coefficients for the angular spline\nof the g_(sigma,jik)(THETA_ijk) for e_1-e_1-e_1 interaction.  The\nfunction can contain up to 10 term thus 10 constants.  The first line\ncan contain up to five constants.  If the spline has more than five\nterms the second line will contain the remaining constants The\nfollowing lines will then contain the constants for the remaining g0,\ng1, g2… (for e_1-e_1-e_2) and the other three body\ninteractions\n\nThe rest of the table has the same structure as the previous section\n(see above).\n\nAngular no-spline table file format:\nThe parameters/coefficients format for the BOP potentials input file\ncontaining pre-tabulated functions of g is given below with variables\nmatching the formulation of Ward (Ward).  This format also\nassumes the angular functions have the formulation of (Zhou).\n\nLine 1: # elements N\n\nThe first two lines are followed by N lines containing the atomic\nnumber, mass, and element symbol of each element.\nFollowing the definition of the elements several global variables for\nthe tabulated functions are given.\n\nLine 1: nr, ntheta, nBOt (nr is the number of divisions the radius is broken\ninto for function tables and MUST be a factor of 5; ntheta is the number of\ndivisions for the tabulated values of the g angular function; nBOt is the number\nof divisions for the tabulated values of THETA_(S,ij)\nLine 2: delta_1-delta_7 (if all are not used in the particular\nformulation, set unused values to 0.0)\n\nFollowing this N lines for e_1-e_N containing p_pi.\n\nLine 3: p_pi (for e_1)\nLine 4: p_pi (for e_2 and continues to e_N)\n\nThe next section contains several pair constants for the number of\ninteraction types e_i-e_j, with i=1->N, j=i->N\n\nLine 1: r_cut (for e_1-e_1 interactions)\nLine 2: c_sigma, a_sigma, c_pi, a_pi\nLine 3: delta_sigma, delta_pi\nLine 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\nthe previous section but is interaction type dependent)\n\nThe next section contains a line for each three body interaction type\ne_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n\nLine 1: g(theta1), g(theta2), g(theta3), g(theta4), g(theta5) (for the e_1-e_1-e_1\ninteraction type)\nLine 2: g(theta6), g(theta7), g(theta8), g(theta9), g(theta10) (this continues\nuntil ntheta)\n…\nLine ntheta/5+1: g(theta1), g(theta2), g(theta3), g(theta4), g(theta5), (for the\ne_1-e_1-e_2 interaction type)\n\nThe rest of the table has the same structure as the previous section (see above).\n\nMixing, shift, table tail correction, restart:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style bop keyword ...",
    "parameters": " * zero or more keywords may be appended\n * keyword = save\n * save = pre-compute and save some values",
    "examples": "pair_style bop\npair_coeff * * ../potentials/CdTe_bop Cd Te\npair_style bop save\npair_coeff * * ../potentials/CdTe.bop.table Cd Te Te\ncomm_modify cutoff 14.70",
    "restrictions": "These pair styles are part of the MANYBODY package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair potentials require the newtion setting to be\n“on” for pair interactions.\nThe CdTe.bop and GaAs.bop potential files provided with LAMMPS (see the\npotentials directory) are parameterized for metal units.\nYou can use the BOP potential with any LAMMPS units, but you would need\nto create your own BOP potential file with coefficients listed in the\nappropriate units if your simulation does not use “metal” units."
},
{
    "command": "pair_style born",
    "html_filename": "pair_born.html",
    "short_description": "The born style computes the Born-Mayer-Huggins or Tosi/Fumi potential described in (Fumi and Tosi), given by  \\[E = A \\exp \\left(\\frac{\\sigma - r}{\\rho} \\right) - \\frac{C}{r^6} + \\frac{D}{r^8} \\qquad r < r_c\\] where \\(\\sigma\\) is an interaction-dependent length parameter, \\(\\rho\\) is an ionic-pair dependent length parameter, and \\(r_c\\) is the cutoff",
    "description": "The born style computes the Born-Mayer-Huggins or Tosi/Fumi\npotential described in (Fumi and Tosi), given by\n\n\\[E = A \\exp \\left(\\frac{\\sigma - r}{\\rho} \\right) -\n\\frac{C}{r^6} + \\frac{D}{r^8} \\qquad r < r_c\\]\nwhere \\(\\sigma\\) is an interaction-dependent length parameter,\n\\(\\rho\\) is an ionic-pair dependent length parameter, and\n\\(r_c\\) is the cutoff.\nThe styles with coul/long or coul/msm add a Coulombic term as\ndescribed for the lj/cut pair styles.  An additional\ndamping factor is applied to the Coulombic term so it can be used in\nconjunction with the kspace_style command and its\newald or pppm of msm option.  The Coulombic cutoff specified for\nthis style means that pairwise interactions within this distance are\ncomputed directly; interactions outside that distance are computed in\nreciprocal space.\nIf one cutoff is specified for the born/coul/long and\nborn/coul/msm style, it is used for both the A,C,D and Coulombic\nterms.  If two cutoffs are specified, the first is used as the cutoff\nfor the A,C,D terms, and the second is the cutoff for the Coulombic\nterm.\nThe born/coul/wolf style adds a Coulombic term as described for the\nWolf potential in the coul/wolf pair style.\nThe born/coul/dsf style computes the Coulomb contribution with the\ndamped shifted force model as in the coul/dsf style.\nNote that these potentials are related to the Buckingham potential.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nA (energy units)\n\\(\\rho\\) (distance units)\n\\(\\sigma\\) (distance units)\nC (energy units * distance units^6)\nD (energy units * distance units^8)\ncutoff (distance units)\n\nThe second coefficient, rho, must be greater than zero.\nThe last coefficient is optional.  If not specified, the global A,C,D\ncutoff specified in the pair_style command is used.\nFor born/coul/long, born/coul/wolf and born/coul/dsf no\nCoulombic cutoff can be specified for an individual I,J type pair.\nAll type pairs use the same global Coulombic cutoff specified in the\npair_style command.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThese styles support the pair_modify shift option\nfor the energy of the exp(), 1/r^6, and 1/r^8 portion of the pair\ninteraction.\nThe born/coul/long pair style supports the\npair_modify table option to tabulate the\nshort-range portion of the long-range Coulombic interaction.\nThese styles support the pair_modify tail option for adding long-range\ntail corrections to energy and pressure.\nThess styles writes thei information to binary restart\nfiles, so pair_style and pair_coeff commands do not need to be\nspecified in an input script that reads a restart file.\nThese styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = born or born/coul/long or born/coul/msm or born/coul/wolf\n * args = list of arguments for a particular style\n * born args = cutoff\n *   cutoff = global cutoff for non-Coulombic interactions (distance units)\n * born/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * born/coul/msm args = cutoff (cutoff2)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * born/coul/wolf args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * born/coul/dsf args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (distance units)",
    "examples": "pair_style born 10.0\npair_coeff * * 6.08 0.317 2.340 24.18 11.51\npair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n\npair_style born/coul/long 10.0\npair_style born/coul/long 10.0 8.\npair_coeff * * 6.08 0.317 2.340 24.18 11.51\npair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n\npair_style born/coul/msm 10.0\npair_style born/coul/msm 10.0 8.0\npair_coeff * * 6.08 0.317 2.340 24.18 11.51\npair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n\npair_style born/coul/wolf 0.25 10.0\npair_style born/coul/wolf 0.25 10.0 9.0\npair_coeff * * 6.08 0.317 2.340 24.18 11.51\npair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n\npair_style born/coul/dsf 0.1 10.0 12.0\npair_coeff * *   0.0 1.00 0.00 0.00 0.00\npair_coeff 1 1 480.0 0.25 0.00 1.05 0.50",
    "restrictions": "The born/coul/long style is part of the KSPACE package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style brownian",
    "html_filename": "pair_brownian.html",
    "short_description": "Styles brownian and brownian/poly compute Brownian forces and torques on finite-size spherical particles",
    "description": "Styles brownian and brownian/poly compute Brownian forces and\ntorques on finite-size spherical particles.  The former requires\nmonodisperse spherical particles; the latter allows for polydisperse\nspherical particles.\nThese pair styles are designed to be used with either the pair_style lubricate or pair_style lubricateU commands to provide thermostatting\nwhen dissipative lubrication forces are acting.  Thus the parameters\nmu, flaglog, flagfld, cutinner, and cutoff should be\nspecified consistent with the settings in the lubrication pair styles.\nFor details, refer to either of the lubrication pair styles.\nThe t_target setting is used to specify the target temperature of\nthe system.  The random number seed is used to generate random\nnumbers for the thermostatting procedure.\nThe flagHI and flagVF settings are optional.  Neither should be\nused, or both must be defined.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutinner (distance units)\ncutoff (distance units)\n\nThe two coefficients are optional.  If neither is specified, the two\ncutoffs specified in the pair_style command are used.  Otherwise both\nmust be specified.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed in this section of\nthe manual.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee this section of the manual for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the two cutoff distances for this\npair style can be mixed.  The default mix value is geometric.  See\nthe “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style mu flaglog flagfld cutinner cutoff t_target seed flagHI flagVF",
    "parameters": " * style = brownian or brownian/poly\n * mu = dynamic viscosity (dynamic viscosity units)\n * flaglog = 0/1 log terms in the lubrication approximation on/off\n * flagfld = 0/1 to include/exclude Fast Lubrication Dynamics effects\n * cutinner = inner cutoff distance (distance units)\n * cutoff = outer cutoff for interactions (distance units)\n * t_target = target temp of the system (temperature units)\n * seed = seed for the random number generator (positive integer)\n * flagHI (optional) = 0/1 to include/exclude 1/r hydrodynamic interactions\n * flagVF (optional) = 0/1 to include/exclude volume fraction corrections in the long-range isotropic terms",
    "examples": "pair_style brownian 1.5 1 1 2.01 2.5 2.0 5878567 (assuming radius = 1)\npair_coeff 1 1 2.05 2.8\npair_coeff * *",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nOnly spherical monodisperse particles are allowed for pair_style\nbrownian.\nOnly spherical particles are allowed for pair_style brownian/poly."
},
{
    "command": "pair_style buck",
    "html_filename": "pair_buck.html",
    "short_description": "The buck style computes a Buckingham potential (exp/6 instead of Lennard-Jones 12/6) given by  \\[E = A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c\\] where \\(\\rho\\) is an ionic-pair dependent length parameter, and \\(r_c\\) is the cutoff on both terms",
    "description": "The buck style computes a Buckingham potential (exp/6 instead of\nLennard-Jones 12/6) given by\n\n\\[E = A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c\\]\nwhere \\(\\rho\\) is an ionic-pair dependent length parameter, and\n\\(r_c\\) is the cutoff on both terms.\nThe styles with coul/cut or coul/long or coul/msm add a\nCoulombic term as described for the lj/cut pair styles.\nFor buck/coul/long and buc/coul/msm, an additional damping factor\nis applied to the Coulombic term so it can be used in conjunction with\nthe kspace_style command and its ewald or pppm\nor msm option.  The Coulombic cutoff specified for this style means\nthat pairwise interactions within this distance are computed directly;\ninteractions outside that distance are computed in reciprocal space.\nIf one cutoff is specified for the born/coul/cut and\nborn/coul/long and born/coul/msm styles, it is used for both the\nA,C and Coulombic terms.  If two cutoffs are specified, the first is\nused as the cutoff for the A,C terms, and the second is the cutoff for\nthe Coulombic term.\nNote that these potentials are related to the Born-Mayer-Huggins potential.\n\nNote\nFor all these pair styles, the terms with A and C are always\ncutoff.  The additional Coulombic term can be cutoff or long-range (no\ncutoff) depending on whether the style name includes coul/cut or\ncoul/long or coul/msm.  If you wish the C/r^6 term to be long-range\n(no cutoff), then see the pair_style buck/long/coul/long command.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA (energy units)\n\\(\\rho\\) (distance units)\nC (energy-distance^6 units)\ncutoff (distance units)\ncutoff2 (distance units)\n\nThe second coefficient, \\(\\rho\\), must be greater than zero.\nThe coefficients A,:math:rho, and C can be written as analytical expressions\nof \\(\\epsilon\\) and \\(\\sigma\\), in analogy to the Lennard-Jones potential\n(Khrapak).\nThe latter 2 coefficients are optional.  If not specified, the global\nA,C and Coulombic cutoffs are used.  If only one cutoff is specified,\nit is used as the cutoff for both A,C and Coulombic interactions for\nthis type pair.  If both coefficients are specified, they are used as\nthe A,C and Coulombic cutoffs for this type pair.  You cannot specify\n2 cutoffs for style buck, since it has no Coulombic terms.\nFor buck/coul/long only the LJ cutoff can be specified since a\nCoulombic cutoff cannot be specified for an individual I,J type pair.\nAll type pairs use the same global Coulombic cutoff specified in the\npair_style command.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThese styles support the pair_modify shift option\nfor the energy of the exp() and 1/r^6 portion of the pair interaction.\nThe buck/coul/long pair style supports the\npair_modify table option to tabulate the\nshort-range portion of the long-range Coulombic interaction.\nThese styles support the pair_modify tail option for adding long-range\ntail corrections to energy and pressure for the A,C terms in the\npair interaction.\nThese styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = buck or buck/coul/cut or buck/coul/long or buck/coul/msm\n * args = list of arguments for a particular style\n * buck args = cutoff\n *   cutoff = global cutoff for Buckingham interactions (distance units)\n * buck/coul/cut args = cutoff (cutoff2)\n *   cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * buck/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * buck/coul/msm args = cutoff (cutoff2)\n *   cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style buck 2.5\npair_coeff * * 100.0 1.5 200.0\npair_coeff * * 100.0 1.5 200.0 3.0\n\npair_style buck/coul/cut 10.0\npair_style buck/coul/cut 10.0 8.0\npair_coeff * * 100.0 1.5 200.0\npair_coeff 1 1 100.0 1.5 200.0 9.0\npair_coeff 1 1 100.0 1.5 200.0 9.0 8.0\n\npair_style buck/coul/long 10.0\npair_style buck/coul/long 10.0 8.0\npair_coeff * * 100.0 1.5 200.0\npair_coeff 1 1 100.0 1.5 200.0 9.0\n\npair_style buck/coul/msm 10.0\npair_style buck/coul/msm 10.0 8.0\npair_coeff * * 100.0 1.5 200.0\npair_coeff 1 1 100.0 1.5 200.0 9.0",
    "restrictions": "The buck/coul/long style is part of the KSPACE package.  They are\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style buck6d/coul/gauss/dsf",
    "html_filename": "pair_buck6d_coul_gauss.html",
    "short_description": "The buck6d/coul/gauss styles evaluate vdW and Coulomb interactions following the MOF-FF force field after (Schmid)",
    "description": "The buck6d/coul/gauss styles evaluate vdW and Coulomb\ninteractions following the MOF-FF force field after\n(Schmid). The vdW term of the buck6d styles\ncomputes a dispersion damped Buckingham potential:\n\n\\[\\begin{split}E = A e^{-\\kappa r} - \\frac{C}{r^6} \\cdot \\frac{1}{1 + D r^{14}} \\qquad r < r_c \\\\\\end{split}\\]\nwhere A and C are a force constant, \\(\\kappa\\) is an ionic-pair dependent\nreciprocal length parameter, D is a dispersion correction parameter,\nand the cutoff \\(r_c\\) truncates the interaction distance.\nThe first term in the potential corresponds to the Buckingham\nrepulsion term and the second term to the dispersion attraction with\na damping correction analog to the Grimme correction used in DFT.\nThe latter corrects for artifacts occurring at short distances which\nbecome an issue for soft vdW potentials.\nThe buck6d styles include a smoothing function which is invoked\naccording to the global smoothing parameter within the specified\ncutoff.  Hereby a parameter of i.e. 0.9 invokes the smoothing\nwithin 90% of the cutoff.  No smoothing is applied at a value\nof 1.0. For the gauss/dsf style this smoothing is only applicable\nfor the dispersion damped Buckingham potential. For the gauss/long\nstyles the smoothing function can also be invoked for the real\nspace coulomb interactions which enforce continuous energies and\nforces at the cutoff.\nBoth styles buck6d/coul/gauss/dsf and buck6d/coul/gauss/long\nevaluate a Coulomb potential using spherical Gaussian type charge\ndistributions which effectively dampen electrostatic interactions\nfor high charges at close distances.  The electrostatic potential\nis thus evaluated as:\n\n\\[E = \\frac{C_{q_i q_j}}{\\epsilon r_{ij}}\\,\\, \\textrm{erf}\\left(\\alpha_{ij} r_{ij}\\right)\\quad\\quad\\quad r < r_c\\]\nwhere C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\nare the charges on the 2 atoms, epsilon is the dielectric constant which\ncan be set by the dielectric command, \\(\\alpha\\)\nis the ion pair dependent damping parameter and erf() is the\nerror-function.  The cutoff \\(r_c\\) truncates the interaction distance.\nThe style buck6d/coul/gauss/dsf computes the Coulomb interaction\nvia the damped shifted force model described in (Fennell)\napproximating an Ewald sum similar to the pair coul/dsf\nstyles. In buck6d/coul/gauss/long an additional damping factor is\napplied to the Coulombic term so it can be used in conjunction with the\nkspace_style command and its ewald or pppm\noptions. The Coulombic cutoff in this case separates the real and\nreciprocal space evaluation of the Ewald sum.\nIf one cutoff is specified it is used for both the vdW and Coulomb\nterms.  If two cutoffs are specified, the first is used as the cutoff\nfor the vdW terms, and the second is the cutoff for the Coulombic term.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA (energy units)\n\\(\\rho\\) (distance^-1 units)\nC (energy-distance^6 units)\nD (distance^14 units)\n\\(\\alpha\\) (distance^-1 units)\ncutoff (distance units)\n\nThe second coefficient, \\(\\rho\\), must be greater than zero. The\nlatter coefficient is optional.  If not specified, the global vdW cutoff\nis used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThese styles do not support the pair_modify shift\noption for the energy. Instead the smoothing function should be applied\nby setting the global smoothing parameter to a value < 1.0.\nThese styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.",
    "syntax": "pair_style style args",
    "parameters": " * style = buck6d/coul/gauss/dsf or buck6d/coul/gauss/long\n * args = list of arguments for a particular style\n * buck6d/coul/gauss/dsf args = smooth cutoff (cutoff2)\n *   smooth  = smoothing onset within Buckingham cutoff (ratio)\n *   cutoff  = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * buck6d/coul/gauss/long args = smooth smooth2 cutoff (cutoff2)\n *   smooth   = smoothing onset within Buckingham cutoff (ratio)\n *   smooth2  = smoothing onset within Coulombic cutoff (ratio)\n *   cutoff   = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2  = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style buck6d/coul/gauss/dsf    0.9000    12.0000\npair_coeff 1  1  1030.  3.061  457.179  4.521  0.608\n\npair_style buck6d/coul/gauss/long   0.9000  1.0000  12.0000\npair_coeff 1  1  1030.  3.061  457.179  4.521  0.608",
    "restrictions": "These styles are part of the USER-MOFFF package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style buck/long/coul/long",
    "html_filename": "pair_buck_long.html",
    "short_description": "The buck/long/coul/long style computes a Buckingham potential (exp/6 instead of Lennard-Jones 12/6) and Coulombic potential, given by  \\[\\begin{split}E = & A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c \\\\ E = & \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\end{split}\\] \\(r_c\\) is the cutoff",
    "description": "The buck/long/coul/long style computes a Buckingham potential (exp/6\ninstead of Lennard-Jones 12/6) and Coulombic potential, given by\n\n\\[\\begin{split}E = & A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c \\\\\nE = & \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\end{split}\\]\n\\(r_c\\) is the cutoff.  If one cutoff is specified in the pair_style\ncommand, it is used for both the Buckingham and Coulombic terms.  If\ntwo cutoffs are specified, they are used as cutoffs for the Buckingham\nand Coulombic terms respectively.\nThe purpose of this pair style is to capture long-range interactions\nresulting from both attractive 1/r^6 Buckingham and Coulombic 1/r\ninteractions.  This is done by use of the flag_buck and flag_coul\nsettings.  The Ismail paper has more details on when it is\nappropriate to include long-range 1/r^6 interactions, using this\npotential.\nIf flag_buck is set to long, no cutoff is used on the Buckingham\n1/r^6 dispersion term.  The long-range portion can be calculated by\nusing the kspace_style ewald/disp or pppm/disp\ncommands.  The specified Buckingham cutoff then determines which\nportion of the Buckingham interactions are computed directly by the\npair potential versus which part is computed in reciprocal space via\nthe Kspace style.  If flag_buck is set to cut, the Buckingham\ninteractions are simply cutoff, as with pair_style buck.\nIf flag_coul is set to long, no cutoff is used on the Coulombic\ninteractions.  The long-range portion can calculated by using any of\nseveral kspace_style command options such as\npppm or ewald.  Note that if flag_buck is also set to long, then\nthe ewald/disp or pppm/disp Kspace style needs to be used to\nperform the long-range calculations for both the Buckingham and\nCoulombic interactions.  If flag_coul is set to off, Coulombic\ninteractions are not computed.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA (energy units)\nrho (distance units)\nC (energy-distance^6 units)\ncutoff (distance units)\ncutoff2 (distance units)\n\nThe second coefficient, rho, must be greater than zero.\nThe latter 2 coefficients are optional.  If not specified, the global\nBuckingham and Coulombic cutoffs specified in the pair_style command\nare used.  If only one cutoff is specified, it is used as the cutoff\nfor both Buckingham and Coulombic interactions for this type pair.  If\nboth coefficients are specified, they are used as the Buckingham and\nCoulombic cutoffs for this type pair.  Note that if you are using\nflag_buck set to long, you cannot specify a Buckingham cutoff for\nan atom type pair, since only one global Buckingham cutoff is allowed.\nSimilarly, if you are using flag_coul set to long, you cannot\nspecify a Coulombic cutoff for an atom type pair, since only one\nglobal Coulombic cutoff is allowed.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair styles does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis pair style supports the pair_modify shift\noption for the energy of the exp() and 1/r^6 portion of the pair\ninteraction, assuming flag_buck is cut.\nThis pair style does not support the pair_modify\nshift option for the energy of the Buckingham portion of the pair\ninteraction.\nThis pair style supports the pair_modify table and\ntable/disp options since they can tabulate the short-range portion of\nthe long-range Coulombic and dispersion interactions.\nThis pair style write its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style supports the use of the inner, middle, and outer\nkeywords of the run_style respa command, meaning the\npairwise forces can be partitioned by distance at different levels of\nthe rRESPA hierarchy.  See the run_style command for\ndetails.",
    "syntax": "pair_style buck/long/coul/long flag_buck flag_coul cutoff (cutoff2)",
    "parameters": " * flag_buck = long or cut\n * long = use Kspace long-range summation for the dispersion term 1/r^6\n * cut = use a cutoff\n * flag_coul = long or off\n * long = use Kspace long-range summation for the Coulombic term 1/r\n * off = omit the Coulombic term\n * cutoff = global cutoff for Buckingham (and Coulombic if only 1 cutoff) (distance units)\n * cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style buck/long/coul/long cut off 2.5\npair_style buck/long/coul/long cut long 2.5 4.0\npair_style buck/long/coul/long long long 4.0\npair_coeff * * 1 1\npair_coeff 1 1 1 3 4",
    "restrictions": "This style is part of the KSPACE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style lj/charmm/coul/charmm",
    "html_filename": "pair_charmm.html",
    "short_description": "These pair styles compute Lennard Jones (LJ) and Coulombic interactions with additional switching or shifting functions that ramp the energy and/or force smoothly to zero between an inner and outer cutoff",
    "description": "These pair styles compute Lennard Jones (LJ) and Coulombic\ninteractions with additional switching or shifting functions that ramp\nthe energy and/or force smoothly to zero between an inner and outer\ncutoff.  They are implementations of the widely used CHARMM force\nfield used in the CHARMM MD code (and\nothers).  See (MacKerell) for a description of the\nCHARMM force field.\nThe styles with charmm (not charmmfsw or charmmfsh) in their\nname are the older, original LAMMPS implementations.  They compute the\nLJ and Coulombic interactions with an energy switching function (esw,\nshown in the formula below as S(r)), which ramps the energy smoothly\nto zero between the inner and outer cutoff.  This can cause\nirregularities in pair-wise forces (due to the discontinuous 2nd\nderivative of energy at the boundaries of the switching region), which\nin some cases can result in detectable artifacts in an MD simulation.\nThe newer styles with charmmfsw or charmmfsh in their name replace\nthe energy switching with force switching (fsw) and force shifting\n(fsh) functions, for LJ and Coulombic interactions respectively.\nThese follow the formulas and description given in\n(Steinbach) and (Brooks) to minimize these\nartifacts.\n\nNote\nThe newer charmmfsw or charmmfsh styles were released in\nMarch 2017.  We recommend they be used instead of the older charmm\nstyles.  This includes the newer dihedral_style charmmfsw command.  Eventually code from the new\nstyles will propagate into the related pair styles (e.g. implicit,\naccelerator, free energy variants).\n\n\nNote\nThe newest CHARMM pair styles reset the Coulombic energy\nconversion factor used internally in the code, from the LAMMPS value\nto the CHARMM value, as if it were effectively a parameter of the\nforce field.  This is because the CHARMM code uses a slightly\ndifferent value for the this conversion factor in real units (Kcal/mole), namely CHARMM = 332.0716, LAMMPS =\n332.06371.  This is to enable more precise agreement by LAMMPS with\nthe CHARMM force field energies and forces, when using one of these\ntwo CHARMM pair styles.\n\n\n\\[\\begin{split}E = & LJ(r) \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n  = & S(r) * LJ(r) \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n  = & 0 \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\nE = & C(r) \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n  = & S(r) * C(r) \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n  = & 0 \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\nLJ(r) = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n        \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\nC(r) = & \\frac{C q_i q_j}{ \\epsilon r} \\\\\nS(r) = & \\frac{ \\left[r_{\\rm out}^2 - r^2\\right]^2\n  \\left[r_{\\rm out}^2 + 2r^2 - 3{r_{\\rm in}^2}\\right]}\n{ \\left[r_{\\rm out}^2 - {r_{\\rm in}}^2\\right]^3 }\\end{split}\\]\nwhere S(r) is the energy switching function mentioned above for the\ncharmm styles.  See the (Steinbach) paper for the\nfunctional forms of the force switching and force shifting functions\nused in the charmmfsw and charmmfsh styles.\nWhen using the lj/charmm/coul/charmm styles, both the LJ and\nCoulombic terms require an inner and outer cutoff. They can be the\nsame for both formulas or different depending on whether 2 or 4\narguments are used in the pair_style command.  For the\nlj/charmmfsw/coul/charmmfsh style, the LJ term requires both an\ninner and outer cutoff, while the Coulombic term requires only one\ncutoff.  If the Coulombic cutoff is not specified (2 instead of 3\narguments), the LJ outer cutoff is used for the Coulombic cutoff.  In\nall cases where an inner and outer cutoff are specified, the inner\ncutoff distance must be less than the outer cutoff.  It is typical to\nmake the difference between the inner and outer cutoffs about 2.0\nAngstroms.\nStyle lj/charmm/coul/charmm/implicit computes the same formulas as\nstyle lj/charmm/coul/charmm except that an additional 1/r term is\nincluded in the Coulombic formula.  The Coulombic energy thus varies\nas 1/r^2.  This is effectively a distance-dependent dielectric term\nwhich is a simple model for an implicit solvent with additional\nscreening.  It is designed for use in a simulation of an unsolvated\nbiomolecule (no explicit water molecules).\nStyles lj/charmm/coul/long and lj/charmm/coul/msm compute the same\nformulas as style lj/charmm/coul/charmm and style\nlj/charmmfsw/coul/long computes the same formulas as style\nlj/charmmfsw/coul/charmmfsh, except that an additional damping\nfactor is applied to the Coulombic term, so it can be used in\nconjunction with the kspace_style command and its\newald or pppm or msm option.  Only one Coulombic cutoff is\nspecified for these styles; if only 2 arguments are used in the\npair_style command, then the outer LJ cutoff is used as the single\nCoulombic cutoff.  The Coulombic cutoff specified for these styles\nmeans that pairwise interactions within this distance are computed\ndirectly; interactions outside that distance are computed in\nreciprocal space.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\\(\\epsilon_{14}\\) (energy units)\n\\(\\sigma_{14}\\) (distance units)\n\nNote that \\(\\sigma\\) is defined in the LJ formula as the zero-crossing\ndistance for the potential, not as the energy minimum at \\(2^{1/6} \\sigma\\).\nThe latter 2 coefficients are optional.  If they are specified, they\nare used in the LJ formula between 2 atoms of these types which are\nalso first and fourth atoms in any dihedral.  No cutoffs are specified\nbecause the CHARMM force field does not allow varying cutoffs for\nindividual atom pairs; all pairs use the global cutoff(s) specified in\nthe pair_style command.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon, sigma, epsilon_14,\nand sigma_14 coefficients for all of the lj/charmm pair styles can be\nmixed.  The default mix value is arithmetic to coincide with the\nusual settings for the CHARMM force field.  See the “pair_modify”\ncommand for details.\nNone of the lj/charmm or lj/charmmfsw pair styles support the\npair_modify shift option, since the Lennard-Jones\nportion of the pair interaction is smoothed to 0.0 at the cutoff.\nThe lj/charmm/coul/long and lj/charmmfsw/coul/long styles support\nthe pair_modify table option since they can\ntabulate the short-range portion of the long-range Coulombic\ninteraction.\nNone of the lj/charmm or lj/charmmfsw pair styles support the\npair_modify tail option for adding long-range tail\ncorrections to energy and pressure, since the Lennard-Jones portion of\nthe pair interaction is smoothed to 0.0 at the cutoff.\nAll of the lj/charmm and lj/charmmfsw pair styles write their\ninformation to binary restart files, so pair_style and\npair_coeff commands do not need to be specified in an input script\nthat reads a restart file.\nThe lj/charmm/coul/long and lj/charmmfsw/coul/long pair styles\nsupport the use of the inner, middle, and outer keywords of the\nrun_style respa command, meaning the pairwise forces\ncan be partitioned by distance at different levels of the rRESPA\nhierarchy.  The other styles only support the pair keyword of\nrun_style respa.  See the run_style command for\ndetails.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/charmm/coul/charmm or lj/charmm/coul/charmm/implicit or lj/charmm/coul/long or lj/charmm/coul/msm or lj/charmmfsw/coul/charmmfsh or lj/charmmfsw/coul/long\n * args = list of arguments for a particular style\n * lj/charmm/coul/charmm args = inner outer (inner2) (outer2)\n *   inner, outer = global switching cutoffs for Lennard Jones (and Coulombic if only 2 args)\n *   inner2, outer2 = global switching cutoffs for Coulombic (optional)\n * lj/charmm/coul/charmm/implicit args = inner outer (inner2) (outer2)\n *   inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n *   inner2, outer2 = global switching cutoffs for Coulombic (optional)\n * lj/charmm/coul/long args = inner outer (cutoff)\n *   inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n *   cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n * lj/charmm/coul/msm args = inner outer (cutoff)\n *   inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n *   cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n * lj/charmmfsw/coul/charmmfsh args = inner outer (cutoff)\n *   inner, outer = global cutoffs for LJ (and Coulombic if only 2 args)\n *   cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n * lj/charmmfsw/coul/long args = inner outer (cutoff)\n *   inner, outer = global cutoffs for LJ (and Coulombic if only 2 args)\n *   cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)",
    "examples": "pair_style lj/charmm/coul/charmm 8.0 10.0\npair_style lj/charmm/coul/charmm 8.0 10.0 7.0 9.0\npair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0\npair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0 9.0\npair_coeff * * 100.0 2.0\npair_coeff 1 1 100.0 2.0 150.0 3.5\n\npair_style lj/charmm/coul/charmm/implicit 8.0 10.0\npair_style lj/charmm/coul/charmm/implicit 8.0 10.0 7.0 9.0\npair_coeff * * 100.0 2.0\npair_coeff 1 1 100.0 2.0 150.0 3.5\n\npair_style lj/charmm/coul/long 8.0 10.0\npair_style lj/charmm/coul/long 8.0 10.0 9.0\npair_style lj/charmmfsw/coul/long 8.0 10.0\npair_style lj/charmmfsw/coul/long 8.0 10.0 9.0\npair_coeff * * 100.0 2.0\npair_coeff 1 1 100.0 2.0 150.0 3.5\n\npair_style lj/charmm/coul/msm 8.0 10.0\npair_style lj/charmm/coul/msm 8.0 10.0 9.0\npair_coeff * * 100.0 2.0\npair_coeff 1 1 100.0 2.0 150.0 3.5",
    "restrictions": "All the styles with coul/charmm or coul/charmmfsh styles are part\nof the MOLECULE package.  All the styles with coul/long style are\npart of the KSPACE package.  They are only enabled if LAMMPS was built\nwith those packages.  See the Build package doc\npage for more info."
},
{
    "command": "pair_style lj/class2",
    "html_filename": "pair_class2.html",
    "short_description": "The lj/class2 styles compute a 6/9 Lennard-Jones potential given by  \\[E = \\epsilon \\left[ 2 \\left(\\frac{\\sigma}{r}\\right)^9 -   3 \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\qquad r < r_c\\] \\(r_c\\) is the cutoff",
    "description": "The lj/class2 styles compute a 6/9 Lennard-Jones potential given by\n\n\\[E = \\epsilon \\left[ 2 \\left(\\frac{\\sigma}{r}\\right)^9 -\n  3 \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n\\qquad r < r_c\\]\n\\(r_c\\) is the cutoff.\nThe lj/class2/coul/cut and lj/class2/coul/long styles add a\nCoulombic term as described for the lj/cut pair styles.\nSee (Sun) for a description of the COMPASS class2 force field.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nThe latter 2 coefficients are optional.  If not specified, the global\nclass 2 and Coulombic cutoffs are used.  If only one cutoff is\nspecified, it is used as the cutoff for both class 2 and Coulombic\ninteractions for this type pair.  If both coefficients are specified,\nthey are used as the class 2 and Coulombic cutoffs for this type pair.\nYou cannot specify 2 cutoffs for style lj/class2, since it has no\nCoulombic terms.\nFor lj/class2/coul/long only the class 2 cutoff can be specified\nsince a Coulombic cutoff cannot be specified for an individual I,J\ntype pair.  All type pairs use the same global Coulombic cutoff\nspecified in the pair_style command.\n\nIf the pair_coeff command is not used to define coefficients for a\nparticular I != J type pair, the mixing rule for \\(\\epsilon\\) and\n\\(\\sigma\\) for all class2 potentials is to use the sixthpower\nformulas documented by the pair_modify command.\nThe pair_modify mix setting is thus ignored for\nclass2 potentials for epsilon and sigma.  However it is still followed\nfor mixing the cutoff distance.\n\nA version of these styles with a soft core, lj/cut/soft, suitable for use in\nfree energy calculations, is part of the USER-FEP package and is documented with\nthe pair_style */soft styles. The version with soft core is\nonly available if LAMMPS was built with that package. See the Build package doc page for more info.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/class2 pair styles can be mixed.\nEpsilon and sigma are always mixed with the value sixthpower.  The\ncutoff distance is mixed by whatever option is set by the pair_modify\ncommand (default = geometric).  See the “pair_modify” command for\ndetails.\nAll of the lj/class2 pair styles support the\npair_modify shift option for the energy of the\nLennard-Jones portion of the pair interaction.\nThe lj/class2/coul/long pair style does not support the\npair_modify table option since a tabulation\ncapability has not yet been added to this potential.\nAll of the lj/class2 pair styles support the\npair_modify tail option for adding a long-range\ntail correction to the energy and pressure of the Lennard-Jones\nportion of the pair interaction.\nAll of the lj/class2 pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\nnot need to be specified in an input script that reads a restart file.\nOnly the lj/class2 and lj/class2/coul/long pair styles support the use of the\ninner, middle, and outer keywords of the run_style respa command, meaning the pairwise forces can be\npartitioned by distance at different levels of the rRESPA hierarchy.\nThe other styles only support the pair keyword of run_style respa.\nSee the run_style command for details.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/class2 or lj/class2/coul/cut or lj/class2/coul/long\n * args = list of arguments for a particular style\n * lj/class2 args = cutoff\n *   cutoff = global cutoff for class 2 interactions (distance units)\n * lj/class2/coul/cut args = cutoff (cutoff2)\n *   cutoff = global cutoff for class 2 (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/class2/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for class 2 (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style lj/class2 10.0\npair_coeff \\* \\* 100.0 2.5\npair_coeff 1 2\\* 100.0 2.5 9.0\n\npair_style lj/class2/coul/cut 10.0\npair_style lj/class2/coul/cut 10.0 8.0\npair_coeff \\* \\* 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0\npair_coeff 1 1 100.0 3.5 9.0 9.0\n\npair_style lj/class2/coul/long 10.0\npair_style lj/class2/coul/long 10.0 8.0\npair_coeff \\* \\* 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0",
    "restrictions": "These styles are part of the CLASS2 package.  They are only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_coeff",
    "html_filename": "pair_coeff.html",
    "short_description": "Specify the pairwise force field coefficients for one or more pairs of atom types",
    "description": "Specify the pairwise force field coefficients for one or more pairs of\natom types.  The number and meaning of the coefficients depends on the\npair style.  Pair coefficients can also be set in the data file read\nby the read_data command or in a restart file.\nI and J can be specified in one of two ways.  Explicit numeric values\ncan be used for each, as in the 1st example above.  I <= J is\nrequired.  LAMMPS sets the coefficients for the symmetric J,I\ninteraction to the same values.\nA wildcard asterisk can be used in place of or in conjunction with the\nI,J arguments to set the coefficients for multiple pairs of atom\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means all\ntypes from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).  Note that only type pairs with I <= J are considered; if\nasterisks imply type pairs where J < I, they are ignored.\nNote that a pair_coeff command can override a previous setting for the\nsame I,J pair.  For example, these commands set the coeffs for all I,J\npairs, then overwrite the coeffs for just the I,J = 2,3 pair:\npair_coeff \\* \\* 1.0 1.0 2.5\npair_coeff 2 3 2.0 1.0 1.12\n\n\nA line in a data file that specifies pair coefficients uses the exact\nsame format as the arguments of the pair_coeff command in an input\nscript, with the exception of the I,J type arguments.  In each line of\nthe “Pair Coeffs” section of a data file, only a single type I is\nspecified, which sets the coefficients for type I interacting with\ntype I.  This is because the section has exactly N lines, where N =\nthe number of atom types.  For this reason, the wild-card asterisk\nshould also not be used as part of the I argument.  Thus in a data\nfile, the line corresponding to the 1st example above would be listed\nas\n2 1.0 1.0 2.5\n\n\nFor many potentials, if coefficients for type pairs with I != J are\nnot set explicitly by a pair_coeff command, the values are inferred\nfrom the I,I and J,J settings by mixing rules; see the\npair_modify command for a discussion.  Details on\nthis option as it pertains to individual potentials are described on\nthe doc page for the potential.\nMany pair styles, typically for many-body potentials, use tabulated\npotential files as input, when specifying the pair_coeff command.\nPotential files provided with LAMMPS are in the potentials directory\nof the distribution.  For some potentials, such as EAM, other archives\nof suitable files can be found on the Web.  They can be used with\nLAMMPS so long as they are in the format LAMMPS expects, as discussed\non the individual doc pages.\nWhen a pair_coeff command using a potential file is specified, LAMMPS\nlooks for the potential file in 2 places.  First it looks in the\nlocation specified.  E.g. if the file is specified as “niu3.eam”, it\nis looked for in the current working directory.  If it is specified as\n“../potentials/niu3.eam”, then it is looked for in the potentials\ndirectory, assuming it is a sister directory of the current working\ndirectory.  If the file is not found, it is then looked for in the\ndirectory specified by the LAMMPS_POTENTIALS environment variable.\nThus if this is set to the potentials directory in the LAMMPS distribution,\nthen you can use those files from anywhere on your system, without\ncopying them into your working directory.  Environment variables are\nset in different ways for different shells.  Here are example settings\nfor\ncsh, tcsh:\n% setenv LAMMPS_POTENTIALS /path/to/lammps/potentials\n\n\nbash:\n% export LAMMPS_POTENTIALS=/path/to/lammps/potentials\n\n\nWindows:\n% set LAMMPS_POTENTIALS=\"C:\\Path to LAMMPS\\Potentials\"\n\nThe alphabetic list of pair styles defined in LAMMPS is given on the\npair_style doc page.  They are also listed in more\ncompact form on the Commands pair doc page.\nClick on the style to display the formula it computes and its\ncoefficients as specified by the associated pair_coeff command.",
    "syntax": "pair_coeff I J args",
    "parameters": " * I,J = atom types (see asterisk form below)\n * args = coefficients for one or more pairs of atom types",
    "examples": "pair_coeff 1 2 1.0 1.0 2.5\npair_coeff 2 \\* 1.0 1.0\npair_coeff 3\\* 1\\*2 1.0 1.0 2.5\npair_coeff \\* \\* 1.0 1.0\npair_coeff \\* \\* nialhjea 1 1 2\npair_coeff \\* 3 morse.table ENTRY1\npair_coeff 1 2 lj/cut 1.0 1.0 2.5 (for pair_style hybrid)",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command."
},
{
    "command": "pair_style colloid",
    "html_filename": "pair_colloid.html",
    "short_description": "Style colloid computes pairwise interactions between large colloidal particles and small solvent particles using 3 formulas",
    "description": "Style colloid computes pairwise interactions between large colloidal\nparticles and small solvent particles using 3 formulas.  A colloidal\nparticle has a size > sigma; a solvent particle is the usual\nLennard-Jones particle of size sigma.\nThe colloid-colloid interaction energy is given by\n\n\\[\\begin{split} U_A = & - \\frac{A_{cc}}{6} \\left[\n \\frac{2 a_1 a_2}{r^2-\\left(a_1+a_2\\right)^2}\n + \\frac{2 a_1 a_2}{r^2 - \\left(a_1 - a_2\\right)^2}\n   + \\mathrm{ln}\n     \\left(\n\\frac{r^2-\\left(a_1+a_2\\right)^2}{r^2-\\left(a_1-a_2\\right)^2}\n \\right)\n\\right] \\\\\n  & \\\\\n  U_R = & \\frac{A_{cc}}{37800}  \\frac{\\sigma^6}{r}\n  \\biggl[ \\frac{r^2-7r\\left(a_1+a_2\\right)+6\\left(a_1^2+7a_1a_2+a_2^2\\right)}\n{\\left(r-a_1-a_2\\right)^7} \\\\\n &\\qquad              +\\frac{r^2+7r\\left(a_1+a_2\\right)+6\\left(a_1^2+7a_1a_2+a_2^2\\right)}\n{\\left(r+a_1+a_2\\right)^7}  \\\\\n&\\qquad               -\\frac{r^2+7r\\left(a_1-a_2\\right)+6\\left(a_1^2-7a_1a_2+a_2^2\\right)}\n{\\left(r+a_1-a_2\\right)^7} \\\\\n&\\qquad       \\left.  -\\frac{r^2-7r\\left(a_1-a_2\\right)+6\\left(a_1^2-7a_1a_2+a_2^2\\right)}\n{\\left(r-a_1+a_2\\right)^7}\n\\right]  \\\\\n& \\\\\nU = & U_A + U_R, \\qquad r < r_c\\end{split}\\]\nwhere \\(A_{cc}\\) is the Hamaker constant, \\(a_1\\) and \\(a_2\\) are the\nradii of the two colloidal particles, and \\(r_c\\) is the cutoff.  This\nequation results from describing each colloidal particle as an\nintegrated collection of Lennard-Jones particles of size sigma and is\nderived in (Everaers).\nThe colloid-solvent interaction energy is given by\n\n\\[U = \\frac{2 ~ a^3 ~ \\sigma^3 ~ A_{cs}}{9 \\left( a^2 - r^2 \\right)^3}\n\\left[ 1 - \\frac{\\left(5 ~ a^6+45~a^4~r^2+63~a^2~r^4+15~r^6\\right) \\sigma^6}\n{15 \\left(a-r\\right)^6 \\left( a+r \\right)^6} \\right], \\quad r < r_c\\]\nwhere :math:A_{cs}` is the Hamaker constant, a is the radius of the colloidal\nparticle, and \\(r_c\\) is the cutoff.  This formula is derived from the\ncolloid-colloid interaction, letting one of the particle sizes go to\nzero.\nThe solvent-solvent interaction energy is given by the usual\nLennard-Jones formula\n\n\\[U = \\frac{A_{ss}}{36} \\left[ \\left( \\frac{\\sigma}{r}\n     \\right)^{12} - \\left( \\frac{ \\sigma}{r} \\right)^6 \\right], \\quad\n     r < r_c\\]\nwith \\(A_{ss}\\) set appropriately, which results from letting both\nparticle sizes go to zero.\nWhen used in combination with pair_style yukawa/colloid, the two terms become the so-called DLVO potential,\nwhich combines electrostatic repulsion and van der Waals attraction.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nA (energy units)\n\\(\\sigma\\) (distance units)\nd1 (distance units)\nd2 (distance units)\ncutoff (distance units)\n\nA is the Hamaker energy prefactor and should typically be set as\nfollows:\n\n\\(A_{cc}\\) = colloid/colloid = \\(4 \\pi^2 = 39.5\\)\n\\(A_{cs}\\) = colloid/solvent = \\(\\sqrt{A_{cc} A_{ss}}\\)\n\\(A_{ss}\\) = solvent/solvent = 144 (assuming epsilon = 1, so that 144/36 = 4)\n\n\\(\\sigma\\) is the size of the solvent particle or the constituent\nparticles integrated over in the colloidal particle and should typically\nbe set as follows:\n\n\\(\\sigma_{cc}\\) = colloid/colloid = 1.0\n\\(\\sigma_{cs}\\) = colloid/solvent = arithmetic mixing between colloid \\(\\sigma\\) and solvent \\(\\sigma\\)\n\\(\\sigma_{ss}\\) = solvent/solvent = 1.0 or whatever size the solvent particle is\n\nThus typically \\(\\sigma_{cs} = 1.0\\), unless the solvent particle’s size !=\n1.0.\nD1 and d2 are particle diameters, so that d1 = 2*a1 and d2 = 2*a2 in\nthe formulas above.  Both d1 and d2 must be values >= 0.  If d1 > 0\nand d2 > 0, then the pair interacts via the colloid-colloid formula\nabove.  If d1 = 0 and d2 = 0, then the pair interacts via the\nsolvent-solvent formula.  I.e. a d value of 0 is a Lennard-Jones\nparticle of size \\(\\sigma\\).  If either d1 = 0 or d2 = 0 and the other is\nlarger, then the pair interacts via the colloid-solvent formula.\nNote that the diameter of a particular particle type may appear in\nmultiple pair_coeff commands, as it interacts with other particle\ntypes.  You should insure the particle diameter is specified\nconsistently each time it appears.\nThe last coefficient is optional.  If not specified, the global cutoff\nspecified in the pair_style command is used.  However, you typically\nwant different cutoffs for interactions between different particle\nsizes.  E.g. if colloidal particles of diameter 10 are used with\nsolvent particles of diameter 1, then a solvent-solvent cutoff of 2.5\nwould correspond to a colloid-colloid cutoff of 25.  A good\nrule-of-thumb is to use a colloid-solvent cutoff that is half the big\ndiameter + 4 times the small diameter.  I.e. 9 = 5 + 4 for the\ncolloid-solvent cutoff in this case.\n\nNote\nWhen using pair_style colloid for a mixture with 2 (or more)\nwidely different particles sizes (e.g. sigma=10 colloids in a\nbackground sigma=1 LJ fluid), you will likely want to use these\ncommands for efficiency: neighbor multi and\ncomm_modify multi.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A, sigma, d1, and d2\ncoefficients and cutoff distance for this pair style can be mixed.  A\nis an energy value mixed like a LJ epsilon.  D1 and d2 are distance\nvalues and are mixed like sigma.  The default mix value is\ngeometric.  See the “pair_modify” command for details.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style colloid cutoff",
    "parameters": " * cutoff = global cutoff for colloidal interactions (distance units)",
    "examples": "pair_style colloid 10.0\npair_coeff * *  25 1.0 10.0 10.0\npair_coeff 1 1 144 1.0 0.0 0.0 3.0\npair_coeff 1 2  75.398 1.0 0.0 10.0 9.0\npair_coeff 2 2  39.478 1.0 10.0 10.0 25.0",
    "restrictions": "This style is part of the COLLOID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nNormally, this pair style should be used with finite-size particles\nwhich have a diameter, e.g. see the atom_style sphere command.  However, this is not a requirement,\nsince the only definition of particle size is via the pair_coeff\nparameters for each type.  In other words, the physical radius of the\nparticle is ignored.  Thus you should insure that the d1,d2 parameters\nyou specify are consistent with the physical size of the particles of\nthat type.\nPer-particle polydispersity is not yet supported by this pair style;\nonly per-type polydispersity is enabled via the pair_coeff parameters."
},
{
    "command": "pair_style comb",
    "html_filename": "pair_comb.html",
    "short_description": "Style comb computes the second-generation variable charge COMB (Charge-Optimized Many-Body) potential",
    "description": "Style comb computes the second-generation variable charge COMB\n(Charge-Optimized Many-Body) potential.  Style comb3 computes the\nthird-generation COMB potential.  These COMB potentials are described\nin (COMB) and (COMB3).  Briefly, the\ntotal energy \\(E_T\\) of a system of atoms is given by\n\n\\[\\begin{split}E_T  = & \\sum_i [ E_i^{self} (q_i) + \\sum_{j>i} [E_{ij}^{short} (r_{ij}, q_i, q_j) + E_{ij}^{Coul} (r_{ij}, q_i, q_j)] + \\\\\n       & E^{polar} (q_i, r_{ij}) + E^{vdW} (r_{ij}) + E^{barr} (q_i) + E^{corr} (r_{ij}, \\theta_{jik})]\\end{split}\\]\nwhere \\(E_i^{self}\\) is the self-energy of atom i (including\natomic ionization energies and electron affinities),\n\\(E_{ij}^{short}\\) is the bond-order potential between atoms i and\nj, \\(E_{ij}^{Coul}\\) is the Coulomb interactions,\n\\(E^{polar}\\) is the polarization term for organic systems (style\ncomb3 only), \\(E^{vdW}\\) is the van der Waals energy (style\ncomb3 only), \\(E^{barr}\\) is a charge barrier function, and\n\\(E^{corr}\\) are angular correction terms.\nThe COMB potentials (styles comb and comb3) are variable charge\npotentials.  The equilibrium charge on each atom is calculated by the\nelectronegativity equalization (QEq) method.  See Rick for\nfurther details.  This is implemented by the fix qeq/comb command, which should normally be\nspecified in the input script when running a model with the COMB\npotential.  The fix qeq/comb command has options\nthat determine how often charge equilibration is performed, its\nconvergence criterion, and which atoms are included in the\ncalculation.\nOnly a single pair_coeff command is used with the comb and comb3\nstyles which specifies the COMB potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the potential file in the pair_coeff\ncommand, where N is the number of LAMMPS atom types.\nFor example, if your LAMMPS simulation of a Si/SiO2/\nHfO2 interface has 4 atom types, and you want the 1st and\nlast to be Si, the 2nd to be Hf, and the 3rd to be O, and you would\nuse the following pair_coeff command:\npair_coeff * * ../potentials/ffield.comb Si Hf O Si\n\n\nThe first two arguments must be * * so as to span all LAMMPS atom\ntypes.  The first and last Si arguments map LAMMPS atom types 1 and 4\nto the Si element in the ffield.comb file.  The second Hf argument\nmaps LAMMPS atom type 2 to the Hf element, and the third O argument\nmaps LAMMPS atom type 3 to the O element in the potential file.  If a\nmapping value is specified as NULL, the mapping is not performed.\nThis can be used when a comb potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\nFor style comb, the provided potential file ffield.comb contains\nall currently-available 2nd generation COMB parameterizations: for Si,\nCu, Hf, Ti, O, their oxides and Zr, Zn and U metals.  For style\ncomb3, the potential file ffield.comb3 contains all\ncurrently-available 3rd generation COMB parameterizations: O, Cu, N, C,\nH, Ti, Zn and Zr.  The status of the optimization of the compounds, for\nexample Cu2O, TiN and hydrocarbons, are given in the\nfollowing table:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO\nCu\nN\nC\nH\nTi\nZn\nZr\n\nO\nF\nF\nF\nF\nF\nF\nF\nF\n\nCu\nF\nF\nP\nF\nF\nP\nF\nP\n\nN\nF\nP\nF\nM\nF\nP\nP\nP\n\nC\nF\nF\nM\nF\nF\nM\nM\nM\n\nH\nF\nF\nF\nF\nF\nM\nM\nF\n\nTi\nF\nP\nP\nM\nM\nF\nP\nP\n\nZn\nF\nF\nP\nM\nM\nP\nF\nP\n\nZr\nF\nP\nP\nM\nF\nP\nP\nF\n\n\n\n\nF = Fully optimized\nM = Only optimized for dimer molecule\nP = in progress, but have it from mixing rule\n\nFor style comb3, in addition to ffield.comb3, a special parameter\nfile, lib.comb3, that is exclusively used for C/O/H systems, will be\nautomatically loaded if carbon atom is detected in LAMMPS input\nstructure.  This file must be in your working directory or in the\ndirectory pointed to by the environment variable LAMMPS_POTENTIALS, as\ndescribed on the pair_coeff command doc page.\nKeyword polar indicates whether the force field includes\nthe atomic polarization.  Since the equilibration of the polarization\nhas not yet been implemented, it can only set polar_off at present.\n\nNote\nYou can not use potential file ffield.comb with style comb3,\nnor file ffield.comb3 with style comb.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThese pair styles does not support the pair_modify\nshift, table, and tail options.\nThese pair styles do not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style, pair_coeff, and fix qeq/comb commands in an input script that reads a\nrestart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style comb",
    "parameters": " * pair_style comb3 keyword\n * keyword = polar\n *   polar value = polar_on or polar_off = whether or not to include atomic polarization",
    "examples": "pair_style comb\npair_coeff * * ../potentials/ffield.comb Si\npair_coeff * * ../potentials/ffield.comb Hf Si O\n\npair_style comb3 polar_off\npair_coeff * * ../potentials/ffield.comb3 O Cu N C O",
    "restrictions": "These pair styles are part of the MANYBODY package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair styles requires the newton setting to be “on”\nfor pair interactions.\nThe COMB potentials in the ffield.comb and ffield.comb3 files provided\nwith LAMMPS (see the potentials directory) are parameterized for metal\nunits.  You can use the COMB potential with any LAMMPS\nunits, but you would need to create your own COMB potential file with\ncoefficients listed in the appropriate units if your simulation\ndoesn’t use “metal” units."
},
{
    "command": "pair_style cosine/squared",
    "html_filename": "pair_cosine_squared.html",
    "short_description": "Style cosine/squared computes a potential of the form  \\[\\begin{split}E = \\begin{cases} -\\epsilon& \\quad r < \\sigma \\\\ -\\epsilon\\cos\\left(\\frac{\\pi\\left(r - \\sigma\\right)}{2\\left(r_c - \\sigma\\right)}\\right)&\\quad \\sigma \\leq r < r_c \\\\ 0& \\quad r \\geq r_c \\end{cases}\\end{split}\\] between two point particles, where (\\(\\sigma, -\\epsilon\\)) is the location of the (rightmost) minimum of the potential, as explained in the syntax section above",
    "description": "Style cosine/squared computes a potential of the form\n\n\\[\\begin{split}E =\n\\begin{cases}\n-\\epsilon& \\quad r < \\sigma \\\\\n-\\epsilon\\cos\\left(\\frac{\\pi\\left(r - \\sigma\\right)}{2\\left(r_c - \\sigma\\right)}\\right)&\\quad \\sigma \\leq r < r_c \\\\\n0& \\quad r \\geq r_c\n\\end{cases}\\end{split}\\]\nbetween two point particles, where (\\(\\sigma, -\\epsilon\\)) is the\nlocation of the (rightmost) minimum of the potential, as explained in\nthe syntax section above.\nThis potential was first used in (Cooke)_#CKD for a coarse-grained lipid\nmembrane model.  It is generally very useful as a non-specific\ninteraction potential because it is fully adjustable in depth and width\nwhile joining the minimum at (sigma, -epsilon) and zero at (cutoff, 0)\nsmoothly, requiring no shifting and causing no related artifacts, tail\nenergy calculations etc. This evidently requires cutoff to be larger\nthan sigma.\nIf the wca option is used then a Weeks-Chandler-Andersen potential\n(Weeks)_#WCA is added to the above specified cosine-squared potential,\nspecifically the following:\n\n\\[E = \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      2\\left(\\frac{\\sigma}{r}\\right)^6 + 1\\right]\n                      , \\quad r < \\sigma\\]\nIn this case, and this case only, the \\(\\sigma\\) parameter can be equal to\ncutoff (\\(\\sigma =\\) cutoff) which will result in ONLY the WCA potential\nbeing used (and print a warning), so the minimum will be attained at\n(sigma, 0). This is a convenience feature that enables a purely\nrepulsive potential to be used without a need to define an additional\npair style and use the hybrid styles.\nThe energy and force of this pair style for parameters epsilon = 1.0,\nsigma = 1.0, cutoff = 2.5, with and without the WCA potential, are shown\nin the graphs below:\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nMixing is not supported for this style.\nThe shift, table and tail options are not relevant for this style.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style cosine/squared cutoff",
    "parameters": " * cutoff = global cutoff for cosine-squared interactions (distance units)\n * pair_coeff i j eps sigma\n * pair_coeff i j eps sigma cutoff\n * pair_coeff i j eps sigma wca\n * pair_coeff i j eps sigma cutoff wca\n * i,j = a particle type\n * eps = interaction strength, i.e. the depth of the potential minimum (energy units)\n * sigma = distance of the potential minimum from 0\n * cutoff = the cutoff distance for this pair type, if different from global (distance units)\n * wca = if specified a Weeks-Chandler-Andersen potential (with eps strength and minimum at sigma) is added, otherwise not",
    "examples": "pair_style cosine/squared 3.0\npair_coeff \\* \\* 1.0 1.3\npair_coeff 1 3 1.0 1.3 2.0\npair_coeff 1 3 1.0 1.3 wca\npair_coeff 1 3 1.0 1.3 2.0 wca",
    "restrictions": "The cosine/squared style is part of the “USER-MISC” package. It is only\nenabled if LAMMPS is build with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style coul/cut",
    "html_filename": "pair_coul.html",
    "short_description": "The coul/cut style computes the standard Coulombic interaction potential given by  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\] where C is an energy-conversion constant, Qi and Qj are the charges on the 2 atoms, and \\(\\epsilon\\) is the dielectric constant which can be set by the dielectric command",
    "description": "The coul/cut style computes the standard Coulombic interaction\npotential given by\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\nwhere C is an energy-conversion constant, Qi and Qj are the charges on\nthe 2 atoms, and \\(\\epsilon\\) is the dielectric constant which can be set\nby the dielectric command.  The cutoff \\(r_c\\) truncates\nthe interaction distance.\n\nStyle coul/debye adds an additional exp() damping factor to the\nCoulombic term, given by\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\exp(- \\kappa r) \\qquad r < r_c\\]\nwhere \\(\\kappa\\) is the Debye length.  This potential is another way to\nmimic the screening effect of a polar solvent.\n\nStyle coul/dsf computes Coulombic interactions via the damped\nshifted force model described in Fennell, given by:\n\n\\[E = q_iq_j \\left[ \\frac{\\mbox{erfc} (\\alpha r)}{r} -  \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c} +\n\\left( \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c^2} +  \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{\\exp (-\\alpha^2    r^2_c)}{r_c} \\right)(r-r_c) \\right] \\qquad r < r_c\\]\nwhere \\(\\alpha\\) is the damping parameter and erfc() is the\ncomplementary error-function. The potential corrects issues in the\nWolf model (described below) to provide consistent forces and energies\n(the Wolf potential is not differentiable at the cutoff) and smooth\ndecay to zero.\n\nStyle coul/wolf computes Coulombic interactions via the Wolf\nsummation method, described in Wolf, given by:\n\n\\[E_i = \\frac{1}{2} \\sum_{j \\neq i}\n\\frac{q_i q_j {\\rm erfc}(\\alpha r_{ij})}{r_{ij}} +\n\\frac{1}{2} \\sum_{j \\neq i}\n\\frac{q_i q_j {\\rm erf}(\\alpha r_{ij})}{r_{ij}} \\qquad r < r_c\\]\nwhere \\(\\alpha\\) is the damping parameter, and erc() and erfc() are\nerror-function and complementary error-function terms.  This potential\nis essentially a short-range, spherically-truncated,\ncharge-neutralized, shifted, pairwise 1/r summation.  With a\nmanipulation of adding and subtracting a self term (for i = j) to the\nfirst and second term on the right-hand-side, respectively, and a\nsmall enough \\(\\alpha\\) damping parameter, the second term shrinks and\nthe potential becomes a rapidly-converging real-space summation.  With\na long enough cutoff and small enough \\(\\alpha\\) parameter, the energy and\nforces calculated by the Wolf summation method approach those of the\nEwald sum.  So it is a means of getting effective long-range\ninteractions with a short-range potential.\n\nStyle coul/streitz is the Coulomb pair interaction defined as part\nof the Streitz-Mintmire potential, as described in this paper, in which charge distribution about an atom is modeled\nas a Slater 1s orbital.  More details can be found in the referenced\npaper.  To fully reproduce the published Streitz-Mintmire potential,\nwhich is a variable charge potential, style coul/streitz must be\nused with pair_style eam/alloy (or some other\nshort-range potential that has been parameterized appropriately) via\nthe pair_style hybrid/overlay command.  Likewise,\ncharge equilibration must be performed via the fix qeq/slater command. For example:\npair_style hybrid/overlay coul/streitz 12.0 wolf 0.31 eam/alloy\npair_coeff * * coul/streitz AlO.streitz Al O\npair_coeff * * eam/alloy AlO.eam.alloy Al O\nfix 1 all qeq/slater 1 12.0 1.0e-6 100 coul/streitz\n\n\nThe keyword wolf in the coul/streitz command denotes computing\nCoulombic interactions via Wolf summation.  An additional damping\nparameter is required for the Wolf summation, as described for the\ncoul/wolf potential above.  Alternatively, Coulombic interactions can\nbe computed via an Ewald summation.  For example:\npair_style hybrid/overlay coul/streitz 12.0 ewald eam/alloy\nkspace_style ewald 1e-6\n\n\nKeyword ewald does not need a damping parameter, but a\nkspace_style must be defined, which can be style\newald or pppm.  The Ewald method was used in Streitz and\nMintmire’s original paper, but a Wolf summation offers a speed-up in\nsome cases.\nFor the fix qeq/slater command, the qfile can be a filename that\ncontains QEq parameters as discussed on the fix qeq\ncommand doc page.  Alternatively qfile can be replaced by\n“coul/streitz”, in which case the fix will extract QEq parameters from\nthe coul/streitz pair style itself.\nSee the examples/strietz directory for an example input script that\nuses the Streitz-Mintmire potential.  The potentials directory has the\nAlO.eam.alloy and AlO.streitz potential files used by the example.\nNote that the Streiz-Mintmire potential is generally used for oxides,\nbut there is no conceptual problem with extending it to nitrides and\ncarbides (such as SiC, TiN).  Pair coul/strietz used by itself or with\nany other pair style such as EAM, MEAM, Tersoff, or LJ in\nhybrid/overlay mode.  To do this, you would need to provide a\nStreitz-Mintmire parameterization for the material being modeled.\n\nStyles coul/long and coul/msm compute the same Coulombic\ninteractions as style coul/cut except that an additional damping\nfactor is applied so it can be used in conjunction with the\nkspace_style command and its ewald or pppm\noption.  The Coulombic cutoff specified for this style means that\npairwise interactions within this distance are computed directly;\ninteractions outside that distance are computed in reciprocal space.\nStyles tip4p/cut and tip4p/long implement the Coulomb part of\nthe TIP4P water model of (Jorgensen), which introduces\na massless site located a short distance away from the oxygen atom\nalong the bisector of the HOH angle.  The atomic types of the oxygen and\nhydrogen atoms, the bond and angle types for OH and HOH interactions,\nand the distance to the massless charge site are specified as\npair_style arguments.  Style tip4p/cut uses a global cutoff for\nCoulomb interactions; style tip4p/long is for use with a long-range\nCoulombic solver (Ewald or PPPM).\n\nNote\nFor each TIP4P water molecule in your system, the atom IDs for\nthe O and 2 H atoms must be consecutive, with the O atom first.  This\nis to enable LAMMPS to “find” the 2 H atoms associated with each O\natom.  For example, if the atom ID of an O atom in a TIP4P water\nmolecule is 500, then its 2 H atoms must have IDs 501 and 502.\n\nSee the Howto tip4p doc page for more information\non how to use the TIP4P pair styles and lists of parameters to set.\nNote that the neighbor list cutoff for Coulomb interactions is\neffectively extended by a distance 2*qdist when using the TIP4P pair\nstyle, to account for the offset distance of the fictitious charges on\nO atoms in water molecules.  Thus it is typically best in an\nefficiency sense to use a LJ cutoff >= Coulombic cutoff + 2*qdist, to\nshrink the size of the neighbor list.  This leads to slightly larger\ncost for the long-range calculation, so you can test the trade-off for\nyour model.\n\nNote that these potentials are designed to be combined with other pair\npotentials via the pair_style hybrid/overlay\ncommand.  This is because they have no repulsive core.  Hence if they\nare used by themselves, there will be no repulsion to keep two\noppositely charged particles from moving arbitrarily close to each\nother.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutoff (distance units)\n\nFor coul/cut and coul/debye, the cutoff coefficient is optional.\nIf it is not used (as in some of the examples above), the default\nglobal value specified in the pair_style command is used.\nFor coul/long and coul/msm no cutoff can be specified for an\nindividual I,J type pair via the pair_coeff command.  All type pairs\nuse the same global Coulomb cutoff specified in the pair_style\ncommand.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the cutoff distance for the\ncoul/cut style can be mixed.  The default mix value is geometric.\nSee the “pair_modify” command for details.\nThe pair_modify shift option is not relevant\nfor these pair styles.\nThe coul/long style supports the pair_modify\ntable option for tabulation of the short-range portion of the\nlong-range Coulombic interaction.\nThese pair styles do not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThese pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style coul/cut cutoff",
    "parameters": " * pair_style coul/debye kappa cutoff\n * pair_style coul/dsf alpha cutoff\n * pair_style coul/long cutoff\n * pair_style coul/long/gpu cutoff\n * pair_style coul/wolf alpha cutoff\n * pair_style coul/streitz cutoff keyword alpha\n * pair_style tip4p/cut otype htype btype atype qdist cutoff\n * pair_style tip4p/long otype htype btype atype qdist cutoff\n * cutoff = global cutoff for Coulombic interactions\n * kappa = Debye length (inverse distance units)\n * alpha = damping parameter (inverse distance units)",
    "examples": "pair_style coul/cut 2.5\npair_coeff * *\npair_coeff 2 2 3.5\n\npair_style coul/debye 1.4 3.0\npair_coeff * *\npair_coeff 2 2 3.5\n\npair_style coul/dsf 0.05 10.0\npair_coeff * *\n\npair_style coul/long 10.0\npair_coeff * *\n\npair_style coul/msm 10.0\npair_coeff * *\n\npair_style coul/wolf 0.2 9.0\npair_coeff * *\n\npair_style coul/streitz 12.0 ewald\npair_style coul/streitz 12.0 wolf 0.30\npair_coeff * * AlO.streitz Al O\n\npair_style tip4p/cut 1 2 7 8 0.15 12.0\npair_coeff * *\n\npair_style tip4p/long 1 2 7 8 0.15 10.0\npair_coeff * *",
    "restrictions": "The coul/long, coul/msm and tip4p/long styles are part of the\nKSPACE package.  They are only enabled if LAMMPS was built with that\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "pair_style coul/diel",
    "html_filename": "pair_coul_diel.html",
    "short_description": "Style coul/diel computes a Coulomb correction for implicit solvent ion interactions in which the dielectric permittivity is distance dependent",
    "description": "Style coul/diel computes a Coulomb correction for implicit solvent\nion interactions in which the dielectric permittivity is distance dependent.\nThe dielectric permittivity epsilon_D(r) connects to limiting regimes:\nOne limit is defined by a small dielectric permittivity (close to vacuum)\nat or close to contact separation between the ions. At larger separations\nthe dielectric permittivity reaches a bulk value used in the regular Coulomb\ninteraction coul/long or coul/cut.\nThe transition is modeled by a hyperbolic function which is incorporated\nin the Coulomb correction term for small ion separations as follows\n\n\\[\\begin{split}E  = & \\frac{Cq_iq_j}{\\epsilon r} \\left( \\frac{\\epsilon}{\\epsilon_D(r)}-1\\right)                       \\qquad r < r_c \\\\\n\\epsilon_D(r)  = & \\frac{5.2+\\epsilon}{2} +  \\frac{\\epsilon-5.2}{2}\\tanh\\left(\\frac{r-r_{me}}{\\sigma_e}\\right)\\end{split}\\]\nwhere \\(r_{me}\\) is the inflection point of \\(\\epsilon_D(r)\\) and \\(\\sigma_e\\) is a slope\ndefining length scale. C is the same Coulomb conversion factor as in the\npair_styles coul/cut, coul/long, and coul/debye. In this way the Coulomb\ninteraction between ions is corrected at small distances r. The lower\nlimit of epsilon_D(r->0)=5.2 due to dielectric saturation (Stiles)\nwhile the Coulomb interaction reaches its bulk limit by setting\n\\(\\epsilon_D(r \\to \\infty) = \\epsilon\\), the bulk value of the solvent which is 78\nfor water at 298K.\nExamples of the use of this type of Coulomb interaction include implicit\nsolvent simulations of salt ions\n(Lenart) and of ionic surfactants (Jusufi).\nNote that this potential is only reasonable for implicit solvent simulations\nand in combination with coul/cut or coul/long. It is also usually combined\nwith gauss/cut, see (Lenart) or (Jusufi).\nThe following coefficients must be defined for each pair of atom\ntypes via the pair_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(\\epsilon\\) (no units)\n\\(r_{me}\\) (distance units)\n\\(\\sigma_e\\) (distance units)\n\nThe global cutoff (\\(r_c\\)) specified in the pair_style command is used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support parameter mixing. Coefficients must\nbe given explicitly for each type of particle pairs.\nThis pair style supports the pair_modify shift\noption for the energy of the Gauss-potential portion of the pair\ninteraction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style coul/diel cutoff",
    "parameters": " * cutoff = global cutoff (distance units)",
    "examples": "pair_style coul/diel 3.5\npair_coeff 1 4 78. 1.375 0.112",
    "restrictions": "This style is part of the “USER-MISC” package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style coul/shield",
    "html_filename": "pair_coul_shield.html",
    "short_description": "Style coul/shield computes a Coulomb interaction for boron and nitrogen atoms located in different layers of hexagonal boron nitride",
    "description": "Style coul/shield computes a Coulomb interaction for boron and\nnitrogen atoms located in different layers of hexagonal boron\nnitride. This potential is designed be used in combination with\nthe pair style ilp/graphene/hbn\n\nNote\nThis potential is intended for electrostatic interactions between\ntwo different layers of hexagonal boron nitride. Therefore, to avoid\ninteraction within the same layers, each layer should have a separate\nmolecule id and is recommended to use the “full” atom style, so that\ncharge and molecule ID information is included.\n\n\n\\[\\begin{split}E      = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\nV_{ij} = & {\\rm Tap}(r_{ij})\\frac{\\kappa q_i q_j}{\\sqrt[3]{r_{ij}^3+(1/\\lambda_{ij})^3}}\\\\\n{\\rm Tap}(r_{ij}) = & 20\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^7 -\n                       70\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^6 +\n                       84\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^5 -\n                       35\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^4 + 1\\end{split}\\]\nWhere Tap(\\(r_{ij}\\)) is the taper function which provides a continuous cutoff\n(up to third derivative) for inter-atomic separations larger than \\(r_c\\)\n(Leven1), (Leven2) and (Maaravi).\nHere \\(\\lambda\\) is the shielding parameter that\neliminates the short-range singularity of the classical mono-polar\nelectrostatic interaction expression (Maaravi).\nThe shielding parameter \\(\\lambda\\) (1/distance units) must be defined for\neach pair of atom types via the pair_coeff command as\nin the example above, or in the data file or restart files read by the\nread_data or read_restart commands:\nThe global cutoff (\\(r_c\\)) specified in the pair_style command is used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support parameter mixing. Coefficients must\nbe given explicitly for each type of particle pairs.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style coul/shield cutoff tap_flag",
    "parameters": " * cutoff = global cutoff (distance units)\n * tap_flag = 0/1 to turn off/on the taper function",
    "examples": "pair_style coul/shield 16.0 1\npair_coeff 1 2 0.70",
    "restrictions": "This style is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style born/coul/dsf/cs",
    "html_filename": "pair_cs.html",
    "short_description": "These pair styles are designed to be used with the adiabatic core/shell model of (Mitchell and Finchham)",
    "description": "These pair styles are designed to be used with the adiabatic\ncore/shell model of (Mitchell and Finchham).  See\nthe Howto coreshell doc page for an overview of\nthe model as implemented in LAMMPS.\nAll the styles are identical to the corresponding pair style without\nthe “/cs” in the name:\n\npair_style born/coul/dsf\npair_style born/coul/long\npair_style born/coul/wolf\npair_style buck/coul/long\npair_style coul/long\npair_style coul/wolf\npair_style lj/cut/coul/long\n\nexcept that they correctly treat the special case where the distance\nbetween two charged core and shell atoms in the same core/shell pair\napproach r = 0.0.\nStyles with a “/long” in the name are used with a long-range solver\nfor Coulombic interactions via the kspace_style\ncommand.  They require special treatment of the short-range Coulombic\ninteractions within the cor/shell model.\nSpecifically, the short-range Coulomb interaction between a core and\nits shell should be turned off using the\nspecial_bonds command by setting the 1-2 weight\nto 0.0, which works because the core and shell atoms are bonded to\neach other.  This induces a long-range correction approximation which\nfails at small distances (~< 10e-8). Therefore, the Coulomb term which\nis used to calculate the correction factor is extended by a minimal\ndistance (r_min = 1.0-6) when the interaction between a core/shell\npair is treated, as follows\n\n\\[E = \\frac{C q_i q_j}{\\epsilon (r + r_{min})} \\qquad r \\rightarrow 0\\]\nwhere C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\nare the charges on the core and shell, epsilon is the dielectric\nconstant and \\(r_{min}\\) is the minimal distance.\nFor styles that are not used with a long-range solver, i.e. those with\n“/dsf” or “/wolf” in the name, the only correction is the addition of\na minimal distance to avoid the possible r = 0.0 case for a core/shell\npair.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nSee the corresponding doc pages for pair styles without the “cs”\nsuffix to see how mixing, shifting, tabulation, tail correction,\nrestarting, and rRESPA are handled by theses pair styles.",
    "syntax": "pair_style style args",
    "parameters": " * style = born/coul/dsf/cs or born/coul/long/cs or born/coul/wolf/cs or buck/coul/long/cs or coul/long/cs or coul/wolf/cs or lj/cut/coul/long/cs\n * args = list of arguments for a particular style\n * born/coul/dsf/cs args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (distance units)\n * born/coul/long/cs args = cutoff (cutoff2)\n *   cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * born/coul/wolf/cs args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * buck/coul/long/cs args = cutoff (cutoff2)\n *   cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * coul/long args = cutoff\n *   cutoff = global cutoff for Coulombic (distance units)\n * coul/wolf args = alpha cutoff\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for Coulombic (distance units)\n * lj/cut/coul/long/cs args = cutoff (cutoff2)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style born/coul/dsf/cs 0.1 10.0 12.0\npair_coeff * *   0.0 1.00 0.00 0.00 0.00\npair_coeff 1 1 480.0 0.25 0.00 1.05 0.50\n\npair_style born/coul/long/cs 10.0 8.0\npair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n\npair_style born/coul/wolf/cs 0.25 10.0 12.0\npair_coeff * *   0.0 1.00 0.00 0.00 0.00\npair_coeff 1 1 480.0 0.25 0.00 1.05 0.50\n\npair_style buck/coul/long/cs 10.0\npair_style buck/coul/long/cs 10.0 8.0\npair_coeff * * 100.0 1.5 200.0\npair_coeff 1 1 100.0 1.5 200.0 9.0\n\npair_style coul/long/cs 10.0\npair_coeff * *\n\npair_style coul/wolf/cs 0.2 9.0\npair_coeff * *\n\npair_style lj/cut/coul/long/cs 10.0\npair_style lj/cut/coul/long/cs 10.0 8.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0",
    "restrictions": "These pair styles are part of the CORESHELL package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style lj/cut/dipole/cut",
    "html_filename": "pair_dipole.html",
    "short_description": "Style lj/cut/dipole/cut computes interactions between pairs of particles that each have a charge and/or a point dipole moment",
    "description": "Style lj/cut/dipole/cut computes interactions between pairs of particles\nthat each have a charge and/or a point dipole moment.  In addition to\nthe usual Lennard-Jones interaction between the particles (Elj) the\ncharge-charge (Eqq), charge-dipole (Eqp), and dipole-dipole (Epp)\ninteractions are computed by these formulas for the energy (E), force\n(F), and torque (T) between particles I and J.\n\n\\[\\begin{split}E_{LJ}  = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                     \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\nE_{qq}  = & \\frac{q_i q_j}{r} \\\\\nE_{qp}  = & \\frac{q}{r^3} (p \\bullet \\vec{r}) \\\\\nE_{pp}  = & \\frac{1}{r^3} (\\vec{p_i} \\bullet \\vec{p_j}) -\n          \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{r}) (\\vec{p_j} \\bullet \\vec{r}) \\\\\n          & \\\\\nF_{qq}  = & \\frac{q_i q_j}{r^3} \\vec{r} \\\\\nF_{qp}  = & -\\frac{q}{r^3} \\vec{p} + \\frac{3q}{r^5}\n          (\\vec{p} \\bullet \\vec{r}) \\vec{r} \\\\\nF_{pp}  = & \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{p_j}) \\vec{r} -\n          \\frac{15}{r^7} (\\vec{p_i} \\bullet \\vec{r})\n          (\\vec{p_j} \\bullet \\vec{r}) \\vec{r} +\n          \\frac{3}{r^5} \\left[ (\\vec{p_j} \\bullet \\vec{r}) \\vec{p_i} +\n          (\\vec{p_i} \\bullet \\vec{r}) \\vec{p_j} \\right] \\\\\n          & \\\\\nT_{pq} = T_{ij}  = & \\frac{q_j}{r^3} (\\vec{p_i} \\times \\vec{r}) \\\\\nT_{qp} = T_{ji}  = & - \\frac{q_i}{r^3} (\\vec{p_j} \\times \\vec{r}) \\\\\nT_{pp} = T_{ij}  = & -\\frac{1}{r^3} (\\vec{p_i} \\times \\vec{p_j}) +\n                   \\frac{3}{r^5} (\\vec{p_j} \\bullet \\vec{r})\n                   (\\vec{p_i} \\times \\vec{r}) \\\\\nT_{pp} = T_{ji}  = & -\\frac{1}{r^3} (\\vec{p_j} \\times \\vec{p_i}) +\n                   \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{r})\n                   (\\vec{p_j} \\times \\vec{r})\\end{split}\\]\nwhere \\(q_i\\) and \\(q_j\\) are the charges on the two particles,\n\\(\\vec{p_i}\\) and \\(\\vec{p_j}\\) are the dipole moment vectors of\nthe two particles, r is their separation distance, and the vector r =\nRi - Rj is the separation vector between the two particles.  Note that\nEqq and Fqq are simply Coulombic energy and force, Fij = -Fji as\nsymmetric forces, and Tij != -Tji since the torques do not act\nsymmetrically.  These formulas are discussed in (Allen)\nand in (Toukmaji).\nAlso note, that in the code, all of these terms (except Elj) have a\n\\(C/\\epsilon\\) prefactor, the same as the Coulombic term in the LJ +\nCoulombic pair styles discussed here.  C is an\nenergy-conversion constant and epsilon is the dielectric constant\nwhich can be set by the dielectric command.  The\nsame is true of the equations that follow for other dipole pair\nstyles.\nStyle lj/sf/dipole/sf computes “shifted-force” interactions between\npairs of particles that each have a charge and/or a point dipole\nmoment. In general, a shifted-force potential is a (slightly) modified\npotential containing extra terms that make both the energy and its\nderivative go to zero at the cutoff distance; this removes\n(cutoff-related) problems in energy conservation and any numerical\ninstability in the equations of motion (Allen). Shifted-force\ninteractions for the Lennard-Jones (E_LJ), charge-charge (Eqq),\ncharge-dipole (Eqp), dipole-charge (Epq) and dipole-dipole (Epp)\npotentials are computed by these formulas for the energy (E), force\n(F), and torque (T) between particles I and J:\n\n\\[ \\begin{align}\\begin{aligned}\\begin{split} E_{LJ}  = &  4\\epsilon \\left\\{ \\left[ \\left( \\frac{\\sigma}{r} \\right)^{\\!12} -\n\\left( \\frac{\\sigma}{r} \\right)^{\\!6}  \\right] +\n\\left[ 6\\left( \\frac{\\sigma}{r_c} \\right)^{\\!12} -\n3\\left(\\frac{\\sigma}{r_c}\\right)^{\\!6}\\right]\\left(\\frac{r}{r_c}\\right)^{\\!2}\n- 7\\left( \\frac{\\sigma}{r_c} \\right)^{\\!12} +\n4\\left( \\frac{\\sigma}{r_c} \\right)^{\\!6}\\right\\} \\\\\nE_{qq}  = & \\frac{q_i q_j}{r}\\left(1-\\frac{r}{r_c}\\right)^{\\!2} \\\\\nE_{pq}  = & E_{ji} = -\\frac{q}{r^3} \\left[ 1 -\n3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p}\\bullet\\vec{r}) \\\\\nE_{qp}  = & E_{ij} = \\frac{q}{r^3} \\left[ 1 -\n3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p}\\bullet\\vec{r}) \\\\\nE_{pp} = & \\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\\left[\\frac{1}{r^3}\n(\\vec{p_i} \\bullet \\vec{p_j}) - \\frac{3}{r^5}\n(\\vec{p_i} \\bullet \\vec{r}) (\\vec{p_j} \\bullet \\vec{r})\\right] \\\\\n         & \\\\\\end{split}\\\\\\begin{split}F_{LJ}  = & \\left\\{\\left[48\\epsilon \\left(\\frac{\\sigma}{r}\\right)^{\\!12} -\n24\\epsilon \\left(\\frac{\\sigma}{r}\\right)^{\\!6} \\right]\\frac{1}{r^2} -\n\\left[48\\epsilon \\left(\\frac{\\sigma}{r_c}\\right)^{\\!12} - 24\\epsilon\n\\left(\\frac{\\sigma}{r_c}\\right)^{\\!6} \\right]\\frac{1}{r_c^2}\\right\\}\\vec{r}\\\\\nF_{qq}  = & \\frac{q_i q_j}{r}\\left(\\frac{1}{r^2} -\n\\frac{1}{r_c^2}\\right)\\vec{r} \\\\\nF_{pq} = & F_{ij } =  -\\frac{3q}{r^5} \\left[ 1 -\n\\left(\\frac{r}{r_c}\\right)^{\\!2}\\right](\\vec{p}\\bullet\\vec{r})\\vec{r} +\n\\frac{q}{r^3}\\left[1-3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] \\vec{p} \\\\\nF_{qp} = & F_{ij}  = \\frac{3q}{r^5} \\left[ 1 -\n\\left(\\frac{r}{r_c}\\right)^{\\!2}\\right] (\\vec{p}\\bullet\\vec{r})\\vec{r} -\n\\frac{q}{r^3}\\left[1-3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] \\vec{p} \\\\\nF_{pp}  = &\\frac{3}{r^5}\\Bigg\\{\\left[1-\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\n\\left[(\\vec{p_i}\\bullet\\vec{p_j}) - \\frac{3}{r^2} (\\vec{p_i}\\bullet\\vec{r})\n(\\vec{p_j} \\bullet \\vec{r})\\right] \\vec{r} + \\\\\n  & \\left[1 -\n4\\left(\\frac{r}{r_c}\\right)^{\\!3}+3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\n\\left[ (\\vec{p_j} \\bullet \\vec{r}) \\vec{p_i} + (\\vec{p_i} \\bullet \\vec{r})\n\\vec{p_j} -\\frac{2}{r^2} (\\vec{p_i} \\bullet \\vec{r})\n(\\vec{p_j} \\bullet \\vec{r})\\vec{r}\\right] \\Bigg\\}\\end{split}\\end{aligned}\\end{align} \\]\n\n\\[\\begin{split} T_{pq} = T_{ij}  = & \\frac{q_j}{r^3} \\left[ 1 -\n3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p_i}\\times\\vec{r}) \\\\\nT_{qp} = T_{ji}  = & - \\frac{q_i}{r^3} \\left[ 1 -\n3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n2\\left(\\frac{r}{r_c}\\right)^{\\!3} \\right] (\\vec{p_j}\\times\\vec{r}) \\\\\nT_{pp} = T_{ij}  = & -\\frac{1}{r^3}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\ne3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_i} \\times \\vec{p_j}) + \\\\\n                   & \\frac{3}{r^5}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_j}\\bullet\\vec{r})\n(\\vec{p_i} \\times \\vec{r}) \\\\\nT_{pp} = T_{ji} = & -\\frac{1}{r^3}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right](\\vec{p_j} \\times \\vec{p_i}) + \\\\\n                   & \\frac{3}{r^5}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_i} \\bullet \\vec{r})\n(\\vec{p_j} \\times \\vec{r})\\end{split}\\]\nwhere \\(\\epsilon\\) and \\(\\sigma\\) are the standard LJ\nparameters, \\(r_c\\) is the cutoff, \\(q_i\\) and \\(q_j\\) are\nthe charges on the two particles, \\(\\vec{p_i}\\) and\n\\(\\vec{p_j}\\) are the dipole moment vectors of the two particles, r\nis their separation distance, and the vector r = Ri - Rj is the\nseparation vector between the two particles.  Note that Eqq and Fqq are\nsimply Coulombic energy and force, Fij = -Fji as symmetric forces, and\nTij != -Tji since the torques do not act symmetrically.  The\nshifted-force formula for the Lennard-Jones potential is reported in\n(Stoddard).  The original (non-shifted) formulas for\nthe electrostatic potentials, forces and torques can be found in\n(Price). The shifted-force electrostatic potentials have\nbeen obtained by applying equation 5.13 of (Allen). The\nformulas for the corresponding forces and torques have been obtained by\napplying the ‘chain rule’ as in appendix C.3 of (Allen).\nIf one cutoff is specified in the pair_style command, it is used for\nboth the LJ and Coulombic (q,p) terms.  If two cutoffs are specified,\nthey are used as cutoffs for the LJ and Coulombic (q,p) terms\nrespectively. This pair style also supports an optional scale keyword\nas part of a pair_coeff statement, where the interactions can be\nscaled according to this factor. This scale factor is also made available\nfor use with fix adapt.\nStyle lj/cut/dipole/long computes long-range point-dipole\ninteractions as discussed in (Toukmaji). Dipole-dipole,\ndipole-charge, and charge-charge interactions are all supported, along\nwith the standard 12/6 Lennard-Jones interactions, which are computed\nwith a cutoff.  A kspace_style must be defined to\nuse this pair style.  Currently, only kspace_style ewald/disp support long-range point-dipole\ninteractions.\nStyle lj/long/dipole/long also computes point-dipole interactions as\ndiscussed in (Toukmaji). Long-range dipole-dipole,\ndipole-charge, and charge-charge interactions are all supported, along\nwith the standard 12/6 Lennard-Jones interactions.  LJ interactions\ncan be cutoff or long-ranged.\nFor style lj/long/dipole/long, if flag_lj is set to long, no\ncutoff is used on the LJ 1/r^6 dispersion term.  The long-range\nportion is calculated by using the kspace_style ewald_disp command.  The specified LJ cutoff then\ndetermines which portion of the LJ interactions are computed directly\nby the pair potential versus which part is computed in reciprocal\nspace via the Kspace style.  If flag_lj is set to cut, the LJ\ninteractions are simply cutoff, as with pair_style lj/cut.  If flag_lj is set to off, LJ interactions\nare not computed at all.\nIf flag_coul is set to long, no cutoff is used on the Coulombic or\ndipole interactions.  The long-range portion is calculated by using\newald_disp of the kspace_style command. If\nflag_coul is set to off, Coulombic and dipole interactions are not\ncomputed at all.\nAtoms with dipole moments should be integrated using the fix nve/sphere update dipole or the fix nvt/sphere update dipole command to rotate the\ndipole moments.  The omega option on the fix langevin command can be used to thermostat the\nrotational motion.  The compute temp/sphere\ncommand can be used to monitor the temperature, since it includes\nrotational degrees of freedom.  The atom_style hybrid dipole sphere command should be used since\nit defines the point dipoles and their rotational state.\nThe magnitude and orientation of the dipole moment for each particle\ncan be defined by the set command or in the “Atoms” section\nof the data file read in by the read_data command.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nThe latter 2 coefficients are optional.  If not specified, the global\nLJ and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both LJ\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the LJ and Coulombic cutoffs for this\ntype pair.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distances for this pair style can be mixed.  The default\nmix value is geometric.  See the “pair_modify” command for details.\nFor atom type pairs I,J and I != J, the A, sigma, d1, and d2\ncoefficients and cutoff distance for this pair style can be mixed.  A\nis an energy value mixed like a LJ epsilon.  D1 and d2 are distance\nvalues and are mixed like sigma.  The default mix value is\ngeometric.  See the “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option for the energy of the Lennard-Jones portion of the pair\ninteraction; such energy goes to zero at the cutoff by construction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style lj/cut/dipole/cut cutoff (cutoff2)",
    "parameters": " * pair_style lj/sf/dipole/sf cutoff (cutoff2)\n * pair_style lj/cut/dipole/long cutoff (cutoff2)\n * pair_style lj/long/dipole/long flag_lj flag_coul cutoff (cutoff2)\n * cutoff = global cutoff LJ (and Coulombic if only 1 arg) (distance units)\n * cutoff2 = global cutoff for Coulombic and dipole (optional) (distance units)\n * flag_lj = long or cut or off\n * long = use long-range damping on dispersion 1/r^6 term\n * cut = use a cutoff on dispersion 1/r^6 term\n * off = omit disperion 1/r^6 term entirely\n * flag_coul = long or off\n * long = use long-range damping on Coulombic 1/r and point-dipole terms\n * off = omit Coulombic and point-dipole terms entirely",
    "examples": "pair_style lj/cut/dipole/cut 10.0\npair_coeff * * 1.0 1.0\npair_coeff 2 3 1.0 1.0 2.5 4.0\n\npair_style lj/sf/dipole/sf 9.0\npair_coeff * * 1.0 1.0\npair_coeff 2 3 1.0 1.0 2.5 4.0 scale 0.5\npair_coeff 2 3 1.0 1.0 2.5 4.0\n\npair_style lj/cut/dipole/long 10.0\npair_coeff * * 1.0 1.0\npair_coeff 2 3 1.0 1.0 2.5 4.0\n\npair_style lj/long/dipole/long long long 3.5 10.0\npair_coeff * * 1.0 1.0\npair_coeff 2 3 1.0 1.0 2.5 4.0",
    "restrictions": "The lj/cut/dipole/cut, lj/cut/dipole/long, and\nlj/long/dipole/long styles are part of the DIPOLE package.  They are\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThe lj/sf/dipole/sf style is part of the USER-MISC package.  It is\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nUsing dipole pair styles with electron units is not\ncurrently supported."
},
{
    "command": "pair_style dpd",
    "html_filename": "pair_dpd.html",
    "short_description": "Style dpd computes a force field for dissipative particle dynamics (DPD) following the exposition in (Groot)",
    "description": "Style dpd computes a force field for dissipative particle dynamics\n(DPD) following the exposition in (Groot).\nStyle dpd/tstat invokes a DPD thermostat on pairwise interactions,\nwhich is equivalent to the non-conservative portion of the DPD force\nfield.  This pair-wise thermostat can be used in conjunction with any\npair style, and in leiu of per-particle thermostats\nlike fix langevin or ensemble thermostats like\nNose Hoover as implemented by fix nvt.  To use\ndpd/tstat as a thermostat for another pair style, use the pair_style hybrid/overlay command to compute both the desired\npair interaction and the thermostat for each pair of particles.\nFor style dpd, the force on atom I due to atom J is given as a sum\nof 3 terms\n\n\\[\\begin{split}\\vec{f}  = & (F^C + F^D + F^R) \\hat{r_{ij}} \\qquad \\qquad r < r_c \\\\\nF^C      = & A w(r) \\\\\nF^D      = & - \\gamma w^2(r) (\\hat{r_{ij}} \\bullet \\vec{v_{ij}}) \\\\\nF^R      = & \\sigma w(r) \\alpha (\\Delta t)^{-1/2} \\\\\nw(r)     = & 1 - r/r_c\\end{split}\\]\nwhere \\(F^C\\) is a conservative force, \\(F^D\\) is a dissipative\nforce, and \\(F^R\\) is a random force.  \\(r_{ij}\\) is a unit\nvector in the direction \\(r_i - r_j\\), \\(V_{ij} is the vector\ndifference in velocities of the two atoms :math:\\)alpha` is a Gaussian random number with zero mean and\nunit variance, dt is the timestep size, and w(r) is a weighting factor\nthat varies between 0 and 1.  \\(r_c\\) is the cutoff.  \\(\\sigma\\)\nis set equal to \\(\\sqrt{2 k_B T \\gamma}\\), where \\(k_B\\) is the\nBoltzmann constant and T is the temperature parameter in the pair_style\ncommand.\nFor style dpd/tstat, the force on atom I due to atom J is the same\nas the above equation, except that the conservative Fc term is\ndropped.  Also, during the run, T is set each timestep to a ramped\nvalue from Tstart to Tstop.\nFor style dpd, the pairwise energy associated with style dpd is\nonly due to the conservative force term Fc, and is shifted to be zero\nat the cutoff distance Rc.  The pairwise virial is calculated using\nall 3 terms.  For style dpd/tstat there is no pairwise energy, but\nthe last two terms of the formula make a contribution to the virial.\nFor style dpd, the following coefficients must be defined for each\npair of atoms types via the pair_coeff command as in\nthe examples above, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA (force units)\n\\(\\gamma\\) (force/velocity units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global DPD\ncutoff is used.  Note that sigma is set equal to sqrt(2 T gamma),\nwhere T is the temperature set by the pair_style\ncommand so it does not need to be specified.\nFor style dpd/tstat, the coefficients defined for each pair of\natoms types via the pair_coeff command is the same,\nexcept that A is not included.\nThe GPU-accelerated versions of these styles are implemented based on\nthe work of (Afshar) and (Phillips).\n\nNote\nIf you are modeling DPD polymer chains, you may want to use the\npair_style srp command in conjunction with these pair\nstyles.  It is a soft segmental repulsive potential (SRP) that can\nprevent DPD polymer chains from crossing each other.\n\n\nNote\nThe virial calculation for pressure when using this pair style\nincludes all the components of force listed above, including the\nrandom force.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThese pair styles do not support the pair_modify\nshift option for the energy of the pair interaction.  Note that as\ndiscussed above, the energy due to the conservative Fc term is already\nshifted to be 0.0 at the cutoff distance Rc.\nThe pair_modify table option is not relevant\nfor these pair styles.\nThese pair style do not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThese pair styles writes their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.  Note\nthat the user-specified random number seed is stored in the restart\nfile, so when a simulation is restarted, each processor will\nre-initialize its random number generator the same way it did\ninitially.  This means the random forces will be random, but will not\nbe the same as they would have been if the original simulation had\ncontinued past the restart time.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.\nThe dpd/tstat style can ramp its target temperature over multiple\nruns, using the start and stop keywords of the run\ncommand.  See the run command for details of how to do\nthis.",
    "syntax": "pair_style dpd T cutoff seed",
    "parameters": " * pair_style dpd/tstat Tstart Tstop cutoff seed\n * T = temperature (temperature units)\n * Tstart,Tstop = desired temperature at start/end of run (temperature units)\n * cutoff = global cutoff for DPD interactions (distance units)\n * seed = random # seed (positive integer)",
    "examples": "pair_style dpd 1.0 2.5 34387\npair_coeff * * 3.0 1.0\npair_coeff 1 1 3.0 1.0 1.0\n\npair_style dpd/tstat 1.0 1.0 2.5 34387\npair_coeff * * 1.0\npair_coeff 1 1 1.0 1.0",
    "restrictions": "The default frequency for rebuilding neighbor lists is every 10 steps\n(see the neigh_modify command). This may be too\ninfrequent for style dpd simulations since particles move rapidly\nand can overlap by large amounts.  If this setting yields a non-zero\nnumber of “dangerous” reneighborings (printed at the end of a\nsimulation), you should experiment with forcing reneighboring more\noften and see if system energies/trajectories change.\nThese pair styles requires you to use the comm_modify vel yes command so that velocities are stored by ghost\natoms.\nThese pair styles will not restart exactly when using the\nread_restart command, though they should provide\nstatistically similar results.  This is because the forces they\ncompute depend on atom velocities.  See the\nread_restart command for more details."
},
{
    "command": "pair_style dpd/fdt",
    "html_filename": "pair_dpd_fdt.html",
    "short_description": "Styles dpd/fdt and dpd/fdt/energy compute the force for dissipative particle dynamics (DPD) simulations",
    "description": "Styles dpd/fdt and dpd/fdt/energy compute the force for dissipative\nparticle dynamics (DPD) simulations.  The dpd/fdt style is used to\nperform DPD simulations under isothermal and isobaric conditions,\nwhile the dpd/fdt/energy style is used to perform DPD simulations\nunder isoenergetic and isoenthalpic conditions (see (Lisal)).\nFor DPD simulations in general, the force on atom I due to atom J is\ngiven as a sum of 3 terms\n\n\\[\\begin{split}\\vec{f}  = & (F^C + F^D + F^R) \\hat{r_{ij}} \\qquad \\qquad r < r_c \\\\\nF^C      = & A w(r) \\\\\nF^D      = & - \\gamma w^2(r) (\\hat{r_{ij}} \\bullet \\vec{v_{ij}}) \\\\\nF^R      = & \\sigma w(r) \\alpha (\\Delta t)^{-1/2} \\\\\nw(r)     = & 1 - r/r_c\\end{split}\\]\nwhere \\(F^C\\) is a conservative force, \\(F^D\\) is a dissipative\nforce, and \\(F^R\\) is a random force.  \\(r_{ij}\\) is a unit\nvector in the direction \\(r_i - r_j\\), \\(V_{ij} is the vector\ndifference in velocities of the two atoms :math:\\)alpha` is a Gaussian random number with zero mean and\nunit variance, dt is the timestep size, and w(r) is a weighting factor\nthat varies between 0 and 1.  Rc is the cutoff.  The weighting factor,\n\\(\\omega_{ij}\\), varies between 0 and 1, and is chosen to have the\nfollowing functional form:\n\n\\[\\omega_{ij} = 1 - \\frac{r_{ij}}{r_{c}}\\]\nNote that alternative definitions of the weighting function exist, but\nwould have to be implemented as a separate pair style command.\nFor style dpd/fdt, the fluctuation-dissipation theorem defines \\(\\gamma\\)\nto be set equal to \\(\\sigma^2/(2 T)\\), where T is the set point\ntemperature specified as a pair style parameter in the above examples.\nThe following coefficients must be defined for each pair of atoms types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart commands:\n\nA (force units)\n\\(\\sigma\\) (force*time^(1/2) units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global DPD\ncutoff is used.\nStyle dpd/fdt/energy is used to perform DPD simulations under\nisoenergetic and isoenthalpic conditions.  The fluctuation-dissipation\ntheorem defines \\(\\gamma\\) to be set equal to \\(sigma^2/(2\n\\theta)\\), where :math:theta` is the average internal temperature for the\npair. The particle internal temperature is related to the particle\ninternal energy through a mesoparticle equation of state (see fix\neos). The differential internal conductive and mechanical\nenergies are computed within style dpd/fdt/energy as:\n\n\\[\\begin{split}du_{i}^{cond}  = & \\kappa_{ij}(\\frac{1}{\\theta_{i}}-\\frac{1}{\\theta_{j}})\\omega_{ij}^{2} + \\alpha_{ij}\\omega_{ij}\\zeta_{ij}^{q}(\\Delta{t})^{-1/2} \\\\\ndu_{i}^{mech}  = & -\\frac{1}{2}\\gamma_{ij}\\omega_{ij}^{2}(\\frac{\\vec{r_{ij}}}{r_{ij}}\\bullet\\vec{v_{ij}})^{2} -\n\\frac{\\sigma^{2}_{ij}}{4}(\\frac{1}{m_{i}}+\\frac{1}{m_{j}})\\omega_{ij}^{2} -\n\\frac{1}{2}\\sigma_{ij}\\omega_{ij}(\\frac{\\vec{r_{ij}}}{r_{ij}}\\bullet\\vec{v_{ij}})\\zeta_{ij}(\\Delta{t})^{-1/2}\\end{split}\\]\nwhere\n\n\\[\\begin{split}\\alpha_{ij}^{2}  = & 2k_{B}\\kappa_{ij} \\\\\n\\sigma^{2}_{ij}  = & 2\\gamma_{ij}k_{B}\\Theta_{ij} \\\\\n\\Theta_{ij}^{-1}  = & \\frac{1}{2}(\\frac{1}{\\theta_{i}}+\\frac{1}{\\theta_{j}})\\end{split}\\]\n\\(\\zeta_ij^q\\) is a second Gaussian random number with zero mean and unit\nvariance that is used to compute the internal conductive energy. The\nfluctuation-dissipation theorem defines \\(alpha^2\\) to be set\nequal to :math:2k_Bkappa`, where \\(\\kappa\\) is the mesoparticle thermal\nconductivity parameter.   The following coefficients must be defined for\neach pair of atoms types via the pair_coeff\ncommand as in the examples above, or in the data file or restart files\nread by the read_data or read_restart\ncommands:\n\nA (force units)\n\\(\\sigma\\) (force*time^(1/2) units)\n\\(\\kappa\\) (energy*temperature/time units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global DPD\ncutoff is used.\nThe pairwise energy associated with styles dpd/fdt and\ndpd/fdt/energy is only due to the conservative force term Fc, and is\nshifted to be zero at the cutoff distance Rc.  The pairwise virial is\ncalculated using only the conservative term.\nThe forces computed through the dpd/fdt and dpd/fdt/energy styles\ncan be integrated with the velocity-Verlet integration scheme or the\nShardlow splitting integration scheme described by (Lisal).\nIn the cases when these pair styles are combined with the\nfix shardlow, these pair styles differ from the\nother dpd styles in that the dissipative and random forces are split\nfrom the force calculation and are not computed within the pair style.\nThus, only the conservative force is computed by the pair style,\nwhile the stochastic integration of the dissipative and random forces\nare handled through the Shardlow splitting algorithm approach.  The\nShardlow splitting algorithm is advantageous, especially when\nperforming DPD under isoenergetic conditions, as it allows\nsignificantly larger timesteps to be taken.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style style args",
    "parameters": " * style = dpd/fdt or dpd/fdt/energy\n * args = list of arguments for a particular style\n * dpd/fdt args = T cutoff seed\n *   T = temperature (temperature units)\n *   cutoff = global cutoff for DPD interactions (distance units)\n *   seed = random # seed (positive integer)\n * dpd/fdt/energy args = cutoff seed\n *   cutoff = global cutoff for DPD interactions (distance units)\n *   seed = random # seed (positive integer)",
    "examples": "pair_style dpd/fdt 300.0 2.5 34387\npair_coeff * * 3.0 1.0 2.5\n\npair_style dpd/fdt/energy 2.5 34387\npair_coeff * * 3.0 1.0 0.1 2.5",
    "restrictions": "These commands are part of the USER-DPD package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nPair styles dpd/fdt and dpd/fdt/energy require use of the\ncomm_modify vel yes option so that velocities are\nstored by ghost atoms.\nPair style dpd/fdt/energy requires atom_style dpd\nto be used in order to properly account for the particle internal\nenergies and temperatures."
},
{
    "command": "pair_style drip",
    "html_filename": "pair_drip.html",
    "short_description": "Style drip computes the interlayer interactions of layered materials using the dihedral-angle-corrected registry-dependent (DRIP) potential as described in (Wen), which is based on the (Kolmogorov) potential and provides an improved prediction for forces",
    "description": "Style drip computes the interlayer interactions of layered materials using\nthe dihedral-angle-corrected registry-dependent (DRIP) potential as described\nin (Wen), which is based on the (Kolmogorov)\npotential and provides an improved prediction for forces.\nThe total potential energy of a system is\n\n\\[\\begin{split}E = & \\frac{1}{2} \\sum_{i} \\sum_{j\\notin\\text{layer}\\,i} \\phi_{ij} \\\\\n\\phi_{ij} = &f_\\text{c}(x_r) \\left[ e^{-\\lambda(r_{ij} - z_0 )} \\left[C+f(\\rho_{ij})+  g(\\rho_{ij}, \\{\\alpha_{ij}^{(m)}\\}) \\right]- A\\left (\\frac{z_0}{r_{ij}} \\right)^6 \\right]\\end{split}\\]\nwhere the \\(r^{-6}\\) term models the attractive London dispersion,\nthe exponential term is designed to capture the registry effect due to\noverlapping pi bonds, and fc is a cutoff function.\nThis potential (DRIP) only provides the interlayer interactions between\ngraphene layers. So, to perform a realistic simulation, it should be used in\ncombination with an intralayer potential such as REBO and\nTersoff.\nTo keep the intralayer interactions unaffected, we should avoid applying DRIP\nto contribute energy to intralayer interactions. This can be achieved by\nassigning different molecular IDs to atoms in different layers, and DRIP is\nimplemented such that only atoms with different molecular ID can interact with\neach other. For this purpose, atom style “molecular” or\n“full” has to be used.\nOn the other way around, REBO (Tersoff\nor any other potential used to provide the intralayer interactions) should not\ninterfere with the interlayer interactions described by DRIP. This is typically\nautomatically achieved using the commands provided in the Examples section\nabove, since the cutoff distance for carbon-carbon interaction in the intralayer\npotentials (e.g. 2 Angstrom for REBO) is much smaller than\nthe equilibrium layer distance of graphene layers (about 3.4 Angstrom).\nIf you want, you can enforce this by assigning different atom types to atoms in\ndifferent layers, and apply an intralayer potential to one atom type.\nSee pair_hybrid for details.\n\nThe pair_coeff command for DRIP takes 4+N arguments, where\nN is the number of LAMMPS atom types. The fist three arguments must be fixed\nto be * * drip, the fourth argument is the path to the DRIP parameter file,\nand the remaining N arguments specifying the mapping between element in the\nparameter file and atom types. For example, if your LAMMPS simulation has 3 atom\ntypes and you want all of them to be C, you would use the following pair_coeff\ncommand:\npair_coeff * * drip  C.drip  C C C\n\n\nIf a mapping value is specified as NULL, the mapping is not performed. This\ncould be useful when DRIP is used to model part of the system where other\nelement exists. Suppose you have a hydrocarbon system, with C of atom type 1\nand H of atom type 2, you can use the following command to inform DRIP not to\nmodel H atoms:\npair_style hybrid/overlay drip rebo\npair_coeff * * drip  C.drip     C NULL\npair_coeff * * rebo  CH.airebo  C H\n\n\n\nNote\nThe potential parameters developed in (Wen) are provided with\nLAMMPS (see the “potentials” directory). Besides those in Wen, an\nadditional parameter “normal_cutoff”, specific to the LAMMPS implementation, is\nused to find the three nearest neighbors of an atom to construct the normal.\n\n\nMixing, shift, table, tail correction, and restart info:\nThis pair style does not support the pair_modify mix, shift, table,\nand tail options.\nThis pair style does not write their information to binary restart files, since\nit is stored in potential files. Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.",
    "syntax": "pair_style hybrid/overlay drip [styles ...]",
    "parameters": " * styles = other styles to be overlayed with drip (optional)",
    "examples": "pair_style hybrid/overlay drip\npair_coeff * * none\npair_coeff * * drip  C.drip  C\n\npair_style hybrid/overlay drip rebo\npair_coeff * * drip  C.drip     C\npair_coeff * * rebo  CH.airebo  C\n\npair_style hybrid/overlay drip rebo\npair_coeff * * drip  C.drip     C NULL\npair_coeff * * rebo  CH.airebo  C H",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc\npage for more info.\nThis pair potential requires the newton setting to be “on” for\npair interactions.\nThe C.drip parameter file provided with LAMMPS (see the “potentials”\ndirectory) is parameterized for metal units. You can use the DRIP\npotential with any LAMMPS units, but you would need to create your own custom\nparameter file with coefficients listed in the appropriate units, if your\nsimulation doesn’t use “metal” units."
},
{
    "command": "pair_style dsmc",
    "html_filename": "pair_dsmc.html",
    "short_description": "Style dsmc computes collisions between pairs of particles for a direct simulation Monte Carlo (DSMC) model following the exposition in (Bird)",
    "description": "Style dsmc computes collisions between pairs of particles for a\ndirect simulation Monte Carlo (DSMC) model following the exposition in\n(Bird).  Each collision resets the velocities of the two\nparticles involved.  The number of pairwise collisions for each pair\nor particle types and the length scale within which they occur are\ndetermined by the parameters of the pair_style and pair_coeff\ncommands.\nStochastic collisions are performed using the variable hard sphere\n(VHS) approach, with the user-defined max_cell_size value used as\nthe maximum DSMC cell size, and reference cross-sections for\ncollisions given using the pair_coeff command.\nThere is no pairwise energy or virial contributions associated with\nthis pair style.\nThe following coefficient must be defined for each pair of atoms types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nsigma (area units, i.e. distance-squared)\n\nThe global DSMC max_cell_size determines the maximum cell length\nused in the DSMC calculation.  A structured mesh is overlayed on the\nsimulation box such that an integer number of cells are created in\neach direction for each processor’s sub-domain.  Cell lengths are\nadjusted up to the user-specified maximum cell size.\n\nTo perform a DSMC simulation with LAMMPS, several additional options\nshould be set in your input script, though LAMMPS does not check for\nthese settings.\nSince this pair style does not compute particle forces, you should use\nthe “fix nve/noforce” time integration fix for the DSMC particles,\ne.g.\nfix 1 all nve/noforce\n\n\nThis pair style assumes that all particles will communicated to\nneighboring processors every timestep as they move.  This makes it\npossible to perform all collisions between pairs of particles that are\non the same processor.  To ensure this occurs, you should use\nthese commands:\nneighbor 0.0 bin\nneigh_modify every 1 delay 0 check no\natom_modify sort 0 0.0\ncommunicate single cutoff 0.0\n\n\nThese commands ensure that LAMMPS communicates particles to\nneighboring processors every timestep and that no ghost atoms are\ncreated.  The output statistics for a simulation run should indicate\nthere are no ghost particles or neighbors.\nIn order to get correct DSMC collision statistics, users should\nspecify a Gaussian velocity distribution when populating the\nsimulation domain. Note that the default velocity distribution is\nuniform, which will not give good DSMC collision rates. Specify\n“dist gaussian” when using the velocity command\nas in the following:\nvelocity all create 594.6 87287 loop geom dist gaussian\n\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.  Note\nthat the user-specified random number seed is stored in the restart\nfile, so when a simulation is restarted, each processor will\nre-initialize its random number generator the same way it did\ninitially.  This means the random forces will be random, but will not\nbe the same as they would have been if the original simulation had\ncontinued past the restart time.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style dsmc max_cell_size seed weighting Tref Nrecompute Nsample",
    "parameters": " * max_cell_size = global maximum cell size for DSMC interactions (distance units)\n * seed = random # seed (positive integer)\n * weighting = macroparticle weighting\n * Tref = reference temperature (temperature units)\n * Nrecompute = re-compute v*sigma_max every this many timesteps (timesteps)\n * Nsample = sample this many times in recomputing v*sigma_max",
    "examples": "pair_style dsmc 2.5 34387 10 1.0 100 20\npair_coeff * * 1.0\npair_coeff 1 1 1.0",
    "restrictions": "This style is part of the MC package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style e3b",
    "html_filename": "pair_e3b.html",
    "short_description": "The e3b style computes an “explicit three-body” (E3B) potential for water (Kumar 2008)",
    "description": "The e3b style computes an “explicit three-body” (E3B) potential for water (Kumar 2008).\n\n\\[\\begin{split}E =& E_2 \\sum_{i,j}e^{-k_2 r_{ij}} + E_A \\sum_{\\substack{i,j,k,\\ell \\\\\n\\in \\textrm{type A}}} f(r_{ij})f(r_{k\\ell}) + E_B \\sum_{\\substack{i,j,k,\\ell \\\\\n\\in \\textrm{type B}}} f(r_{ij})f(r_{k\\ell}) + E_C \\sum_{\\substack{i,j,k,\\ell \\\\\n\\in \\textrm{type C}}} f(r_{ij})f(r_{k\\ell}) \\\\\nf(r) =& e^{-k_3 r}s(r) \\\\\ns(r) =& \\begin{cases}\n1 & r<R_s \\\\\n\\displaystyle\\frac{(R_f-r)^2(R_f-3R_s+2r)}{(R_f-R_s)^3} & R_s\\leq r\\leq R_f \\\\\n0 & r>R_f\\\\\n\\end{cases}\\end{split}\\]\nThis potential was developed as a water model that includes the three-body cooperativity of hydrogen bonding explicitly.\nTo use it in this way, it must be applied in conjunction with a conventional two-body water model, through pair_style hybrid/overlay.\nThe three body interactions are split into three types: A, B, and C.\nType A corresponds to anti-cooperative double hydrogen bond donor interactions.\nType B corresponds to the cooperative interaction of molecules that both donate and accept a hydrogen bond.\nType C corresponds to anti-cooperative double hydrogen bond acceptor interactions.\nThe three-body interactions are smoothly cutoff by the switching function s(r) between Rs and Rc3.\nThe two-body interactions are designed to correct for the effective many-body interactions implicitly included in the conventional two-body potential.\nThe two-body interactions are cut off sharply at Rc2, because K3 is typically significantly smaller than K2.\nSee (Kumar 2008) for more details.\nOnly a single pair_coeff command is used with the e3b style.\nThe 1st two arguments must be * *.\nThe oxygen atom type for the pair style is passed as the only argument to the pair_style command, not in the pair_coeff command.\nThe hydrogen atom type is inferred by the ordering of the atoms.\n\nNote\nEvery atom of type Otype must be part of a water molecule.\nEach water molecule must have consecutive IDs with the oxygen first.\nThis pair style does not test that this criteria is met.\n\nThe pair_coeff command must have at least one keyword/value pair, as described above.\nThe preset keyword sets the potential parameters to the values used in (Tainter 2011) or (Tainter 2015).\nTo use the water models defined in those references, the e3b style should always be used in conjunction with an lj/cut/tip4p/long style through pair_style hybrid/overlay, as demonstrated in the second example above.\nThe preset 2011 option should be used with the TIP4P water model.\nThe preset 2015 option should be used with the TIP4P/2005 water model.\nIf the preset keyword is used, no other keyword is needed.\nChanges to the preset parameters can be made by specifying the preset keyword followed by the specific parameter to change, like Ea.\nNote that the other keywords must come after preset in the pair_style command.\nThe e3b style can also be used to implement any three-body potential of the same form by specifying all the keywords except neigh: Ea, Eb, Ec, E2, K3, K2, Rc3, Rc2, Rs, and bondL.\nThe keyword bondL specifies the intramolecular OH bond length of the water model being used.\nThis is needed to include H atoms that are within the cutoff even when the attached oxygen atom is not.\nThis pair style allocates arrays sized according to the number of pairwise interactions within Rc3.\nTo do this it needs an estimate for the number of water molecules within Rc3 of an oxygen atom.\nThis estimate defaults to 10 and can be changed using the neigh keyword, which takes an integer as an argument.\nIf the neigh setting is too small, the simulation will fail with the error “neigh is too small”.\nIf the neigh setting is too large, the pair style will use more memory than necessary.\nThis pair style tallies a breakdown of the total E3B potential energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 4.\nThe 4 values correspond to the terms in the first equation above: the E2 term, the Ea term, the Eb term, and the Ec term.\nSee the examples/USER/misc/e3b directory for a complete example script.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style is incompatible with respa.",
    "syntax": "pair_style e3b Otype",
    "parameters": " * Otype = atom type for oxygen\n * pair_coeff * * keyword\n * one or more keyword/value pairs must be appended.\n * keyword = preset or Ea or Eb or Ec or E2 or K3 or K2 or Rs or Rc3 or Rc2 or bondL or neigh\n * If the preset keyword is given, no others are needed.\n * Otherwise, all are mandatory except for neigh.\n * The neigh keyword is always optional.\n * preset arg = 2011 or 2015 = which set of predefined parameters to use\n *          2011 = use the potential parameters from (Tainter 2011)\n *          2015 = use the potential parameters from (Tainter 2015)\n * Ea arg = three-body energy for type A hydrogen bonding interactions (energy units)\n * Eb arg = three-body energy for type B hydrogen bonding interactions (energy units)\n * Ec arg = three-body energy for type C hydrogen bonding interactions (energy units)\n * E2 arg = two-body energy correction (energy units)\n * K3 arg = three-body exponential constant (inverse distance units)\n * K2 arg = two-body exponential constant (inverse distance units)\n * Rc3 arg = three-body cutoff (distance units)\n * Rc2 arg = two-body cutoff (distance units)\n * Rs arg = three-body switching function cutoff (distance units)\n * bondL arg = intramolecular OH bond length (distance units)\n * neigh arg = approximate integer number of molecules within Rc3 of an oxygen atom",
    "examples": "pair_style e3b 1\npair_coeff * * Ea 35.85 Eb -240.2 Ec 449.3 E2 108269.9 K3 1.907 K2 4.872 Rc3 5.2 Rc2 5.2 Rs 5.0 bondL 0.9572\n\npair_style hybrid/overlay e3b 1 lj/cut/tip4p/long 1 2 1 1 0.15 8.5\npair_coeff * * e3b preset 2011",
    "restrictions": "This pair style is part of the USER-MISC package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThis pair style requires a fixed number of atoms in the simulation, so it is incompatible with fixes like fix deposit.\nIf the number of atoms changes between runs, this pair style must be re-initialized by calling the pair_style and pair_coeffs commands.\nThis is not a fundamental limitation of the pair style, but the code currently does not support a variable number of atoms.\nThe preset keyword currently only works with real, metal, si, and cgs units."
},
{
    "command": "pair_style eam",
    "html_filename": "pair_eam.html",
    "short_description": "Style eam computes pairwise interactions for metals and metal alloys using embedded-atom method (EAM) potentials (Daw)",
    "description": "Style eam computes pairwise interactions for metals and metal alloys\nusing embedded-atom method (EAM) potentials (Daw).  The total\nenergy Ei of an atom I is given by\n\n\\[E_i = F_\\alpha \\left(\\sum_{j \\neq i}\\ \\rho_\\beta (r_{ij})\\right) +\n      \\frac{1}{2} \\sum_{j \\neq i} \\phi_{\\alpha\\beta} (r_{ij})\\]\nwhere F is the embedding energy which is a function of the atomic\nelectron density rho, phi is a pair potential interaction, and alpha\nand beta are the element types of atoms I and J.  The multi-body\nnature of the EAM potential is a result of the embedding energy term.\nBoth summations in the formula are over all neighbors J of atom I\nwithin the cutoff distance.\nThe cutoff distance and the tabulated values of the functionals F,\nrho, and phi are listed in one or more files which are specified by\nthe pair_coeff command.  These are ASCII text files\nin a DYNAMO-style format which is described below.  DYNAMO was the\noriginal serial EAM MD code, written by the EAM originators.  Several\nDYNAMO potential files for different metals are included in the\n“potentials” directory of the LAMMPS distribution.  All of these files\nare parameterized in terms of LAMMPS metal units.\n\nNote\nThe eam style reads single-element EAM potentials in the\nDYNAMO funcfl format.  Either single element or alloy systems can be\nmodeled using multiple funcfl files and style eam.  For the alloy\ncase LAMMPS mixes the single-element potentials to produce alloy\npotentials, the same way that DYNAMO does.  Alternatively, a single\nDYNAMO setfl file or Finnis/Sinclair EAM file can be used by LAMMPS\nto model alloy systems by invoking the eam/alloy or eam/cd or\neam/fs styles as described below.  These files require no mixing\nsince they specify alloy interactions explicitly.\n\n\nNote\nNote that unlike for other potentials, cutoffs for EAM\npotentials are not set in the pair_style or pair_coeff command; they\nare specified in the EAM potential files themselves.  Likewise, the\nEAM potential files list atomic masses; thus you do not need to use\nthe mass command to specify them.\n\nThere are several WWW sites that distribute and document EAM\npotentials stored in DYNAMO or other formats:\nhttp://www.ctcms.nist.gov/potentials\nhttp://cst-www.nrl.navy.mil/ccm6/ap\nhttp://enpub.fulton.asu.edu/cms/potentials/main/main.htm\n\n\nThese potentials should be usable with LAMMPS, though the alternate\nformats would need to be converted to the DYNAMO format used by LAMMPS\nand described on this page.  The NIST site is maintained by Chandler\nBecker (cbecker at nist.gov) who is good resource for info on\ninteratomic potentials and file formats.\n\nFor style eam, potential values are read from a file that is in the\nDYNAMO single-element funcfl format.  If the DYNAMO file was created\nby a Fortran program, it cannot have “D” values in it for exponents.\nC only recognizes “e” or “E” for scientific notation.\nNote that unlike for other potentials, cutoffs for EAM potentials are\nnot set in the pair_style or pair_coeff command; they are specified in\nthe EAM potential files themselves.\nFor style eam a potential file must be assigned to each I,I pair of\natom types by using one or more pair_coeff commands, each with a\nsingle argument:\n\nfilename\n\nThus the following command\npair_coeff *2 1*2 cuu3.eam\n\n\nwill read the cuu3 potential file and use the tabulated Cu values for\nF, phi, rho that it contains for type pairs 1,1 and 2,2 (type pairs\n1,2 and 2,1 are ignored).  See the pair_coeff doc\npage for alternate ways to specify the path for the potential file.\nIn effect, this makes atom types 1 and 2 in LAMMPS be Cu atoms.\nDifferent single-element files can be assigned to different atom types\nto model an alloy system.  The mixing to create alloy potentials for\ntype pairs with I != J is done automatically the same way that the\nserial DYNAMO code originally did it; you do not need to specify\ncoefficients for these type pairs.\nFuncfl files in the potentials directory of the LAMMPS\ndistribution have an “.eam” suffix.  A DYNAMO single-element funcfl\nfile is formatted as follows:\n\nline 1: comment (ignored)\nline 2: atomic number, mass, lattice constant, lattice type (e.g. FCC)\nline 3: Nrho, drho, Nr, dr, cutoff\n\nOn line 2, all values but the mass are ignored by LAMMPS.  The mass is\nin mass units, e.g. mass number or grams/mole for metal\nunits.  The cubic lattice constant is in Angstroms.  On line 3, Nrho\nand Nr are the number of tabulated values in the subsequent arrays,\ndrho and dr are the spacing in density and distance space for the\nvalues in those arrays, and the specified cutoff becomes the pairwise\ncutoff used by LAMMPS for the potential.  The units of dr are\nAngstroms; I’m not sure of the units for drho - some measure of\nelectron density.\nFollowing the three header lines are three arrays of tabulated values:\n\nembedding function F(rho) (Nrho values)\neffective charge function Z(r) (Nr values)\ndensity function rho(r) (Nr values)\n\nThe values for each array can be listed as multiple values per line,\nso long as each array starts on a new line.  For example, the\nindividual Z(r) values are for r = 0,dr,2*dr, … (Nr-1)*dr.\nThe units for the embedding function F are eV.  The units for the\ndensity function rho are the same as for drho (see above, electron\ndensity).  The units for the effective charge Z are “atomic charge” or\nsqrt(Hartree * Bohr-radii).  For two interacting atoms i,j this is used\nby LAMMPS to compute the pair potential term in the EAM energy\nexpression as r*phi, in units of eV-Angstroms, via the formula\n\n\\[r \\cdot \\phi = 27.2 \\cdot 0.529 \\cdot Z_i \\cdot Z_j\\]\nwhere 1 Hartree = 27.2 eV and 1 Bohr = 0.529 Angstroms.\n\nStyle eam/alloy computes pairwise interactions using the same\nformula as style eam.  However the associated\npair_coeff command reads a DYNAMO setfl file\ninstead of a funcfl file.  Setfl files can be used to model a\nsingle-element or alloy system.  In the alloy case, as explained\nabove, setfl files contain explicit tabulated values for alloy\ninteractions.  Thus they allow more generality than funcfl files for\nmodeling alloys.\nFor style eam/alloy, potential values are read from a file that is\nin the DYNAMO multi-element setfl format, except that element names\n(Ni, Cu, etc) are added to one of the lines in the file.  If the\nDYNAMO file was created by a Fortran program, it cannot have “D”\nvalues in it for exponents.  C only recognizes “e” or “E” for\nscientific notation.\nOnly a single pair_coeff command is used with the eam/alloy style\nwhich specifies a DYNAMO setfl file, which contains information for\nM elements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of setfl elements to atom types\n\nAs an example, the potentials/NiAlH_jea.eam.alloy file is a setfl\nfile which has tabulated EAM values for 3 elements and their alloy\ninteractions: Ni, Al, and H.  See the pair_coeff doc\npage for alternate ways to specify the path for the potential file.\nIf your LAMMPS simulation has 4 atoms types and you want the 1st 3 to\nbe Ni, and the 4th to be Al, you would use the following pair_coeff\ncommand:\npair_coeff * * NiAlH_jea.eam.alloy Ni Ni Ni Al\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Ni arguments map LAMMPS atom types 1,2,3 to the Ni\nelement in the setfl file.  The final Al argument maps LAMMPS atom\ntype 4 to the Al element in the setfl file.  Note that there is no\nrequirement that your simulation use all the elements specified by the\nsetfl file.\nIf a mapping value is specified as NULL, the mapping is not performed.\nThis can be used when an eam/alloy potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\nSetfl files in the potentials directory of the LAMMPS distribution\nhave an “.eam.alloy” suffix.  A DYNAMO multi-element setfl file is\nformatted as follows:\n\nlines 1,2,3 = comments (ignored)\nline 4: Nelements Element1 Element2 … ElementN\nline 5: Nrho, drho, Nr, dr, cutoff\n\nIn a DYNAMO setfl file, line 4 only lists Nelements = the # of\nelements in the setfl file.  For LAMMPS, the element name (Ni, Cu,\netc) of each element must be added to the line, in the order the\nelements appear in the file.\nThe meaning and units of the values in line 5 is the same as for the\nfuncfl file described above.  Note that the cutoff (in Angstroms) is\na global value, valid for all pairwise interactions for all element\npairings.\nFollowing the 5 header lines are Nelements sections, one for each\nelement, each with the following format:\n\nline 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\nembedding function F(rho) (Nrho values)\ndensity function rho(r) (Nr values)\n\nAs with the funcfl files, only the mass (in mass units,\ne.g. mass number or grams/mole for metal units) is used by LAMMPS from\nthe 1st line.  The cubic lattice constant is in Angstroms.  The F and\nrho arrays are unique to a single element and have the same format and\nunits as in a funcfl file.\nFollowing the Nelements sections, Nr values for each pair potential\nphi(r) array are listed for all i,j element pairs in the same format\nas other arrays.  Since these interactions are symmetric (i,j = j,i)\nonly phi arrays with i >= j are listed, in the following order: i,j =\n(1,1), (2,1), (2,2), (3,1), (3,2), (3,3), (4,1), …, (Nelements,\nNelements).  Unlike the effective charge array Z(r) in funcfl files,\nthe tabulated values for each phi function are listed in setfl files\ndirectly as r*phi (in units of eV-Angstroms), since they are for atom\npairs.\n\nStyle eam/cd is similar to the eam/alloy style, except that it\ncomputes alloy pairwise interactions using the concentration-dependent\nembedded-atom method (CD-EAM).  This model can reproduce the enthalpy\nof mixing of alloys over the full composition range, as described in\n(Stukowski). Style eam/cd/old is an older, slightly\ndifferent and slower two-site formulation of the model (Caro).\nThe pair_coeff command is specified the same as for the eam/alloy\nstyle.  However the DYNAMO setfl file must has two\nlines added to it, at the end of the file:\n\nline 1: Comment line (ignored)\nline 2: N Coefficient0 Coefficient1 … CoefficientN\n\nThe last line begins with the degree N of the polynomial function\nh(x) that modifies the cross interaction between A and B elements.\nThen N+1 coefficients for the terms of the polynomial are then\nlisted.\nModified EAM setfl files used with the eam/cd style must contain\nexactly two elements, i.e. in the current implementation the eam/cd\nstyle only supports binary alloys.  The first and second elements in\nthe input EAM file are always taken as the A and B species.\nCD-EAM files in the potentials directory of the LAMMPS\ndistribution have a “.cdeam” suffix.\n\nStyle eam/fs computes pairwise interactions for metals and metal\nalloys using a generalized form of EAM potentials due to Finnis and\nSinclair (Finnis).  The total energy Ei of an atom I is\ngiven by\n\n\\[E_i = F_\\alpha \\left(\\sum_{j \\neq i}\\\n\\rho_{\\alpha\\beta} (r_{ij})\\right) +\n\\frac{1}{2} \\sum_{j \\neq i} \\phi_{\\alpha\\beta} (r_{ij})\\]\nThis has the same form as the EAM formula above, except that rho is\nnow a functional specific to the atomic types of both atoms I and J,\nso that different elements can contribute differently to the total\nelectron density at an atomic site depending on the identity of the\nelement at that atomic site.\nThe associated pair_coeff command for style eam/fs\nreads a DYNAMO setfl file that has been extended to include\nadditional rho_alpha_beta arrays of tabulated values.  A discussion of\nhow FS EAM differs from conventional EAM alloy potentials is given in\n(Ackland1).  An example of such a potential is the same\nauthor’s Fe-P FS potential (Ackland2).  Note that while FS\npotentials always specify the embedding energy with a square root\ndependence on the total density, the implementation in LAMMPS does not\nrequire that; the user can tabulate any functional form desired in the\nFS potential files.\nFor style eam/fs, the form of the pair_coeff command is exactly the\nsame as for style eam/alloy, e.g.\npair_coeff * * NiAlH_jea.eam.fs Ni Ni Ni Al\n\n\nwhere there are N additional arguments after the filename, where N is\nthe number of LAMMPS atom types.  See the pair_coeff\ndoc page for alternate ways to specify the path for the potential\nfile.  The N values determine the mapping of LAMMPS atom types to EAM\nelements in the file, as described above for style eam/alloy.  As\nwith eam/alloy, if a mapping value is NULL, the mapping is not\nperformed.  This can be used when an eam/fs potential is used as\npart of the hybrid pair style.  The NULL values are used as\nplaceholders for atom types that will be used with other potentials.\nFS EAM files include more information than the DYNAMO setfl format\nfiles read by eam/alloy, in that i,j density functionals for all\npairs of elements are included as needed by the Finnis/Sinclair\nformulation of the EAM.\nFS EAM files in the potentials directory of the LAMMPS distribution\nhave an “.eam.fs” suffix.  They are formatted as follows:\n\nlines 1,2,3 = comments (ignored)\nline 4: Nelements Element1 Element2 … ElementN\nline 5: Nrho, drho, Nr, dr, cutoff\n\nThe 5-line header section is identical to an EAM setfl file.\nFollowing the header are Nelements sections, one for each element I,\neach with the following format:\n\nline 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\nembedding function F(rho) (Nrho values)\ndensity function rho(r) for element I at element 1 (Nr values)\ndensity function rho(r) for element I at element 2\n…\ndensity function rho(r) for element I at element Nelement\n\nThe units of these quantities in line 1 are the same as for setfl\nfiles.  Note that the rho(r) arrays in Finnis/Sinclair can be\nasymmetric (i,j != j,i) so there are Nelements^2 of them listed in the\nfile.\nFollowing the Nelements sections, Nr values for each pair potential\nphi(r) array are listed in the same manner (r*phi, units of\neV-Angstroms) as in EAM setfl files.  Note that in Finnis/Sinclair,\nthe phi(r) arrays are still symmetric, so only phi arrays for i >= j\nare listed.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above with the individual styles.  You never need to specify\na pair_coeff command with I != J arguments for the eam styles.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThe eam pair styles do not write their information to binary restart files, since it is stored in tabulated potential files.\nThus, you need to re-specify the pair_style and pair_coeff commands in\nan input script that reads a restart file.\nThe eam pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style",
    "parameters": " * style = eam or eam/alloy or eam/cd or eam/cd/old or eam/fs",
    "examples": "pair_style eam\npair_coeff * * cuu3\npair_coeff 1*3 1\\*3 niu3.eam\n\npair_style eam/alloy\npair_coeff * * ../potentials/NiAlH_jea.eam.alloy Ni Al Ni Ni\n\npair_style eam/cd\npair_coeff * * ../potentials/FeCr.cdeam Fe Cr\n\npair_style eam/fs\npair_coeff * * NiAlH_jea.eam.fs Ni Al Ni Ni",
    "restrictions": "All of these styles are part of the MANYBODY package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style edip",
    "html_filename": "pair_edip.html",
    "short_description": "The edip and edip/multi styles compute a 3-body EDIP potential which is popular for modeling silicon materials where it can have advantages over other models such as the Stillinger-Weber or Tersoff potentials",
    "description": "The edip and edip/multi styles compute a 3-body EDIP\npotential which is popular for modeling silicon materials where\nit can have advantages over other models such as the\nStillinger-Weber or Tersoff\npotentials. The edip style has been programmed for single element\npotentials, while edip/multi supports multi-element EDIP runs.\nIn EDIP, the energy E of a system of atoms is\n\n\\[\\begin{split}E  = & \\sum_{j \\ne i} \\phi_{2}(R_{ij}, Z_{i}) + \\sum_{j \\ne i} \\sum_{k \\ne i,k > j} \\phi_{3}(R_{ij}, R_{ik}, Z_{i}) \\\\\n\\phi_{2}(r, Z)  = & A\\left[\\left(\\frac{B}{r}\\right)^{\\rho} - e^{-\\beta Z^2}\\right]exp{\\left(\\frac{\\sigma}{r-a}\\right)} \\\\\n\\phi_{3}(R_{ij}, R_{ik}, Z_i)  = & exp{\\left(\\frac{\\gamma}{R_{ij}-a}\\right)}exp{\\left(\\frac{\\gamma}{R_{ik}-a}\\right)}h(cos\\theta_{ijk},Z_i) \\\\\nZ_i  = & \\sum_{m \\ne i} f(R_{im}) \\qquad\nf(r) = \\begin{cases}\n       1 & \\quad r<c \\\\\n       \\exp\\left(\\frac{\\alpha}{1-x^{-3}}\\right) & \\quad c<r<a \\\\\n       0 & \\quad r>a\n       \\end{cases} \\\\\nh(l,Z)  = & \\lambda [(1-e^{-Q(Z)(l+\\tau(Z))^2}) + \\eta Q(Z)(l+\\tau(Z))^2 ] \\\\\nQ(Z)  = & Q_0 e^{-\\mu Z} \\qquad \\tau(Z) = u_1 + u_2 (u_3 e^{-u_4 Z} - e^{-2u_4 Z})\\end{split}\\]\nwhere \\(\\phi_2\\) is a two-body term and \\(\\phi_3\\) is a\nthree-body term.  The summations in the formula are over all neighbors J\nand K of atom I within a cutoff distance = a.  Both terms depend on the\nlocal environment of atom I through its effective coordination number\ndefined by Z, which is unity for a cutoff distance < c and gently goes\nto 0 at distance = a.\nOnly a single pair_coeff command is used with the edip style which\nspecifies a EDIP potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of EDIP elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine a file Si.edip has EDIP values for Si.\nEDIP files in the potentials directory of the LAMMPS\ndistribution have a “.edip” suffix.  Lines that are not blank or\ncomments (starting with #) define parameters for a triplet of\nelements.  The parameters in a single entry correspond to the two-body\nand three-body coefficients in the formula above:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2\nelement 3\nA (energy units)\nB (distance units)\ncutoffA (distance units)\ncutoffC (distance units)\n\\(\\alpha\\)\n\\(\\beta\\)\n\\(\\eta\\)\n\\(\\gamma\\) (distance units)\n\\(lambda\\) (energy units)\n\\(\\mu\\)\n\\(\\tau\\)\n\\(\\sigma\\) (distance units)\nQ0\nu1\nu2\nu3\nu4\n\nThe A, B, beta, sigma parameters are used only for two-body interactions.\nThe eta, gamma, lambda, mu, Q0 and all u1 to u4 parameters are used only\nfor three-body interactions. The alpha and cutoffC parameters are used\nfor the coordination environment function only.\nThe EDIP potential file must contain entries for all the\nelements listed in the pair_coeff command.  It can also contain\nentries for additional elements not being used in a particular\nsimulation; LAMMPS ignores those entries.\nFor a single-element simulation, only a single entry is required\n(e.g. SiSiSi).  For a two-element simulation, the file must contain 8\nentries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\nspecify EDIP parameters for all permutations of the two elements\ninteracting in three-body configurations.  Thus for 3 elements, 27\nentries would be required, etc.\nAt the moment, only a single element parameterization is\nimplemented. However, the author is not aware of other\nmulti-element EDIP parameterization. If you know any and\nyou are interest in that, please contact the author of\nthe EDIP package.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style",
    "parameters": " * style = edip or edip/multi",
    "examples": "pair_style edip\npair_coeff * * Si.edip Si",
    "restrictions": "This pair style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe EDIP potential files provided with LAMMPS (see the potentials directory)\nare parameterized for metal units.\nYou can use the EDIP potential with any LAMMPS units, but you would need\nto create your own EDIP potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style eff/cut",
    "html_filename": "pair_eff.html",
    "short_description": "This pair style contains a LAMMPS implementation of the electron Force Field (eFF) potential currently under development at Caltech, as described in (Jaramillo-Botero)",
    "description": "This pair style contains a LAMMPS implementation of the electron Force\nField (eFF) potential currently under development at Caltech, as\ndescribed in (Jaramillo-Botero).  The eFF for Z<6\nwas first introduced by (Su) in 2007. It has been extended to\nhigher Zs by using effective core potentials (ECPs) that now cover up\nto 2nd and 3rd row p-block elements of the periodic table.\neFF can be viewed as an approximation to QM wave packet dynamics and\nFermionic molecular dynamics, combining the ability of electronic\nstructure methods to describe atomic structure, bonding, and chemistry\nin materials, and of plasma methods to describe nonequilibrium\ndynamics of large systems with a large number of highly excited\nelectrons.  Yet, eFF relies on a simplification of the electronic\nwave function in which electrons are described as floating Gaussian\nwave packets whose position and size respond to the various dynamic\nforces between interacting classical nuclear particles and spherical\nGaussian electron wave packets.  The wave function is taken to be a\nHartree product of the wave packets.  To compensate for the lack of\nexplicit antisymmetry in the resulting wave function, a spin-dependent\nPauli potential is included in the Hamiltonian.  Substituting this\nwave function into the time-dependent Schrodinger equation produces\nequations of motion that correspond - to second order - to classical\nHamiltonian relations between electron position and size, and their\nconjugate momenta.  The N-electron wave function is described as a\nproduct of one-electron Gaussian functions, whose size is a dynamical\nvariable and whose position is not constrained to a nuclear\ncenter. This form allows for straightforward propagation of the\nwave function, with time, using a simple formulation from which the\nequations of motion are then integrated with conventional MD\nalgorithms. In addition to this spin-dependent Pauli repulsion\npotential term between Gaussians, eFF includes the electron kinetic\nenergy from the Gaussians.  These two terms are based on\nfirst-principles quantum mechanics.  On the other hand, nuclei are\ndescribed as point charges, which interact with other nuclei and\nelectrons through standard electrostatic potential forms.\nThe full Hamiltonian (shown below), contains then a standard\ndescription for electrostatic interactions between a set of\ndelocalized point and Gaussian charges which include, nuclei-nuclei\n(NN), electron-electron (ee), and nuclei-electron (Ne). Thus, eFF is a\nmixed QM-classical mechanics method rather than a conventional force\nfield method (in which electron motions are averaged out into ground\nstate nuclear motions, i.e a single electronic state, and particle\ninteractions are described via empirically parameterized interatomic\npotential functions). This makes eFF uniquely suited to simulate\nmaterials over a wide range of temperatures and pressures where\nelectronically excited and ionized states of matter can occur and\ncoexist.  Furthermore, the interactions between particles -nuclei and\nelectrons- reduce to the sum of a set of effective pairwise potentials\nin the eFF formulation.  The eff/cut style computes the pairwise\nCoulomb interactions between nuclei and electrons (E_NN,E_Ne,E_ee),\nand the quantum-derived Pauli (E_PR) and Kinetic energy interactions\npotentials between electrons (E_KE) for a total energy expression\ngiven as,\n\n\\[U\\left(R,r,s\\right) =  E_{NN} \\left( R \\right) + E_{Ne} \\left( {R,r,s} \\right) + E_{ee} \\left( {r,s} \\right) + E_{KE} \\left( {r,s} \\right) + E_{PR} \\left( { \\uparrow  \\downarrow ,S} \\right)\\]\nThe individual terms are defined as follows:\n\n\\[\\begin{split}E_{KE}  = & \\frac{\\hbar^2 }{{m_{e} }}\\sum\\limits_i {\\frac{3}{{2s_i^2 }}} \\\\\nE_{NN}  = & \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i < j} {\\frac{{Z_i Z_j }}{{R_{ij} }}} \\\\\nE_{Ne}  = & - \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i,j} {\\frac{{Z_i }}{{R_{ij} }}Erf\\left( {\\frac{{\\sqrt 2 R_{ij} }}{{s_j }}} \\right)} \\\\\nE_{ee}  = & \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i < j} {\\frac{1}{{r_{ij} }}Erf\\left( {\\frac{{\\sqrt 2 r_{ij} }}{{\\sqrt {s_i^2  + s_j^2 } }}} \\right)} \\\\\nE_{Pauli}  = & \\sum\\limits_{\\sigma _i  = \\sigma _j } {E\\left( { \\uparrow  \\uparrow } \\right)_{ij}}  + \\sum\\limits_{\\sigma _i  \\ne \\sigma _j } {E\\left( { \\uparrow  \\downarrow } \\right)_{ij}} \\\\\\end{split}\\]\nwhere, s_i correspond to the electron sizes, the sigmas i’s to the\nfixed spins of the electrons, Z_i to the charges on the nuclei, R_ij\nto the distances between the nuclei or the nuclei and electrons, and\nr_ij to the distances between electrons.  For additional details see\n(Jaramillo-Botero).\nThe overall electrostatics energy is given in Hartree units of energy\nby default and can be modified by an energy-conversion constant,\naccording to the units chosen (see electron_units).  The\ncutoff Rc, given in Bohrs (by default), truncates the interaction\ndistance.  The recommended cutoff for this pair style should follow\nthe minimum image criterion, i.e. half of the minimum unit cell\nlength.\nStyle eff/long (not yet available) computes the same interactions as\nstyle eff/cut except that an additional damping factor is applied so\nit can be used in conjunction with the\nkspace_style command and its ewald or pppm\noption.  The Coulombic cutoff specified for this style means that\npairwise interactions within this distance are computed directly;\ninteractions outside that distance are computed in reciprocal space.\nThis potential is designed to be used with atom_style electron definitions, in order to handle the\ndescription of systems with interacting nuclei and explicit electrons.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutoff (distance units)\n\nFor eff/cut, the cutoff coefficient is optional.  If it is not used\n(as in some of the examples above), the default global value specified\nin the pair_style command is used.\nFor eff/long (not yet available) no cutoff will be specified for an\nindividual I,J type pair via the pair_coeff command.\nAll type pairs use the same global cutoff specified in the pair_style\ncommand.\n\nThe limit/eradius and pressure/evirials keywords are optional.\nNeither or both must be specified.  If not specified they are unset.\nThe limit/eradius keyword is used to restrain electron size from\nbecoming excessively diffuse at very high temperatures were the\nGaussian wave packet representation breaks down, and from expanding as\nfree particles to infinite size.  If unset, electron radius is free to\nincrease without bounds.  If set, a restraining harmonic potential of\nthe form E = 1/2k_ss^2 for s > L_box/2, where k_s = 1 Hartrees/Bohr^2,\nis applied on the electron radius.\nThe pressure/evirials keyword is used to control between two types\nof pressure computation: if unset, the computed pressure does not\ninclude the electronic radial virials contributions to the total\npressure (scalar or tensor).  If set, the computed pressure will\ninclude the electronic radial virial contributions to the total\npressure (scalar and tensor).\nThe ecp keyword is used to associate an ECP representation for a\nparticular atom type.  The ECP captures the orbital overlap between a\ncore pseudo particle and valence electrons within the Pauli repulsion.\nA list of type:element-symbol pairs may be provided for all ECP\nrepresentations, after the “ecp” keyword.\n\nNote\nDefault ECP parameters are provided for C, N, O, Al, and Si.\nUsers can modify these using the pair_coeff command as exemplified\nabove.  For this, the User must distinguish between two different\nfunctional forms supported, one that captures the orbital overlap\nassuming the s-type core interacts with an s-like valence electron\n(s-s) and another that assumes the interaction is s-p.  For systems\nthat exhibit significant p-character (e.g. C, N, O) the s-p form is\nrecommended. The “s” ECP form requires 3 parameters and the “p” 5\nparameters.\n\n\nNote\nthere are two different pressures that can be reported for eFF\nwhen defining this pair_style, one (default) that considers electrons\ndo not contribute radial virial components (i.e. electrons treated as\nincompressible ‘rigid’ spheres) and one that does.  The radial\nelectronic contributions to the virials are only tallied if the\nflexible pressure option is set, and this will affect both global and\nper-atom quantities.  In principle, the true pressure of a system is\nsomewhere in between the rigid and the flexible eFF pressures, but,\nfor most cases, the difference between these two pressures will not be\nsignificant over long-term averaged runs (i.e. even though the energy\npartitioning changes, the total energy remains similar).\n\n\n\nNote\nThis implementation of eFF gives a reasonably accurate description\nfor systems containing nuclei from Z = 1-6 in “all electron”\nrepresentations.  For systems with increasingly non-spherical\nelectrons, Users should use the ECP representations.  ECPs are now\nsupported and validated for most of the 2nd and 3rd row elements of\nthe p-block.  Predefined parameters are provided for C, N, O, Al, and\nSi.  The ECP captures the orbital overlap between the core and valence\nelectrons (i.e. Pauli repulsion) with one of the functional forms:\n\n\n\\[\\begin{split}E_{Pauli(ECP_s)} = & p_1\\exp\\left(-\\frac{p_2r^2}{p_3+s^2} \\right) \\\\\nE_{Pauli(ECP_p)} = & p_1\\left( \\frac{2}{p_2/s+s/p_2} \\right)\\left( r-p_3s\\right)^2\\exp \\left[ -\\frac{p_4\\left( r-p_3s \\right)^2}{p_5+s^2} \\right]\\end{split}\\]\nWhere the 1st form correspond to core interactions with s-type valence\nelectrons and the 2nd to core interactions with p-type valence\nelectrons.\nThe current version adds full support for models with fixed-core and\nECP definitions.  to enable larger timesteps (i.e. by avoiding the\nhigh frequency vibrational modes -translational and radial- of the 2 s\nelectrons), and in the ECP case to reduce the increased orbital\ncomplexity in higher Z elements (up to Z<18).  A fixed-core should be\ndefined with a mass that includes the corresponding nuclear mass plus\nthe 2 s electrons in atomic mass units (2x5.4857990943e-4), and a\nradius equivalent to that of minimized 1s electrons (see examples\nunder /examples/USER/eff/fixed-core).  An pseudo-core should be\ndescribed with a mass that includes the corresponding nuclear mass,\nplus all the core electrons (i.e no outer shell electrons), and a\nradius equivalent to that of a corresponding minimized full-electron\nsystem.  The charge for a pseudo-core atom should be given by the\nnumber of outer shell electrons.\nIn general, eFF excels at computing the properties of materials in\nextreme conditions and tracing the system dynamics over multi-picosecond\ntimescales; this is particularly relevant where electron excitations\ncan change significantly the nature of bonding in the system. It can\ncapture with surprising accuracy the behavior of such systems because\nit describes consistently and in an unbiased manner many different\nkinds of bonds, including covalent, ionic, multicenter, ionic, and\nplasma, and how they interconvert and/or change when they become\nexcited.  eFF also excels in computing the relative thermochemistry of\nisodemic reactions and conformational changes, where the bonds of the\nreactants are of the same type as the bonds of the products.  eFF\nassumes that kinetic energy differences dominate the overall exchange\nenergy, which is true when the electrons present are nearly spherical\nand nodeless and valid for covalent compounds such as dense hydrogen,\nhydrocarbons, and diamond; alkali metals (e.g. lithium), alkali earth\nmetals (e.g. beryllium) and semimetals such as boron; and various\ncompounds containing ionic and/or multicenter bonds, such as boron\ndihydride.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the cutoff distance for the\neff/cut style can be mixed.  The default mix value is geometric.\nSee the “pair_modify” command for details.\nThe pair_modify shift option is not relevant for\nthese pair styles.\nThe eff/long (not yet available) style supports the\npair_modify table option for tabulation of the\nshort-range portion of the long-range Coulombic interaction.\nThese pair styles do not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThese pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style eff/cut cutoff keyword args ...",
    "parameters": " * cutoff = global cutoff for Coulombic interactions\n * zero or more keyword/value pairs may be appended\n * keyword = limit/eradius or pressure/evirials or ecp\n *   limit/eradius args = none\n *   pressure/evirials args = none\n *   ecp args = type element type element ...\n *     type = LAMMPS atom type (1 to Ntypes)\n *     element = element symbol (e.g. H, Si)",
    "examples": "pair_style eff/cut 39.7\npair_style eff/cut 40.0 limit/eradius\npair_style eff/cut 40.0 limit/eradius pressure/evirials\npair_style eff/cut 40.0 ecp 1 Si 3 C\npair_coeff * *\npair_coeff 2 2 20.0\npair_coeff 1 s 0.320852 2.283269 0.814857\npair_coeff 3 p 22.721015 0.728733 1.103199 17.695345 6.693621",
    "restrictions": "These pair styles will only be enabled if LAMMPS is built with the\nUSER-EFF package.  It will only be enabled if LAMMPS was built with\nthat package.  See the Build package doc page for\nmore info.\nThese pair styles require that particles store electron attributes\nsuch as radius, radial velocity, and radial force, as defined by the\natom_style.  The electron atom style does all of\nthis.\nThes pair styles require you to use the comm_modify vel yes command so that velocities are stored by ghost\natoms."
},
{
    "command": "pair_style eim",
    "html_filename": "pair_eim.html",
    "short_description": "Style eim computes pairwise interactions for ionic compounds using embedded-ion method (EIM) potentials (Zhou)",
    "description": "Style eim computes pairwise interactions for ionic compounds\nusing embedded-ion method (EIM) potentials (Zhou).  The\nenergy of the system E is given by\n\n\\[E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\phi_{ij} \\left(r_{ij}\\right) + \\sum_{i=1}^{N}E_i\\left(q_i,\\sigma_i\\right)\\]\nThe first term is a double pairwise sum over the J neighbors of all I\natoms, where \\(\\phi_{ij}\\) is a pair potential.  The second term sums over\nthe embedding energy E_i of atom I, which is a function of its charge\nq_i and the electrical potential \\(\\sigma_i\\) at its location.  E_i, q_i,\nand \\(sigma_i\\) are calculated as\n\n\\[\\begin{split}q_i  = & \\sum_{j=i_1}^{i_N} \\eta_{ji}\\left(r_{ij}\\right) \\\\\n\\sigma_i  = & \\sum_{j=i_1}^{i_N} q_j \\cdot \\psi_{ij} \\left(r_{ij}\\right) \\\\\nE_i\\left(q_i,\\sigma_i\\right)  = & \\frac{1}{2} \\cdot q_i \\cdot \\sigma_i\\end{split}\\]\nwhere \\(\\eta_{ji} is a pairwise function describing electron flow from atom\nI to atom J, and :math:\\)psi_{ij}` is another pairwise function.  The multi-body\nnature of the EIM potential is a result of the embedding energy term.\nA complete list of all the pair functions used in EIM is summarized\nbelow\n\n\\[\\begin{split}\\phi_{ij}\\left(r\\right) = & \\left\\{ \\begin{array}{lr}\n\\left[\\frac{E_{b,ij}\\beta_{ij}}{\\beta_{ij}-\\alpha_{ij}}\\exp\\left(-\\alpha_{ij} \\frac{r-r_{e,ij}}{r_{e,ij}}\\right)-\\frac{E_{b,ij}\\alpha_{ij}}{\\beta_{ij}-\\alpha_{ij}}\\exp\\left(-\\beta_{ij} \\frac{r-r_{e,ij}}{r_{e,ij}}\\right)\\right]f_c\\left(r,r_{e,ij},r_{c,\\phi,ij}\\right),& p_{ij}=1 \\\\\n\\left[\\frac{E_{b,ij}\\beta_{ij}}{\\beta_{ij}-\\alpha_{ij}} \\left(\\frac{r_{e,ij}}{r}\\right)^{\\alpha_{ij}}  -\\frac{E_{b,ij}\\alpha_{ij}}{\\beta_{ij}-\\alpha_{ij}} \\left(\\frac{r_{e,ij}}{r}\\right)^{\\beta_{ij}}\\right]f_c\\left(r,r_{e,ij},r_{c,\\phi,ij}\\right),& p_{ij}=2\n\\end{array}\n\\right.\\\\\n\\eta_{ji} = & A_{\\eta,ij}\\left(\\chi_j-\\chi_i\\right)f_c\\left(r,r_{s,\\eta,ij},r_{c,\\eta,ij}\\right) \\\\\n\\psi_{ij}\\left(r\\right) = & A_{\\psi,ij}\\exp\\left(-\\zeta_{ij}r\\right)f_c\\left(r,r_{s,\\psi,ij},r_{c,\\psi,ij}\\right) \\\\\nf_{c}\\left(r,r_p,r_c\\right) = & 0.510204 \\mathrm{erfc}\\left[\\frac{1.64498\\left(2r-r_p-r_c\\right)}{r_c-r_p}\\right] - 0.010204\\end{split}\\]\nHere \\(E_b, r_e, r_(c,\\phi), \\alpha, \\beta, A_(\\psi), \\zeta, r_(s,\\psi),\nr_(c,\\psi), A_(\\eta), r_(s,\\eta), r_(c,\\eta), \\chi,\\) and pair function type\np are parameters, with subscripts ij indicating the two species of\natoms in the atomic pair.\n\nNote\nEven though the EIM potential is treating atoms as charged ions,\nyou should not use a LAMMPS atom_style that stores a\ncharge on each atom and thus requires you to assign a charge to each\natom, e.g. the charge or full atom styles.  This is because the\nEIM potential infers the charge on an atom from the equation above for\nq_i; you do not assign charges explicitly.\n\n\nAll the EIM parameters are listed in a potential file which is\nspecified by the pair_coeff command.  This is an\nASCII text file in a format described below.  The “ffield.eim” file\nincluded in the “potentials” directory of the LAMMPS distribution\ncurrently includes nine elements Li, Na, K, Rb, Cs, F, Cl, Br, and I.\nA system with any combination of these elements can be modeled.  This\nfile is parameterized in terms of LAMMPS metal units.\nNote that unlike other potentials, cutoffs for EIM potentials are not\nset in the pair_style or pair_coeff command; they are specified in the\nEIM potential file itself.  Likewise, the EIM potential file lists\natomic masses; thus you do not need to use the mass\ncommand to specify them.\nOnly a single pair_coeff command is used with the eim style which\nspecifies an EIM potential file and the element(s) to extract\ninformation for.  The EIM elements are mapped to LAMMPS atom types by\nspecifying N additional arguments after the filename in the pair_coeff\ncommand, where N is the number of LAMMPS atom types:\n\nElem1, Elem2, …\nEIM potential file\nN element names = mapping of EIM elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example like one of those above, suppose you want to model a\nsystem with Na and Cl atoms.  If your LAMMPS simulation has 4 atoms\ntypes and you want the 1st 3 to be Na, and the 4th to be Cl, you would\nuse the following pair_coeff command:\npair_coeff * * Na Cl ffield.eim Na Na Na Cl\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe filename is the EIM potential file.  The Na and Cl arguments\n(before the file name) are the two elements for which info will be\nextracted from the potential file.  The first three trailing Na\narguments map LAMMPS atom types 1,2,3 to the EIM Na element.  The\nfinal Cl argument maps LAMMPS atom type 4 to the EIM Cl element.\nIf a mapping value is specified as NULL, the mapping is not performed.\nThis can be used when an eim potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\nThe ffield.eim file in the potentials directory of the LAMMPS\ndistribution is formatted as follows:\nLines starting with # are comments and are ignored by LAMMPS.  Lines\nstarting with “global:” include three global values. The first value\ndivides the cations from anions, i.e., any elements with\nelectronegativity above this value are viewed as anions, and any\nelements with electronegativity below this value are viewed as\ncations. The second and third values are related to the cutoff\nfunction - i.e. the 0.510204, 1.64498, and 0.010204 shown in the above\nequation can be derived from these values.\nLines starting with “element:” are formatted as follows: name of\nelement, atomic number, atomic mass, electronic negativity, atomic\nradius (LAMMPS ignores it), ionic radius (LAMMPS ignores it), cohesive\nenergy (LAMMPS ignores it), and q0 (must be 0).\nLines starting with “pair:” are entered as: element 1, element 2,\nr_(c,phi), r_(c,phi) (redundant for historical reasons), E_b, r_e,\nalpha, beta, r_(c,eta), A_(eta), r_(s,eta), r_(c,psi), A_(psi), zeta,\nr_(s,psi), and p.\nThe lines in the file can be in any order; LAMMPS extracts the info it\nneeds.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style style",
    "parameters": " * style = eim",
    "examples": "pair_style eim\npair_coeff * * Na Cl ../potentials/ffield.eim Na Cl\npair_coeff * * Na Cl ffield.eim  Na Na Na Cl\npair_coeff * * Na Cl ../potentials/ffield.eim Cl NULL Na",
    "restrictions": "This style is part of the MANYBODY package.  It is only enabled if\nLAMMPS was built with that package."
},
{
    "command": "pair_style exp6/rx",
    "html_filename": "pair_exp6_rx.html",
    "short_description": "Style exp6/rx is used in reaction DPD simulations, where the coarse-grained (CG) particles are composed of m species whose reaction rate kinetics are determined from a set of n reaction rate equations through the fix rx command",
    "description": "Style exp6/rx is used in reaction DPD simulations, where the\ncoarse-grained (CG) particles are composed of m species whose\nreaction rate kinetics are determined from a set of n reaction rate\nequations through the fix rx command.  The species of\none CG particle can interact with a species in a neighboring CG\nparticle through a site-site interaction potential model.  The\nexp6/rx style computes an exponential-6 potential given by\n\n\\[U_{ij}(r) = \\frac{\\epsilon}{\\alpha-6}\\{6\\exp[\\alpha(1-\\frac{r_{ij}}{R_{m}})]-\\alpha(\\frac{R_{m}}{r_{ij}})^6\\}\\]\nwhere the \\(\\epsilon\\) parameter determines the depth of the\npotential minimum located at \\(R_m\\), and \\(\\alpha\\) determines\nthe softness of the repulsion.\nThe coefficients must be defined for each species in a given particle\ntype via the pair_coeff command as in the examples\nabove, where the first argument is the filename that includes the\nexponential-6 parameters for each species.  The file includes the\nspecies tag followed by the \\(\\alpha, \\epsilon\\) and \\(R_m\\)\nparameters. The format of the file is described below.\nThe second and third arguments specify the site-site interaction\npotential between two species contained within two different\nparticles.  The species tags must either correspond to the species\ndefined in the reaction kinetics files specified with the fix rx command or they must correspond to the tag “1fluid”,\nsignifying interaction with a product species mixture determined\nthrough a one-fluid approximation.  The interaction potential is\nweighted by the geometric average of either the mole fraction concentrations\nor the number of molecules associated with the interacting coarse-grained\nparticles (see the fractional or molecular weighting pair style options).\nThe coarse-grained potential is stored before and after the\nreaction kinetics solver is applied, where the difference is defined\nto be the internal chemical energy (uChem).\nThe fourth argument specifies the type of scaling that will be used\nto scale the EXP-6 parameters as reactions occur.  Currently, there\nare three scaling options:  exponent, polynomial and none.\nExponent scaling requires two additional arguments for scaling\nthe \\(R_m\\) and \\(\\epsilon\\) parameters, respectively.  The scaling factor\nis computed by phi^exponent, where phi is the number of molecules\nrepresented by the coarse-grain particle and exponent is specified\nas a pair coefficient argument for \\(R_m\\) and \\(\\epsilon\\), respectively.\nThe \\(R_m\\) and \\(\\epsilon\\) parameters are multiplied by the scaling\nfactor to give the scaled interaction parameters for the CG particle.\nPolynomial scaling requires a filename to be specified as a pair\ncoeff argument.  The file contains the coefficients to a fifth order\npolynomial for the \\(\\alpha\\), \\(\\epsilon\\) and \\(R_m\\) parameters that depend\nupon phi (the number of molecules represented by the CG particle).\nThe format of a polynomial file is provided below.\nThe none option to the scaling does not have any additional pair coeff\narguments.  This is equivalent to specifying the exponent option with\n\\(R_m\\) and \\(\\epsilon\\) exponents of 0.0 and 0.0, respectively.\nThe final argument specifies the interaction cutoff (optional).\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# exponential-6 parameters for various species      (one or more comment or blank lines)\n\nh2o  exp6  11.00 0.02 3.50                          (species, exp6, alpha, Rm, epsilon)\nno2  exp6  13.60 0.01 3.70\n...\nco2  exp6  13.00 0.03 3.20\n\n\nThe format of the polynomial scaling file as follows (without the\nparenthesized comments):\n# POLYNOMIAL FILE          (one or more comment or blank lines)\n\n#  General Functional Form:\n#  A*phi^5 + B*phi^4 + C*phi^3 + D*phi^2 + E*phi + F\n#\n#  Parameter  A        B         C        D         E        F\n                           (blank)\nalpha        0.0000   0.00000   0.00008  0.04955  -0.73804  13.63201\nepsilon      0.0000   0.00478  -0.06283  0.24486  -0.33737   2.60097\nrm           0.0001  -0.00118  -0.00253  0.05812  -0.00509   1.50106\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.\nFollowing a blank line, the next N lines list the species and their\ncorresponding parameters.  The first argument is the species tag, the\nsecond argument is the exp6 tag, the 3rd argument is the \\(\\alpha\\)\nparameter (energy units), the 4th argument is the \\(\\epsilon\\) parameter\n(energy-distance^6 units), and the 5th argument is the \\(R_m\\) parameter\n(distance units).  If a species tag of “1fluid” is listed as a pair\ncoefficient, a one-fluid approximation is specified where a\nconcentration-dependent combination of the parameters is computed\nthrough the following equations:\n\n\\[\\begin{split}R_{m}^{3} = & \\sum_{a}\\sum_{b} x_{a}x_{b}R_{m,ab}^{3} \\\\\n\\epsilon  = & \\frac{1}{R_{m}^{3}}\\sum_{a}\\sum_{b} x_{a}x_{b}\\epsilon_{ab}R_{m,ab}^{3} \\\\\n\\alpha    = & \\frac{1}{\\epsilon R_{m}^{3}}\\sum_{a}\\sum_{b} x_{a}x_{b}\\alpha_{ab}\\epsilon_{ab}R_{m,ab}^{3}\\end{split}\\]\nwhere\n\n\\[\\begin{split}\\epsilon_{ab} = & \\sqrt{\\epsilon_{a}\\epsilon_{b}} \\\\\nR_{m,ab}      = & \\frac{R_{m,a}+R_{m,b}}{2} \\\\\n\\alpha_{ab}   = & \\sqrt{\\alpha_{a}\\alpha_{b}}\\end{split}\\]\nand \\(x_a\\) and \\(x_b\\) are the mole fractions of a and b, respectively, which\ncomprise the gas mixture.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify shift option\nfor the energy of the exp() and 1/r^6 portion of the pair interaction.\nThis style does not support the pair_modify tail option for adding long-range\ntail corrections to energy and pressure for the A,C terms in the\npair interaction.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style exp6/rx cutoff ...",
    "parameters": " * cutoff = global cutoff for DPD interactions (distance units)\n * weighting = fractional or molecular (optional)",
    "examples": "pair_style exp6/rx 10.0\npair_style exp6/rx 10.0 fractional\npair_style exp6/rx 10.0 molecular\npair_coeff * * exp6.params h2o h2o exponent 1.0 1.0 10.0\npair_coeff * * exp6.params h2o 1fluid exponent 1.0 1.0 10.0\npair_coeff * * exp6.params 1fluid 1fluid exponent 1.0 1.0 10.0\npair_coeff * * exp6.params 1fluid 1fluid none 10.0\npair_coeff * * exp6.params 1fluid 1fluid polynomial filename 10.0",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style extep",
    "html_filename": "pair_extep.html",
    "short_description": "Style extep computes the Extended Tersoff Potential (ExTeP) interactions as described in (Los2017)",
    "description": "Style extep computes the Extended Tersoff Potential (ExTeP)\ninteractions as described in (Los2017).",
    "syntax": "pair_style extep",
    "parameters": " * ",
    "examples": "pair_style extep\npair_coeff * * BN.extep B N",
    "restrictions": "none"
},
{
    "command": "pair_style lj/cut/soft",
    "html_filename": "pair_fep_soft.html",
    "short_description": "These pair styles have a soft repulsive core, tunable by a parameter lambda, in order to avoid singularities during free energy calculations when sites are created or annihilated (Beutler)",
    "description": "These pair styles have a soft repulsive core, tunable by a parameter lambda,\nin order to avoid singularities during free energy calculations when sites are\ncreated or annihilated (Beutler).  When lambda tends to 0 the pair\ninteraction vanishes with a soft repulsive core.  When lambda tends to 1, the pair\ninteraction approaches the normal, non-soft potential. These pair styles\nare suited for “alchemical” free energy calculations using the fix adapt/fep and compute fep commands.\nThe lj/cut/soft style and related sub-styles compute the 12-6 Lennard-Jones\nand Coulomb potentials modified by a soft core, with the functional form\n\n\\[E = \\lambda^n 4 \\epsilon \\left\\{\n\\frac{1}{ \\left[ \\alpha_{\\mathrm{LJ}} (1-\\lambda)^2 +\n\\left( \\displaystyle\\frac{r}{\\sigma} \\right)^6 \\right]^2 } -\n\\frac{1}{ \\alpha_{\\mathrm{LJ}} (1-\\lambda)^2 +\n\\left( \\displaystyle\\frac{r}{\\sigma} \\right)^6 }\n\\right\\} \\qquad r < r_c\\]\nThe lj/class2/soft style is a 9-6 potential with the exponent of the\ndenominator of the first term in brackets taking the value 1.5 instead of 2\n(other details differ, see the form of the potential in\npair_style lj/class2).\nCoulomb interactions can also be damped with a soft core at short distance,\n\n\\[E = \\lambda^n \\frac{ C q_i q_j}{\\epsilon \\left[ \\alpha_{\\mathrm{C}}\n(1-\\lambda)^2 + r^2 \\right]^{1/2}} \\qquad r < r_c\\]\nIn the Coulomb part \\(C\\) is an energy-conversion constant, \\(q_i\\) and\n\\(q_j\\) are the charges on the 2 atoms, and epsilon is the dielectric\nconstant which can be set by the dielectric command.\nThe coefficient lambda is an activation parameter. When \\(\\lambda = 1\\) the\npair potential is identical to a Lennard-Jones term or a Coulomb term or a\ncombination of both. When \\(\\lambda = 0\\) the interactions are\ndeactivated. The transition between these two extrema is smoothed by a soft\nrepulsive core in order to avoid singularities in potential energy and forces\nwhen sites are created or annihilated and can overlap (Beutler).\nThe parameters \\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and\n\\(\\alpha_\\mathrm{C}\\) are set in the pair_style command,\nbefore the cutoffs.  Usual choices for the exponent are \\(n = 2\\) or\n\\(n = 1\\). For the remaining coefficients \\(\\alpha_\\mathrm{LJ} = 0.5\\)\nand \\(\\alpha_\\mathrm{C} = 10~\\text{A}^2\\) are appropriate choices. Plots of\nthe 12-6 LJ and Coulomb terms are shown below, for lambda ranging from 1 to 0\nevery 0.1.\n\n\nFor the lj/cut/coul/cut/soft or lj/cut/coul/long/soft pair styles, as well\nas for the equivalent class2 versions, the following coefficients must be\ndefined for each pair of atoms types via the pair_coeff\ncommand as in the examples above, or in the data file or restart files read by\nthe read_data or read_restart commands,\nor by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\\(\\lambda\\) (activation parameter, between 0 and 1)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nThe latter two coefficients are optional.  If not specified, the global\nLJ and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both LJ\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the LJ and Coulombic cutoffs for this\ntype pair.  You cannot specify 2 cutoffs for style lj/cut/soft,\nsince it has no Coulombic terms. For the coul/cut/soft and\ncoul/long/soft only lambda and the optional cutoff2 are to be\nspecified.\nStyle lj/cut/tip4p/long/soft implements a soft-core version of the TIP4P water\nmodel. The usage of the TIP4P pair style is documented in the pair_lj styles. In the soft version the parameters \\(n\\),\n\\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm {C}\\) are set in the\npair_style command, after the specific parameters of the\nTIP4P water model and before the cutoffs. The activation parameter lambda is\nsupplied as an argument of the pair_coeff command, after\nepsilon and sigma and before the optional cutoffs.\nStyle lj/charmm/coul/long/soft implements a soft-core version of the modified\n12-6 LJ potential used in CHARMM and documented in the pair_style\nlj/charmm/coul/long style. In the soft version the parameters\n\\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm{C}\\) are set in\nthe pair_style command, before the global cutoffs. The\nactivation parameter lambda is introduced as an argument of the pair_coeff command, after \\(\\epsilon\\) and \\(\\sigma\\) and before the\noptional eps14 and sigma14.\nStyle lj/class2/soft implements a soft-core version of the 9-6 potential in\npair_style lj/class2. In the soft version the parameters\n\\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm{C}\\) are set in the\npair_style command, before the global cutoffs. The\nactivation parameter lambda is introduced as an argument of the the\npair_coeff command, after \\(\\epsilon\\) and\n\\(\\sigma\\) and before the optional cutoffs.\nThe coul/cut/soft, coul/long/soft and tip4p/long/soft sub-styles are\ndesigned to be combined with other pair potentials via the pair_style\nhybrid/overlay command.  This is because they have no repulsive\ncore.  Hence, if used by themselves, there will be no repulsion to keep two\noppositely charged particles from overlapping each other. In this case, if\n\\(\\lambda = 1\\), a singularity may occur.  These sub-styles are suitable to\nrepresent charges embedded in the Lennard-Jones radius of another site (for\nexample hydrogen atoms in several water models).\n\nNote\nWhen using the soft-core Coulomb potentials with long-range solvers (coul/long/soft, lj/cut/coul/long/soft, etc.)  in a free energy\ncalculation in which sites holding electrostatic charges are being created or\nannihilated (using fix adapt/fep and compute fep) it is important to adapt both the \\(\\lambda\\) activation\nparameter (from 0 to 1, or the reverse) and the value of the charge (from 0\nto its final value, or the reverse). This ensures that long-range\nelectrostatic terms (kspace) are correct. It is not necessary to use\nsoft-core Coulomb potentials if the van der Waals site is present during the\nfree-energy route, thus avoiding overlap of the charges. Examples are\nprovided in the LAMMPS source directory tree, under examples/USER/fep.\n\n\nNote\nTo avoid division by zero do not set \\(\\sigma = 0\\) in the lj/cut/soft\nand related styles; use the lambda parameter instead to activate/deactivate\ninteractions, or use \\(\\epsilon = 0\\) and \\(\\sigma = 1\\).\nAlternatively, when sites do not interact though the Lennard-Jones term\nthe coul/long/soft or similar sub-style can be used via the\npair_style hybrid/overlay command.\n\n\nThe morse/soft variant modifies the pair_morse style at\nshort range to have a soft core. The functional form differs from that of the\nlj/soft styles, and is instead given by:\n\n\\[\\begin{split}\\begin{split}\ns(\\lambda) =& (1 - \\lambda) / (1 - \\lambda_f), \\qquad B = -2D e^{-2 \\alpha\nr_0} (e^{\\alpha r_0} - 1) / 3 \\\\\nE =& D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] +\ns(\\lambda) B e^{-3\\alpha(r-r_0)}, \\qquad \\hspace{2.85em}\\lambda \\geq\n\\lambda_f,\\quad r < r_c \\\\\nE =& \\left( D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)}\n\\right] + B e^{-3\\alpha(r-r_0)} \\right)(\\lambda/\\lambda_f)^n, \\qquad \\lambda\n< \\lambda_f,\\quad r < r_c\n\\end{split}\\end{split}\\]\nThe morse/soft style requires the following pair coefficients:\n\n\\(D_0\\) (energy units)\n\\(\\alpha\\) (1/distance units)\n\\(r_0\\) (distance units)\n\\(\\lambda\\) (unitless, between 0.0 and 1.0)\ncutoff (distance units)\n\nThe last coefficient is optional. If not specified, the global morse cutoff is\nused.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script by\nincluding their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the suffix\ncommand in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, tail correction, restart info:\nThe different versions of the lj/cut/soft pair styles support mixing.  For\natom type pairs I,J and I != J, the \\(\\epsilon\\) and \\(\\sigma\\)\ncoefficients and cutoff distance for these pair style can be mixed.  The default\nmix value is geometric for 12-6 styles.\nThe mixing rule for epsilon and sigma for lj/class2/soft 9-6 potentials is to\nuse the sixthpower formulas. The pair_modify mix setting\nis thus ignored for class2 potentials for \\(\\epsilon\\) and\n\\(\\sigma\\). However it is still followed for mixing the cutoff distance. See\nthe pair_modify command for details.\nThe morse/soft pair style does not support mixing. Thus, coefficients for all\nLJ pairs must be specified explicitly.\nAll of the pair styles with soft core support the pair_modify\nshift option for the energy of the Lennard-Jones portion of the pair\ninteraction.\nThe different versions of the lj/cut/soft pair styles support the\npair_modify tail option for adding a long-range tail\ncorrection to the energy and pressure for the Lennard-Jones portion of the pair\ninteraction.\n\nNote\nThe analytical form of the tail corrections for energy and pressure used in\nthe lj/cut/soft potentials are approximate, being identical to that of the\ncorresponding non-soft potentials scaled by a factor \\(\\lambda^n\\). The\nerrors due to this approximation should be negligible. For example, for a\ncutoff of \\(2.5\\sigma\\) this approximation leads to maximum relative\nerrors in tail corrections of the order of 1e-4 for energy and virial\n(\\(\\alpha_\\mathrm{LJ} = 0.5, n = 2\\)). The error vanishes when lambda\napproaches 0 or 1. Note that these are the errors affecting the long-range\ntail (itself a correction to the interaction energy) which includes other\napproximations, namely that the system is homogeneous (local density equal\nthe average density) beyond the cutoff.\n\nThe morse/soft pair style does not support the pair_modify tail option for adding long-range tail corrections to energy and\npressure.\nAll of these pair styles write information to binary restart files, so pair_style and pair_coeff commands do not need to be specified\nin an input script that reads a restart file.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/cut/soft or lj/cut/coul/cut/soft or lj/cut/coul/long/soft or lj/cut/tip4p/long/soft or lj/charmm/coul/long/soft or lj/class2/soft or lj/class2/coul/cut/soft or lj/class2/coul/long/soft or coul/cut/soft or coul/long/soft or tip4p/long/soft or morse/soft\n * args = list of arguments for a particular style\n * lj/cut/soft args = n alpha_lj cutoff\n *   n, alpha_LJ = parameters of soft-core potential\n *   cutoff = global cutoff for Lennard-Jones interactions (distance units)\n * lj/cut/coul/cut/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n *   n, alpha_LJ, alpha_C = parameters of soft-core potential\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/coul/long/soft args = n alpha_LJ alpha_C cutoff\n *   n, alpha_LJ, alpha_C = parameters of the soft-core potential\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/tip4p/long/soft args = otype htype btype atype qdist n alpha_LJ alpha_C cutoff (cutoff2)\n *   otype,htype = atom types for TIP4P O and H\n *   btype,atype = bond and angle types for TIP4P waters\n *   qdist = distance from O atom to massless charge (distance units)\n *   n, alpha_LJ, alpha_C = parameters of the soft-core potential\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/charmm/coul/long/soft args = n alpha_LJ alpha_C inner outer (cutoff)\n *   n, alpha_LJ, alpha_C = parameters of the soft-core potential\n *   inner, outer = global switching cutoffs for LJ (and Coulombic if only 5 args)\n *   cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 5 args)\n * lj/class2/soft args = n alpha_lj cutoff\n *   n, alpha_LJ = parameters of soft-core potential\n *   cutoff = global cutoff for Lennard-Jones interactions (distance units)\n * lj/class2/coul/cut/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n *   n, alpha_LJ, alpha_C = parameters of soft-core potential\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/class2/coul/long/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n *   n, alpha_LJ, alpha_C = parameters of soft-core potential\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * coul/cut/soft args = n alpha_C cutoff\n *   n, alpha_C = parameters of the soft-core potential\n *   cutoff = global cutoff for Coulomb interactions (distance units)\n * coul/long/soft args = n alpha_C cutoff\n *   n, alpha_C = parameters of the soft-core potential\n *   cutoff = global cutoff for Coulomb interactions (distance units)\n * tip4p/long/soft args = otype htype btype atype qdist n alpha_C cutoff\n *   otype,htype = atom types for TIP4P O and H\n *   btype,atype = bond and angle types for TIP4P waters\n *   qdist = distance from O atom to massless charge (distance units)\n *   n, alpha_C = parameters of the soft-core potential\n *   cutoff = global cutoff for Coulomb interactions (distance units)\n * morse/soft args = n lf cutoff\n *   n = soft-core parameter\n *   lf = transformation range is lf < lambda < 1\n *   cutoff = global cutoff for Morse interactions (distance units)",
    "examples": "pair_style lj/cut/soft 2.0 0.5 9.5\npair_coeff * * 0.28 3.1 1.0\npair_coeff 1 1 0.28 3.1 1.0 9.5\n\npair_style lj/cut/coul/cut/soft 2.0 0.5 10.0 9.5\npair_style lj/cut/coul/cut/soft 2.0 0.5 10.0 9.5 9.5\npair_coeff * * 0.28 3.1 1.0\npair_coeff 1 1 0.28 3.1 0.5 10.0\npair_coeff 1 1 0.28 3.1 0.5 10.0 9.5\n\npair_style lj/cut/coul/long/soft 2.0 0.5 10.0 9.5\npair_style lj/cut/coul/long/soft 2.0 0.5 10.0 9.5 9.5\npair_coeff * * 0.28 3.1 1.0\npair_coeff 1 1 0.28 3.1 0.0 10.0\npair_coeff 1 1 0.28 3.1 0.0 10.0 9.5\n\npair_style lj/cut/tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8\npair_style lj/cut/tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8 9.5\npair_coeff * * 0.155 3.1536 1.0\npair_coeff 1 1 0.155 3.1536 1.0 9.5\n\npair_style lj/charmm/coul/long 2.0 0.5 10.0 8.0 10.0\npair_style lj/charmm/coul/long 2.0 0.5 10.0 8.0 10.0 9.0\npair_coeff * * 0.28 3.1 1.0\npair_coeff 1 1 0.28 3.1 1.0 0.14 3.1\n\npair_style lj/class2/coul/long/soft 2.0 0.5 10.0 9.5\npair_style lj/class2/coul/long/soft 2.0 0.5 10.0 9.5 9.5\npair_coeff * * 0.28 3.1 1.0\npair_coeff 1 1 0.28 3.1 0.0 10.0\npair_coeff 1 1 0.28 3.1 0.0 10.0 9.5\n\npair_style coul/long/soft 1.0 10.0 9.5\npair_coeff * * 1.0\npair_coeff 1 1 1.0 9.5\n\npair_style tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8\npair_coeff * * 1.0\npair_coeff 1 1 1.0 9.5\n\npair_style morse/soft 4 0.9 10.0\npair_coeff * * 100.0 2.0 1.5 1.0\npair_coeff 1 1 100.0 2.0 1.5 1.0 3.0",
    "restrictions": "The pair styles with soft core are only enabled if LAMMPS was built with the\nUSER-FEP package. The long versions also require the KSPACE package to be\ninstalled. The soft tip4p versions also require the MOLECULE package to be\ninstalled. These styles are only enabled if LAMMPS was built with those\npackages.  See the Build package doc page for more\ninfo."
},
{
    "command": "pair_style gauss",
    "html_filename": "pair_gauss.html",
    "short_description": "Style gauss computes a tethering potential of the form  \\[E = - A \\exp(-B r^2) \\qquad r < r_c\\] between an atom and its corresponding tether site which will typically be a frozen atom in the simulation",
    "description": "Style gauss computes a tethering potential of the form\n\n\\[E = - A \\exp(-B r^2) \\qquad r < r_c\\]\nbetween an atom and its corresponding tether site which will typically\nbe a frozen atom in the simulation.  \\(r_c\\) is the cutoff.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA (energy units)\nB (1/distance^2 units)\ncutoff (distance units)\n\nThe last coefficient is optional. If not specified, the global cutoff\nis used.\nStyle gauss/cut computes a generalized Gaussian interaction potential\nbetween pairs of particles:\n\n\\[E = \\frac{H}{\\sigma_h\\sqrt{2\\pi}} \\exp\\left[-\\frac{(r-r_{mh})^2}{2\\sigma_h^2}\\right]\\]\nwhere H determines together with the standard deviation \\(\\sigma_h\\)\nthe peak height of the Gaussian function, and \\(r_{mh}\\) the peak\nposition.  Examples of the use of the Gaussian potentials include\nimplicit solvent simulations of salt ions (Lenart) and\nof surfactants (Jusufi).  In these instances the\nGaussian potential mimics the hydration barrier between a pair of\nparticles. The hydration barrier is located at \\(r_{mh}\\) and has a\nwidth of \\(\\sigma_h\\). The prefactor determines the height of the\npotential barrier.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the example above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nH (energy * distance units)\n\\(r_{mh}\\) (distance units)\n\\(\\sigma_h\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional. If not specified, the global cutoff\nis used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A, B, H, sigma_h, r_mh\nparameters, and the cutoff distance for these pair styles can be mixed:\nA (energy units)\nsqrt(1/B) (distance units, see below)\nH (energy units)\nsigma_h (distance units)\nr_mh (distance units)\ncutoff (distance units):ul\nThe default mix value is geometric.\nOnly arithmetic and geometric mix values are supported.\nSee the “pair_modify” command for details.\nThe A and H parameters are mixed using the same rules normally\nused to mix the “epsilon” parameter in a Lennard Jones interaction.\nThe sigma_h, r_mh, and the cutoff distance are mixed using the same\nrules used to mix the “sigma” parameter in a Lennard Jones interaction.\nThe B parameter is converted to a distance (sigma), before mixing\n(using sigma=B^-0.5), and converted back to a coefficient\nafterwards (using B=sigma^2).\nNegative A values are converted to positive A values (using abs(A))\nbefore mixing, and converted back after mixing\n(by multiplying by min(sign(Ai),sign(Aj))).\nThis way, if either particle is repulsive (if Ai<0 or Aj<0),\nthen the default interaction between both particles will be repulsive.\nThe gauss style does not support the pair_modify\nshift option. There is no effect due to the Gaussian well beyond the\ncutoff; hence reasonable cutoffs need to be specified.\nThe gauss/cut style supports the pair_modify shift\noption for the energy of the Gauss-potential portion of the pair\ninteraction.\nThe pair_modify table and tail options are not\nrelevant for these pair styles.\nThese pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.\nThe gauss pair style tallies an “occupancy” count of how many Gaussian-well\nsites have an atom within the distance at which the force is a maximum\n= sqrt(0.5/b).  This quantity can be accessed via the compute pair command as a vector of values of length 1.\nTo print this quantity to the log file (with a descriptive column\nheading) the following commands could be included in an input script:\ncompute gauss all pair gauss\nvariable occ equal c_gauss[1]\nthermo_style custom step temp epair v_occ",
    "syntax": "pair_style gauss cutoff",
    "parameters": " * pair_style gauss/cut cutoff\n * cutoff = global cutoff for Gauss interactions (distance units)",
    "examples": "pair_style gauss 12.0\npair_coeff * * 1.0 0.9\npair_coeff 1 4 1.0 0.9 10.0\n\npair_style gauss/cut 3.5\npair_coeff 1 4 0.2805 1.45 0.112",
    "restrictions": "The gauss/cut style is part of the “user-misc” package. It is only\nenabled if LAMMPS is build with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style gayberne",
    "html_filename": "pair_gayberne.html",
    "short_description": "The gayberne styles compute a Gay-Berne anisotropic LJ interaction (Berardi) between pairs of ellipsoidal particles or an ellipsoidal and spherical particle via the formulas  \\[\\begin{split}U ( \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12} ) = & U_r ( \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12}, \\gamma ) \\cdot \\eta_{12} ( \\mathbf{A}_1, \\mathbf{A}_2, \\upsilon ) \\cdot \\chi_{12} ( \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12}, \\mu ) \\\\ U_r = & 4 \\epsilon ( \\varrho^{12} - \\varrho^6) \\\\ \\varrho = & \\frac{\\sigma}{ h_{12} + \\gamma \\sigma}\\end{split}\\] where A1 and A2 are the transformation matrices from the simulation box frame to the body frame and \\(r_{12}\\) is the center to center vector between the particles",
    "description": "The gayberne styles compute a Gay-Berne anisotropic LJ interaction\n(Berardi) between pairs of ellipsoidal particles or an\nellipsoidal and spherical particle via the formulas\n\n\\[\\begin{split}U ( \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12} ) = & U_r (\n\\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12}, \\gamma ) \\cdot \\eta_{12} (\n\\mathbf{A}_1, \\mathbf{A}_2, \\upsilon ) \\cdot \\chi_{12} ( \\mathbf{A}_1,\n\\mathbf{A}_2, \\mathbf{r}_{12}, \\mu ) \\\\\nU_r = & 4 \\epsilon ( \\varrho^{12} - \\varrho^6) \\\\\n\\varrho = & \\frac{\\sigma}{ h_{12} + \\gamma \\sigma}\\end{split}\\]\nwhere A1 and A2 are the transformation matrices from the simulation box\nframe to the body frame and \\(r_{12}\\) is the center to center\nvector between the particles.  \\(U_r\\) controls the shifted distance\ndependent interaction based on the distance of closest approach of the\ntwo particles (\\(h_{12}\\)) and the user-specified shift parameter\ngamma.  When both particles are spherical, the formula reduces to the\nusual Lennard-Jones interaction (see details below for when Gay-Berne\ntreats a particle as “spherical”).\nFor large uniform molecules it has been shown that the energy\nparameters are approximately representable in terms of local contact\ncurvatures (Everaers):\n\n\\[\\epsilon_a = \\sigma \\cdot { \\frac{a}{ b \\cdot c } }; \\epsilon_b =\n\\sigma \\cdot { \\frac{b}{ a \\cdot c } }; \\epsilon_c = \\sigma \\cdot {\n\\frac{c}{ a \\cdot b } }\\]\nThe variable names utilized as potential parameters are for the most\npart taken from (Everaers) in order to be consistent with\nthe RE-squared pair potential.  Details on the\nupsilon and mu parameters are given\nhere.\nMore details of the Gay-Berne formulation are given in the references\nlisted below and in this supplementary document.\nUse of this pair style requires the NVE, NVT, or NPT fixes with the\nasphere extension (e.g. fix nve/asphere) in\norder to integrate particle rotation.  Additionally, atom_style ellipsoid should be used since it defines the\nrotational state and the size and shape of each ellipsoidal particle.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) = well depth (energy units)\n\\(\\sigma\\) = minimum effective particle radii (distance units)\n\\(\\epsilon_{i,a}\\) = relative well depth of type I for side-to-side interactions\n\\(\\epsilon_{i,b}\\) = relative well depth of type I for face-to-face interactions\n\\(\\epsilon_{i,c}\\) = relative well depth of type I for end-to-end interactions\n\\(\\epsilon_{j,a}\\) = relative well depth of type J for side-to-side interactions\n\\(\\epsilon_{j,b}\\) = relative well depth of type J for face-to-face interactions\n\\(\\epsilon_{j,c}\\) = relative well depth of type J for end-to-end interactions\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global\ncutoff specified in the pair_style command is used.\nIt is typical with the Gay-Berne potential to define \\(\\sigma\\) as\nthe minimum of the 3 shape diameters of the particles involved in an I,I\ninteraction, though this is not required.  Note that this is a different\nmeaning for \\(\\sigma\\) than the pair_style resquared potential uses.\nThe \\(\\epsilon_i\\) and \\(\\epsilon_j\\) coefficients are actually\ndefined for atom types, not for pairs of atom types.  Thus, in a series\nof pair_coeff commands, they only need to be specified once for each\natom type.\nSpecifically, if any of \\(\\epsilon_{i,a}\\), \\(\\epsilon_{i,b}\\),\n\\(\\epsilon_{i,c}\\) are non-zero, the three values are assigned to\natom type I.  If all the \\(\\epsilon_i\\) values are zero, they are\nignored.  If any of \\(\\epsilon_{j,a}\\), \\(\\epsilon_{j,b}\\),\n\\(\\epsilon_{j,c}\\) are non-zero, the three values are assigned to\natom type J.  If all three epsilon_j values are zero, they are ignored.\nThus the typical way to define the \\(\\epsilon_i\\) and\n\\(\\epsilon_j\\) coefficients is to list their values in “pair_coeff\nI J” commands when I = J, but set them to 0.0 when I != J.  If you do\nlist them when I != J, you should insure they are consistent with their\nvalues in other pair_coeff commands, since only the last setting will\nbe in effect.\nNote that if this potential is being used as a sub-style of\npair_style hybrid, and there is no “pair_coeff I I”\nsetting made for Gay-Berne for a particular type I (because I-I\ninteractions are computed by another hybrid pair potential), then you\nstill need to insure the \\(\\epsilon\\) a,b,c coefficients are assigned to\nthat type. e.g. in a “pair_coeff I J” command.\n\nNote\nIf the \\(\\epsilon\\) a = b = c for an atom type, and if the shape\nof the particle itself is spherical, meaning its 3 shape parameters\nare all the same, then the particle is treated as an LJ sphere by the\nGay-Berne potential.  This is significant because if two LJ spheres\ninteract, then the simple Lennard-Jones formula is used to compute\ntheir interaction energy/force using the specified epsilon and sigma\nas the standard LJ parameters.  This is much cheaper to compute than\nthe full Gay-Berne formula.  To treat the particle as a LJ sphere\nwith sigma = D, you should normally set \\(\\epsilon\\) a = b = c =\n1.0, set the pair_coeff \\(\\sigma = D\\), and also set the 3 shape\nparameters for the particle to D.  The one exception is that if the 3\nshape parameters are set to 0.0, which is a valid way in LAMMPS to\nspecify a point particle, then the Gay-Berne potential will treat\nthat as shape parameters of 1.0 (i.e. a LJ particle with\n\\(\\sigma = 1\\)), since it requires finite-size particles.  In\nthis case you should still set the pair_coeff \\(\\sigma\\) to 1.0\nas well.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for this pair style can be mixed.  The default mix\nvalue is geometric.  See the “pair_modify” command for details.\nThis pair styles supports the pair_modify shift\noption for the energy of the Lennard-Jones portion of the pair\ninteraction, but only for sphere-sphere interactions.  There is no\nshifting performed for ellipsoidal interactions due to the anisotropic\ndependence of the interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style gayberne gamma upsilon mu cutoff",
    "parameters": " * gamma = shift for potential minimum (typically 1)\n * upsilon = exponent for eta orientation-dependent energy function\n * mu = exponent for chi orientation-dependent energy function\n * cutoff = global cutoff for interactions (distance units)",
    "examples": "pair_style gayberne 1.0 1.0 1.0 10.0\npair_coeff * * 1.0 1.7 1.7 3.4 3.4 1.0 1.0 1.0",
    "restrictions": "The gayberne style is part of the ASPHERE package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair style require that atoms store torque and a quaternion to\nrepresent their orientation, as defined by the\natom_style.  It also require they store a per-type\nshape.  The particles cannot store a per-particle\ndiameter.\nThis pair style requires that atoms be ellipsoids as defined by the\natom_style ellipsoid command.\nParticles acted on by the potential can be finite-size aspherical or\nspherical particles, or point particles.  Spherical particles have all\n3 of their shape parameters equal to each other.  Point particles have\nall 3 of their shape parameters equal to 0.0.\nThe Gay-Berne potential does not become isotropic as r increases\n(Everaers).  The distance-of-closest-approach\napproximation used by LAMMPS becomes less accurate when high-aspect\nratio ellipsoids are used."
},
{
    "command": "pair_style gran/hooke",
    "html_filename": "pair_gran.html",
    "short_description": "The gran styles use the following formulas for the frictional force between two granular particles, as described in (Brilliantov), (Silbert), and (Zhang), when the distance r between two particles of radii Ri and Rj is less than their contact distance d = Ri + Rj",
    "description": "The gran styles use the following formulas for the frictional force\nbetween two granular particles, as described in\n(Brilliantov), (Silbert), and\n(Zhang), when the distance r between two particles of radii\nRi and Rj is less than their contact distance d = Ri + Rj.  There is\nno force between the particles when r > d.\nThe two Hookean styles use this formula:\n\n\\[F_{hk} = (k_n \\delta \\mathbf{n}_{ij} -\nm_{eff} \\gamma_n\\mathbf{ v}_n) -\n(k_t \\mathbf{ \\Delta s}_t +\nm_{eff} \\gamma_t \\mathbf{v}_t)\\]\nThe Hertzian style uses this formula:\n\n\\[F_{hz} = \\sqrt{\\delta} \\sqrt{\\frac{R_i R_j}{R_i + R_j}} F_{hk} =\n  \\sqrt{\\delta} \\sqrt{\\frac{R_i R_j}{R_i + R_j}}\n  \\Big[ (k_n \\delta \\mathbf{n}_{ij} -\n    m_{eff} \\: \\gamma_n \\mathbf{ v}_n) -\n    (k_t \\mathbf{ \\Delta s}_t +\n    m_{eff} \\: \\gamma_t \\mathbf{v}_t) \\Big]\\]\nIn both equations the first parenthesized term is the normal force\nbetween the two particles and the second parenthesized term is the\ntangential force.  The normal force has 2 terms, a contact force and a\ndamping force.  The tangential force also has 2 terms: a shear force\nand a damping force.  The shear force is a “history” effect that\naccounts for the tangential displacement between the particles for the\nduration of the time they are in contact.  This term is included in\npair styles hooke/history and hertz/history, but is not included\nin pair style hooke.  The tangential damping force term is included\nin all three pair styles if dampflag is set to 1; it is not included\nif dampflag is set to 0.\nThe other quantities in the equations are as follows:\n\n\\(\\delta\\) = d - r = overlap distance of 2 particles\n\\(K_n\\) = elastic constant for normal contact\n\\(K_t\\) = elastic constant for tangential contact\n\\(\\gamma_n\\) = viscoelastic damping constant for normal contact\n\\(\\gamma_t\\) = viscoelastic damping constant for tangential contact\n\\(m_{eff} = M_i M_j / (M_i + M_j) =\\) effective mass of 2 particles of mass M_i and M_j\n\\(\\mathbf{\\Delta s}_t =\\) tangential displacement vector between 2 particles       which is truncated to satisfy a frictional yield criterion\n\\(n_{ij} =\\) unit vector along the line connecting the centers of the 2 particles\n\\(V_n =\\) normal component of the relative velocity of the 2 particles\n\\(V_t =\\) tangential component of the relative velocity of the 2 particles\n\nThe \\(K_n\\), \\(K_t\\), \\(\\gamma_n\\), and \\(\\gamma_t\\)\ncoefficients are specified as parameters to the pair_style command.  If\na NULL is used for \\(K_t\\), then a default value is used where\n\\(K_t = 2/7 K_n\\).  If a NULL is used for \\(\\gamma_t\\), then a\ndefault value is used where \\(\\gamma_t = 1/2 \\gamma_n\\).\nThe interpretation and units for these 4 coefficients are different in\nthe Hookean versus Hertzian equations.\nThe Hookean model is one where the normal push-back force for two\noverlapping particles is a linear function of the overlap distance.\nThus the specified \\(K_n\\) is in units of (force/distance).  Note\nthat this push-back force is independent of absolute particle size (in\nthe monodisperse case) and of the relative sizes of the two particles\n(in the polydisperse case).  This model also applies to the other terms\nin the force equation so that the specified \\(\\gamma_n\\) is in units\nof (1/time), \\(K_t\\) is in units of (force/distance), and\n\\(\\gamma_t\\) is in units of (1/time).\nThe Hertzian model is one where the normal push-back force for two\noverlapping particles is proportional to the area of overlap of the\ntwo particles, and is thus a non-linear function of overlap distance.\nThus Kn has units of force per area and is thus specified in units of\n(pressure).  The effects of absolute particle size (monodispersity)\nand relative size (polydispersity) are captured in the radii-dependent\npre-factors.  When these pre-factors are carried through to the other\nterms in the force equation it means that the specified \\(\\gamma_n\\) is in\nunits of (1/(time*distance)), \\(K_t\\) is in units of (pressure), and\n\\(\\gamma_t\\) is in units of (1/(time*distance)).\nNote that in the Hookean case, \\(K_n\\) can be thought of as a linear\nspring constant with units of force/distance.  In the Hertzian case,\n\\(K_n\\) is like a non-linear spring constant with units of\nforce/area or pressure, and as shown in the (Zhang)\npaper, \\(K_n = 4G / (3(1-\\nu))\\) where \\(\\nu =\\) the Poisson ratio,\nG = shear modulus = \\(E / (2(1+\\nu))\\), and E = Young’s modulus.  Similarly,\n\\(K_t = 4G / (2-\\nu)\\).  (NOTE: in an earlier version of the manual, we incorrectly\nstated that \\(K_t = 8G / (2-\\nu)\\).)\nThus in the Hertzian case \\(K_n\\) and \\(K_t\\) can be set to\nvalues that corresponds to properties of the material being modeled.\nThis is also true in the Hookean case, except that a spring constant\nmust be chosen that is appropriate for the absolute size of particles in\nthe model.  Since relative particle sizes are not accounted for, the\nHookean styles may not be a suitable model for polydisperse systems.\n\nNote\nIn versions of LAMMPS before 9Jan09, the equation for Hertzian\ninteractions did not include the \\(\\sqrt{r_i r_j / (r_i + r_j)}\\)\nterm and thus was not as accurate for polydisperse systems.  For\nmonodisperse systems, \\(\\sqrt{ r_i r_j /(r_i+r_j)}\\) is a\nconstant factor that effectively scales all 4 coefficients:\n\\(K_n, K_t, \\gamma_n, \\gamma_t\\).  Thus you can set the values of\nthese 4 coefficients appropriately in the current code to reproduce\nthe results of a previous Hertzian monodisperse calculation.  For\nexample, for the common case of a monodisperse system with particles\nof diameter 1, all 4 of these coefficients should now be set 2x\nlarger than they were previously.\n\nXmu is also specified in the pair_style command and is the upper limit\nof the tangential force through the Coulomb criterion Ft = xmu*Fn,\nwhere Ft and Fn are the total tangential and normal force components\nin the formulas above.  Thus in the Hookean case, the tangential force\nbetween 2 particles grows according to a tangential spring and\ndash-pot model until Ft/Fn = xmu and is then held at Ft = Fn*xmu until\nthe particles lose contact.  In the Hertzian case, a similar analogy\nholds, though the spring is no longer linear.\n\nNote\nNormally, xmu should be specified as a fractional value between\n0.0 and 1.0, however LAMMPS allows large values (up to 1.0e4) to allow\nfor modeling of systems which can sustain very large tangential\nforces.\n\nThe effective mass m_eff is given by the formula above for two\nisolated particles.  If either particle is part of a rigid body, its\nmass is replaced by the mass of the rigid body in the formula above.\nThis is determined by searching for a fix rigid\ncommand (or its variants).\nFor granular styles there are no additional coefficients to set for\neach pair of atom types via the pair_coeff command.\nAll settings are global and are made via the pair_style command.\nHowever you must still use the pair_coeff for all\npairs of granular atom types.  For example the command\npair_coeff * *\n\n\nshould be used if all atoms in the simulation interact via a granular\npotential (i.e. one of the pair styles above is used).  If a granular\npotential is used as a sub-style of pair_style hybrid, then specific atom types can be used in the\npair_coeff command to determine which atoms interact via a granular\npotential.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe pair_modify mix, shift, table, and tail options\nare not relevant for granular pair styles.\nThese pair styles write their information to binary restart files, so a pair_style command does not need to be\nspecified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.\nThe single() function of these pair styles returns 0.0 for the energy\nof a pairwise interaction, since energy is not conserved in these\ndissipative potentials.  It also returns only the normal component of\nthe pairwise interaction force.  However, the single() function also\ncalculates 10 extra pairwise quantities.  The first 3 are the\ncomponents of the tangential force between particles I and J, acting\non particle I.  The 4th is the magnitude of this tangential force.\nThe next 3 (5-7) are the components of the relative velocity in the\nnormal direction (along the line joining the 2 sphere centers).  The\nlast 3 (8-10) the components of the relative velocity in the\ntangential direction.\nThese extra quantities can be accessed by the compute pair/local command, as p1, p2, …,\np10.",
    "syntax": "pair_style style Kn Kt gamma_n gamma_t xmu dampflag",
    "parameters": " * style = gran/hooke or gran/hooke/history or gran/hertz/history\n * Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n * Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n * gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n * gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n * xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n * dampflag = 0 or 1 if tangential damping force is excluded or included\n * Note\n * Versions of LAMMPS before 9Jan09 had different style names for\n * granular force fields.  This is to emphasize the fact that the\n * Hertzian equation has changed to model polydispersity more accurately.\n * A side effect of the change is that the Kn, Kt, gamma_n, and gamma_t\n * coefficients in the pair_style command must be specified with\n * different values in order to reproduce calculations made with earlier\n * versions of LAMMPS, even for monodisperse systems.  See the NOTE below\n * for details.",
    "examples": "pair_style gran/hooke/history 200000.0 NULL 50.0 NULL 0.5 1\npair_style gran/hooke 200000.0 70000.0 50.0 30.0 0.5 0",
    "restrictions": "All the granular pair styles are part of the GRANULAR package.  It is\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair styles require that atoms store torque and angular velocity\n(omega) as defined by the atom_style.  They also\nrequire a per-particle radius is stored.  The sphere atom style does\nall of this.\nThis pair style requires you to use the comm_modify vel yes command so that velocities are stored by ghost\natoms.\nThese pair styles will not restart exactly when using the\nread_restart command, though they should provide\nstatistically similar results.  This is because the forces they\ncompute depend on atom velocities.  See the\nread_restart command for more details."
},
{
    "command": "pair_style granular",
    "html_filename": "pair_granular.html",
    "short_description": "The granular styles support a variety of options for the normal, tangential, rolling and twisting forces resulting from contact between two granular particles",
    "description": "The granular styles support a variety of options for the normal,\ntangential, rolling and twisting forces resulting from contact between\ntwo granular particles. This expands on the options offered by the\npair gran/* pair styles. The total computed forces\nand torques are the sum of various models selected for the normal,\ntangential, rolling and twisting modes of motion.\nAll model choices and parameters are entered in the\npair_coeff command, as described below.  Unlike\ne.g. pair gran/hooke, coefficient values are not\nglobal, but can be set to different values for different combinations\nof particle types, as determined by the pair_coeff\ncommand.  If the contact model choice is the same for two particle\ntypes, the mixing for the cross-coefficients can be carried out\nautomatically. This is shown in the last example, where model\nchoices are the same for type 1 - type 1 as for type 2 - type2\ninteractions, but coefficients are different. In this case, the\nmixed coefficients for type 1 - type 2 interactions can be determined from\nmixing rules discussed below.  For additional flexibility,\ncoefficients as well as model forms can vary between particle types,\nas shown in the fourth example: type 1 - type 1 interactions are based\non a Johnson-Kendall-Roberts normal contact model and 2-2 interactions\nare based on a DMT cohesive model (see below).  In that example, 1-1\nand 2-2 interactions have different model forms, in which case mixing of\ncoefficients cannot be determined, so 1-2 interactions must be\nexplicitly defined via the pair_coeff 1 * command, otherwise an\nerror would result.\n\nThe first required keyword for the pair_coeff command is the normal\ncontact model. Currently supported options for normal contact models\nand their required arguments are:\n\nhooke : \\(k_n\\), \\(\\eta_{n0}\\) (or \\(e\\))\nhertz : \\(k_n\\), \\(\\eta_{n0}\\) (or \\(e\\))\nhertz/material : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\)\ndmt : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\), \\(\\gamma\\)\njkr : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\), \\(\\gamma\\)\n\nHere, \\(k_n\\) is spring stiffness (with units that depend on model\nchoice, see below); \\(\\eta_{n0}\\) is a damping prefactor (or, in its\nplace a coefficient of restitution \\(e\\), depending on the choice of\ndamping mode, see below); E is Young’s modulus in units of\nforce/length^2, i.e. pressure; \\(\\nu\\) is Poisson’s ratio and\n\\(\\gamma\\) is a surface energy density, in units of\nenergy/length^2.\nFor the hooke model, the normal, elastic component of force acting\non particle i due to contact with particle j is given by:\n\n\\[\\mathbf{F}_{ne, Hooke} = k_N \\delta_{ij} \\mathbf{n}\\]\nWhere \\(\\delta_{ij} = R_i + R_j - \\|\\mathbf{r}_{ij}\\|\\) is the particle\noverlap, \\(R_i, R_j\\) are the particle radii, \\(\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j\\) is the vector separating the two\nparticle centers (note the i-j ordering so that \\(F_{ne}\\) is\npositive for repulsion), and \\(\\mathbf{n} = \\frac{\\mathbf{r}_{ij}}{\\|\\mathbf{r}_{ij}\\|}\\).  Therefore,\nfor hooke, the units of the spring constant \\(k_n\\) are\nforce/distance, or equivalently mass/time^2.\nFor the hertz model, the normal component of force is given by:\n\n\\[\\mathbf{F}_{ne, Hertz} = k_N R_{eff}^{1/2}\\delta_{ij}^{3/2} \\mathbf{n}\\]\nHere, \\(R_{eff} = \\frac{R_i R_j}{R_i + R_j}\\) is the effective\nradius, denoted for simplicity as R from here on.  For hertz, the\nunits of the spring constant \\(k_n\\) are force/length^2, or\nequivalently pressure.\nFor the hertz/material model, the force is given by:\n\n\\[\\mathbf{F}_{ne, Hertz/material} = \\frac{4}{3} E_{eff} R_{eff}^{1/2}\\delta_{ij}^{3/2} \\mathbf{n}\\]\nHere, \\(E_{eff} = E = \\left(\\frac{1-\\nu_i^2}{E_i} + \\frac{1-\\nu_j^2}{E_j}\\right)^{-1}\\) is the effective Young’s\nmodulus, with \\(\\nu_i, \\nu_j\\) the Poisson ratios of the particles of\ntypes i and j. Note that if the elastic modulus and the shear\nmodulus of the two particles are the same, the hertz/material model\nis equivalent to the hertz model with \\(k_N = 4/3 E_{eff}\\)\nThe dmt model corresponds to the\n(Derjaguin-Muller-Toporov) cohesive model, where the force\nis simply Hertz with an additional attractive cohesion term:\n\n\\[\\mathbf{F}_{ne, dmt} = \\left(\\frac{4}{3} E R^{1/2}\\delta_{ij}^{3/2} - 4\\pi\\gamma R\\right)\\mathbf{n}\\]\nThe jkr model is the (Johnson-Kendall-Roberts) model,\nwhere the force is computed as:\n\n\\[\\mathbf{F}_{ne, jkr} = \\left(\\frac{4Ea^3}{3R} - 2\\pi a^2\\sqrt{\\frac{4\\gamma E}{\\pi a}}\\right)\\mathbf{n}\\]\nHere, a is the radius of the contact zone, related to the overlap\n\\(\\delta\\) according to:\n\n\\[\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\]\nLAMMPS internally inverts the equation above to solve for a in terms\nof \\(\\delta\\), then solves for the force in the previous\nequation. Additionally, note that the JKR model allows for a tensile\nforce beyond contact (i.e. for \\(\\delta < 0\\)), up to a maximum of\n\\(3\\pi\\gamma R\\) (also known as the ‘pull-off’ force).  Note that this\nis a hysteretic effect, where particles that are not contacting\ninitially will not experience force until they come into contact\n\\(\\delta \\geq 0\\); as they move apart and (\\(\\delta < 0\\)), they\nexperience a tensile force up to \\(3\\pi\\gamma R\\), at which point they\nlose contact.\n\nIn addition, the normal force is augmented by a damping term of the\nfollowing general form:\n\n\\[\\mathbf{F}_{n,damp} = -\\eta_n \\mathbf{v}_{n,rel}\\]\nHere, \\(\\mathbf{v}_{n,rel} = (\\mathbf{v}_j - \\mathbf{v}_i) \\cdot \\mathbf{n} \\mathbf{n}\\) is the component of relative velocity along\n\\(\\mathbf{n}\\).\nThe optional damping keyword to the pair_coeff command followed by\na keyword determines the model form of the damping factor \\(\\eta_n\\),\nand the interpretation of the \\(\\eta_{n0}\\) or \\(e\\) coefficients\nspecified as part of the normal contact model settings. The damping\nkeyword and corresponding model form selection may be appended\nanywhere in the pair coeff command.  Note that the choice of damping\nmodel affects both the normal and tangential damping (and depending on\nother settings, potentially also the twisting damping).  The options\nfor the damping model currently supported are:\n\nvelocity\nmass_velocity\nviscoelastic\ntsuji\n\nIf the damping keyword is not specified, the viscoelastic model is\nused by default.\nFor damping velocity, the normal damping is simply equal to the\nuser-specified damping coefficient in the normal model:\n\n\\[\\eta_n = \\eta_{n0}\\]\nHere, \\(\\eta_{n0}\\) is the damping coefficient specified for the normal\ncontact model, in units of mass/time.\nFor damping mass_velocity, the normal damping is given by:\n\n\\[\\eta_n = \\eta_{n0} m_{eff}\\]\nHere, \\(\\eta_{n0}\\) is the damping coefficient specified for the normal\ncontact model, in units of mass/time and\n\\(m_{eff} = m_i m_j/(m_i + m_j)\\) is the effective mass.\nUse damping mass_velocity to reproduce the damping behavior of\npair gran/hooke/*.\nThe damping viscoelastic model is based on the viscoelastic\ntreatment of (Brilliantov et al), where the normal\ndamping is given by:\n\n\\[\\eta_n = \\eta_{n0}\\ a m_{eff}\\]\nHere, a is the contact radius, given by \\(a =\\sqrt{R\\delta}\\)\nfor all models except jkr, for which it is given implicitly according\nto \\(\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\).  For damping viscoelastic,\n\\(\\eta_{n0}\\) is in units of 1/(time*distance).\nThe tsuji model is based on the work of (Tsuji et al). Here, the damping coefficient specified as part of\nthe normal model is interpreted as a restitution coefficient\n\\(e\\). The damping constant \\(\\eta_n\\) is given by:\n\n\\[\\eta_n = \\alpha (m_{eff}k_n)^{1/2}\\]\nFor normal contact models based on material parameters, \\(k_n = 4/3Ea\\).  The parameter \\(\\alpha\\) is related to the restitution\ncoefficient e according to:\n\n\\[\\alpha = 1.2728-4.2783e+11.087e^2-22.348e^3+27.467e^4-18.022e^5+4.8218e^6\\]\nThe dimensionless coefficient of restitution \\(e\\) specified as part\nof the normal contact model parameters should be between 0 and 1, but\nno error check is performed on this.\nThe total normal force is computed as the sum of the elastic and\ndamping components:\n\n\\[\\mathbf{F}_n = \\mathbf{F}_{ne} + \\mathbf{F}_{n,damp}\\]\n\nThe pair_coeff command also requires specification of the tangential\ncontact model. The required keyword tangential is expected, followed\nby the model choice and associated parameters. Currently supported\ntangential model choices and their expected parameters are as follows:\n\nlinear_nohistory : \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\nlinear_history : \\(k_t\\), \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\nmindlin : \\(k_t\\) or NULL, \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\nmindlin_rescale : \\(k_t\\) or NULL, \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\n\nHere, \\(x_{\\gamma,t}\\) is a dimensionless multiplier for the normal\ndamping \\(\\eta_n\\) that determines the magnitude of the tangential\ndamping, \\(\\mu_t\\) is the tangential (or sliding) friction\ncoefficient, and \\(k_t\\) is the tangential stiffness coefficient.\nFor tangential linear_nohistory, a simple velocity-dependent Coulomb\nfriction criterion is used, which mimics the behavior of the pair\ngran/hooke style. The tangential force (mathbf{F}_t) is given by:\n\n\\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|\\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\nThe tangential damping force \\(\\mathbf{F}_\\mathrm{t,damp}\\) is given by:\n\n\\[\\mathbf{F}_\\mathrm{t,damp} = -\\eta_t \\mathbf{v}_{t,rel}\\]\nThe tangential damping prefactor \\(\\eta_t\\) is calculated by scaling\nthe normal damping \\(\\eta_n\\) (see above):\n\n\\[\\eta_t = -x_{\\gamma,t} \\eta_n\\]\nThe normal damping prefactor \\(\\eta_n\\) is determined by the choice\nof the damping keyword, as discussed above.  Thus, the damping\nkeyword also affects the tangential damping.  The parameter\n\\(x_{\\gamma,t}\\) is a scaling coefficient. Several works in the\nliterature use \\(x_{\\gamma,t} = 1\\) (Marshall,\nTsuji et al, Silbert et al).  The relative\ntangential velocity at the point of contact is given by\n\\(\\mathbf{v}_{t, rel} = \\mathbf{v}_{t} - (R_i\\Omega_i + R_j\\Omega_j) \\times \\mathbf{n}\\), where \\(\\mathbf{v}_{t} = \\mathbf{v}_r - \\mathbf{v}_r\\cdot\\mathbf{n}{n}\\),\n\\(\\mathbf{v}_r = \\mathbf{v}_j - \\mathbf{v}_i\\).\nThe direction of the applied force is \\(\\mathbf{t} = \\mathbf{v_{t,rel}}/\\|\\mathbf{v_{t,rel}}\\|\\) .\nThe normal force value \\(F_{n0}\\) used to compute the critical force\ndepends on the form of the contact model. For non-cohesive models\n(hertz, hertz/material, hooke), it is given by the magnitude of\nthe normal force:\n\n\\[F_{n0} = \\|\\mathbf{F}_n\\|\\]\nFor cohesive models such as jkr and dmt, the critical force is\nadjusted so that the critical tangential force approaches \\(\\mu_t F_{pulloff}\\), see Marshall, equation 43, and\nThornton.  For both models, \\(F_{n0}\\) takes the\nform:\n\n\\[F_{n0} = \\|\\mathbf{F}_ne + 2 F_{pulloff}\\|\\]\nWhere \\(F_{pulloff} = 3\\pi \\gamma R\\) for jkr, and\n\\(F_{pulloff} = 4\\pi \\gamma R\\) for dmt.\nThe remaining tangential options all use accumulated tangential\ndisplacement (i.e. contact history). This is discussed below in the\ncontext of the linear_history option, but the same treatment of the\naccumulated displacement applies to the other options as well.\nFor tangential linear_history, the tangential force is given by:\n\n\\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|-k_t\\mathbf{\\xi} + \\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\nHere, \\(\\mathbf{\\xi}\\) is the tangential displacement accumulated\nduring the entire duration of the contact:\n\n\\[\\mathbf{\\xi} = \\int_{t0}^t \\mathbf{v}_{t,rel}(\\tau) \\mathrm{d}\\tau\\]\nThis accumulated tangential displacement must be adjusted to account\nfor changes in the frame of reference of the contacting pair of\nparticles during contact. This occurs due to the overall motion of the\ncontacting particles in a rigid-body-like fashion during the duration\nof the contact. There are two modes of motion that are relevant: the\n‘tumbling’ rotation of the contacting pair, which changes the\norientation of the plane in which tangential displacement occurs; and\n‘spinning’ rotation of the contacting pair about the vector connecting\ntheir centers of mass (\\(\\mathbf{n}\\)).  Corrections due to the\nformer mode of motion are made by rotating the accumulated\ndisplacement into the plane that is tangential to the contact vector\nat each step, or equivalently removing any component of the tangential\ndisplacement that lies along \\(\\mathbf{n}\\), and rescaling to\npreserve the magnitude.  This follows the discussion in\nLuding, see equation 17 and relevant discussion in that\nwork:\n\n\\[\\mathbf{\\xi} = \\left(\\mathbf{\\xi'} - (\\mathbf{n} \\cdot \\mathbf{\\xi'})\\mathbf{n}\\right) \\frac{\\|\\mathbf{\\xi'}\\|}{\\|\\mathbf{\\xi'}\\| - \\mathbf{n}\\cdot\\mathbf{\\xi'}}\\]\nHere, \\(\\mathbf{\\xi'}\\) is the accumulated displacement prior to the\ncurrent time step and \\(\\mathbf{\\xi}\\) is the corrected\ndisplacement. Corrections to the displacement due to the second mode\nof motion described above (rotations about \\(\\mathbf{n}\\)) are not\ncurrently implemented, but are expected to be minor for most\nsimulations.\nFurthermore, when the tangential force exceeds the critical force, the\ntangential displacement is re-scaled to match the value for the\ncritical force (see Luding, equation 20 and related\ndiscussion):\n\n\\[\\mathbf{\\xi} = -\\frac{1}{k_t}\\left(\\mu_t F_{n0}\\mathbf{t} + \\mathbf{F}_{t,damp}\\right)\\]\nThe tangential force is added to the total normal force (elastic plus\ndamping) to produce the total force on the particle. The tangential\nforce also acts at the contact point (defined as the center of the\noverlap region) to induce a torque on each particle according to:\n\n\\[\\mathbf{\\tau}_i = -(R_i - 0.5 \\delta) \\mathbf{n} \\times \\mathbf{F}_t\\]\n\n\\[\\mathbf{\\tau}_j = -(R_j - 0.5 \\delta) \\mathbf{n} \\times \\mathbf{F}_t\\]\nFor tangential mindlin, the Mindlin no-slip solution is used, which differs from the linear_history\noption by an additional factor of a, the radius of the contact region. The tangential force is given by:\n\n\\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|-k_t a \\mathbf{\\xi} + \\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\nHere, a is the radius of the contact region, given by \\(a =\\sqrt{R\\delta}\\)\nfor all normal contact models, except for jkr, where it is given\nimplicitly by \\(\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\), see\ndiscussion above. To match the Mindlin solution, one should set \\(k_t = 4G/(2-\\nu)\\), where \\(G\\) is the shear modulus, related to Young’s modulus\n\\(E\\) by \\(G = E/(2(1+\\nu))\\), where \\(\\nu\\) is Poisson’s ratio. This\ncan also be achieved by specifying NULL for \\(k_t\\), in which case a\nnormal contact model that specifies material parameters \\(E\\) and\n\\(\\nu\\) is required (e.g. hertz/material, dmt or jkr). In this\ncase, mixing of the shear modulus for different particle types i and\nj is done according to:\n\n\\[1/G = 2(2-\\nu_i)(1+\\nu_i)/E_i + 2(2-\\nu_j)(1+\\nu_j)/E_j\\]\nThe mindlin_rescale option uses the same form as mindlin, but the\nmagnitude of the tangential displacement is re-scaled as the contact\nunloads, i.e. if \\(a < a_{t_{n-1}}\\):\n\n\\[\\mathbf{\\xi} = \\mathbf{\\xi_{t_{n-1}}} \\frac{a}{a_{t_{n-1}}}\\]\nHere, \\(t_{n-1}\\) indicates the value at the previous time\nstep. This rescaling accounts for the fact that a decrease in the\ncontact area upon unloading leads to the contact being unable to\nsupport the previous tangential loading, and spurious energy is\ncreated without the rescaling above (Walton ). See also\ndiscussion in Thornton et al, 2013 , particularly\nequation 18(b) of that work and associated discussion.\n\nThe optional rolling keyword enables rolling friction, which resists\npure rolling motion of particles. The options currently supported are:\n\nnone\nsds : \\(k_{roll}\\), \\(\\gamma_{roll}\\), \\(\\mu_{roll}\\)\n\nIf the rolling keyword is not specified, the model defaults to none.\nFor rolling sds, rolling friction is computed via a\nspring-dashpot-slider, using a ‘pseudo-force’ formulation, as detailed\nby Luding. Unlike the formulation in\nMarshall, this allows for the required adjustment of\nrolling displacement due to changes in the frame of reference of the\ncontacting pair.  The rolling pseudo-force is computed analogously to\nthe tangential force:\n\n\\[\\mathbf{F}_{roll,0} =  k_{roll} \\mathbf{\\xi}_{roll}  - \\gamma_{roll} \\mathbf{v}_{roll}\\]\nHere, \\(\\mathbf{v}_{roll} = -R(\\mathbf{\\Omega}_i - \\mathbf{\\Omega}_j) \\times \\mathbf{n}\\) is the relative rolling\nvelocity, as given in Wang et al and\nLuding. This differs from the expressions given by Kuhn and Bagi and used in Marshall; see Wang et al for details. The rolling displacement is given by:\n\n\\[\\mathbf{\\xi}_{roll} = \\int_{t_0}^t \\mathbf{v}_{roll} (\\tau) \\mathrm{d} \\tau\\]\nA Coulomb friction criterion truncates the rolling pseudo-force if it\nexceeds a critical value:\n\n\\[\\mathbf{F}_{roll} =  min(\\mu_{roll} F_{n,0}, \\|\\mathbf{F}_{roll,0}\\|)\\mathbf{k}\\]\nHere, \\(\\mathbf{k} = \\mathbf{v}_{roll}/\\|\\mathbf{v}_{roll}\\|\\) is the direction of\nthe pseudo-force.  As with tangential displacement, the rolling\ndisplacement is rescaled when the critical force is exceeded, so that\nthe spring length corresponds the critical force. Additionally, the\ndisplacement is adjusted to account for rotations of the frame of\nreference of the two contacting particles in a manner analogous to the\ntangential displacement.\nThe rolling pseudo-force does not contribute to the total force on\neither particle (hence ‘pseudo’), but acts only to induce an equal and\nopposite torque on each particle, according to:\n\n\\[\\tau_{roll,i} =  R_{eff} \\mathbf{n} \\times \\mathbf{F}_{roll}\\]\n\n\\[\\tau_{roll,j} =  -\\tau_{roll,i}\\]\n\nThe optional twisting keyword enables twisting friction, which\nresists rotation of two contacting particles about the vector\n\\(\\mathbf{n}\\) that connects their centers. The options currently\nsupported are:\n\nnone\nsds : \\(k_{twist}\\), \\(\\gamma_{twist}\\), \\(\\mu_{twist}\\)\nmarshall\n\nIf the twisting keyword is not specified, the model defaults to none.\nFor both twisting sds and twisting marshall, a history-dependent\nspring-dashpot-slider is used to compute the twisting torque. Because\ntwisting displacement is a scalar, there is no need to adjust for\nchanges in the frame of reference due to rotations of the particle\npair. The formulation in Marshall therefore provides\nthe most straightforward treatment:\n\n\\[\\tau_{twist,0} = -k_{twist}\\xi_{twist} - \\gamma_{twist}\\Omega_{twist}\\]\nHere \\(\\xi_{twist} = \\int_{t_0}^t \\Omega_{twist} (\\tau) \\mathrm{d}\\tau\\) is the twisting angular displacement, and\n\\(\\Omega_{twist} = (\\mathbf{\\Omega}_i - \\mathbf{\\Omega}_j) \\cdot \\mathbf{n}\\) is the relative twisting angular velocity. The torque\nis then truncated according to:\n\n\\[\\tau_{twist} = min(\\mu_{twist} F_{n,0}, \\tau_{twist,0})\\]\nSimilar to the sliding and rolling displacement, the angular\ndisplacement is rescaled so that it corresponds to the critical value\nif the twisting torque exceeds this critical value:\n\n\\[\\xi_{twist} = \\frac{1}{k_{twist}} (\\mu_{twist} F_{n,0}sgn(\\Omega_{twist}) - \\gamma_{twist}\\Omega_{twist})\\]\nFor twisting sds, the coefficients \\(k_{twist}, \\gamma_{twist}\\)\nand \\(\\mu_{twist}\\) are simply the user input parameters that follow\nthe twisting sds keywords in the pair_coeff command.\nFor twisting_marshall, the coefficients are expressed in terms of\nsliding friction coefficients, as discussed in\nMarshall (see equations 32 and 33 of that work):\n\n\\[k_{twist} = 0.5k_ta^2\\]\n\n\\[\\eta_{twist} = 0.5\\eta_ta^2\\]\n\n\\[\\mu_{twist} = \\frac{2}{3}a\\mu_t\\]\nFinally, the twisting torque on each particle is given by:\n\n\\[\\mathbf{\\tau}_{twist,i} = \\tau_{twist}\\mathbf{n}\\]\n\n\\[\\mathbf{\\tau}_{twist,j} = -\\mathbf{\\tau}_{twist,i}\\]\n\nThe granular pair style can reproduce the behavior of the\npair gran/* styles with the appropriate settings (some very\nminor differences can be expected due to corrections in\ndisplacement history frame-of-reference, and the application\nof the torque at the center of the contact rather than\nat each particle). The first example above\nis equivalent to pair gran/hooke 1000.0 NULL 50.0 50.0 0.4 1.\nThe second example is equivalent to\npair gran/hooke/history 1000.0 500.0 50.0 50.0 0.4 1.\nThe third example is equivalent to\npair gran/hertz/history 1000.0 500.0 50.0 50.0 0.4 1.\n\nLAMMPS automatically sets pairwise cutoff values for pair_style\ngranular based on particle radii (and in the case of jkr pull-off\ndistances). In the vast majority of situations, this is adequate.\nHowever, a cutoff value can optionally be appended to the pair_style\ngranular command to specify a global cutoff (i.e. a cutoff for all\natom types). Additionally, the optional cutoff keyword can be passed\nto the pair_coeff command, followed by a cutoff value.  This will\nset a pairwise cutoff for the atom types in the pair_coeff command.\nThese options may be useful in some rare cases where the automatic\ncutoff determination is not sufficient, e.g.  if particle diameters\nare being modified via the fix adapt command. In that case, the\nglobal cutoff specified as part of the pair_style granular command\nis applied to all atom types, unless it is overridden for a given atom\ntype combination by the cutoff value specified in the pair coeff\ncommand.  If cutoff is only specified in the pair coeff command\nand no global cutoff is appended to the pair_style granular command,\nthen LAMMPS will use that cutoff for the specified atom type\ncombination, and automatically set pairwise cutoffs for the remaining\natom types.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe pair_modify mix, shift, table, and tail options\nare not relevant for granular pair styles.\nMixing of coefficients is carried out using geometric averaging for\nmost quantities, e.g. if friction coefficient for type 1-type 1\ninteractions is set to \\(\\mu_1\\), and friction coefficient for type\n2-type 2 interactions is set to \\(\\mu_2\\), the friction coefficient\nfor type1-type2 interactions is computed as \\(\\sqrt{\\mu_1\\mu_2}\\)\n(unless explicitly specified to a different value by a pair_coeff 1 2\n… command). The exception to this is elastic modulus, only\napplicable to hertz/material, dmt and jkr normal contact\nmodels. In that case, the effective elastic modulus is computed as:\n\n\\[E_{eff,ij} = \\left(\\frac{1-\\nu_i^2}{E_i} + \\frac{1-\\nu_j^2}{E_j}\\right)^{-1}\\]\nIf the i-j coefficients \\(E_{ij}\\) and \\(\\nu_{ij}\\) are\nexplicitly specified, the effective modulus is computed as:\n\n\\[E_{eff,ij} = \\left(\\frac{1-\\nu_{ij}^2}{E_{ij}} + \\frac{1-\\nu_{ij}^2}{E_{ij}}\\right)^{-1}\\]\nor\n\n\\[E_{eff,ij} = \\frac{E_{ij}}{2(1-\\nu_{ij})}\\]\nThese pair styles write their information to binary restart files, so a pair_style command does not need to be\nspecified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.\nThe single() function of these pair styles returns 0.0 for the energy\nof a pairwise interaction, since energy is not conserved in these\ndissipative potentials.  It also returns only the normal component of\nthe pairwise interaction force.  However, the single() function also\ncalculates 12 extra pairwise quantities.  The first 3 are the\ncomponents of the tangential force between particles I and J, acting\non particle I.  The 4th is the magnitude of this tangential force.\nThe next 3 (5-7) are the components of the rolling torque acting on\nparticle I. The next entry (8) is the magnitude of the rolling torque.\nThe next entry (9) is the magnitude of the twisting torque acting\nabout the vector connecting the two particle centers.\nThe last 3 (10-12) are the components of the vector connecting\nthe centers of the two particles (x_I - x_J).\nThese extra quantities can be accessed by the compute pair/local command, as p1, p2, …,\np12.",
    "syntax": "pair_style granular cutoff",
    "parameters": " * cutoff = global cutoff (optional).  See discussion below.",
    "examples": "pair_style granular\npair_coeff * * hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping mass_velocity\n\npair_style granular\npair_coeff * * hooke 1000.0 50.0 tangential linear_history 500.0 1.0 0.4 damping mass_velocity\n\npair_style granular\npair_coeff * * hertz 1000.0 50.0 tangential mindlin 1000.0 1.0 0.4\n\npair_style granular\npair_coeff * * hertz/material 1e8 0.3 0.3 tangential mindlin_rescale NULL 1.0 0.4 damping tsuji\n\npair_style granular\npair_coeff 1 * jkr 1000.0 500.0 0.3 10 tangential mindlin 800.0 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall\npair_coeff 2 2 hertz 200.0 100.0 tangential linear_history 300.0 1.0 0.1 rolling sds 200.0 100.0 0.1 twisting marshall\n\npair_style granular\npair_coeff 1 1 dmt 1000.0 50.0 0.3 0.0 tangential mindlin NULL 0.5 0.5 rolling sds 500.0 200.0 0.5 twisting marshall\npair_coeff 2 2 dmt 1000.0 50.0 0.3 10.0 tangential mindlin NULL 0.5 0.1 rolling sds 500.0 200.0 0.1 twisting marshall",
    "restrictions": "All the granular pair styles are part of the GRANULAR package.  It is\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair styles require that atoms store torque and angular velocity\n(omega) as defined by the atom_style.  They also\nrequire a per-particle radius is stored.  The sphere atom style does\nall of this.\nThis pair style requires you to use the comm_modify vel yes command so that velocities are stored by ghost\natoms.\nThese pair styles will not restart exactly when using the\nread_restart command, though they should provide\nstatistically similar results.  This is because the forces they\ncompute depend on atom velocities.  See the\nread_restart command for more details."
},
{
    "command": "pair_style lj/gromacs",
    "html_filename": "pair_gromacs.html",
    "short_description": "The lj/gromacs styles compute shifted LJ and Coulombic interactions with an additional switching function S(r) that ramps the energy and force smoothly to zero between an inner and outer cutoff",
    "description": "The lj/gromacs styles compute shifted LJ and Coulombic interactions\nwith an additional switching function S(r) that ramps the energy and force\nsmoothly to zero between an inner and outer cutoff.  It is a commonly\nused potential in the GROMACS MD code and for\nthe coarse-grained models of (Marrink).\n\n\\[\\begin{split}E_{LJ} = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n         \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + S_{LJ}(r)\n                    \\qquad r < r_c \\\\\nE_C  = & \\frac{C q_i q_j}{\\epsilon  r} + S_C(r) \\qquad r < r_c \\\\\nS(r) = & C \\qquad r < r_1 \\\\\nS(r) = & \\frac{A}{3} (r - r_1)^3 + \\frac{B}{4} (r - r_1)^4 + C \\qquad  r_1 < r < r_c \\\\\nA = & (-3 E'(r_c) + (r_c - r_1) E''(r_c))/(r_c - r_1)^2 \\\\\nB = & (2 E'(r_c) - (r_c - r_1) E''(r_c))/(r_c - r_1)^3 \\\\\nC = & -E(r_c) + \\frac{1}{2} (r_c - r_1) E'(r_c) - \\frac{1}{12} (r_c - r_1)^2 E''(r_c)\\end{split}\\]\n\\(r_1\\) is the inner cutoff; \\(r_c\\) is the outer cutoff.  The\ncoefficients A, B, and C are computed by LAMMPS to perform the shifting\nand smoothing.  The function S(r) is actually applied once to each term\nof the LJ formula and once to the Coulombic formula, so there are 2 or 3\nsets of A,B,C coefficients depending on which pair_style is used.  The\nboundary conditions applied to the smoothing function are as follows:\n\\(S'(r_1) = S''(r_1) = 0, S(r_c) = -E(r_c), S'(r_c) = -E'(r_c)\\),\nand \\(S''(r_c) = -E''(r_c)\\), where E(r) is the corresponding term\nin the LJ or Coulombic potential energy function.  Single and double\nprimes denote first and second derivatives with respect to r,\nrespectively.\nThe inner and outer cutoff for the LJ and Coulombic terms can be the\nsame or different depending on whether 2 or 4 arguments are used in\nthe pair_style command.  The inner LJ cutoff must be > 0, but the\ninner Coulombic cutoff can be >= 0.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ninner (distance units)\nouter (distance units)\n\nNote that sigma is defined in the LJ formula as the zero-crossing\ndistance for the potential, not as the energy minimum at \\(2^{1/6} \\sigma\\).\nThe last 2 coefficients are optional inner and outer cutoffs for style\nlj/gromacs.  If not specified, the global inner and outer values\nare used.\nThe last 2 coefficients cannot be used with style\nlj/gromacs/coul/gromacs because this force field does not allow\nvarying cutoffs for individual atom pairs; all pairs use the global\ncutoff(s) specified in the pair_style command.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/cut pair styles can be mixed.\nThe default mix value is geometric.  See the “pair_modify” command\nfor details.\nNone of the GROMACS pair styles support the\npair_modify shift option, since the Lennard-Jones\nportion of the pair interaction is already smoothed to 0.0 at the\ncutoff.\nThe pair_modify table option is not relevant\nfor this pair style.\nNone of the GROMACS pair styles support the\npair_modify tail option for adding long-range tail\ncorrections to energy and pressure, since there are no corrections for\na potential that goes to 0.0 at the cutoff.\nAll of the GROMACS pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\nnot need to be specified in an input script that reads a restart file.\nAll of the GROMACS pair styles can only be used via the pair\nkeyword of the run_style respa command.  They do not\nsupport the inner, middle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/gromacs or lj/gromacs/coul/gromacs\n * args = list of arguments for a particular style\n * lj/gromacs args = inner outer\n *   inner, outer = global switching cutoffs for Lennard Jones\n * lj/gromacs/coul/gromacs args = inner outer (inner2) (outer2)\n *   inner, outer = global switching cutoffs for Lennard Jones (and Coulombic if only 2 args)\n *   inner2, outer2 = global switching cutoffs for Coulombic (optional)",
    "examples": "pair_style lj/gromacs 9.0 12.0\npair_coeff * * 100.0 2.0\npair_coeff 2 2 100.0 2.0 8.0 10.0\n\npair_style lj/gromacs/coul/gromacs 9.0 12.0\npair_style lj/gromacs/coul/gromacs 8.0 10.0 7.0 9.0\npair_coeff * * 100.0 2.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style gw",
    "html_filename": "pair_gw.html",
    "short_description": "The gw style computes a 3-body Gao-Weber potential; similarly gw/zbl combines this potential with a modified repulsive ZBL core function in a similar fashion as implemented in the tersoff/zbl pair style",
    "description": "The gw style computes a 3-body Gao-Weber potential;\nsimilarly gw/zbl combines this potential with a modified\nrepulsive ZBL core function in a similar fashion as implemented\nin the tersoff/zbl pair style.\nUnfortunately the author of this contributed code has not been\nable to submit a suitable documentation explaining the details\nof the potentials. The LAMMPS developers thus have finally decided\nto release the code anyway with only the technical explanations.\nFor details of the model and the parameters, please refer to the\nlinked publication.\nOnly a single pair_coeff command is used with the gw and gw/zbl\nstyles which specifies a Gao-Weber potential file with parameters\nfor all needed elements.  These are mapped to LAMMPS atom types by\nspecifying N additional arguments after the filename in the pair_coeff\ncommand, where N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of GW elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine a file SiC.gw has Gao-Weber values for Si and C.\nIf your LAMMPS simulation has 4 atoms types and you want the first 3 to\nbe Si, and the 4th to be C, you would use the following pair_coeff command:\npair_coeff * * SiC.gw Si Si Si C\n\n\nThe first 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the GW file.  The final C argument maps LAMMPS atom type 4\nto the C element in the GW file.  If a mapping value is specified as\nNULL, the mapping is not performed.  This can be used when a gw\npotential is used as part of the hybrid pair style.  The NULL values\nare placeholders for atom types that will be used with other\npotentials.\nGao-Weber files in the potentials directory of the LAMMPS\ndistribution have a “.gw” suffix.  Gao-Weber with ZBL files\nhave a “.gz.zbl” suffix. The structure of the potential files\nis similar to other many-body potentials supported by LAMMPS.\nYou have to refer to the comments in the files and the literature\nto learn more details.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style",
    "parameters": " * style = gw or gw/zbl",
    "examples": "pair_style gw\npair_coeff * * SiC.gw Si C C\n\npair_style gw/zbl\npair_coeff * * SiC.gw.zbl C Si",
    "restrictions": "This pair style is part of the MANYBODY package. It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe Gao-Weber potential files provided with LAMMPS (see the\npotentials directory) are parameterized for metal units.\nYou can use the GW potential with any LAMMPS units, but you would need\nto create your own GW potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style hbond/dreiding/lj",
    "html_filename": "pair_hbond_dreiding.html",
    "short_description": "The hbond/dreiding styles compute the Acceptor-Hydrogen-Donor (AHD) 3-body hydrogen bond interaction for the DREIDING force field, given by:  \\[\\begin{split}E  = & \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\    = & S(r) * \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\    = & 0 \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\ LJ(r)  = & AR^{-12}-BR^{-10}cos^n\\theta=       \\epsilon\\left\\lbrace 5\\left[ \\frac{\\sigma}{r}\\right]^{12}-       6\\left[ \\frac{\\sigma}{r}\\right]^{10}  \\right\\rbrace cos^n\\theta\\\\ Morse(r)  = & D_0\\left\\lbrace \\chi^2 - 2\\chi\\right\\rbrace cos^n\\theta=       D_{0}\\left\\lbrace e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)}       \\right\\rbrace cos^n\\theta \\\\ S(r)  = & \\frac{ \\left[r_{\\rm out}^2 - r^2\\right]^2 \\left[r_{\\rm out}^2 + 2r^2 - 3{r_{\\rm in}^2}\\right]} { \\left[r_{\\rm out}^2 - {r_{\\rm in}}^2\\right]^3 }\\end{split}\\] where \\(r_{\\rm in}\\) is the inner spline distance cutoff, \\(r_{\\rm out}\\) is the outer distance cutoff, \\(\\theta_c\\) is the angle cutoff, and n is the cosine periodicity",
    "description": "The hbond/dreiding styles compute the Acceptor-Hydrogen-Donor (AHD)\n3-body hydrogen bond interaction for the DREIDING\nforce field, given by:\n\n\\[\\begin{split}E  = & \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n   = & S(r) * \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n   = & 0 \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\nLJ(r)  = & AR^{-12}-BR^{-10}cos^n\\theta=\n      \\epsilon\\left\\lbrace 5\\left[ \\frac{\\sigma}{r}\\right]^{12}-\n      6\\left[ \\frac{\\sigma}{r}\\right]^{10}  \\right\\rbrace cos^n\\theta\\\\\nMorse(r)  = & D_0\\left\\lbrace \\chi^2 - 2\\chi\\right\\rbrace cos^n\\theta=\n      D_{0}\\left\\lbrace e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)}\n      \\right\\rbrace cos^n\\theta \\\\\nS(r)  = & \\frac{ \\left[r_{\\rm out}^2 - r^2\\right]^2\n\\left[r_{\\rm out}^2 + 2r^2 - 3{r_{\\rm in}^2}\\right]}\n{ \\left[r_{\\rm out}^2 - {r_{\\rm in}}^2\\right]^3 }\\end{split}\\]\nwhere \\(r_{\\rm in}\\) is the inner spline distance cutoff,\n\\(r_{\\rm out}\\) is the outer distance cutoff, \\(\\theta_c\\) is\nthe angle cutoff, and n is the cosine periodicity.\nHere, r is the radial distance between the donor (D) and acceptor\n(A) atoms and \\(\\theta\\) is the bond angle between the acceptor, the\nhydrogen (H) and the donor atoms:\n\nThese 3-body interactions can be defined for pairs of acceptor and\ndonor atoms, based on atom types.  For each donor/acceptor atom pair,\nthe 3rd atom in the interaction is a hydrogen permanently bonded to\nthe donor atom, e.g. in a bond list read in from a data file via the\nread_data command.  The atom types of possible\nhydrogen atoms for each donor/acceptor type pair are specified by the\npair_coeff command (see below).\nStyle hbond/dreiding/lj is the original DREIDING potential of\n(Mayo).  It uses a LJ 12/10 functional for the Donor-Acceptor\ninteractions. To match the results in the original paper, use n = 4.\nStyle hbond/dreiding/morse is an improved version using a Morse\npotential for the Donor-Acceptor interactions. (Liu) showed\nthat the Morse form gives improved results for Dendrimer simulations,\nwhen n = 2.\nSee the Howto bioFF doc page for more information\non the DREIDING force field.\n\nNote\nBecause the Dreiding hydrogen bond potential is only one portion\nof an overall force field which typically includes other pairwise\ninteractions, it is common to use it as a sub-style in a pair_style hybrid/overlay command, where another pair style\nprovides the repulsive core interaction between pairs of atoms, e.g. a\n1/r^12 Lennard-Jones repulsion.\n\n\nNote\nWhen using the hbond/dreiding pair styles with pair_style hybrid/overlay, you should explicitly define pair\ninteractions between the donor atom and acceptor atoms, (as well as\nbetween these atoms and ALL other atoms in your system).  Whenever\npair_style hybrid/overlay is used, ordinary mixing\nrules are not applied to atoms like the donor and acceptor atoms\nbecause they are typically referenced in multiple pair styles.\nNeglecting to do this can cause difficult-to-detect physics problems.\n\n\nNote\nIn the original Dreiding force field paper 1-4 non-bonded\ninteractions ARE allowed.  If this is desired for your model, use the\nspecial_bonds command (e.g. “special_bonds lj 0.0 0.0 1.0”) to turn\nthese interactions on.\n\n\nThe following coefficients must be defined for pairs of eligible\ndonor/acceptor types via the pair_coeff command as\nin the examples above.\n\nNote\nUnlike other pair styles and their associated\npair_coeff commands, you do not need to specify\npair_coeff settings for all possible I,J type pairs.  Only I,J type\npairs for atoms which act as joint donors/acceptors need to be\nspecified; all other type pairs are assumed to be inactive.\n\n\nNote\nA pair_coeff command can be specified multiple\ntimes for the same donor/acceptor type pair.  This enables multiple\nhydrogen types to be assigned to the same donor/acceptor type pair.\nFor other pair_styles, if the pair_coeff command is re-used for the\nsame I.J type pair, the settings for that type pair are overwritten.\nFor the hydrogen bond potentials this is not the case; the settings\nare cumulative.  This means the only way to turn off a previous\nsetting, is to re-use the pair_style command and start over.\n\nFor the hbond/dreiding/lj style the list of coefficients is as\nfollows:\n\nK = hydrogen atom type = 1 to Ntypes\ndonor flag = i or j\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\nn = exponent in formula above\ndistance cutoff \\(r_{\\rm in}\\) (distance units)\ndistance cutoff \\(r_{\\rm out}\\) (distance units)\nangle cutoff (degrees)\n\nFor the hbond/dreiding/morse style the list of coefficients is as\nfollows:\n\nK = hydrogen atom type = 1 to Ntypes\ndonor flag = i or j\n\\(D_0\\) (energy units)\n\\(\\alpha\\) (1/distance units)\n\\(r_0\\) (distance units)\nn = exponent in formula above\ndistance cutoff \\(r_{\\rm in}\\) (distance units)\ndistance cutoff \\(r_{out}\\) (distance units)\nangle cutoff (degrees)\n\nA single hydrogen atom type K can be specified, or a wild-card asterisk\ncan be used in place of or in conjunction with the K arguments to\nselect multiple types as hydrogen atoms.  This takes the form\n“*” or “*n” or “n*” or “m*n”.  See the pair_coeff\ncommand doc page for details.\nIf the donor flag is i, then the atom of type I in the pair_coeff\ncommand is treated as the donor, and J is the acceptor.  If the donor\nflag is j, then the atom of type J in the pair_coeff command is\ntreated as the donor and I is the donor.  This option is required\nbecause the pair_coeff command requires that I <= J.\n\\(\\epsilon\\) and \\(\\sigma\\) are settings for the hydrogen bond\npotential based on a Lennard-Jones functional form.  Note that sigma is\ndefined as the zero-crossing distance for the potential, not as the\nenergy minimum at \\(2^{1/6} \\sigma\\).\n\\(D_0\\) and \\(\\alpha\\) and \\(r_0\\) are settings for the\nhydrogen bond potential based on a Morse functional form.\nThe last 3 coefficients for both styles are optional.  If not\nspecified, the global n, distance cutoff, and angle cutoff specified\nin the pair_style command are used.  If you wish to only override the\n2nd or 3rd optional parameter, you must also specify the preceding\noptional parameters.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing. You must explicitly identify\neach donor/acceptor type pair.\nThese styles do not support the pair_modify shift\noption for the energy of the interactions.\nThe pair_modify table option is not relevant for\nthese pair styles.\nThese pair styles do not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThese pair styles do not write their information to binary restart files, so pair_style and pair_coeff commands need to be\nre-specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.\nThese pair styles tally a count of how many hydrogen bonding\ninteractions they calculate each timestep and the hbond energy.  These\nquantities can be accessed via the compute pair\ncommand as a vector of values of length 2.\nTo print these quantities to the log file (with a descriptive column\nheading) the following commands could be included in an input script:\ncompute hb all pair hbond/dreiding/lj\nvariable n_hbond equal c_hb[1] #number hbonds\nvariable E_hbond equal c_hb[2] #hbond energy\nthermo_style custom step temp epair v_E_hbond",
    "syntax": "pair_style style N inner_distance_cutoff outer_distance_cutoff angle_cutof",
    "parameters": " * style = hbond/dreiding/lj or hbond/dreiding/morse\n * n = cosine angle periodicity\n * inner_distance_cutoff = global inner cutoff for Donor-Acceptor interactions (distance units)\n * outer_distance_cutoff = global cutoff for Donor-Acceptor interactions (distance units)\n * angle_cutoff = global angle cutoff for Acceptor-Hydrogen-Donor\n * interactions (degrees)",
    "examples": "pair_style hybrid/overlay lj/cut 10.0 hbond/dreiding/lj 4 9.0 11.0 90\npair_coeff 1 2 hbond/dreiding/lj 3 i 9.5 2.75 4 9.0 11.0 90.0\n\npair_style hybrid/overlay lj/cut 10.0 hbond/dreiding/morse 2 9.0 11.0 90\npair_coeff 1 2 hbond/dreiding/morse 3 i 3.88 1.7241379 2.9 2 9 11 90",
    "restrictions": "\nnone"
},
{
    "command": "pair_style hybrid",
    "html_filename": "pair_hybrid.html",
    "short_description": "The hybrid and hybrid/overlay styles enable the use of multiple pair styles in one simulation",
    "description": "The hybrid and hybrid/overlay styles enable the use of multiple\npair styles in one simulation.  With the hybrid style, exactly one\npair style is assigned to each pair of atom types.  With the\nhybrid/overlay style, one or more pair styles can be assigned to\neach pair of atom types.  The assignment of pair styles to type pairs\nis made via the pair_coeff command.\nHere are two examples of hybrid simulations.  The hybrid style could\nbe used for a simulation of a metal droplet on a LJ surface.  The\nmetal atoms interact with each other via an eam potential, the\nsurface atoms interact with each other via a lj/cut potential, and\nthe metal/surface interaction is also computed via a lj/cut\npotential.  The hybrid/overlay style could be used as in the 2nd\nexample above, where multiple potentials are superposed in an additive\nfashion to compute the interaction between atoms.  In this example,\nusing lj/cut and coul/long together gives the same result as if\nthe lj/cut/coul/long potential were used by itself.  In this case,\nit would be more efficient to use the single combined potential, but\nin general any combination of pair potentials can be used together in\nto produce an interaction that is not encoded in any single pair_style\nfile, e.g. adding Coulombic forces between granular particles.\nAll pair styles that will be used are listed as “sub-styles” following\nthe hybrid or hybrid/overlay keyword, in any order.  Each\nsub-style’s name is followed by its usual arguments, as illustrated in\nthe example above.  See the doc pages of individual pair styles for a\nlisting and explanation of the appropriate arguments.\nNote that an individual pair style can be used multiple times as a\nsub-style.  For efficiency this should only be done if your model\nrequires it.  E.g. if you have different regions of Si and C atoms and\nwish to use a Tersoff potential for pure Si for one set of atoms, and\na Tersoff potential for pure C for the other set (presumably with some\n3rd potential for Si-C interactions), then the sub-style tersoff\ncould be listed twice.  But if you just want to use a Lennard-Jones or\nother pairwise potential for several different atom type pairs in your\nmodel, then you should just list the sub-style once and use the\npair_coeff command to assign parameters for the different type pairs.\n\nNote\nThere is one exception to this option to list an individual\npair style multiple times: GPU-enabled pair styles in the GPU package.\nThis is because the GPU package currently assumes that only one\ninstance of a pair style is being used.\n\nIn the pair_coeff commands, the name of a pair style must be added\nafter the I,J type specification, with the remaining coefficients\nbeing those appropriate to that style.  If the pair style is used\nmultiple times in the pair_style command, then an additional numeric\nargument must also be specified which is a number from 1 to M where M\nis the number of times the sub-style was listed in the pair style\ncommand.  The extra number indicates which instance of the sub-style\nthese coefficients apply to.\nFor example, consider a simulation with 3 atom types: types 1 and 2\nare Ni atoms, type 3 are LJ atoms with charges.  The following\ncommands would set up a hybrid simulation:\npair_style hybrid eam/alloy lj/cut/coul/cut 10.0 lj/cut 8.0\npair_coeff * * eam/alloy nialhjea Ni Ni NULL\npair_coeff 3 3 lj/cut/coul/cut 1.0 1.0\npair_coeff 1*2 3 lj/cut 0.8 1.3\n\n\nAs an example of using the same pair style multiple times, consider a\nsimulation with 2 atom types.  Type 1 is Si, type 2 is C.  The\nfollowing commands would model the Si atoms with Tersoff, the C atoms\nwith Tersoff, and the cross-interactions with Lennard-Jones:\npair_style hybrid lj/cut 2.5 tersoff tersoff\npair_coeff * * tersoff 1 Si.tersoff Si NULL\npair_coeff * * tersoff 2 C.tersoff NULL C\npair_coeff 1 2 lj/cut 1.0 1.5\n\n\nIf pair coefficients are specified in the data file read via the\nread_data command, then the same rule applies.\nE.g. “eam/alloy” or “lj/cut” must be added after the atom type, for\neach line in the “Pair Coeffs” section, e.g.\nPair Coeffs\n\n1 lj/cut/coul/cut 1.0 1.0\n...\n\n\nNote that the pair_coeff command for some potentials such as\npair_style eam/alloy includes a mapping specification\nof elements to all atom types, which in the hybrid case, can include\natom types not assigned to the eam/alloy potential.  The NULL\nkeyword is used by many such potentials (eam/alloy, Tersoff, AIREBO,\netc), to denote an atom type that will be assigned to a different\nsub-style.\nFor the hybrid style, each atom type pair I,J is assigned to exactly\none sub-style.  Just as with a simulation using a single pair style,\nif you specify the same atom type pair in a second pair_coeff command,\nthe previous assignment will be overwritten.\nFor the hybrid/overlay style, each atom type pair I,J can be\nassigned to one or more sub-styles.  If you specify the same atom type\npair in a second pair_coeff command with a new sub-style, then the\nsecond sub-style is added to the list of potentials that will be\ncalculated for two interacting atoms of those types.  If you specify\nthe same atom type pair in a second pair_coeff command with a\nsub-style that has already been defined for that pair of atoms, then\nthe new pair coefficients simply override the previous ones, as in the\nnormal usage of the pair_coeff command.  E.g. these two sets of\ncommands are the same:\npair_style lj/cut 2.5\npair_coeff * * 1.0 1.0\npair_coeff 2 2 1.5 0.8\n\npair_style hybrid/overlay lj/cut 2.5\npair_coeff * * lj/cut 1.0 1.0\npair_coeff 2 2 lj/cut 1.5 0.8\n\n\nCoefficients must be defined for each pair of atoms types via the\npair_coeff command as described above, or in the\ndata file or restart files read by the read_data or\nread_restart commands, or by mixing as described\nbelow.\nFor both the hybrid and hybrid/overlay styles, every atom type\npair I,J (where I <= J) must be assigned to at least one sub-style via\nthe pair_coeff command as in the examples above, or\nin the data file read by the read_data, or by mixing\nas described below.\nIf you want there to be no interactions between a particular pair of\natom types, you have 3 choices.  You can assign the type pair to some\nsub-style and use the neigh_modify exclude type\ncommand.  You can assign it to some sub-style and set the coefficients\nso that there is effectively no interaction (e.g. epsilon = 0.0 in a\nLJ potential).  Or, for hybrid and hybrid/overlay simulations, you\ncan use this form of the pair_coeff command in your input script:\npair_coeff        2 3 none\n\n\nor this form in the “Pair Coeffs” section of the data file:\n3 none\n\n\nIf an assignment to none is made in a simulation with the\nhybrid/overlay pair style, it wipes out all previous assignments of\nthat atom type pair to sub-styles.\nNote that you may need to use an atom_style hybrid\ncommand in your input script, if atoms in the simulation will need\nattributes from several atom styles, due to using multiple pair\npotentials.\n\nDifferent force fields (e.g. CHARMM vs AMBER) may have different rules\nfor applying weightings that change the strength of pairwise\ninteractions between pairs of atoms that are also 1-2, 1-3, and 1-4\nneighbors in the molecular bond topology, as normally set by the\nspecial_bonds command.  Different weights can be\nassigned to different pair hybrid sub-styles via the pair_modify special command. This allows multiple force fields\nto be used in a model of a hybrid system, however, there is no consistent\napproach to determine parameters automatically for the interactions\nbetween the two force fields, this is only recommended when particles\ndescribed by the different force fields do not mix.\nHere is an example for mixing CHARMM and AMBER: The global amber\nsetting sets the 1-4 interactions to non-zero scaling factors and\nthen overrides them with 0.0 only for CHARMM:\nspecial_bonds amber\npair_hybrid lj/charmm/coul/long 8.0 10.0 lj/cut/coul/long 10.0\npair_modify pair lj/charmm/coul/long special lj/coul 0.0 0.0 0.0\n\n\nThe this input achieves the same effect:\nspecial_bonds 0.0 0.0 0.1\npair_hybrid lj/charmm/coul/long 8.0 10.0 lj/cut/coul/long 10.0\npair_modify pair lj/cut/coul/long special lj 0.0 0.0 0.5\npair_modify pair lj/cut/coul/long special coul 0.0 0.0 0.83333333\npair_modify pair lj/charmm/coul/long special lj/coul 0.0 0.0 0.0\n\n\nHere is an example for mixing Tersoff with OPLS/AA based on\na data file that defines bonds for all atoms where for the\nTersoff part of the system the force constants for the bonded\ninteractions have been set to 0. Note the global settings are\neffectively lj/coul 0.0 0.0 0.5 as required for OPLS/AA:\nspecial_bonds lj/coul 1e-20 1e-20 0.5\npair_hybrid tersoff lj/cut/coul/long 12.0\npair_modify pair tersoff special lj/coul 1.0 1.0 1.0\n\n\nFor use with the various compute */tally\ncomputes, the pair_modify compute/tally\ncommand can be used to selectively turn off processing of\nthe compute tally styles, for example, if those pair styles\n(e.g. many-body styles) do not support this feature.\nSee the pair_modify doc page for details on\nthe specific syntax, requirements and restrictions.\n\nThe potential energy contribution to the overall system due to an\nindividual sub-style can be accessed and output via the compute pair command.\n\n\nNote\nSeveral of the potentials defined via the pair_style command in\nLAMMPS are really many-body potentials, such as Tersoff, AIREBO, MEAM,\nReaxFF, etc.  The way to think about using these potentials in a\nhybrid setting is as follows.\n\nA subset of atom types is assigned to the many-body potential with a\nsingle pair_coeff command, using “* *” to include\nall types and the NULL keywords described above to exclude specific\ntypes not assigned to that potential.  If types 1,3,4 were assigned in\nthat way (but not type 2), this means that all many-body interactions\nbetween all atoms of types 1,3,4 will be computed by that potential.\nPair_style hybrid allows interactions between type pairs 2-2, 1-2,\n2-3, 2-4 to be specified for computation by other pair styles.  You\ncould even add a second interaction for 1-1 to be computed by another\npair style, assuming pair_style hybrid/overlay is used.\nBut you should not, as a general rule, attempt to exclude the\nmany-body interactions for some subset of the type pairs within the\nset of 1,3,4 interactions, e.g. exclude 1-1 or 1-3 interactions.  That\nis not conceptually well-defined for many-body interactions, since the\npotential will typically calculate energies and foces for small groups\nof atoms, e.g. 3 or 4 atoms, using the neighbor lists of the atoms to\nfind the additional atoms in the group.  It is typically non-physical\nto think of excluding an interaction between a particular pair of\natoms when the potential computes 3-body or 4-body interactions.\nHowever, you can still use the pair_coeff none setting or the\nneigh_modify exclude command to exclude certain\ntype pairs from the neighbor list that will be passed to a many-body\nsub-style.  This will alter the calculations made by a many-body\npotential, since it builds its list of 3-body, 4-body, etc\ninteractions from the pair list.  You will need to think carefully as\nto whether it produces a physically meaningful result for your model.\nFor example, imagine you have two atom types in your model, type 1 for\natoms in one surface, and type 2 for atoms in the other, and you wish\nto use a Tersoff potential to compute interactions within each\nsurface, but not between surfaces.  Then either of these two command\nsequences would implement that model:\npair_style hybrid tersoff\npair_coeff * * tersoff SiC.tersoff C C\npair_coeff 1 2 none\n\npair_style tersoff\npair_coeff * * SiC.tersoff C C\nneigh_modify exclude type 1 2\n\n\nEither way, only neighbor lists with 1-1 or 2-2 interactions would be\npassed to the Tersoff potential, which means it would compute no\n3-body interactions containing both type 1 and 2 atoms.\nHere is another example, using hybrid/overlay, to use 2 many-body\npotentials together, in an overlapping manner.  Imagine you have CNT\n(C atoms) on a Si surface.  You want to use Tersoff for Si/Si and Si/C\ninteractions, and AIREBO for C/C interactions.  Si atoms are type 1; C\natoms are type 2.  Something like this will work:\npair_style hybrid/overlay tersoff airebo 3.0\npair_coeff * * tersoff SiC.tersoff.custom Si C\npair_coeff * * airebo CH.airebo NULL C\n\n\nNote that to prevent the Tersoff potential from computing C/C\ninteractions, you would need to modify the SiC.tersoff file to turn\noff C/C interaction, i.e. by setting the appropriate coefficients to\n0.0.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.\nSince the hybrid and hybrid/overlay styles delegate computation to\nthe individual sub-styles, the suffix versions of the hybrid and\nhybrid/overlay styles are used to propagate the corresponding suffix\nto all sub-styles, if those versions exist. Otherwise the\nnon-accelerated version will be used.\nThe individual accelerated sub-styles are part of the GPU, USER-OMP\nand OPT packages, respectively.  They are only enabled if LAMMPS was\nbuilt with those packages.  See the Build package\ndoc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nAny pair potential settings made via the\npair_modify command are passed along to all\nsub-styles of the hybrid potential.\nFor atom type pairs I,J and I != J, if the sub-style assigned to I,I\nand J,J is the same, and if the sub-style allows for mixing, then the\ncoefficients for I,J can be mixed.  This means you do not have to\nspecify a pair_coeff command for I,J since the I,J type pair will be\nassigned automatically to the sub-style defined for both I,I and J,J\nand its coefficients generated by the mixing rule used by that\nsub-style.  For the hybrid/overlay style, there is an additional\nrequirement that both the I,I and J,J pairs are assigned to a single\nsub-style.  See the “pair_modify” command for details of mixing rules.\nSee the See the doc page for the sub-style to see if allows for\nmixing.\nThe hybrid pair styles supports the pair_modify\nshift, table, and tail options for an I,J pair interaction, if the\nassociated sub-style supports it.\nFor the hybrid pair styles, the list of sub-styles and their\nrespective settings are written to binary restart files, so a pair_style command does\nnot need to specified in an input script that reads a restart file.\nHowever, the coefficient information is not stored in the restart\nfile.  Thus, pair_coeff commands need to be re-specified in the\nrestart input script.\nThese pair styles support the use of the inner, middle, and\nouter keywords of the run_style respa command, if\ntheir sub-styles do.",
    "syntax": "pair_style hybrid style1 args style2 args ...",
    "parameters": " * pair_style hybrid/overlay style1 args style2 args ...\n * style1,style2 = list of one or more pair styles and their arguments",
    "examples": "pair_style hybrid lj/cut/coul/cut 10.0 eam lj/cut 5.0\npair_coeff 1*2 1*2 eam niu3\npair_coeff 3 3 lj/cut/coul/cut 1.0 1.0\npair_coeff 1*2 3 lj/cut 0.5 1.2\n\npair_style hybrid/overlay lj/cut 2.5 coul/long 2.0\npair_coeff * * lj/cut 1.0 1.0\npair_coeff * * coul/long",
    "restrictions": "When using a long-range Coulombic solver (via the\nkspace_style command) with a hybrid pair_style,\none or more sub-styles will be of the “long” variety,\ne.g. lj/cut/coul/long or buck/coul/long.  You must insure that the\nshort-range Coulombic cutoff used by each of these long pair styles is\nthe same or else LAMMPS will generate an error."
},
{
    "command": "pair_style ilp/graphene/hbn",
    "html_filename": "pair_ilp_graphene_hbn.html",
    "short_description": "The ilp/graphene/hbn style computes the registry-dependent interlayer potential (ILP) potential as described in (Leven1), (Leven2) and (Maaravi)",
    "description": "The ilp/graphene/hbn style computes the registry-dependent interlayer\npotential (ILP) potential as described in (Leven1),\n(Leven2) and (Maaravi).\nThe normals are calculated in the way as described\nin (Kolmogorov).\n\n\\[\\begin{split}E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\nV_{ij}  = & {\\rm Tap}(r_{ij})\\left \\{ e^{-\\alpha (r_{ij}/\\beta -1)}\n             \\left [ \\epsilon + f(\\rho_{ij}) + f(\\rho_{ji})\\right ] -\n              \\frac{1}{1+e^{-d\\left [ \\left ( r_{ij}/\\left (s_R \\cdot r^{eff} \\right ) \\right )-1 \\right ]}}\n              \\cdot \\frac{C_6}{r^6_{ij}} \\right \\}\\\\\n\\rho_{ij}^2 = & r_{ij}^2 - ({\\bf r}_{ij} \\cdot {\\bf n}_i)^2 \\\\\n\\rho_{ji}^2  = & r_{ij}^2 - ({\\bf r}_{ij} \\cdot {\\bf n}_j)^2 \\\\\nf(\\rho)  = &  C e^{ -( \\rho / \\delta )^2 } \\\\\n{\\rm Tap}(r_{ij})  = & 20\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^7 -\n                        70\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^6 +\n                        84\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^5 -\n                        35\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^4 + 1\\end{split}\\]\nWhere \\(\\mathrm{Tap}(r_{ij})\\) is the taper function which provides\na continuous cutoff (up to third derivative) for interatomic separations\nlarger than \\(r_c\\) (Maaravi). The definitions of\neach parameter in the above equation can be found in (Leven1) and (Maaravi).\nIt is important to include all the pairs to build the neighbor list for\ncalculating the normals.\n\nNote\nThis potential (ILP) is intended for interlayer interactions between two\ndifferent layers of graphene, hexagonal boron nitride (h-BN) and their hetero-junction.\nTo perform a realistic simulation, this potential must be used in combination with\nintralayer potential, such as AIREBO or Tersoff potential.\nTo keep the intralayer properties unaffected, the interlayer interaction\nwithin the same layers should be avoided. Hence, each atom has to have a layer\nidentifier such that atoms residing on the same layer interact via the\nappropriate intralayer potential and atoms residing on different layers\ninteract via the ILP. Here, the molecule id is chosen as the layer identifier,\nthus a data file with the “full” atom style is required to use this potential.\n\nThe parameter file (e.g. BNCH.ILP), is intended for use with metal\nunits, with energies in meV. Two additional parameters,\nS, and rcut are included in the parameter file. S is designed to\nfacilitate scaling of energies. rcut is designed to build the neighbor\nlist for calculating the normals for each atom pair.\n\nNote\nThe parameters presented in the parameter file (e.g. BNCH.ILP),\nare fitted with taper function by setting the cutoff equal to 16.0\nAngstrom.  Using different cutoff or taper function should be careful.\nThe parameters for atoms pairs between Boron and Nitrogen are fitted with\na screened Coulomb interaction coul/shield. Therefore,\nto simulated the properties of h-BN correctly, this potential must be used in\ncombination with the pair style coul/shield.\n\n\nNote\nFour new sets of parameters of ILP for 2D layered Materials with bilayer and\nbulk configurations are presented in (Ouyang1) and (Ouyang2), respectively.\nThese parameters provide a good description in both short- and long-range interaction regimes.\nWhile the old ILP parameters published in (Leven2) and\n(Maaravi) are only suitable for long-range interaction\nregime. This feature is essential for simulations in high pressure\nregime (i.e., the interlayer distance is smaller than the equilibrium\ndistance). The benchmark tests and comparison of these parameters can\nbe found in (Ouyang1) and (Ouyang2).\n\nThis potential must be used in combination with hybrid/overlay.\nOther interactions can be set to zero using pair_style none.\nThis pair style tallies a breakdown of the total interlayer potential\nenergy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 2.\nThe 2 values correspond to the following sub-categories:\n\nE_vdW = vdW (attractive) energy\nE_Rep = Repulsive energy\n\nTo print these quantities to the log file (with descriptive column\nheadings) the following commands could be included in an input script:\ncompute 0 all pair ilp/graphene/hbn\nvariable Evdw  equal c_0[1]\nvariable Erep  equal c_0[2]\nthermo_style custom step temp epair v_Erep v_Evdw\n\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify mix, shift, table, and\ntail options.\nThis pair style does not write their information to binary restart\nfiles, since it is stored in potential files. Thus, you need to\nre-specify the pair_style and pair_coeff commands in an input script\nthat reads a restart file.",
    "syntax": "pair_style [hybrid/overlay ...] ilp/graphene/hbn cutoff tap_flag",
    "parameters": " * cutoff = global cutoff (distance units)\n * tap_flag = 0/1 to turn off/on the taper function",
    "examples": "pair_style  hybrid/overlay ilp/graphene/hbn 16.0 1\npair_coeff  * * ilp/graphene/hbn  BNCH.ILP B N C\n\npair_style  hybrid/overlay rebo tersoff ilp/graphene/hbn 16.0 coul/shield 16.0\npair_coeff  * * rebo              CH.rebo     NULL NULL C\npair_coeff  * * tersoff           BNC.tersoff B    N    NULL\npair_coeff  * * ilp/graphene/hbn  BNCH.ILP    B    N    C\npair_coeff  1 1 coul/shield 0.70\npair_coeff  1 2 coul/shield 0.695\npair_coeff  2 2 coul/shield 0.69",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair potential requires the newton setting to be on for pair\ninteractions.\nThe BNCH.ILP potential file provided with LAMMPS (see the potentials\ndirectory) are parameterized for metal units.  You can use this\npotential with any LAMMPS units, but you would need to create your\nBNCH.ILP potential file with coefficients listed in the appropriate\nunits, if your simulation does not use metal units."
},
{
    "command": "pair_style kim",
    "html_filename": "pair_kim.html",
    "short_description": "This pair style is a wrapper on the Open Knowledgebase of Interatomic Models (OpenKIM) repository of interatomic potentials to enable their use in LAMMPS scripts",
    "description": "This pair style is a wrapper on the Open Knowledgebase of Interatomic Models (OpenKIM) repository of interatomic\npotentials to enable their use in LAMMPS scripts.\nThe preferred interface for using interatomic models archived in\nOpenKIM is the kim_commands interface. That\ninterface supports both “KIM Portable Models” (PMs) that conform to the\nKIM API Portable Model Interface (PMI) and can be used by any\nsimulation code that conforms to the KIM API/PMI, and\n“KIM Simulator Models” that are natively implemented within a single\nsimulation code (like LAMMPS) and can only be used with it.\nThe pair_style kim command is limited to KIM PMs. It is\nused by the kim_commands interface as needed.\n\nNote\nSince pair_style kim is called by kim_interactions as needed,\nis not recommended to be directly used in input scripts.\n\n\nThe argument model is the name of the KIM PM.\nFor potentials archived in OpenKIM\nthis is the extended KIM ID (see kim_commands\nfor details). LAMMPS can invoke any KIM PM, however there can\nbe incompatibilities (for example due to unit matching issues).\nIn the event of an incompatibility, the code will terminate with\nan error message. Check both the LAMMPS and KIM log files for details.\nOnly a single pair_coeff command is used with the kim style, which\nspecifies the mapping of LAMMPS atom types to the species supported by\nthe KIM PM.  This is done by specifying N additional arguments\nafter the * * in the pair_coeff command, where N is the number of\nLAMMPS atom types:\n\nN element names = mapping of KIM elements to atom types\n\nFor example, consider a KIM PM that supports Si and C species.\nIf the LAMMPS simulation has four atom types, where the first three are Si,\nand the fourth is C, the following pair_coeff command would be used:\npair_coeff * * Si Si Si C\n\n\nThe first two arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1, 2, and 3 to Si as\ndefined within KIM PM.  The final C argument maps LAMMPS atom type 4 to C.\n\nIn addition to the usual LAMMPS error messages, the KIM library itself\nmay generate errors, which should be printed to the screen.  In this\ncase it is also useful to check the kim.log file for additional error\ninformation.  The file kim.log should be generated in the same\ndirectory where LAMMPS is running.\nTo download, build, and install the KIM library on your system, see\nthe lib/kim/README file.  Once you have done this and built LAMMPS\nwith the KIM package installed you can run the example input scripts\nin examples/kim.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since KIM stores the potential parameters.\nThus, you need to re-specify the pair_style and pair_coeff commands in\nan input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style kim model",
    "parameters": " * model = name of a KIM model (the KIM ID for models archived in OpenKIM)",
    "examples": "pair_style kim SW_StillingerWeber_1985_Si__MO_405512056662_005\npair_coeff * * Si",
    "restrictions": "This pair style is part of the KIM package. See details on\nrestrictions in kim_commands.\nThis current version of pair_style kim is compatible with the\nkim-api package version 2.0.0 and higher."
},
{
    "command": "pair_style kolmogorov/crespi/full",
    "html_filename": "pair_kolmogorov_crespi_full.html",
    "short_description": "The kolmogorov/crespi/full style computes the Kolmogorov-Crespi (KC) interaction potential as described in (Kolmogorov)",
    "description": "The kolmogorov/crespi/full style computes the Kolmogorov-Crespi (KC)\ninteraction potential as described in (Kolmogorov).\nNo simplification is made,\n\n\\[\\begin{split} E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n V_{ij}  = & e^{-\\lambda (r_{ij} -z_0)} \\left [ C + f(\\rho_{ij}) + f(\\rho_{ji}) - A \\left ( \\frac{r_{ij}}{z_0}\\right )^{-6} \\right ] \\\\\n\\rho_{ij}^2 = & r_{ij}^2 - ({\\bf r}_{ij}\\cdot {\\bf n}_{i})^2 \\\\\n\\rho_{ji}^2 = & r_{ij}^2 - ({\\bf r}_{ij}\\cdot  {\\bf n}_{j})^2 \\\\\nf(\\rho) & =  e^{-(\\rho/\\delta)^2} \\sum_{n=0}^2 C_{2n} { (\\rho/\\delta) }^{2n}\\end{split}\\]\nIt is important to have a sufficiently large cutoff to ensure smooth\nforces and to include all the pairs to build the neighbor list for\ncalculating the normals.  Energies are shifted so that they go\ncontinuously to zero at the cutoff assuming that the exponential part of\n\\(V_{ij}\\) (first term) decays sufficiently fast.  This shift is achieved by\nthe last term in the equation for \\(V_{ij}\\) above. This is essential only\nwhen the tapper function is turned off. The formula of taper function\ncan be found in pair style ilp/graphene/hbn.\n\nNote\nThis potential (ILP) is intended for interlayer interactions between two\ndifferent layers of graphene. To perform a realistic simulation, this potential\nmust be used in combination with intralayer potential, such as\nAIREBO or Tersoff potential.\nTo keep the intralayer properties unaffected, the interlayer interaction\nwithin the same layers should be avoided. Hence, each atom has to have a layer\nidentifier such that atoms residing on the same layer interact via the\nappropriate intralayer potential and atoms residing on different layers\ninteract via the ILP. Here, the molecule id is chosen as the layer identifier,\nthus a data file with the “full” atom style is required to use this potential.\n\nThe parameter file (e.g. CH.KC), is intended for use with metal\nunits, with energies in meV. Two additional parameters, S,\nand rcut are included in the parameter file. S is designed to\nfacilitate scaling of energies. rcut is designed to build the neighbor\nlist for calculating the normals for each atom pair.\n\nNote\nTwo new sets of parameters of KC potential for hydrocarbons, CH.KC\n(without the taper function) and CH_taper.KC (with the taper function)\nare presented in (Ouyang1).  The energy for the KC potential\nwith the taper function goes continuously to zero at the cutoff.  The\nparameters in both CH.KC and CH_taper.KC provide a good description in\nboth short- and long-range interaction regimes. While the original\nparameters (CC.KC) published in (Kolmogorov) are only\nsuitable for long-range interaction regime.  This feature is essential\nfor simulations in high pressure regime (i.e., the interlayer distance\nis smaller than the equilibrium distance).  The benchmark tests and\ncomparison of these parameters can be found in (Ouyang1) and (Ouyang2).\n\nThis potential must be used in combination with hybrid/overlay.\nOther interactions can be set to zero using pair_style none.\nThis pair style tallies a breakdown of the total interlayer potential\nenergy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 2.\nThe 2 values correspond to the following sub-categories:\n\nE_vdW = vdW (attractive) energy\nE_Rep = Repulsive energy\n\nTo print these quantities to the log file (with descriptive column\nheadings) the following commands could be included in an input script:\ncompute 0 all pair kolmogorov/crespi/full\nvariable Evdw  equal c_0[1]\nvariable Erep  equal c_0[2]\nthermo_style custom step temp epair v_Erep v_Evdw\n\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify mix, shift, table,\nand tail options.\nThis pair style does not write their information to binary restart\nfiles, since it is stored in potential files. Thus, you need to\nre-specify the pair_style and pair_coeff commands in an input script\nthat reads a restart file.",
    "syntax": "pair_style hybrid/overlay kolmogorov/crespi/full cutoff tap_flag",
    "parameters": " * cutoff = global cutoff (distance units)\n * tap_flag = 0/1 to turn off/on the taper function",
    "examples": "pair_style hybrid/overlay kolmogorov/crespi/full 20.0 0\npair_coeff * * none\npair_coeff * * kolmogorov/crespi/full  CH.KC   C C\n\npair_style hybrid/overlay rebo kolmogorov/crespi/full 16.0 1\npair_coeff * * rebo                    CH.rebo      C H\npair_coeff * * kolmogorov/crespi/full  CH_taper.KC  C H",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair potential requires the newton setting to be on for pair\ninteractions.\nThe CH.KC potential file provided with LAMMPS (see the potentials\nfolder) are parameterized for metal units.  You can use this potential\nwith any LAMMPS units, but you would need to create your own custom\nCC.KC potential file with all coefficients converted to the appropriate\nunits."
},
{
    "command": "pair_style kolmogorov/crespi/z",
    "html_filename": "pair_kolmogorov_crespi_z.html",
    "short_description": "The kolmogorov/crespi/z style computes the Kolmogorov-Crespi interaction potential as described in (Kolmogorov)",
    "description": "The kolmogorov/crespi/z style computes the Kolmogorov-Crespi interaction\npotential as described in (Kolmogorov). An important simplification is made,\nwhich is to take all normals along the z-axis.\n\n\\[\\begin{split}E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\nV_{ij}  = & e^{-\\lambda(r_{ij} -z_0}) \\left[ C + f(\\rho_{ij}) + f(\\rho_{ji}) \\right] - A \\left( \\frac{r_{ij}}{z_0}\\right)^{-6} + A \\left( \\frac{\\textrm{cutoff}}{z_0}\\right)^{-6} \\\\\n\\rho_{ij}^2 = & \\rho_{ji}^2  =  x_{ij}^2 + y_{ij}^2 \\qquad \\qquad (\\mathbf{n}_i \\equiv \\mathbf{\\hat{z}}) \\\\\nf(\\rho)  = &  e^{-(\\rho/\\delta)^2} \\sum_{n=0}^2 C_{2n} \\left( \\rho/\\delta \\right)^{2n}\\end{split}\\]\nIt is important to have a sufficiently large cutoff to ensure smooth forces.\nEnergies are shifted so that they go continuously to zero at the cutoff assuming\nthat the exponential part of \\(V_{ij}\\) (first term) decays sufficiently fast.\nThis shift is achieved by the last term in the equation for \\(V_{ij}\\) above.\nThis potential is intended for interactions between two layers of graphene.\nTherefore, to avoid interaction between layers in multi-layered materials,\neach layer should have a separate atom type and interactions should only\nbe computed between atom types of neighboring layers.\nThe parameter file (e.g. CC.KC), is intended for use with metal\nunits, with energies in meV. An additional parameter, S,\nis available to facilitate scaling of energies in accordance with\n(vanWijk).\nThis potential must be used in combination with hybrid/overlay.\nOther interactions can be set to zero using pair_style none.",
    "syntax": "pair_style [hybrid/overlay ...] kolmogorov/crespi/z cutoff",
    "parameters": " * ",
    "examples": "pair_style hybrid/overlay kolmogorov/crespi/z 20.0\npair_coeff * * none\npair_coeff 1 2 kolmogorov/crespi/z  CC.KC   C C\n\npair_style hybrid/overlay rebo kolmogorov/crespi/z 14.0\npair_coeff * * rebo                 CH.rebo    C C\npair_coeff 1 2 kolmogorov/crespi/z  CC.KC      C C",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style lcbop",
    "html_filename": "pair_lcbop.html",
    "short_description": "The lcbop pair style computes the long-range bond-order potential for carbon (LCBOP) of (Los and Fasolino)",
    "description": "The lcbop pair style computes the long-range bond-order potential\nfor carbon (LCBOP) of (Los and Fasolino).  See section II in\nthat paper for the analytic equations associated with the potential.\nOnly a single pair_coeff command is used with the lcbop style which\nspecifies an LCBOP potential file with parameters for specific\nelements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of LCBOP elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, if your LAMMPS simulation has 4 atom types and you want\nthe 1st 3 to be C you would use the following pair_coeff command:\npair_coeff * * C.lcbop C C C NULL\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first C argument maps LAMMPS atom type 1 to the C element in the\nLCBOP file. If a mapping value is specified as NULL, the mapping is\nnot performed.  This can be used when a lcbop potential is used as\npart of the hybrid pair style.  The NULL values are placeholders for\natom types that will be used with other potentials.\nThe parameters/coefficients for the LCBOP potential as applied to C\nare listed in the C.lcbop file to agree with the original (Los and Fasolino) paper.  Thus the parameters are specific to this\npotential and the way it was fit, so modifying the file should be done\ncarefully.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style lcbop",
    "parameters": " * ",
    "examples": "pair_style lcbop\npair_coeff * * ../potentials/C.lcbop C",
    "restrictions": "This pair styles is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair potential requires the newton setting to be\n“on” for pair interactions.\nThe C.lcbop potential file provided with LAMMPS (see the potentials\ndirectory) is parameterized for metal units.  You can use\nthe LCBOP potential with any LAMMPS units, but you would need to\ncreate your own LCBOP potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style lebedeva/z",
    "html_filename": "pair_lebedeva_z.html",
    "short_description": "The lebedeva/z style computes the Lebedeva interaction potential as described in (Lebedeva et al",
    "description": "The lebedeva/z style computes the Lebedeva interaction\npotential as described in (Lebedeva et al.). An important simplification is made,\nwhich is to take all normals along the z-axis.\n\n\\[\\begin{split}E       = & \\frac{1}{2} \\sum_i \\sum_{i \\neq j} V_{ij}\\\\\nV_{ij}  = & B e^{-\\alpha(r_{ij} - z_0)} \\\\\n          & + C(1 + D_1\\rho^2_{ij} + D_2\\rho^4_{ij} e^{-\\lambda_1\\rho^2_{ij}} e^{-\\lambda_2 (z^2_{ij} - z^2_0)} \\\\\n          & - A \\left(\\frac{z_0}{r_ij}\\right)^6 + A \\left( \\frac{z_0}{r_c} \\right)^6 \\\\\n\\rho^2_{ij} = & x^2_{ij} + y^2_{ij} \\qquad (\\mathbf{n_i} \\equiv \\mathbf{\\hat{z}})\\end{split}\\]\nIt is important to have a sufficiently large cutoff to ensure smooth forces.\nEnergies are shifted so that they go continuously to zero at the cutoff assuming\nthat the exponential part of \\(V_{ij}\\) (first term) decays sufficiently fast.\nThis shift is achieved by the last term in the equation for \\(V_{ij}\\) above.\nThe parameter file (e.g. CC.Lebedeva), is intended for use with metal\nunits, with energies in meV. An additional parameter, S,\nis available to facilitate scaling of energies.\nThis potential must be used in combination with hybrid/overlay.\nOther interactions can be set to zero using pair_style none.",
    "syntax": "pair_style [hybrid/overlay ...] lebedeva/z cutoff",
    "parameters": " * ",
    "examples": "pair_style hybrid/overlay lebedeva/z 20.0\npair_coeff * * none\npair_coeff 1 2 lebedeva/z  CC.Lebedeva   C C\n\npair_style hybrid/overlay rebo lebedeva/z 14.0\npair_coeff * * rebo        CH.rebo       C C\npair_coeff 1 2 lebedeva/z  CC.Lebedeva   C C",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style line/lj",
    "html_filename": "pair_line_lj.html",
    "short_description": "Style line/lj treats particles which are line segments as a set of small spherical particles that tile the line segment length as explained below",
    "description": "Style line/lj treats particles which are line segments as a set of\nsmall spherical particles that tile the line segment length as explained\nbelow.  Interactions between two line segments, each with N1 and N2\nspherical particles, are calculated as the pairwise sum of N1*N2\nLennard-Jones interactions.  Interactions between a line segment with N\nspherical particles and a point particle are treated as the pairwise sum\nof N Lennard-Jones interactions.  See the pair_style lj/cut doc page for the definition of Lennard-Jones interactions.\nThe set of non-overlapping spherical sub-particles that represent a\nline segment are generated in the following manner.  Their size is a\nfunction of the line segment length and the specified sub-particle\nsize for that particle type.  If a line segment has a length L and is\nof type I, then the number of spheres N that represent the segment is\ncalculated as N = L/sizeI, rounded up to an integer value.  Thus if L\nis not evenly divisible by sizeI, N is incremented to include one\nextra sphere.  The centers of the spheres are spaced equally along the\nline segment.  Imagine N+1 equally-space points, which include the 2\nend points of the segment.  The sphere centers are halfway between\neach pair of points.\nThe LJ interaction between 2 spheres on different line segments (or a\nsphere on a line segment and a point particles) is computed with\nsub-particle \\(\\epsilon\\), \\(\\sigma\\), and cutoff values that\nare set by the pair_coeff command, as described below.  If the distance\nbetween the 2 spheres is greater than the sub-particle cutoff, there is\nno interaction.  This means that some pairs of sub-particles on 2 line\nsegments may interact, but others may not.\nFor purposes of creating the neighbor list for pairs of interacting\nline segments or lines/point particles, a regular particle-particle\ncutoff is used, as defined by the cutoff setting above in the\npair_style command or overridden with an optional argument in the\npair_coeff command for a type pair as discussed below.  The distance\nbetween the centers of 2 line segments, or the center of a line\nsegment and a point particle, must be less than this distance (plus\nthe neighbor skin; see the neighbor command), for\nthe pair of particles to be included in the neighbor list.\n\nNote\nThis means that a too-short value for the cutoff setting can\nexclude a pair of particles from the neighbor list even if pairs of\ntheir sub-particle spheres would interact, based on the sub-particle\ncutoff specified in the pair_coeff command.  E.g. sub-particles at the\nends of the line segments that are close to each other.  Which may not\nbe what you want, since it means the ends of 2 line segments could\npass through each other.  It is up to you to specify a cutoff\nsetting that is consistent with the length of the line segments you\nare using and the sub-particle cutoff settings.\n\nFor style line/lj, the following coefficients must be defined for\neach pair of atom types via the pair_coeff command\nas in the examples above, or in the data file or restart files read by\nthe read_data or read_restart\ncommands:\n\nsizeI (distance units)\nsizeJ (distance units)\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\nsubcutoff (distance units)\ncutoff (distance units)\n\nThe sizeI and sizeJ coefficients are the sub-particle sizes for\nline particles of type I and type J.  They are used to define the N\nsub-particles per segment as described above.  These coefficients are\nactually stored on a per-type basis.  Thus if there are multiple\npair_coeff commands that involve type I, as either the first or\nsecond atom type, you should use consistent values for sizeI or sizeJ\nin all of them.  If you do not do this, the last value specified for\nsizeI will apply to all segments of type I.  If typeI or typeJ refers\nto point particles, the corresponding sizeI or sizeJ is ignored; it\ncan be set to 0.0.\nThe \\(\\epsilon\\), \\(\\sigma\\), and subcutoff coefficients are\nused to compute an LJ interactions between a pair of sub-particles on 2\nline segments (of type I and J), or between a sub particle/point\nparticle pair.  As discussed above, the subcutoff and cutoff params\nare different.  The latter is only used for building the neighbor list\nwhen the distance between centers of two line segments or one segment\nand a point particle is calculated.\nThe cutoff coefficient is optional.  If not specified, the global\ncutoff is used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, coefficients must be specified.\nNo default mixing rules are used.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style line/lj cutoff",
    "parameters": " * cutoff = global cutoff for interactions (distance units)",
    "examples": "pair_style line/lj 3.0\npair_coeff * * 1.0 1.0 1.0 0.8 1.12\npair_coeff 1 2 1.0 2.0 1.0 1.5 1.12 5.0\npair_coeff 1 2 1.0 0.0 1.0 1.0 2.5",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nDefining particles to be line segments so they participate in\nline/line or line/particle interactions requires the use the\natom_style line command."
},
{
    "command": "pair_style list",
    "html_filename": "pair_list.html",
    "short_description": "Style list computes interactions between explicitly listed pairs of atoms with the option to select functional form and parameters for each individual pair",
    "description": "Style list computes interactions between explicitly listed pairs of\natoms with the option to select functional form and parameters for\neach individual pair.  Because the parameters are set in the list\nfile, the pair_coeff command has no parameters (but still needs to be\nprovided).  The check and nocheck keywords enable/disable a test\nthat checks whether all listed bonds were present and computed.\nThis pair style can be thought of as a hybrid between bonded,\nnon-bonded, and restraint interactions.  It will typically be used as\nan additional interaction within the hybrid/overlay pair style.  It\ncurrently supports three interaction styles: a 12-6 Lennard-Jones, a\nMorse and a harmonic potential.\nThe format of the list file is as follows:\n\none line per pair of atoms\nempty lines will be ignored\ncomment text starts with a ‘#’ character\nline syntax: ID1 ID2 style coeffs cutoff\nID1 = atom ID of first atom\nID2 = atom ID of second atom\nstyle = style of interaction\ncoeffs = list of coeffs\ncutoff = cutoff for interaction (optional)\n\n\n\n\nThe cutoff parameter is optional. If not specified, the global cutoff\nis used.\nHere is an example file:\n# this is a comment\n\n15 259 lj126     1.0 1.0      50.0\n15 603 morse    10.0 1.2 2.0  10.0 # and another comment\n18 470 harmonic 50.0 1.2       5.0\n\n\nThe style lj126 computes pairwise interactions with the formula\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\qquad r < r_c\\]\nand the coefficients:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\nThe style morse computes pairwise interactions with the formula\n\n\\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] \\qquad r < r_c\\]\nand the coefficients:\n\n\\(D_0\\) (energy units)\n\\(\\alpha\\) (1/distance units)\n\\(r_0\\) (distance units)\n\nThe style harmonic computes pairwise interactions with the formula\n\n\\[E = K (r - r_0)^2\\]\nand the coefficients:\n\n\\(K\\) (energy units)\n\\(r_0\\) (distance units)\n\nNote that the usual 1/2 factor is included in \\(K\\).\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing since all parameters are\nexplicit for each pair.\nThe pair_modify shift option is supported by this\npair style.\nThe pair_modify table and tail options are not\nrelevant for this pair style.\nThis pair style does not write its information to binary restart files, so pair_style and pair_coeff commands need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style list listfile cutoff keyword",
    "parameters": " * listfile = name of file with list of pairwise interactions\n * cutoff = global cutoff (distance units)\n * keyword = optional flag nocheck or check (default is check)",
    "examples": "pair_style list restraints.txt 200.0\npair_coeff * *\n\npair_style hybrid/overlay lj/cut 1.1225 list pair_list.txt 300.0\npair_coeff * * lj/cut 1.0 1.0\npair_coeff 3* 3* list",
    "restrictions": "This pair style does not use a neighbor list and instead identifies\natoms by their IDs. This has two consequences: 1) The cutoff has to be\nchosen sufficiently large, so that the second atom of a pair has to be\na ghost atom on the same node on which the first atom is local;\notherwise the interaction will be skipped. You can use the check\noption to detect, if interactions are missing. 2) Unlike other pair\nstyles in LAMMPS, an atom I will not interact with multiple images of\natom J (assuming the images are within the cutoff distance), but only\nwith the nearest image.\nThis style is part of the USER-MISC package. It is only enabled if\nLAMMPS is build with that package. See the Build package doc page on for more info."
},
{
    "command": "pair_style lj/cut",
    "html_filename": "pair_lj.html",
    "short_description": "The lj/cut styles compute the standard 12/6 Lennard-Jones potential, given by  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -     \\left(\\frac{\\sigma}{r}\\right)^6 \\right]                     \\qquad r < r_c\\] Rc is the cutoff",
    "description": "The lj/cut styles compute the standard 12/6 Lennard-Jones potential,\ngiven by\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n    \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                    \\qquad r < r_c\\]\nRc is the cutoff.\nStyle lj/cut/coul/cut adds a Coulombic pairwise interaction given by\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\nwhere C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\nare the charges on the 2 atoms, and \\(\\epsilon\\) is the dielectric\nconstant which can be set by the dielectric command.\nIf one cutoff is specified in the pair_style command, it is used for\nboth the LJ and Coulombic terms.  If two cutoffs are specified, they are\nused as cutoffs for the LJ and Coulombic terms respectively.\nStyle lj/cut/coul/debye adds an additional exp() damping factor\nto the Coulombic term, given by\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\exp(- \\kappa r) \\qquad r < r_c\\]\nwhere \\(\\kappa\\) is the inverse of the Debye length.  This potential\nis another way to mimic the screening effect of a polar solvent.\nStyle lj/cut/coul/dsf computes the Coulombic term via the damped\nshifted force model described in Fennell, given by:\n\n\\[E =\n q_iq_j \\left[ \\frac{\\mbox{erfc} (\\alpha r)}{r} -  \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c} +\n\\left( \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c^2} +  \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{\\exp (-\\alpha^2    r^2_c)}{r_c} \\right)(r-r_c) \\right] \\qquad r < r_c\\]\nwhere \\(\\alpha\\) is the damping parameter and erfc() is the complementary\nerror-function. This potential is essentially a short-range,\nspherically-truncated, charge-neutralized, shifted, pairwise 1/r\nsummation.  The potential is based on Wolf summation, proposed as an\nalternative to Ewald summation for condensed phase systems where\ncharge screening causes electrostatic interactions to become\neffectively short-ranged. In order for the electrostatic sum to be\nabsolutely convergent, charge neutralization within the cutoff radius\nis enforced by shifting the potential through placement of image\ncharges on the cutoff sphere. Convergence can often be improved by\nsetting \\(\\alpha\\) to a small non-zero value.\nStyles lj/cut/coul/long and lj/cut/coul/msm compute the same\nCoulombic interactions as style lj/cut/coul/cut except that an\nadditional damping factor is applied to the Coulombic term so it can\nbe used in conjunction with the kspace_style\ncommand and its ewald or pppm option.  The Coulombic cutoff\nspecified for this style means that pairwise interactions within this\ndistance are computed directly; interactions outside that distance are\ncomputed in reciprocal space.\nStyle coul/wolf adds a Coulombic pairwise interaction via the Wolf\nsummation method, described in Wolf, given by:\n\n\\[E_i = \\frac{1}{2} \\sum_{j \\neq i}\n\\frac{q_i q_j {\\rm erfc}(\\alpha r_{ij})}{r_{ij}} +\n\\frac{1}{2} \\sum_{j \\neq i}\n\\frac{q_i q_j {\\rm erf}(\\alpha r_{ij})}{r_{ij}} \\qquad r < r_c\\]\nwhere \\(\\alpha\\) is the damping parameter, and erfc() is the\ncomplementary error-function terms.  This potential is essentially a\nshort-range, spherically-truncated, charge-neutralized, shifted,\npairwise 1/r summation.  With a manipulation of adding and subtracting\na self term (for i = j) to the first and second term on the\nright-hand-side, respectively, and a small enough \\(\\alpha\\) damping\nparameter, the second term shrinks and the potential becomes a\nrapidly-converging real-space summation.  With a long enough cutoff and\nsmall enough \\(\\alpha\\) parameter, the energy and forces calculated by the\nWolf summation method approach those of the Ewald sum.  So it is a means\nof getting effective long-range interactions with a short-range\npotential.\nStyles lj/cut/tip4p/cut and lj/cut/tip4p/long implement the TIP4P\nwater model of (Jorgensen), which introduces a massless\nsite located a short distance away from the oxygen atom along the\nbisector of the HOH angle.  The atomic types of the oxygen and\nhydrogen atoms, the bond and angle types for OH and HOH interactions,\nand the distance to the massless charge site are specified as\npair_style arguments.  Style lj/cut/tip4p/cut uses a cutoff for\nCoulomb interactions; style lj/cut/tip4p/long is for use with a\nlong-range Coulombic solver (Ewald or PPPM).\n\nNote\nFor each TIP4P water molecule in your system, the atom IDs for\nthe O and 2 H atoms must be consecutive, with the O atom first.  This\nis to enable LAMMPS to “find” the 2 H atoms associated with each O\natom.  For example, if the atom ID of an O atom in a TIP4P water\nmolecule is 500, then its 2 H atoms must have IDs 501 and 502.\n\nSee the Howto tip4p doc page for more information\non how to use the TIP4P pair styles and lists of parameters to set.\nNote that the neighbor list cutoff for Coulomb interactions is\neffectively extended by a distance 2*qdist when using the TIP4P pair\nstyle, to account for the offset distance of the fictitious charges on\nO atoms in water molecules.  Thus it is typically best in an\nefficiency sense to use a LJ cutoff >= Coulombic cutoff + 2*qdist, to\nshrink the size of the neighbor list.  This leads to slightly larger\ncost for the long-range calculation, so you can test the trade-off for\nyour model.\nFor all of the lj/cut pair styles, the following coefficients must\nbe defined for each pair of atoms types via the\npair_coeff command as in the examples above, or in\nthe data file or restart files read by the read_data\nor read_restart commands, or by mixing as\ndescribed below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nNote that \\(\\sigma\\) is defined in the LJ formula as the zero-crossing\ndistance for the potential, not as the energy minimum at \\(2^{\\frac{1}{6}} \\sigma\\).\nThe latter 2 coefficients are optional.  If not specified, the global\nLJ and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both LJ\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the LJ and Coulombic cutoffs for this\ntype pair.  You cannot specify 2 cutoffs for style lj/cut, since it\nhas no Coulombic terms.\nFor lj/cut/coul/long and lj/cut/coul/msm and lj/cut/tip4p/cut\nand lj/cut/tip4p/long only the LJ cutoff can be specified since a\nCoulombic cutoff cannot be specified for an individual I,J type pair.\nAll type pairs use the same global Coulombic cutoff specified in the\npair_style command.\n\nA version of these styles with a soft core, lj/cut/soft, suitable\nfor use in free energy calculations, is part of the USER-FEP package and\nis documented with the pair_style */soft\nstyles. The version with soft core is only available if LAMMPS was built\nwith that package. See the Build package doc page\nfor more info.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/cut pair styles can be mixed.\nThe default mix value is geometric.  See the “pair_modify” command\nfor details.\nAll of the lj/cut pair styles support the\npair_modify shift option for the energy of the\nLennard-Jones portion of the pair interaction.\nThe lj/cut/coul/long and lj/cut/tip4p/long pair styles support the\npair_modify table option since they can tabulate\nthe short-range portion of the long-range Coulombic interaction.\nAll of the lj/cut pair styles support the\npair_modify tail option for adding a long-range\ntail correction to the energy and pressure for the Lennard-Jones\nportion of the pair interaction.\nAll of the lj/cut pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\nnot need to be specified in an input script that reads a restart file.\nThe lj/cut and lj/cut/coul/long pair styles support the use of the\ninner, middle, and outer keywords of the run_style respa command, meaning the pairwise forces can be\npartitioned by distance at different levels of the rRESPA hierarchy.\nThe other styles only support the pair keyword of run_style respa.\nSee the run_style command for details.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/cut or lj/cut/coul/cut or lj/cut/coul/debye or lj/cut/coul/dsf or lj/cut/coul/long lj/cut/coul/msm or lj/cut/tip4p/long\n * args = list of arguments for a particular style\n * lj/cut args = cutoff\n *   cutoff = global cutoff for Lennard Jones interactions (distance units)\n * lj/cut/coul/cut args = cutoff (cutoff2)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/coul/debye args = kappa cutoff (cutoff2)\n *   kappa = inverse of the Debye length (inverse distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/coul/dsf args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (distance units)\n * lj/cut/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/coul/msm args = cutoff (cutoff2)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/coul/wolf args = alpha cutoff (cutoff2)\n *   alpha = damping parameter (inverse distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 2 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/tip4p/cut args = otype htype btype atype qdist cutoff (cutoff2)\n *   otype,htype = atom types for TIP4P O and H\n *   btype,atype = bond and angle types for TIP4P waters\n *   qdist = distance from O atom to massless charge (distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/cut/tip4p/long args = otype htype btype atype qdist cutoff (cutoff2)\n *   otype,htype = atom types for TIP4P O and H\n *   btype,atype = bond and angle types for TIP4P waters\n *   qdist = distance from O atom to massless charge (distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style lj/cut 2.5\npair_coeff * * 1 1\npair_coeff 1 1 1 1.1 2.8\n\npair_style lj/cut/coul/cut 10.0\npair_style lj/cut/coul/cut 10.0 8.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0\npair_coeff 1 1 100.0 3.5 9.0 9.0\n\npair_style lj/cut/coul/debye 1.5 3.0\npair_style lj/cut/coul/debye 1.5 2.5 5.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.0 1.5 2.5\npair_coeff 1 1 1.0 1.5 2.5 5.0\n\npair_style lj/cut/coul/dsf 0.05 2.5 10.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.0 1.0 2.5\n\npair_style lj/cut/coul/long 10.0\npair_style lj/cut/coul/long 10.0 8.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0\n\npair_style lj/cut/coul/msm 10.0\npair_style lj/cut/coul/msm 10.0 8.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0\n\npair_style lj/cut/tip4p/cut 1 2 7 8 0.15 12.0\npair_style lj/cut/tip4p/cut 1 2 7 8 0.15 12.0 10.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0\n\npair_style lj/cut/coul/wolf 0.2 5. 10.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.0 1.0 2.5\n\npair_style lj/cut/tip4p/long 1 2 7 8 0.15 12.0\npair_style lj/cut/tip4p/long 1 2 7 8 0.15 12.0 10.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0",
    "restrictions": "The lj/cut/coul/long and lj/cut/tip4p/long styles are part of the\nKSPACE package. The lj/cut/tip4p/cut style is part of the MOLECULE\npackage. These styles are only enabled if LAMMPS was built with those\npackages.  See the Build package doc page for\nmore info."
},
{
    "command": "pair_style lj96/cut",
    "html_filename": "pair_lj96.html",
    "short_description": "The lj96/cut style compute a 9/6 Lennard-Jones potential, instead of the standard 12/6 potential, given by  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]                     \\qquad r < r_c\\] \\(r_c\\) is the cutoff",
    "description": "The lj96/cut style compute a 9/6 Lennard-Jones potential, instead\nof the standard 12/6 potential, given by\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} -\n\\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                    \\qquad r < r_c\\]\n\\(r_c\\) is the cutoff.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global LJ\ncutoff specified in the pair_style command is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/cut pair styles can be mixed.\nThe default mix value is geometric.  See the “pair_modify” command\nfor details.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style supports the pair_modify tail\noption for adding a long-range tail correction to the energy and\npressure of the pair interaction.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style supports the use of the inner, middle, and outer\nkeywords of the run_style respa command, meaning the\npairwise forces can be partitioned by distance at different levels of\nthe rRESPA hierarchy.  See the run_style command for\ndetails.",
    "syntax": "pair_style lj96/cut cutoff",
    "parameters": " * cutoff = global cutoff for lj96/cut interactions (distance units)",
    "examples": "pair_style lj96/cut 2.5\npair_coeff * * 1.0 1.0 4.0\npair_coeff 1 1 1.0 1.0",
    "restrictions": "none"
},
{
    "command": "pair_style lj/cubic",
    "html_filename": "pair_lj_cubic.html",
    "short_description": "The lj/cubic style computes a truncated LJ interaction potential whose energy and force are continuous everywhere",
    "description": "The lj/cubic style computes a truncated LJ interaction potential\nwhose energy and force are continuous everywhere.  Inside the\ninflection point the interaction is identical to the standard 12/6\nLennard-Jones potential.  The LJ function outside the\ninflection point is replaced with a cubic function of distance. The\nenergy, force, and second derivative are continuous at the inflection\npoint.  The cubic coefficient A3 is chosen so that both energy and\nforce go to zero at the cutoff distance.  Outside the cutoff distance\nthe energy and force are zero.\n\n\\[\\begin{split}E & = u_{LJ}(r) \\qquad r \\leq r_s \\\\\n  & = u_{LJ}(r_s) + (r-r_s) u'_{LJ}(r_s) - \\frac{1}{6} A_3 (r-r_s)^3 \\qquad r_s < r \\leq r_c \\\\\n  & = 0 \\qquad r > r_c\\end{split}\\]\nThe location of the inflection point \\(r_s\\) is defined\nby the LJ diameter, \\(r_s/\\sigma = (26/7)^{1/6}\\). The cutoff distance\nis defined by \\(r_c/r_s = 67/48\\) or \\(r_c/\\sigma = 1.737...\\)\nThe analytic expression for the\nthe cubic coefficient\n\\(A_3 r_{min}^3/\\epsilon = 27.93...\\) is given in the paper by\nHolian and Ravelo (Holian).\nThis potential is commonly used to study the shock mechanics of FCC\nsolids, as in Ravelo et al. (Ravelo).\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the example above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\nNote that \\(\\sigma\\) is defined in the LJ formula as the\nzero-crossing distance for the potential, not as the energy minimum,\nwhich is located at \\(r_{min} = 2^{\\frac{1}{6}} \\sigma\\). In the\nabove example, \\(\\sigma = 0.8908987\\), so \\(r_{min} = 1.0\\).\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/cut pair styles can be mixed.\nThe default mix value is geometric.  See the “pair_modify” command\nfor details.\nThe lj/cubic pair style does not support the\npair_modify shift option,\nsince pair interaction is already smoothed to 0.0 at the\ncutoff.\nThe pair_modify table option is not relevant\nfor this pair style.\nThe lj/cubic pair style does not support the\npair_modify tail option for adding long-range tail\ncorrections to energy and pressure, since there are no corrections for\na potential that goes to 0.0 at the cutoff.\nThe lj/cubic pair style writes its information to binary restart files, so pair_style and pair_coeff commands do\nnot need to be specified in an input script that reads a restart file.\nThe lj/cubic pair style can only be used via the pair\nkeyword of the run_style respa command.  It does not\nsupport the inner, middle, outer keywords.",
    "syntax": "pair_style lj/cubic",
    "parameters": " * ",
    "examples": "pair_style lj/cubic\npair_coeff * * 1.0 0.8908987",
    "restrictions": "\nnone"
},
{
    "command": "pair_style lj/expand",
    "html_filename": "pair_lj_expand.html",
    "short_description": "Style lj/expand computes a LJ interaction with a distance shifted by delta which can be useful when particles are of different sizes, since it is different that using different sigma values in a standard LJ formula:  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r - \\Delta}\\right)^{12} -   \\left(\\frac{\\sigma}{r - \\Delta}\\right)^6 \\right]   \\qquad r < r_c + \\Delta\\] \\(r_c\\) is the cutoff which does not include the \\(\\Delta\\) distance",
    "description": "Style lj/expand computes a LJ interaction with a distance shifted by\ndelta which can be useful when particles are of different sizes, since\nit is different that using different sigma values in a standard LJ\nformula:\n\n\\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r - \\Delta}\\right)^{12} -\n  \\left(\\frac{\\sigma}{r - \\Delta}\\right)^6 \\right]\n  \\qquad r < r_c + \\Delta\\]\n\\(r_c\\) is the cutoff which does not include the \\(\\Delta\\)\ndistance.  I.e. the actual force cutoff is the sum of \\(r_c +\n\\Delta\\).\nFor all of the lj/expand pair styles, the following coefficients must\nbe defined for each pair of atoms types via the pair_coeff command as in the examples above, or in the data file or\nrestart files read by the read_data or\nread_restart commands, or by mixing as described\nbelow:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\\(\\Delta\\) (distance units)\ncutoff (distance units)\n\nThe \\(\\Delta\\) values can be positive or negative.  The last\ncoefficient is optional.  If not specified, the global LJ cutoff is\nused.\nFor lj/expand/coul/long only the LJ cutoff can be specified since a\nCoulombic cutoff cannot be specified for an individual I,J type pair.\nAll type pairs use the same global Coulombic cutoff specified in the\npair_style command.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon, sigma, and shift\ncoefficients and cutoff distance for this pair style can be mixed.\nShift is always mixed via an arithmetic rule.  The other\ncoefficients are mixed according to the pair_modify mix value.  The\ndefault mix value is geometric.  See the “pair_modify” command for\ndetails.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style supports the pair_modify tail\noption for adding a long-range tail correction to the energy and\npressure of the pair interaction.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style lj/expand cutoff",
    "parameters": " * cutoff = global cutoff for lj/expand interactions (distance units)",
    "examples": "pair_style lj/expand 2.5\npair_coeff * * 1.0 1.0 0.5\npair_coeff 1 1 1.0 1.0 -0.2 2.0\n\npair_style lj/expand/coul/long 2.5\npair_style lj/expand/coul/long 2.5 4.0\npair_coeff * * 1.0 1.0 0.5\npair_coeff 1 1 1.0 1.0 -0.2 3.0",
    "restrictions": "none"
},
{
    "command": "pair_style lj/long/coul/long",
    "html_filename": "pair_lj_long.html",
    "short_description": "Style lj/long/coul/long computes the standard 12/6 Lennard-Jones potential:  \\[\\begin{split}E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -                     \\left(\\frac{\\sigma}{r}\\right)^6 \\right]                     \\qquad r < r_c \\\\\\end{split}\\] with \\(\\epsilon\\) and \\(\\sigma\\) being the usual Lennard-Jones potential parameters, plus the Coulomb potential, given by:  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\] where C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\) are the charges on the 2 atoms, \\(\\epsilon\\) is the dielectric constant which can be set by the dielectric command, and \\(r_c\\) is the cutoff",
    "description": "Style lj/long/coul/long computes the standard 12/6 Lennard-Jones potential:\n\n\\[\\begin{split}E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                    \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                    \\qquad r < r_c \\\\\\end{split}\\]\nwith \\(\\epsilon\\) and \\(\\sigma\\) being the usual Lennard-Jones\npotential parameters, plus the Coulomb potential, given by:\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\nwhere C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\) are the charges on\nthe 2 atoms, \\(\\epsilon\\) is the dielectric constant which can be set by\nthe dielectric command, and \\(r_c\\) is the cutoff.  If\none cutoff is specified in the pair_style command, it is used for both\nthe LJ and Coulombic terms.  If two cutoffs are specified, they are\nused as cutoffs for the LJ and Coulombic terms respectively.\nThe purpose of this pair style is to capture long-range interactions\nresulting from both attractive 1/r^6 Lennard-Jones and Coulombic 1/r\ninteractions.  This is done by use of the flag_lj and flag_coul\nsettings.  The In ‘t Veld paper has more details on when it is\nappropriate to include long-range 1/r^6 interactions, using this\npotential.\nStyle lj/long/tip4p/long implements the TIP4P water model of\n(Jorgensen), which introduces a massless site located a\nshort distance away from the oxygen atom along the bisector of the HOH\nangle.  The atomic types of the oxygen and hydrogen atoms, the bond\nand angle types for OH and HOH interactions, and the distance to the\nmassless charge site are specified as pair_style arguments.\n\nNote\nFor each TIP4P water molecule in your system, the atom IDs for\nthe O and 2 H atoms must be consecutive, with the O atom first.  This\nis to enable LAMMPS to “find” the 2 H atoms associated with each O\natom.  For example, if the atom ID of an O atom in a TIP4P water\nmolecule is 500, then its 2 H atoms must have IDs 501 and 502.\n\nSee the Howto tip4p doc page for more\ninformation on how to use the TIP4P pair style.  Note that the\nneighbor list cutoff for Coulomb interactions is effectively extended\nby a distance 2*qdist when using the TIP4P pair style, to account for\nthe offset distance of the fictitious charges on O atoms in water\nmolecules.  Thus it is typically best in an efficiency sense to use a\nLJ cutoff >= Coulombic cutoff + 2*qdist, to shrink the size of the\nneighbor list.  This leads to slightly larger cost for the long-range\ncalculation, so you can test the trade-off for your model.\nIf flag_lj is set to long, no cutoff is used on the LJ 1/r^6\ndispersion term.  The long-range portion can be calculated by using\nthe kspace_style ewald/disp or pppm/disp commands.\nThe specified LJ cutoff then determines which portion of the LJ\ninteractions are computed directly by the pair potential versus which\npart is computed in reciprocal space via the Kspace style.  If\nflag_lj is set to cut, the LJ interactions are simply cutoff, as\nwith pair_style lj/cut.\nIf flag_coul is set to long, no cutoff is used on the Coulombic\ninteractions.  The long-range portion can calculated by using any of\nseveral kspace_style command options such as\npppm or ewald.  Note that if flag_lj is also set to long, then\nthe ewald/disp or pppm/disp Kspace style needs to be used to\nperform the long-range calculations for both the LJ and Coulombic\ninteractions.  If flag_coul is set to off, Coulombic interactions\nare not computed.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nNote that sigma is defined in the LJ formula as the zero-crossing\ndistance for the potential, not as the energy minimum at 2^(1/6)\nsigma.\nThe latter 2 coefficients are optional.  If not specified, the global\nLJ and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both LJ\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the LJ and Coulombic cutoffs for this\ntype pair.\nNote that if you are using flag_lj set to long, you\ncannot specify a LJ cutoff for an atom type pair, since only one\nglobal LJ cutoff is allowed.  Similarly, if you are using flag_coul\nset to long, you cannot specify a Coulombic cutoff for an atom type\npair, since only one global Coulombic cutoff is allowed.\nFor lj/long/tip4p/long only the LJ cutoff can be specified\nsince a Coulombic cutoff cannot be specified for an individual I,J\ntype pair.  All type pairs use the same global Coulombic cutoff\nspecified in the pair_style command.\n\nA version of these styles with a soft core, lj/cut/soft, suitable for use in\nfree energy calculations, is part of the USER-FEP package and is documented with\nthe pair_style */soft styles. The version with soft core is\nonly available if LAMMPS was built with that package. See the Build package doc page for more info.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/long pair styles can be mixed.\nThe default mix value is geometric.  See the “pair_modify” command\nfor details.\nThese pair styles support the pair_modify shift\noption for the energy of the Lennard-Jones portion of the pair\ninteraction, assuming flag_lj is cut.\nThese pair styles support the pair_modify table and\ntable/disp options since they can tabulate the short-range portion of\nthe long-range Coulombic and dispersion interactions.\nThes pair styles do not support the pair_modify\ntail option for adding a long-range tail correction to the\nLennard-Jones portion of the energy and pressure.\nThese pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThe pair lj/long/coul/long styles support the use of the inner,\nmiddle, and outer keywords of the run_style respa\ncommand, meaning the pairwise forces can be partitioned by distance at\ndifferent levels of the rRESPA hierarchy.  See the\nrun_style command for details.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/long/coul/long or lj/long/tip4p/long\n * args = list of arguments for a particular style\n * lj/long/coul/long args = flag_lj flag_coul cutoff (cutoff2)\n *   flag_lj = long or cut or off\n *     long = use Kspace long-range summation for dispersion 1/r^6 term\n *     cut = use a cutoff on dispersion 1/r^6 term\n *     off = omit disperion 1/r^6 term entirely\n *   flag_coul = long or off\n *     long = use Kspace long-range summation for Coulombic 1/r term\n *     off = omit Coulombic term\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * lj/long/tip4p/long args = flag_lj flag_coul otype htype btype atype qdist cutoff (cutoff2)\n *   flag_lj = long or cut\n *     long = use Kspace long-range summation for dispersion 1/r^6 term\n *     cut = use a cutoff\n *   flag_coul = long or off\n *     long = use Kspace long-range summation for Coulombic 1/r term\n *     off = omit Coulombic term\n *   otype,htype = atom types for TIP4P O and H\n *   btype,atype = bond and angle types for TIP4P waters\n *   qdist = distance from O atom to massless charge (distance units)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style lj/long/coul/long cut off 2.5\npair_style lj/long/coul/long cut long 2.5 4.0\npair_style lj/long/coul/long long long 2.5 4.0\npair_coeff * * 1 1\npair_coeff 1 1 1 3 4\n\npair_style lj/long/tip4p/long long long 1 2 7 8 0.15 12.0\npair_style lj/long/tip4p/long long long 1 2 7 8 0.15 12.0 10.0\npair_coeff * * 100.0 3.0\npair_coeff 1 1 100.0 3.5 9.0",
    "restrictions": "These styles are part of the KSPACE package.  They are only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style lj/smooth",
    "html_filename": "pair_lj_smooth.html",
    "short_description": "Style lj/smooth computes a LJ interaction with a force smoothing applied between the inner and outer cutoff",
    "description": "Style lj/smooth computes a LJ interaction with a force smoothing\napplied between the inner and outer cutoff.\n\n\\[\\begin{split}E & =  4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_{in} \\\\\nF & =  C_1 + C_2 (r - r_{in}) + C_3 (r - r_{in})^2 + C_4 (r - r_{in})^3\n                    \\qquad r_{in} < r < r_c\\end{split}\\]\nThe polynomial coefficients C1, C2, C3, C4 are computed by LAMMPS to\ncause the force to vary smoothly from the inner cutoff \\(r_{in}\\) to the\nouter cutoff \\(r_c\\).\nAt the inner cutoff the force and its 1st derivative\nwill match the non-smoothed LJ formula.  At the outer cutoff the force\nand its 1st derivative will be 0.0.  The inner cutoff cannot be 0.0.\n\nNote\nthis force smoothing causes the energy to be discontinuous both\nin its values and 1st derivative.  This can lead to poor energy\nconservation and may require the use of a thermostat.  Plot the energy\nand force resulting from this formula via the\npair_write command to see the effect.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\\(r_{in}\\) (distance units)\n\\(r_c\\) (distance units)\n\nThe last 2 coefficients are optional inner and outer cutoffs.  If not\nspecified, the global values for \\(r_{in}\\) and \\(r_c\\) are used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon, sigma, Rin\ncoefficients and the cutoff distance for this pair style can be mixed.\nRin is a cutoff value and is mixed like the cutoff.  The other\ncoefficients are mixed according to the pair_modify mix option.  The\ndefault mix value is geometric.  See the “pair_modify” command for\ndetails.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure, since the energy of the pair interaction is smoothed to 0.0\nat the cutoff.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style lj/smooth Rin Rc",
    "parameters": " * Rin = inner cutoff beyond which force smoothing will be applied (distance units)\n * Rc = outer cutoff for lj/smooth interactions (distance units)",
    "examples": "pair_style lj/smooth 8.0 10.0\npair_coeff * * 10.0 1.5\npair_coeff 1 1 20.0 1.3 7.0 9.0",
    "restrictions": "none"
},
{
    "command": "pair_style lj/smooth/linear",
    "html_filename": "pair_lj_smooth_linear.html",
    "short_description": "Style lj/smooth/linear computes a truncated and force-shifted LJ interaction (aka Shifted Force Lennard-Jones) that combines the standard 12/6 Lennard-Jones function and subtracts a linear term based on the cutoff distance, so that both, the potential and the force, go continuously to zero at the cutoff Rc (Toxvaerd):  \\[\\begin{split}\\phi\\left(r\\right) & =  4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -                     \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\ E\\left(r\\right) & =  \\phi\\left(r\\right)  - \\phi\\left(R_c\\right) - \\left(r - R_c\\right) \\left",
    "description": "Style lj/smooth/linear computes a truncated and force-shifted LJ\ninteraction (aka Shifted Force Lennard-Jones) that combines the\nstandard 12/6 Lennard-Jones function and subtracts a linear term based\non the cutoff distance, so that both, the potential and the force, go\ncontinuously to zero at the cutoff Rc (Toxvaerd):\n\n\\[\\begin{split}\\phi\\left(r\\right) & =  4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                    \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\nE\\left(r\\right) & =  \\phi\\left(r\\right)  - \\phi\\left(R_c\\right) - \\left(r - R_c\\right) \\left.\\frac{d\\phi}{d r} \\right|_{r=R_c}       \\qquad r < R_c\\end{split}\\]\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional. If not specified, the global\nLJ cutoff specified in the pair_style command is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance can be mixed. The default mix value is geometric.\nSee the “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction, since it goes\nto 0.0 at the cutoff by construction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure, since the energy of the pair interaction is smoothed to 0.0\nat the cutoff.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style lj/smooth/linear cutoff",
    "parameters": " * cutoff = global cutoff for Lennard-Jones interactions (distance units)",
    "examples": "pair_style lj/smooth/linear 2.5\npair_coeff * * 1.0 1.0\npair_coeff 1 1 0.3 3.0 9.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style lj/switch3/coulgauss/long",
    "html_filename": "pair_lj_switch3_coulgauss_long.html",
    "short_description": "The lj/switch3/coulgauss style evaluates the LJ vdW potential  \\[E = 4\\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6} \\right]\\] , which goes smoothly to zero at the cutoff r_c as defined by the switching function  \\[\\begin{split}S_3(r) = \\left\\lbrace \\begin{array}{ll}                     1 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} - w \\\\                     3x^2 - 2x^3 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} \\quad\\mathrm{with\\quad} x=\\frac{r_\\mathrm{c} - r}{w} \\\\                     0 & \\quad\\mathrm{if}\\quad r >= r_\\mathrm{c}                 \\end{array} \\right",
    "description": "The lj/switch3/coulgauss style evaluates the LJ\nvdW potential\n\n\\[E = 4\\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6} \\right]\\]\n, which goes smoothly to zero at the cutoff r_c as defined\nby the switching function\n\n\\[\\begin{split}S_3(r) = \\left\\lbrace \\begin{array}{ll}\n                    1 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} - w \\\\\n                    3x^2 - 2x^3 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} \\quad\\mathrm{with\\quad} x=\\frac{r_\\mathrm{c} - r}{w} \\\\\n                    0 & \\quad\\mathrm{if}\\quad r >= r_\\mathrm{c}\n                \\end{array} \\right.\\end{split}\\]\nwhere w is the width defined in the arguments. This potential\nis combined with Coulomb interaction between Gaussian charge densities:\n\n\\[E = \\frac{q_i q_j \\mathrm{erf}\\left( r/\\sqrt{\\gamma_1^2+\\gamma_2^2} \\right) }{\\epsilon r_{ij}}\\]\nwhere \\(q_i\\) and \\(q_j\\) are the charges on the 2 atoms,\n\\(\\epsilon\\) is the dielectric constant which can be set by the\ndielectric command, \\(\\gamma_i\\) and\n\\(\\gamma_j\\) are the widths of the Gaussian charge distribution and\nerf() is the error-function.  This style has to be used in conjunction\nwith the kspace_style command\nIf one cutoff is specified it is used for both the vdW and Coulomb\nterms.  If two cutoffs are specified, the first is used as the cutoff\nfor the vdW terms, and the second is the cutoff for the Coulombic term.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(\\epsilon\\) (energy)\n\\(\\sigma\\) (distance)\n\\(\\gamma\\) (distance)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nShifting the potential energy is not necessary because the switching\nfunction ensures that the potential is zero at the cut-off.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/switch3/coulgauss/long\n * args = list of arguments for a particular style\n * lj/switch3/coulgauss/long args = cutoff (cutoff2) width\n *   cutoff  = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n *   width  = width parameter of the smoothing function (distance units)",
    "examples": "pair_style lj/switch3/coulgauss/long    12.0 3.0\npair_coeff 1  0.2 2.5 1.2\n\npair_style lj/switch3/coulgauss/long   12.0 10.0 3.0\npair_coeff 1  0.2 2.5 1.2",
    "restrictions": "These styles are part of the USER-YAFF package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style local/density",
    "html_filename": "pair_local_density.html",
    "short_description": "The local density (LD) potential is a mean-field manybody potential, and, in some sense,a generalization of embedded atom models (EAM)",
    "description": "The local density (LD) potential is a mean-field manybody potential, and, in some\nsense,a generalization of embedded atom models (EAM). The name “local density\npotential” arises from the fact that it assigns an energy to an atom depending\non the number of neighboring atoms of given type around it within a predefined\nspherical volume (i.e., within a cutoff). The bottom-up coarse-graining (CG)\nliterature suggests that such potentials can be widely useful  in capturing\neffective multibody forces in a computationally efficient manner so as to\nimprove the quality of CG models of implicit solvation:ref:(Sanyal1) <Sanyal1> and\nphase-segregation in liquid mixtures:ref:(Sanyal2) <Sanyal2>, and provide guidelines\nto determine the extent of manybody correlations present in a CG\nmodel.:ref:(Rosenberger) <Rosenberger> The LD potential in LAMMPS is primarily\nintended to be used as a corrective potential over traditional pair potentials\nin bottom-up CG models, i.e., as a hybrid pair style with\nother explicit pair interaction terms (e.g., table spline, Lennard Jones, etc.).\nBecause the LD potential is not a pair potential per se,  it is implemented\nsimply as a single auxiliary file with all specifications that will be read\nupon initialization.\n\nNote\nThus when used as the only interaction in the system, there is no\ncorresponding pair_coeff command and when used with other pair styles using the\nhybrid/overlay option, the corresponding pair_coeff command must be supplied\n*  * as placeholders for the atom types.\n\n\nSystem with a single CG atom type:\nA system of a single atom type (e.g., LJ argon) with a single local density (LD)\npotential would have an energy given by:\n\n\\[U_{LD} = \\sum_i F(\\rho_i)\\]\nwhere \\(\\rho_i\\) is the LD at atom i and \\(F(\\rho)\\) is\nsimilar in spirit to the embedding function used in EAM potentials. The\nLD at atom i is given by the sum\n\n\\[\\rho_i = \\sum_{j \\neq i} \\varphi(r_{ij})\\]\nwhere \\(\\varphi\\) is an indicator function that is one at r=0 and\nzero beyond a cutoff distance R2. The choice of the functional form of\n\\(\\varphi\\) is somewhat arbitrary, but the following piecewise cubic\nfunction has proven sufficiently general: (Sanyal1),\n(Sanyal2) (Rosenberger)\n\n\\[\\begin{split}\\varphi(r) =\n\\begin{cases}\n1 & r \\le R_1 \\\\\nc_0 + c_2r^2 + c_4r^4 + c_6r^6  & r \\in (R_1, R_2) \\\\\n0 & r \\ge R_2\n\\end{cases}\\end{split}\\]\nThe constants c are chosen so that the indicator function smoothly\ninterpolates between 1 and 0 between the distances R1 and R2, which are\ncalled the inner and outer cutoffs, respectively. Thus phi satisfies\nphi(R1) = 1, phi(R2) = dphi/dr @ (r=R1) =  dphi/dr @ (r=R2) = 0. The embedding\nfunction F(rho) may or may not have a closed-form expression. To maintain\ngenerality, it is practically represented with a spline-interpolated table\nover a predetermined range of rho. Outside of that range it simply adopts zero\nvalues at the endpoints.\nIt can be shown that the total force between two atoms due to the LD potential\ntakes the form of a pair force, which motivates its designation as a LAMMPS\npair style. Please see (Sanyal1) for details of the derivation.\n\nSystems with arbitrary numbers of atom types:\nThe potential is easily generalized to systems involving multiple atom types:\n\n\\[U_{LD} = \\sum_i a_\\alpha F(\\rho_i)\\]\nwith the LD expressed as\n\n\\[\\rho_i = \\sum_{j \\neq i} b_\\beta \\varphi(r_{ij})\\]\nwhere \\(\\alpha\\) gives the type of atom i, \\(\\beta\\) the\ntype of atom j, and the coefficients a and b filter for atom\ntypes as specified by the user. a is called the central atom filter as\nit determines to which atoms the potential applies; \\(a_{\\alpha} =\n1\\) if the LD potential applies to atom type \\(\\alpha\\) else zero. On the\nother hand, b is called the neighbor atom filter because it specifies\nwhich atom types to use in the calculation of the LD; \\(b_{\\beta} =\n1\\) if atom type \\(\\beta\\) contributes to the LD and zero otherwise.\n\nNote\nNote that the potentials need not be symmetric with respect to atom\ntypes, which is the reason for two distinct sets of coefficients a\nand b. An atom type may contribute to the LD but not the\npotential, or to the potential but not the LD. Such decisions are\nmade by the user and should (ideally) be motivated on physical\ngrounds for the problem at hand.\n\n\nGeneral form for implementation in LAMMPS:\nOf course, a system with many atom types may have many different possible LD\npotentials, each with their own atom type filters, cutoffs, and embedding\nfunctions. The most general form of this potential as implemented in the\npair_style local/density is:\n\n\\[U_{LD} = \\sum_k U_{LD}^{(k)} = \\sum_i \\left[ \\sum_k a_\\alpha^{(k)} F^{(k)} \\left(\\rho_i^{(k)}\\right) \\right]\\]\nwhere, k is an index that spans the (arbitrary) number of applied LD\npotentials N_LD. Each LD is calculated as before with:\n\n\\[\\rho_i^{(k)} = \\sum_j b_\\beta^{(k)} \\varphi^{(k)} (r_{ij})\\]\nThe superscript on the indicator function phi simply indicates that it is\nassociated with specific values of the cutoff distances R1(k) and R2(k). In\nsummary, there may be N_LD distinct LD potentials. With each potential type (k),\none must specify:\n\nthe inner and outer cutoffs as R1 and R2\nthe central type filter a(k), where k = 1,2,…N_LD\nthe neighbor type filter b(k), where k = 1,2,…N_LD\nthe LD potential function F(k)(rho), typically as a table that is later spline-interpolated\n\n\nTabulated input file format:\nLine 1:             comment or blank (ignored)\nLine 2:             comment or blank (ignored)\nLine 3:             N_LD N_rho (# of LD potentials and # of tabulated values, single space separated)\nLine 4:             blank (ignored)\nLine 5:             R1(k) R2(k) (lower and upper cutoffs, single space separated)\nLine 6:             central-types (central atom types, single space separated)\nLine 7:             neighbor-types (neighbor atom types single space separated)\nLine 8:             rho_min rho_max drho (min, max and diff. in tabulated rho values, single space separated)\nLine 9:             F(k)(rho_min + 0.drho)\nLine 10:            F(k)(rho_min + 1.drho)\nLine 11:            F(k)(rho_min + 2.drho)\n...\nLine 9+N_rho:       F(k)(rho_min + N_rho . drho)\nLine 10+N_rho:      blank (ignored)\n\nBlock 2\n\nBlock 3\n\nBlock N_LD\n\n\nLines 5 to 9+N_rho constitute the first block. Thus the input file is separated\n(by blank lines) into N_LD blocks each representing a separate LD potential and\neach specifying its own upper and lower cutoffs, central and neighbor atoms,\nand potential.  In general, blank lines anywhere are ignored.\n\nMixing, shift, table, tail correction, restart, info:\nThis pair style does not support automatic mixing. For atom type pairs\n\\(\\alpha\\), \\(\\beta\\) and \\(\\alpha\\) != \\(\\beta\\), even\nif LD potentials of type (\\(\\alpha\\), \\(\\alpha\\)) and\n(\\(\\beta\\), \\(\\beta\\)) are provided, you will need to explicitly\nprovide LD potential types (\\(\\alpha\\), \\(\\beta\\)) and\n(\\(\\beta\\), \\(\\alpha\\)) if need be (Here, the notation\n(\\(\\alpha\\), \\(\\beta\\)) means that \\(\\alpha\\) is the central\natom to which the LD potential is applied and \\(\\beta\\) is the\nneighbor atom which contributes to the LD potential on \\(\\alpha\\)).\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThe local/density pair style does not write its information to binary restart files, since it is stored in tabulated potential files.\nThus, you need to re-specify the pair_style and pair_coeff commands in\nan input script that reads a restart file.",
    "syntax": "pair_style style arg",
    "parameters": " * style = local/density\n * arg = name of file containing tabulated values of local density and the potential",
    "examples": "pair_style local/density benzene_water.localdensity.table\n\npair_style hybrid/overlay table spline 500 local/density\npair_coeff * * local/density  benzene_water.localdensity.table",
    "restrictions": "The local/density pair style is a part of the USER-MISC package. It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style lubricate",
    "html_filename": "pair_lubricate.html",
    "short_description": "Styles lubricate and lubricate/poly compute hydrodynamic interactions between mono-disperse finite-size spherical particles in a pairwise fashion",
    "description": "Styles lubricate and lubricate/poly compute hydrodynamic\ninteractions between mono-disperse finite-size spherical particles in\na pairwise fashion.  The interactions have 2 components.  The first is\nBall-Melrose lubrication terms via the formulas in (Ball and Melrose)\n\n\\[\\begin{split}W & =  - a_{sq} | (v_1 - v_2) \\bullet \\mathbf{nn} |^2 -\na_{sh} | (\\omega_1 + \\omega_2) \\bullet\n(\\mathbf{I} - \\mathbf{nn}) - 2 \\Omega_N |^2 - \\\\\n&  a_{pu} | (\\omega_1 - \\omega_2) \\bullet (\\mathbf{I} - \\mathbf{nn}) |^2 -\na_{tw} | (\\omega_1 - \\omega_2) \\bullet \\mathbf{nn} |^2  \\qquad r < r_c \\\\\n& \\\\\n\\Omega_N & = \\mathbf{n} \\times (v_1 - v_2) / r\\end{split}\\]\nwhich represents the dissipation W between two nearby particles due to\ntheir relative velocities in the presence of a background solvent with\nviscosity mu.  Note that this is dynamic viscosity which has units of\nmass/distance/time, not kinematic viscosity.\nThe Asq (squeeze) term is the strongest and is included if flagHI is\nset to 1 (default). It scales as 1/gap where gap is the separation\nbetween the surfaces of the 2 particles. The Ash (shear) and Apu\n(pump) terms are only included if flaglog is set to 1. They are the\nnext strongest interactions, and the only other singular interaction,\nand scale as log(gap). Note that flaglog = 1 and flagHI = 0 is\ninvalid, and will result in a warning message, after which flagHI will\nbe set to 1. The Atw (twist) term is currently not included. It is\ntypically a very small contribution to the lubrication forces.\nThe flagHI and flagVF settings are optional.  Neither should be\nused, or both must be defined.\nCutinner sets the minimum center-to-center separation that will be\nused in calculations irrespective of the actual separation.  Cutoff\nis the maximum center-to-center separation at which an interaction is\ncomputed.  Using a cutoff less than 3 radii is recommended if\nflaglog is set to 1.\nThe other component is due to the Fast Lubrication Dynamics (FLD)\napproximation, described in (Kumar), which can be\nrepresented by the following equation\n\n\\[F^{H} = -R_{FU}(U-U^{\\infty}) + R_{FE}E^{\\infty}\\]\nwhere U represents the velocities and angular velocities of the\nparticles, \\(U^{\\infty}\\) represents the velocity and the angular velocity\nof the undisturbed fluid, and \\(E^{\\infty}\\) represents the rate of strain\ntensor of the undisturbed fluid with viscosity mu. Again, note that\nthis is dynamic viscosity which has units of mass/distance/time, not\nkinematic viscosity. Volume fraction corrections to R_FU are included\nas long as flagVF is set to 1 (default).\n\nNote\nWhen using the FLD terms, these pair styles are designed to be\nused with explicit time integration and a correspondingly small\ntimestep.  Thus either fix nve/sphere or fix nve/asphere should be used for time integration.\nTo perform implicit FLD, see the pair_style lubricateU command.\n\nStyle lubricate requires monodisperse spherical particles; style\nlubricate/poly allows for polydisperse spherical particles.\nThe viscosity mu can be varied in a time-dependent manner over the\ncourse of a simulation, in which case in which case the pair_style\nsetting for mu will be overridden.  See the fix adapt\ncommand for details.\nIf the suspension is sheared via the fix deform\ncommand then the pair style uses the shear rate to adjust the\nhydrodynamic interactions accordingly. Volume changes due to fix\ndeform are accounted for when computing the volume fraction\ncorrections to R_FU.\nWhen computing the volume fraction corrections to R_FU, the presence\nof walls (whether moving or stationary) will affect the volume\nfraction available to colloidal particles. This is currently accounted\nfor with the following types of walls: wall/lj93,\nwall/lj126, wall/colloid, and\nwall/harmonic.  For these wall styles, the correct\nvolume fraction will be used when walls do not coincide with the box\nboundary, as well as when walls move and thereby cause a change in the\nvolume fraction. Other wall styles will still work, but they will\nresult in the volume fraction being computed based on the box\nboundaries.\nSince lubrication forces are dissipative, it is usually desirable to\nthermostat the system at a constant temperature. If Brownian motion\n(at a constant temperature) is desired, it can be set using the\npair_style brownian command. These pair styles\nand the brownian style should use consistent parameters for mu,\nflaglog, flagfld, cutinner, cutoff, flagHI and flagVF.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutinner (distance units)\ncutoff (distance units)\n\nThe two coefficients are optional.  If neither is specified, the two\ncutoffs specified in the pair_style command are used.  Otherwise both\nmust be specified.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed in this section of\nthe manual.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee this section of the manual for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the two cutoff distances for this\npair style can be mixed.  The default mix value is geometric.  See\nthe “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style mu flaglog flagfld cutinner cutoff flagHI flagVF",
    "parameters": " * style = lubricate or lubricate/poly\n * mu = dynamic viscosity (dynamic viscosity units)\n * flaglog = 0/1 to exclude/include log terms in the lubrication approximation\n * flagfld = 0/1 to exclude/include Fast Lubrication Dynamics (FLD) effects\n * cutinner = inner cutoff distance (distance units)\n * cutoff = outer cutoff for interactions (distance units)\n * flagHI (optional) = 0/1 to exclude/include 1/r hydrodynamic interactions\n * flagVF (optional) = 0/1 to exclude/include volume fraction corrections in the long-range isotropic terms\n * Examples: (all assume radius = 1)\n * pair_style lubricate 1.5 1 1 2.01 2.5\n * pair_coeff 1 1 2.05 2.8\n * pair_coeff * *\n * pair_style lubricate 1.5 1 1 2.01 2.5\n * pair_coeff * *\n * variable mu equal ramp(1,2)\n * fix 1 all adapt 1 pair lubricate mu * * v_mu",
    "examples": "pair_style local/density benzene_water.localdensity.table\n\npair_style hybrid/overlay table spline 500 local/density\npair_coeff * * local/density  benzene_water.localdensity.table",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nOnly spherical monodisperse particles are allowed for pair_style\nlubricate.\nOnly spherical particles are allowed for pair_style lubricate/poly.\nThese pair styles will not restart exactly when using the\nread_restart command, though they should provide\nstatistically similar results.  This is because the forces they\ncompute depend on atom velocities.  See the\nread_restart command for more details."
},
{
    "command": "pair_style lubricateU",
    "html_filename": "pair_lubricateU.html",
    "short_description": "Styles lubricateU and lubricateU/poly compute velocities and angular velocities for finite-size spherical particles such that the hydrodynamic interaction balances the force and torque due to all other types of interactions",
    "description": "Styles lubricateU and lubricateU/poly compute velocities and\nangular velocities for finite-size spherical particles such that the\nhydrodynamic interaction balances the force and torque due to all\nother types of interactions.\nThe interactions have 2 components.  The first is\nBall-Melrose lubrication terms via the formulas in (Ball and Melrose)\n\n\\[\\begin{split}W & =  - a_{sq} | (v_1 - v_2) \\bullet \\mathbf{nn} |^2 -\na_{sh} | (\\omega_1 + \\omega_2) \\bullet\n(\\mathbf{I} - \\mathbf{nn}) - 2 \\Omega_N |^2 - \\\\\n&  a_{pu} | (\\omega_1 - \\omega_2) \\bullet (\\mathbf{I} - \\mathbf{nn}) |^2 -\na_{tw} | (\\omega_1 - \\omega_2) \\bullet \\mathbf{nn} |^2  \\qquad r < r_c \\\\\n& \\\\\n\\Omega_N & = \\mathbf{n} \\times (v_1 - v_2) / r\\end{split}\\]\nwhich represents the dissipation W between two nearby particles due to\ntheir relative velocities in the presence of a background solvent with\nviscosity mu.  Note that this is dynamic viscosity which has units of\nmass/distance/time, not kinematic viscosity.\nThe Asq (squeeze) term is the strongest and is included as long as\nflagHI is set to 1 (default). It scales as 1/gap where gap is the\nseparation between the surfaces of the 2 particles. The Ash (shear)\nand Apu (pump) terms are only included if flaglog is set to 1. They\nare the next strongest interactions, and the only other singular\ninteraction, and scale as log(gap). Note that flaglog = 1 and\nflagHI = 0 is invalid, and will result in a warning message, after\nwhich flagHI will be set to 1. The Atw (twist) term is currently not\nincluded. It is typically a very small contribution to the lubrication\nforces.\nThe flagHI and flagVF settings are optional.  Neither should be\nused, or both must be defined.\nCutinner sets the minimum center-to-center separation that will be\nused in calculations irrespective of the actual separation.  Cutoff\nis the maximum center-to-center separation at which an interaction is\ncomputed.  Using a cutoff less than 3 radii is recommended if\nflaglog is set to 1.\nThe other component is due to the Fast Lubrication Dynamics (FLD)\napproximation, described in (Kumar).  The equation being\nsolved to balance the forces and torques is\n\n\\[-R_{FU}(U-U^{\\infty}) = -R_{FE}E^{\\infty} - F^{rest}\\]\nwhere U represents the velocities and angular velocities of the\nparticles, \\(U^{\\infty}\\) represents the velocities and the angular\nvelocities of the undisturbed fluid, and \\(E^{\\infty}\\) represents\nthe rate of strain tensor of the undisturbed fluid flow with viscosity\nmu. Again, note that this is dynamic viscosity which has units of\nmass/distance/time, not kinematic viscosity.  Volume fraction\ncorrections to R_FU are included if flagVF is set to 1 (default).\nFrest represents the forces and torques due to all other types of\ninteractions, e.g. Brownian, electrostatic etc.  Note that this\nalgorithm neglects the inertial terms, thereby removing the\nrestriction of resolving the small interial time scale, which may not\nbe of interest for colloidal particles.  This pair style solves for\nthe velocity such that the hydrodynamic force balances all other types\nof forces, thereby resulting in a net zero force (zero inertia limit).\nWhen defining this pair style, it must be defined last so that when\nthis style is invoked all other types of forces have already been\ncomputed.  For the same reason, it won’t work if additional non-pair\nstyles are defined (such as bond or Kspace forces) as they are\ncalculated in LAMMPS after the pairwise interactions have been\ncomputed.\n\nNote\nWhen using these styles, the these pair styles are designed to\nbe used with implicit time integration and a correspondingly larger\ntimestep.  Thus either fix nve/noforce should\nbe used for spherical particles defined via atom_style sphere or fix nve/asphere/noforce should be used for\nspherical particles defined via atom_style ellipsoid.  This is because the velocity and angular\nmomentum of each particle is set by the pair style, and should not be\nreset by the time integration fix.\n\nStyle lubricateU requires monodisperse spherical particles; style\nlubricateU/poly allows for polydisperse spherical particles.\nIf the suspension is sheared via the fix deform\ncommand then the pair style uses the shear rate to adjust the\nhydrodynamic interactions accordingly. Volume changes due to fix\ndeform are accounted for when computing the volume fraction\ncorrections to R_FU.\nWhen computing the volume fraction corrections to R_FU, the presence\nof walls (whether moving or stationary) will affect the volume\nfraction available to colloidal particles. This is currently accounted\nfor with the following types of walls: wall/lj93,\nwall/lj126, wall/colloid, and\nwall/harmonic.  For these wall styles, the correct\nvolume fraction will be used when walls do not coincide with the box\nboundary, as well as when walls move and thereby cause a change in the\nvolume fraction. To use these wall styles with pair_style lubricateU\nor lubricateU/poly, the fld yes option must be specified in the\nfix wall command.\nSince lubrication forces are dissipative, it is usually desirable to\nthermostat the system at a constant temperature. If Brownian motion\n(at a constant temperature) is desired, it can be set using the\npair_style brownian command. These pair styles\nand the brownian style should use consistent parameters for mu,\nflaglog, flagfld, cutinner, cutoff, flagHI and flagVF.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutinner (distance units)\ncutoff (distance units)\n\nThe two coefficients are optional.  If neither is specified, the two\ncutoffs specified in the pair_style command are used.  Otherwise both\nmust be specified.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the two cutoff distances for this\npair style can be mixed.  The default mix value is geometric.  See\nthe “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style mu flaglog cutinner cutoff gdot flagHI flagVF",
    "parameters": " * style = lubricateU or lubricateU/poly\n * mu = dynamic viscosity (dynamic viscosity units)\n * flaglog = 0/1 to exclude/include log terms in the lubrication approximation\n * cutinner = inner cut off distance (distance units)\n * cutoff = outer cutoff for interactions (distance units)\n * gdot = shear rate (1/time units)\n * flagHI (optional) = 0/1 to exclude/include 1/r hydrodynamic interactions\n * flagVF (optional) = 0/1 to exclude/include volume fraction corrections in the long-range isotropic terms\n * Examples: (all assume radius = 1)\n * pair_style lubricateU 1.5 1 2.01 2.5 0.01 1 1\n * pair_coeff 1 1 2.05 2.8\n * pair_coeff * *",
    "examples": "pair_style local/density benzene_water.localdensity.table\n\npair_style hybrid/overlay table spline 500 local/density\npair_coeff * * local/density  benzene_water.localdensity.table",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nCurrently, these pair styles assume that all other types of\nforces/torques on the particles have been already been computed when\nit is invoked.  This requires this style to be defined as the last of\nthe pair styles, and that no fixes apply additional constraint forces.\nOne exception is the fix wall/colloid commands, which\nhas an “fld” option to apply their wall forces correctly.\nOnly spherical monodisperse particles are allowed for pair_style\nlubricateU.\nOnly spherical particles are allowed for pair_style lubricateU/poly.\nFor sheared suspensions, it is assumed that the shearing is done in\nthe xy plane, with x being the velocity direction and y being the\nvelocity-gradient direction. In this case, one must use fix deform with the same rate of shear (erate)."
},
{
    "command": "pair_style lj/mdf",
    "html_filename": "pair_mdf.html",
    "short_description": "The lj/mdf, buck/mdf and lennard/mdf compute the standard 12-6 Lennard-Jones and Buckingham potential with the addition of a taper function that ramps the energy and force smoothly to zero between an inner and outer cutoff",
    "description": "The lj/mdf, buck/mdf and lennard/mdf compute the standard 12-6\nLennard-Jones and Buckingham potential with the addition of a taper\nfunction that ramps the energy and force smoothly to zero between an\ninner and outer cutoff.\n\n\\[E_{smooth}(r) = E(r)*f(r)\\]\nThe tapering, f(r), is done by using the Mei, Davenport, Fernando\nfunction (Mei).\n\n\\[\\begin{split}f(r) & = 1.0  \\qquad \\qquad \\mathrm{for} \\qquad r < r_m \\\\\nf(r) & = (1 - x)^3*(1+3x+6x^2) \\quad \\mathrm{for} \\qquad r_m < r < r_{cut} \\\\\nf(r) & = 0.0  \\qquad \\qquad \\mathrm{for} \\qquad  r >= r_{cut} \\\\\\end{split}\\]\nwhere\n\n\\[x = \\frac{(r-r_m)}{(r_{cut}-r_m)}\\]\nHere \\(r_m\\) is the inner cutoff radius and \\(r_{cut}\\) is the\nouter cutoff radius.\n\nFor the lj/mdf pair_style, the potential energy, E(r), is the\nstandard 12-6 Lennard-Jones written in the epsilon/sigma form:\n\n\\[E(r) = 4\\epsilon\\biggl[\\bigl(\\frac{\\sigma}{r}\\bigr)^{12} - \\bigl(\\frac{\\sigma}{r}\\bigr)^6\\biggr]\\]\nEither the first two or all of the following coefficients must be\ndefined for each pair of atoms types via the pair_coeff command as in\nthe examples above, or in the data file read by the read_data. The two cutoffs default to the global values and\n\\(\\epsilon\\) and \\(\\sigma\\) can also be determined by mixing as\ndescribed below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\n\\(r_m\\) (distance units)\n\\(r_{cut}\\) (distance units)\n\n\nFor the buck/mdf pair_style, the potential energy, E(r), is the\nstandard Buckingham potential with three required coefficients.\nThe two cutoffs can be omitted and default to the corresponding\nglobal values:\n\n\\[E(r) = A e^{(-r/\\rho)} -\\frac{C}{r^6}\\]\n\nA (energy units)\n\\(\\rho\\) (distance units)\nC (energy-distance^6 units)\n\\(r_m\\) (distance units)\n\\(r_{cut}\\) (distance units)\n\n\nFor the lennard/mdf pair_style, the potential energy, E(r), is the\nstandard 12-6 Lennard-Jones written in the A/B form:\n\n\\[E(r) = \\frac{A}{r^{12}} - \\frac{B}{r^{6}}\\]\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples above, or in the\ndata file read by the read_data commands, or by mixing as described below.\nThe two cutoffs default to their global values and must be either both\ngiven or both left out:\n\nA (energy-distance^12 units)\nB (energy-distance^6 units)\n\\(r_m\\) (distance units)\n\\(r_{cut}\\) (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the \\(\\epsilon\\) and\n\\(sigma\\) coefficients and cutoff distances for the lj/mdf pair\nstyle can be mixed.  The default mix value is geometric.  See the\n“pair_modify” command for details. The other two pair styles buck/mdf\nand lennard/mdf do not support mixing, so all I,J pairs of coefficients\nmust be specified explicitly.\nNone of the lj/mdf, buck/mdf, or lennard/mdf pair styles supports\nthe pair_modify shift option or long-range\ntail corrections to pressure and energy.\nThese styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/mdf or buck/mdf or lennard/mdf\n * args = list of arguments for a particular style\n * lj/mdf args = cutoff1 cutoff2\n *   cutoff1 = inner cutoff for the start of the tapering function\n *   cutoff1 = out cutoff for the end of the tapering function\n * buck/mdf args = cutoff1 cutoff2\n *   cutoff1 = inner cutoff for the start of the tapering function\n *   cutoff1 = out cutoff for the end of the tapering function\n * lennard/mdf args = cutoff1 cutoff2\n *   cutoff1 = inner cutoff for the start of the tapering function\n *   cutoff1 = out cutoff for the end of the tapering function",
    "examples": "pair_style lj/mdf 2.5 3.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.1 2.8 3.0 3.2\n\npair_style buck 2.5 3.0\npair_coeff * * 100.0 1.5 200.0\npair_coeff * * 100.0 1.5 200.0 3.0 3.5\n\npair_style lennard/mdf 2.5 3.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1021760.3664 2120.317338 3.0 3.2",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "pair_style meam/spline",
    "html_filename": "pair_meam_spline.html",
    "short_description": "The meam/spline style computes pairwise interactions for metals using a variant of modified embedded-atom method (MEAM) potentials (Lenosky)",
    "description": "The meam/spline style computes pairwise interactions for metals\nusing a variant of modified embedded-atom method (MEAM) potentials\n(Lenosky).  For a single species (“old-style”) MEAM,\nthe total energy E is given by\n\n\\[\\begin{split}E & =\\sum_{i<j}\\phi(r_{ij})+\\sum_{i}U(n_{i}) \\\\\nn_{i} & =\\sum_{j}\\rho(r_{ij})+\\sum_{\\substack{j<k,\\\\j,k\\neq i}}f(r_{ij})f(r_{ik})g[\\cos(\\theta_{jik})]\\end{split}\\]\nwhere \\(\\rho_i\\) is the density at atom I, \\(\\theta_{jik}\\) is\nthe angle between atoms J, I, and K centered on atom I. The five\nfunctions \\(\\phi, U, \\rho, f,\\) and g are represented by cubic splines.\nThe meam/spline style also supports a new style multicomponent\nmodified embedded-atom method (MEAM) potential (Zhang), where\nthe total energy E is given by\n\n\\[\\begin{split}E &= \\sum_{i<j}\\phi_{ij}(r_{ij})+\\sum_{i}U_i(n_{i}) \\\\\nn_{i} & = \\sum_{j\\ne i}\\rho_j(r_{ij})+\\sum_{\\substack{j<k,\\\\j,k\\neq i}}f_{j}(r_{ij})f_{k}(r_{ik})g_{jk}[\\cos(\\theta_{jik})]\\end{split}\\]\nwhere the five functions \\(\\phi, U, \\rho, f,\\) and g depend on the\nchemistry of the atoms in the interaction.  In particular, if there are\nN different chemistries, there are N different U, \\(\\rho\\), and\nf functions, while there are N(N+1)/2 different \\(\\phi\\) and g\nfunctions.  The new style multicomponent MEAM potential files are\nindicated by the second line in the file starts with “meam/spline”\nfollowed by the number of elements and the name of each element.\nThe cutoffs and the coefficients for these spline functions are listed\nin a parameter file which is specified by the\npair_coeff command.  Parameter files for different\nelements are included in the “potentials” directory of the LAMMPS\ndistribution and have a “.meam.spline” file suffix.  All of these\nfiles are parameterized in terms of LAMMPS metal units.\nNote that unlike for other potentials, cutoffs for spline-based MEAM\npotentials are not set in the pair_style or pair_coeff command; they\nare specified in the potential files themselves.\nUnlike the EAM pair style, which retrieves the atomic mass from the\npotential file, the spline-based MEAM potentials do not include mass\ninformation; thus you need to use the mass command to\nspecify it.\nOnly a single pair_coeff command is used with the meam/spline style\nwhich specifies a potential file with parameters for all needed\nelements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of spline-based MEAM elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine the Ti.meam.spline file has values for Ti (old style).  If\nyour LAMMPS simulation has 3 atoms types and they are all to be\ntreated with this potentials, you would use the following pair_coeff\ncommand:\npair_coeff * * Ti.meam.spline Ti Ti Ti\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe three Ti arguments map LAMMPS atom types 1,2,3 to the Ti element\nin the potential file.  If a mapping value is specified as NULL, the\nmapping is not performed.  This can be used when a meam/spline\npotential is used as part of the hybrid pair style.  The NULL values\nare placeholders for atom types that will be used with other\npotentials. The old-style potential maps any non-NULL species named\non the command line to that single type.\nAn example with a two component spline (new style) is TiO.meam.spline, where\nthe command\npair_coeff * * TiO.meam.spline Ti O\n\n\nwill map the 1st atom type to Ti and the second atom type to O. Note\nin this case that the species names need to match exactly with the\nnames of the elements in the TiO.meam.spline file; otherwise an\nerror will be raised. This behavior is different than the old style\nMEAM files.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThe meam/spline pair style does not write its information to binary restart files, since it is stored in an external\npotential parameter file.  Thus, you need to re-specify the pair_style\nand pair_coeff commands in an input script that reads a restart file.\nThe meam/spline pair style can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style meam/spline",
    "parameters": " * ",
    "examples": "pair_style meam/spline\npair_coeff * * Ti.meam.spline Ti\npair_coeff * * Ti.meam.spline Ti Ti Ti",
    "restrictions": "This pair style requires the newton setting to be “on”\nfor pair interactions.\nThis pair style is only enabled if LAMMPS was built with the USER-MISC\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "pair_style meam/sw/spline",
    "html_filename": "pair_meam_sw_spline.html",
    "short_description": "The meam/sw/spline style computes pairwise interactions for metals using a variant of modified embedded-atom method (MEAM) potentials (Lenosky) with an additional Stillinger-Weber (SW) term (Stillinger) in the energy",
    "description": "The meam/sw/spline style computes pairwise interactions for metals\nusing a variant of modified embedded-atom method (MEAM) potentials\n(Lenosky) with an additional Stillinger-Weber (SW) term\n(Stillinger) in the energy.  This form of the potential\nwas first proposed by Nicklas, Fellinger, and Park\n(Nicklas).  We refer to it as MEAM+SW.  The total energy E\nis given by\n\n\\[\\begin{split}E & = E_{MEAM} + E_{SW} \\\\\nE_{MEAM} & =  \\sum _{IJ} \\phi (r_{IJ}) + \\sum _{I} U(\\rho _I) \\\\\nE_{SW} & =  \\sum _{I} \\sum _{JK} F(r_{IJ}) \\, F(r_{IK}) \\, G(\\cos(\\theta _{JIK})) \\\\\n\\rho _I & = \\sum _J \\rho(r_{IJ}) + \\sum _{JK} f(r_{IJ}) \\, f(r_{IK}) \\, g(\\cos(\\theta _{JIK}))\\end{split}\\]\nwhere \\(\\rho_I\\) is the density at atom I, \\(\\theta_{JIK}\\) is\nthe angle between atoms J, I, and K centered on atom I. The seven\nfunctions \\(\\phi, F, G, U, \\rho, f,\\) and g are represented by\ncubic splines.\nThe cutoffs and the coefficients for these spline functions are listed\nin a parameter file which is specified by the\npair_coeff command.  Parameter files for different\nelements are included in the “potentials” directory of the LAMMPS\ndistribution and have a “.meam.sw.spline” file suffix.  All of these\nfiles are parameterized in terms of LAMMPS metal units.\nNote that unlike for other potentials, cutoffs for spline-based\nMEAM+SW potentials are not set in the pair_style or pair_coeff\ncommand; they are specified in the potential files themselves.\nUnlike the EAM pair style, which retrieves the atomic mass from the\npotential file, the spline-based MEAM+SW potentials do not include\nmass information; thus you need to use the mass command to\nspecify it.\nOnly a single pair_coeff command is used with the meam/sw/spline style\nwhich specifies a potential file with parameters for all needed\nelements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of spline-based MEAM+SW elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine the Ti.meam.sw.spline file has values for Ti.\nIf your LAMMPS simulation has 3 atoms types and they are all to be\ntreated with this potential, you would use the following pair_coeff\ncommand:\npair_coeff * * Ti.meam.sw.spline Ti Ti Ti\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe three Ti arguments map LAMMPS atom types 1,2,3 to the Ti element\nin the potential file. If a mapping value is specified as NULL, the\nmapping is not performed. This can be used when a meam/sw/spline\npotential is used as part of the hybrid pair style. The NULL values\nare placeholders for atom types that will be used with other\npotentials.\n\nNote\nThe meam/sw/spline style currently supports only\nsingle-element MEAM+SW potentials.  It may be extended for alloy\nsystems in the future.\n\nExample input scripts that use this pair style are provided\nin the examples/USER/misc/meam_sw_spline directory.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe pair style does not support multiple element types or mixing.\nIt has been designed for pure elements only.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThe meam/sw/spline pair style does not write its information to\nbinary restart files, since it is stored in an external\npotential parameter file.  Thus, you need to re-specify the pair_style\nand pair_coeff commands in an input script that reads a restart file.\nThe meam/sw/spline pair style can only be used via the pair\nkeyword of the run_style respa command.  They do not\nsupport the inner, middle, outer keywords.",
    "syntax": "pair_style meam/sw/spline",
    "parameters": " * ",
    "examples": "pair_style meam/sw/spline\npair_coeff * * Ti.meam.sw.spline Ti\npair_coeff * * Ti.meam.sw.spline Ti Ti Ti",
    "restrictions": "This pair style requires the newton setting to be “on”\nfor pair interactions.\nThis pair style is only enabled if LAMMPS was built with the USER-MISC\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "pair_style meam/c",
    "html_filename": "pair_meamc.html",
    "short_description": " Note The behavior of the MEAM potential for alloy systems has changed as of November 2010; see description below of the mixture_ref_t parameter  Style meam/c computes pairwise interactions for a variety of materials using modified embedded-atom method (MEAM) potentials (Baskes)",
    "description": "\nNote\nThe behavior of the MEAM potential for alloy systems has changed\nas of November 2010; see description below of the mixture_ref_t\nparameter\n\nStyle meam/c computes pairwise interactions for a variety of materials\nusing modified embedded-atom method (MEAM) potentials\n(Baskes).  Conceptually, it is an extension to the original\nEAM potentials which adds angular forces.  It is\nthus suitable for modeling metals and alloys with fcc, bcc, hcp and\ndiamond cubic structures, as well as covalently bonded materials like\nsilicon and carbon. Style meam/c is a translation of the (now obsolete)\nmeam code from Fortran to C++. It is functionally equivalent to meam\nbut more efficient, and thus meam has been removed from LAMMPS after\nthe 12 December 2018 release.\nIn the MEAM formulation, the total energy E of a system of atoms is\ngiven by:\n\n\\[E = \\sum_i \\left\\{ F_i(\\bar{\\rho}_i)\n    + \\frac{1}{2} \\sum_{i \\neq j} \\phi_{ij} (r_{ij}) \\right\\}\\]\nwhere F is the embedding energy which is a function of the atomic\nelectron density \\(\\rho\\), and \\(\\phi\\) is a pair potential\ninteraction.  The pair interaction is summed over all neighbors J of\natom I within the cutoff distance.  As with EAM, the multi-body nature\nof the MEAM potential is a result of the embedding energy term.  Details\nof the computation of the embedding and pair energies, as implemented in\nLAMMPS, are given in (Gullet) and references therein.\nThe various parameters in the MEAM formulas are listed in two files\nwhich are specified by the pair_coeff command.\nThese are ASCII text files in a format consistent with other MD codes\nthat implement MEAM potentials, such as the serial DYNAMO code and\nWarp.  Several MEAM potential files with parameters for different\nmaterials are included in the “potentials” directory of the LAMMPS\ndistribution with a “.meam” suffix.  All of these are parameterized in\nterms of LAMMPS metal units.\nNote that unlike for other potentials, cutoffs for MEAM potentials are\nnot set in the pair_style or pair_coeff command; they are specified in\nthe MEAM potential files themselves.\nOnly a single pair_coeff command is used with the meam style which\nspecifies two MEAM files and the element(s) to extract information\nfor.  The MEAM elements are mapped to LAMMPS atom types by specifying\nN additional arguments after the 2nd filename in the pair_coeff\ncommand, where N is the number of LAMMPS atom types:\n\nMEAM library file\nElem1, Elem2, …\nMEAM parameter file\nN element names = mapping of MEAM elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential files.\nAs an example, the potentials/library.meam file has generic MEAM\nsettings for a variety of elements.  The potentials/SiC.meam file has\nspecific parameter settings for a Si and C alloy system.  If your\nLAMMPS simulation has 4 atoms types and you want the 1st 3 to be Si,\nand the 4th to be C, you would use the following pair_coeff command:\npair_coeff * * library.meam Si C sic.meam Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe two filenames are for the library and parameter file respectively.\nThe Si and C arguments (between the file names) are the two elements\nfor which info will be extracted from the library file.  The first\nthree trailing Si arguments map LAMMPS atom types 1,2,3 to the MEAM Si\nelement.  The final C argument maps LAMMPS atom type 4 to the MEAM C\nelement.\nIf the 2nd filename is specified as NULL, no parameter file is read,\nwhich simply means the generic parameters in the library file are\nused.  Use of the NULL specification for the parameter file is\ndiscouraged for systems with more than a single element type\n(e.g. alloys), since the parameter file is expected to set element\ninteraction terms that are not captured by the information in the\nlibrary file.\nIf a mapping value is specified as NULL, the mapping is not performed.\nThis can be used when a meam potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\n\nNote\nIf the 2nd filename is NULL, the element names between the two\nfilenames can appear in any order, e.g. “Si C” or “C Si” in the\nexample above.  However, if the 2nd filename is not NULL (as in the\nexample above), it contains settings that are Fortran-indexed for the\nelements that preceed it.  Thus you need to insure you list the\nelements between the filenames in an order consistent with how the\nvalues in the 2nd filename are indexed.  See details below on the\nsyntax for settings in the 2nd file.\n\nThe MEAM library file provided with LAMMPS has the name\npotentials/library.meam.  It is the “meamf” file used by other MD\ncodes.  Aside from blank and comment lines (start with #) which can\nappear anywhere, it is formatted as a series of entries, each of which\nhas 19 parameters and can span multiple lines:\nelt, lat, z, ielement, atwt, alpha, b0, b1, b2, b3, alat, esub, asub,\nt0, t1, t2, t3, rozero, ibar\nThe “elt” and “lat” parameters are text strings, such as elt = Si or\nCu and lat = dia or fcc.  Because the library file is used by Fortran\nMD codes, these strings may be enclosed in single quotes, but this is\nnot required.  The other numeric parameters match values in the\nformulas above.  The value of the “elt” string is what is used in the\npair_coeff command to identify which settings from the library file\nyou wish to read in.  There can be multiple entries in the library\nfile with the same “elt” value; LAMMPS reads the 1st matching entry it\nfinds and ignores the rest.\nOther parameters in the MEAM library file correspond to single-element\npotential parameters:\nlat      = lattice structure of reference configuration\nz        = number of nearest neighbors in the reference structure\nielement = atomic number\natwt     = atomic weight\nalat     = lattice constant of reference structure\nesub     = energy per atom (eV) in the reference structure at equilibrium\nasub     = \"A\" parameter for MEAM (see e.g. (Baskes))\nThe alpha, b0, b1, b2, b3, t0, t1, t2, t3 parameters correspond to the\nstandard MEAM parameters in the literature (Baskes) (the b\nparameters are the standard beta parameters). Note that only parameters\nnormalized to t0 = 1.0 are supported.  The rozero parameter is\nan element-dependent density scaling that weights the reference\nbackground density (see e.g. equation 4.5 in (Gullet)) and\nis typically 1.0 for single-element systems.  The ibar parameter\nselects the form of the function G(Gamma) used to compute the electron\ndensity; options are\n 0 => G = sqrt(1+Gamma)\n 1 => G = exp(Gamma/2)\n 2 => not implemented\n 3 => G = 2/(1+exp(-Gamma))\n 4 => G = sqrt(1+Gamma)\n-5 => G = +-sqrt(abs(1+Gamma))\n\n\nIf used, the MEAM parameter file contains settings that override or\ncomplement the library file settings.  Examples of such parameter\nfiles are in the potentials directory with a “.meam” suffix.  Their\nformat is the same as is read by other Fortran MD codes.  Aside from\nblank and comment lines (start with #) which can appear anywhere, each\nline has one of the following forms.  Each line can also have a\ntrailing comment (starting with #) which is ignored.\nkeyword = value\nkeyword(I) = value\nkeyword(I,J) = value\nkeyword(I,J,K) = value\n\n\nThe indices I, J, K correspond to the elements selected from the\nMEAM library file numbered in the order of how those elements were\nselected starting from 1. Thus for the example given below\npair_coeff * * library.meam Si C sic.meam Si Si Si C\n\n\nan index of 1 would refer to Si and an index of 2 to C.\nThe recognized keywords for the parameter file are as follows:\nEc, alpha, rho0, delta, lattce, attrac, repuls, nn2, Cmin, Cmax, rc, delr,\naugt1, gsmooth_factor, re\nwhere\nrc          = cutoff radius for cutoff function; default = 4.0\ndelr        = length of smoothing distance for cutoff function; default = 0.1\nrho0(I)     = relative density for element I (overwrites value\n              read from meamf file)\nEc(I,J)     = cohesive energy of reference structure for I-J mixture\ndelta(I,J)  = heat of formation for I-J alloy; if Ec_IJ is input as\n              zero, then LAMMPS sets Ec_IJ = (Ec_II + Ec_JJ)/2 - delta_IJ\nalpha(I,J)  = alpha parameter for pair potential between I and J (can\n              be computed from bulk modulus of reference structure\nre(I,J)     = equilibrium distance between I and J in the reference\n              structure\nCmax(I,J,K) = Cmax screening parameter when I-J pair is screened\n              by K (I<=J); default = 2.8\nCmin(I,J,K) = Cmin screening parameter when I-J pair is screened\n              by K (I<=J); default = 2.0\nlattce(I,J) = lattice structure of I-J reference structure:\n                fcc = face centered cubic\n                bcc = body centered cubic\n                hcp = hexagonal close-packed\n                dim = dimer\n                dia = diamond (interlaced fcc for alloy)\n                dia3= diamond structure with primary 1NN and secondary 3NN interation\n                b1  = rock salt (NaCl structure)\n                c11 = MoSi2 structure\n                l12 = Cu3Au structure (lower case L, followed by 12)\n                b2  = CsCl structure (interpenetrating simple cubic)\n                ch4 = methane-like structure, only for binary system\n                lin = linear structure (180 degree angle)\n                zig = zigzag structure with a uniform angle\n                tri = H2O-like structure that has an angle\nnn2(I,J)    = turn on second-nearest neighbor MEAM formulation for\n              I-J pair (see for example (Lee)).\n                0 = second-nearest neighbor formulation off\n                1 = second-nearest neighbor formulation on\n                default = 0\nattrac(I,J) = additional cubic attraction term in Rose energy I-J pair potential\n                default = 0\nrepuls(I,J) = additional cubic repulsive term in Rose energy I-J pair potential\n                default = 0\nzbl(I,J)    = blend the MEAM I-J pair potential with the ZBL potential for small\n              atom separations (ZBL)\n                default = 1\ntheta(I,J)  = angle between three atoms in line, zigzag, and trimer reference structures in degrees\n                default = 180\ngsmooth_factor  = factor determining the length of the G-function smoothing\n                  region; only significant for ibar=0 or ibar=4.\n                      99.0 = short smoothing region, sharp step\n                      0.5  = long smoothing region, smooth step\n                      default = 99.0\naugt1           = integer flag for whether to augment t1 parameter by\n                  3/5*t3 to account for old vs. new meam formulations;\n                    0 = don't augment t1\n                    1 = augment t1\n                    default = 1\nialloy          = integer flag to use alternative averaging rule for t parameters,\n                  for comparison with the DYNAMO MEAM code\n                    0 = standard averaging (matches ialloy=0 in DYNAMO)\n                    1 = alternative averaging (matches ialloy=1 in DYNAMO)\n                    2 = no averaging of t (use single-element values)\n                    default = 0\nmixture_ref_t   = integer flag to use mixture average of t to compute the background\n                  reference density for alloys, instead of the single-element values\n                  (see description and warning elsewhere in this doc page)\n                    0 = do not use mixture averaging for t in the reference density\n                    1 = use mixture averaging for t in the reference density\n                    default = 0\nerose_form      = integer value to select the form of the Rose energy function\n                  (see description below).\n                    default = 0\nemb_lin_neg     = integer value to select embedding function for negative densities\n                    0 = F(rho)=0\n                    1 = F(rho) = -asub*esub*rho (linear in rho, matches DYNAMO)\n                    default = 0\nbkgd_dyn        = integer value to select background density formula\n                    0 = rho_bkgd = rho_ref_meam(a) (as in the reference structure)\n                    1 = rho_bkgd = rho0_meam(a)*Z_meam(a) (matches DYNAMO)\n                    default = 0\nRc, delr, re are in distance units (Angstroms in the case of metal\nunits).  Ec and delta are in energy units (eV in the case of metal\nunits).\nEach keyword represents a quantity which is either a scalar, vector,\n2d array, or 3d array and must be specified with the correct\ncorresponding array syntax.  The indices I,J,K each run from 1 to N\nwhere N is the number of MEAM elements being used.\nThus these lines\nrho0(2) = 2.25\nalpha(1,2) = 4.37\n\n\nset rho0 for the 2nd element to the value 2.25 and set alpha for the\nalloy interaction between elements 1 and 2 to 4.37.\nThe augt1 parameter is related to modifications in the MEAM\nformulation of the partial electron density function.  In recent\nliterature, an extra term is included in the expression for the\nthird-order density in order to make the densities orthogonal (see for\nexample (Wang), equation 3d); this term is included in the\nMEAM implementation in lammps.  However, in earlier published work\nthis term was not included when deriving parameters, including most of\nthose provided in the library.meam file included with lammps, and to\naccount for this difference the parameter t1 must be augmented by\n3/5*t3.  If augt1=1, the default, this augmentation is done\nautomatically.  When parameter values are fit using the modified\ndensity function, as in more recent literature, augt1 should be set to\n0.\nThe mixture_ref_t parameter is available to match results with those\nof previous versions of lammps (before January 2011).  Newer versions\nof lammps, by default, use the single-element values of the t\nparameters to compute the background reference density.  This is the\nproper way to compute these parameters.  Earlier versions of lammps\nused an alloy mixture averaged value of t to compute the background\nreference density.  Setting mixture_ref_t=1 gives the old behavior.\nWARNING: using mixture_ref_t=1 will give results that are demonstrably\nincorrect for second-neighbor MEAM, and non-standard for\nfirst-neighbor MEAM; this option is included only for matching with\nprevious versions of lammps and should be avoided if possible.\nThe parameters attrac and repuls, along with the integer selection\nparameter erose_form, can be used to modify the Rose energy function\nused to compute the pair potential.  This function gives the energy of\nthe reference state as a function of interatomic spacing.  The form of\nthis function is:\nastar = alpha * (r/re - 1.d0)\nif erose_form = 0: erose = -Ec*(1+astar+a3*(astar**3)/(r/re))*exp(-astar)\nif erose_form = 1: erose = -Ec*(1+astar+(-attrac+repuls/r)*(astar**3))*exp(-astar)\nif erose_form = 2: erose = -Ec*(1 +astar + a3*(astar**3))*exp(-astar)\na3 = repuls, astar < 0\na3 = attrac, astar >= 0\nMost published MEAM parameter sets use the default values attrac=repulse=0.\nSetting repuls=attrac=delta corresponds to the form used in several\nrecent published MEAM parameter sets, such as (Valone)\n\nNote\nThe default form of the erose expression in LAMMPS was corrected\nin March 2009.  The current version is correct, but may show different\nbehavior compared with earlier versions of lammps with the attrac\nand/or repuls parameters are non-zero.  To obtain the previous default\nform, use erose_form = 1 (this form does not seem to appear in the\nliterature).  An alternative form (see e.g. (Lee2)) is\navailable using erose_form = 2.\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS with\nuser-specifiable parameters as described above.  You never need to\nspecify a pair_coeff command with I != J arguments for this style.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style meam/c",
    "parameters": " * ",
    "examples": "pair_style meam/c\npair_coeff * * ../potentials/library.meam Si ../potentials/si.meam Si\npair_coeff * * ../potentials/library.meam Ni Al NULL Ni Al Ni Ni",
    "restrictions": "The meam/c style is provided in the USER-MEAMC package. It is\nonly enabled if LAMMPS was built with that package.\nSee the Build package doc page for more info.\nThe maximum number of elements, that can be read from the MEAM\nlibrary file, is determined at compile time. The default is 5.\nIf you need support for more elements, you have to change the\ndefine for the constant ‘maxelt’ at the beginning of the file\nsrc/USER-MEAMC/meam.h and update/recompile LAMMPS. There is no\nlimit on the number of atoms types."
},
{
    "command": "pair_style edpd",
    "html_filename": "pair_meso.html",
    "short_description": "The edpd style computes the pairwise interactions and heat fluxes for eDPD particles following the formulations in (Li2014_JCP) and Li2015_CC",
    "description": "The edpd style computes the pairwise interactions and heat fluxes\nfor eDPD particles following the formulations in\n(Li2014_JCP) and Li2015_CC. The time\nevolution of an eDPD particle is governed by the conservation of\nmomentum and energy given by\n\n\\[\\begin{split}\\frac{\\mathrm{d}^2 \\mathbf{r}_i}{\\mathrm{d} t^2}=\n\\frac{\\mathrm{d} \\mathbf{v}_i}{\\mathrm{d} t}\n=\\mathbf{F}_{i}=\\sum_{i\\neq j}(\\mathbf{F}_{ij}^{C}+\\mathbf{F}_{ij}^{D}+\\mathbf{F}_{ij}^{R}) \\\\\nC_v\\frac{\\mathrm{d} T_i}{\\mathrm{d} t}= q_{i} = \\sum_{i\\neq j}(q_{ij}^{C}+q_{ij}^{V}+q_{ij}^{R}),\\end{split}\\]\nwhere the three components of \\(F_{i}\\) including the conservative\nforce \\(F_{ij}^C\\), dissipative force \\(F_{ij}^D\\) and random\nforce \\(F_{ij}^R\\) are expressed as\n\n\\[\\begin{split}\\mathbf{F}_{ij}^{C} & = \\alpha_{ij}{\\omega_{C}}(r_{ij})\\mathbf{e}_{ij} \\\\\n\\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij} \\\\\n\\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij} \\\\\n\\omega_{C}(r) & = 1 - r/r_c \\\\\n\\alpha_{ij} & = A\\cdot k_B(T_i + T_j)/2 \\\\\n\\omega_{D}(r) & = \\omega^2_{R}(r) = (1-r/r_c)^s \\\\\n\\sigma_{ij}^2 & = 4\\gamma k_B T_i T_j/(T_i + T_j)\\end{split}\\]\nin which the exponent of the weighting function s can be defined as a\ntemperature-dependent variable. The heat flux between particles\naccounting for the collisional heat flux \\(q^C\\), viscous heat flux\n\\(q^V\\), and random heat flux \\(q^R\\) are given by\n\n\\[\\begin{split}q_i^C & = \\sum_{j \\ne i} k_{ij} \\omega_{CT}(r_{ij}) \\left( \\frac{1}{T_i} - \\frac{1}{T_j} \\right) \\\\\nq_i^V & = \\frac{1}{2 C_v}\\sum_{j \\ne i}{ \\left\\{ \\omega_D(r_{ij})\\left[\\gamma_{ij} \\left( \\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij} \\right)^2 - \\frac{\\left( \\sigma _{ij} \\right)^2}{m}\\right] - \\sigma _{ij} \\omega_R(r_{ij})\\left( \\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij} \\right){\\xi_{ij}} \\right\\} } \\\\\nq_i^R & = \\sum_{j \\ne i} \\beta _{ij} \\omega_{RT}(r_{ij}) d {t^{ - 1/2}} \\xi_{ij}^e \\\\\n\\omega_{CT}(r) & =\\omega_{RT}^2(r)=\\left(1-r/r_{ct}\\right)^{s_T} \\\\\nk_{ij} & =C_v^2\\kappa(T_i + T_j)^2/4k_B \\\\\n\\beta_{ij}^2 & = 2k_Bk_{ij}\\end{split}\\]\nwhere the mesoscopic heat friction \\(\\kappa\\) is given by\n\n\\[\\kappa  = \\frac{315k_B\\upsilon }{2\\pi \\rho C_v r_{ct}^5}\\frac{1}{Pr},\\]\nwith \\(\\upsilon\\) being the kinematic viscosity. For more details,\nsee Eq.(15) in (Li2014_JCP).\nThe following coefficients must be defined in eDPD system for each\npair of atom types via the pair_coeff command as in\nthe examples above.\n\nA (force units)\n\\(\\gamma\\) (force/velocity units)\npower_f (positive real)\ncutoff (distance units)\nkappa (thermal conductivity units)\npower_T (positive real)\ncutoff_T (distance units)\noptional keyword = power or kappa\n\nThe keyword power or kappa is optional. Both “power” and “kappa”\nrequire 4 parameters \\(c_1, c_2, c_3, c_4\\) showing the temperature\ndependence of the exponent \\(s(T) = \\mathrm{power}_f ( 1+c_1\n(T-1) + c_2 (T-1)^2 + c_3 (T-1)^3 + c_4 (T-1)^4 )\\) and of the mesoscopic\nheat friction \\(s_T(T) = \\kappa (1 + c_1 (T-1) + c_2 (T-1)^2 + c_3\n(T-1)^3 + c_4 (T-1)^4)\\).  If the keyword power or kappa is not\nspecified, the eDPD system will use constant power_f and\n\\(\\kappa\\), which is independent to temperature changes.\n\nThe mdpd/rhosum style computes the local particle mass density\n\\(\\rho\\) for mDPD particles by kernel function interpolation.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above.\n\ncutoff (distance units)\n\n\nThe mdpd style computes the many-body interactions between mDPD\nparticles following the formulations in\n(Li2013_POF). The dissipative and random forces are in\nthe form same as the classical DPD, but the conservative force is\nlocal density dependent, which are given by\n\n\\[\\begin{split}\\mathbf{F}_{ij}^C & = Aw_c(r_{ij})\\mathbf{e}_{ij} + B(\\rho_i+\\rho_j)w_d(r_{ij})\\mathbf{e}_{ij} \\\\\n\\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij} \\\\\n\\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij}\\end{split}\\]\nwhere the first term in \\(F_C\\) with a negative coefficient \\(A\n< 0\\) stands for an attractive force within an interaction range\n\\(r_c\\), and the second term with \\(B > 0\\) is the\ndensity-dependent repulsive force within an interaction range\n\\(r_d\\).\nThe following coefficients must be defined for each pair of atom types via the\npair_coeff command as in the examples above.\n\nA (force units)\nB (force units)\n\\(\\gamma\\) (force/velocity units)\ncutoff_c (distance units)\ncutoff_d (distance units)\n\n\nThe tdpd style computes the pairwise interactions and chemical\nconcentration fluxes for tDPD particles following the formulations in\n(Li2015_JCP).  The time evolution of a tDPD particle is\ngoverned by the conservation of momentum and concentration given by\n\n\\[\\begin{split}\\frac{\\mathrm{d}^2 \\mathbf{r}_i}{\\mathrm{d} t^2} & = \\frac{\\mathrm{d} \\mathbf{v}_i}{\\mathrm{d} t}=\\mathbf{F}_{i}=\\sum_{i\\neq j}(\\mathbf{F}_{ij}^{C}+\\mathbf{F}_{ij}^{D}+\\mathbf{F}_{ij}^{R}) \\\\\n\\frac{\\mathrm{d} C_{i}}{\\mathrm{d} t} & = Q_{i} = \\sum_{i\\neq j}(Q_{ij}^{D}+Q_{ij}^{R}) + Q_{i}^{S}\\end{split}\\]\nwhere the three components of \\(F_{i}\\) including the conservative\nforce \\(F_{ij}^C\\), dissipative force \\(F_{ij}^C\\) and random\nforce \\(F_{ij}^C\\) are expressed as\n\n\\[\\begin{split}\\mathbf{F}_{ij}^{C} & = A{\\omega_{C}}(r_{ij})\\mathbf{e}_{ij} \\\\\n\\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij}  \\\\\n\\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij} \\\\\n\\omega_{C}(r) & = 1 - r/r_c \\\\\n\\omega_{D}(r) & = \\omega^2_{R}(r) = (1-r/r_c)^{\\rm power\\_f} \\\\\n\\sigma^2 = 2\\gamma k_B T\\end{split}\\]\nThe concentration flux between two tDPD particles includes the Fickian\nflux \\(Q_{ij}^D\\) and random flux \\(Q_{ij}^R\\), which are given\nby\n\n\\[\\begin{split}Q_{ij}^D & = -\\kappa_{ij} w_{DC}(r_{ij}) \\left( C_i - C_j \\right) \\\\\nQ_{ij}^R & = \\epsilon_{ij}\\left( C_i + C_j \\right) w_{RC}(r_{ij}) \\xi_{ij} \\\\\nw_{DC}(r_{ij}) & =w^2_{RC}(r_{ij}) = (1 - r/r_{cc})^{\\rm power\\_{cc}} \\\\\n\\epsilon_{ij}^2 & = m_s^2\\kappa_{ij}\\rho\\end{split}\\]\nwhere the parameters kappa and epsilon determine the strength of the\nFickian and random fluxes. \\(m_s\\) is the mass of a single solute\nmolecule.  In general, \\(m_s\\) is much smaller than the mass of a\ntDPD particle m. For more details, see (Li2015_JCP).\nThe following coefficients must be defined for each pair of atom types via the\npair_coeff command as in the examples above.\n\nA (force units)\n\\(\\gamma\\) (force/velocity units)\npower_f (positive real)\ncutoff (distance units)\ncutoff_CC (distance units)\n\\(\\kappa_i\\) (diffusivity units)\n\\(\\epsilon_i\\) (diffusivity units)\npower_cc_i (positive real)\n\nThe last 3 values must be repeated Nspecies times, so that values for\neach of the Nspecies chemical species are specified, as indicated by\nthe “I” suffix.  In the first pair_coeff example above for pair_style\ntdpd, Nspecies = 1.  In the second example, Nspecies = 2, so 3\nadditional coeffs are specified (for species 2).\n\nExample scripts\nThere are example scripts for using all these pair styles in\nexamples/USER/meso.  The example for an eDPD simulation models heat\nconduction with source terms analog of periodic Poiseuille flow\nproblem. The setup follows Fig.12 in (Li2014_JCP). The\noutput of the short eDPD simulation (about 2 minutes on a single core)\ngives a temperature and density profiles as\n\nThe example for a mDPD simulation models the oscillations of a liquid\ndroplet started from a liquid film. The mDPD parameters are adopted\nfrom (Li2013_POF).  The short mDPD run (about 2 minutes\non a single core) generates a particle trajectory which can\nbe visualized as follows.\n\n\nThe first image is the initial state of the simulation.  If you\nclick it a GIF movie should play in your browser.  The second image\nis the final state of the simulation.\nThe example for a tDPD simulation computes the effective diffusion\ncoefficient of a tDPD system using a method analogous to the periodic\nPoiseuille flow.  The tDPD system is specified with two chemical\nspecies, and the setup follows Fig.1 in\n(Li2015_JCP). The output of the short tDPD simulation\n(about one and a half minutes on a single core) gives the\nconcentration profiles of the two chemical species as\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe styles edpd, mdpd, mdpd/rhosum and tdpd do not support\nmixing. Thus, coefficients for all I,J pairs must be specified explicitly.\nThe styles edpd, mdpd, mdpd/rhosum and tdpd do not support\nthe pair_modify shift, table, and tail options.\nThe styles edpd, mdpd, mdpd/rhosum and tdpd do not write\ninformation to binary restart files. Thus, you need\nto re-specify the pair_style and pair_coeff commands in an input script\nthat reads a restart file.",
    "syntax": "pair_style style args",
    "parameters": " * style = edpd or mdpd or mdpd/rhosum or tdpd\n * args = list of arguments for a particular style\n * edpd args = cutoff seed\n *   cutoff = global cutoff for eDPD interactions (distance units)\n *   seed = random # seed (integer) (if <= 0, eDPD will use current time as the seed)\n * mdpd args = T cutoff seed\n *   T = temperature (temperature units)\n *   cutoff = global cutoff for mDPD interactions (distance units)\n *   seed = random # seed (integer) (if <= 0, mDPD will use current time as the seed)\n * mdpd/rhosum args =\n * tdpd args = T cutoff seed\n *   T = temperature (temperature units)\n *   cutoff = global cutoff for tDPD interactions (distance units)\n *   seed = random # seed (integer) (if <= 0, tDPD will use current time as the seed)",
    "examples": "pair_style edpd 1.58 9872598\npair_coeff * * 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58\npair_coeff 1 1 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58 power 10.54 -3.66 3.44 -4.10\npair_coeff 1 1 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58 power 10.54 -3.66 3.44 -4.10 kappa -0.44 -3.21 5.04 0.00\n\npair_style hybrid/overlay mdpd/rhosum mdpd 1.0 1.0 65689\npair_coeff 1 1 mdpd/rhosum  0.75\npair_coeff 1 1 mdpd -40.0 25.0 18.0 1.0 0.75\n\npair_style tdpd 1.0 1.58 935662\npair_coeff * * 18.75 4.5 0.41 1.58 1.58 1.0 1.0E-5 2.0\npair_coeff 1 1 18.75 4.5 0.41 1.58 1.58 1.0 1.0E-5 2.0 3.0 1.0E-5 2.0",
    "restrictions": "The pair styles edpd, mdpd, mdpd/rhosum and tdpd are part of\nthe USER-MESO package. It is only enabled if LAMMPS was built with\nthat package.  See the Build package doc page for\nmore info."
},
{
    "command": "pair_style mesocnt",
    "html_filename": "pair_mesocnt.html",
    "short_description": "Style mesocnt implements a mesoscopic potential for the interaction of carbon nanotubes (CNTs)",
    "description": "Style mesocnt implements a mesoscopic potential\nfor the interaction of carbon nanotubes (CNTs). In this potential,\nCNTs are modelled as chains of cylindrical segments in which\neach infinitesimal surface element interacts with all other\nCNT surface elements with the Lennard-Jones (LJ) term adopted from\nthe airebo style. The interaction energy\nis then computed by integrating over the surfaces of all interacting\nCNTs.\nThe potential is based on interactions between one cylindrical\nsegment and infinitely or semi-infinitely long CNTs as described\nin (Volkov1). Chains of segments are\nconverted to these (semi-)infinite CNTs bases on an approximate\nchain approach outlined in (Volkov2).\nThis allows to simplify the computation of the interactions\nsignificantly and reduces the computational times to the\nsame order of magnitude as for regular bead spring models\nwhere beads interact with the standard pair_lj/cut\npotential.\nIn LAMMPS, cylindrical segments are represented by bonds. Each\nsegment is defined by its two end points (“nodes”) which correspond\nto atoms in LAMMPS. For the exact functional form of the potential\nand implementation details, the reader is referred to the\noriginal papers (Volkov1) and\n(Volkov2).\nThe potential requires tabulated data provided in a single ASCII\ntext file specified in the pair_coeff command.\nThe first line of the file provides a time stamp and\ngeneral information. The second line lists four integers giving\nthe number of data points provided in the subsequent four\ndata tables. The third line lists four floating point numbers:\nthe CNT radius R, the LJ parameter sigma and two numerical\nparameters delta1 and delta2. These four parameters are given\nin Angstroms. This is followed by four data tables each separated\nby a single empty line. The first two tables have two columns\nand list the parameters uInfParallel and Gamma respectively.\nThe last two tables have three columns giving data on a quadratic\narray and list the parameters Phi and uSemiParallel respectively.\nuInfParallel and uSemiParallel are given in eV/Angstrom, Phi is\ngiven in eV and Gamma is unitless.\nPotential files for CNTs can be readily generated using the freely\navailable code provided on\nhttps://github.com/phankl/cntpot\n\n\nUsing the same approach, it should also be possible to\ngenerate potential files for other 1D systems such as\nboron nitride nanotubes.\n\nNote\nLAMMPS comes with one mesocnt style potential file\nwhere the default number of data points per table is 1001.\nThis is sufficient for NVT simulations. For proper energy\nconservation, we recommend using a potential file where\nthe resolution for Phi is at least 2001 data points.\n\n\nNote\nThe mesocnt style requires CNTs to be represented\nas a chain of atoms connected by bonds. Atoms need\nto be numbered consecutively within one chain.\nAtoms belonging to different CNTs need to be assigned\ndifferent molecule IDs.\n\nA full summary of the method and LAMMPS implementation details\nis expected to soon become available in Computer Physics\nCommunications.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThe mesocnt pair style do not write their information to binary restart files,\nsince it is stored in tabulated potential files.\nThus, you need to re-specify the pair_style and pair_coeff commands in\nan input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style mesocnt",
    "parameters": " * ",
    "examples": "pair_style mesocnt\npair_coeff * * 10_10.cnt",
    "restrictions": "This style is part of the USER-MISC package.  It is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair potential requires the newton setting to be\n“on” for pair interactions."
},
{
    "command": "pair_style mgpt",
    "html_filename": "pair_mgpt.html",
    "short_description": "Within DFT quantum mechanics, generalized pseudopotential theory (GPT) (Moriarty1) provides a first-principles approach to multi-ion interatomic potentials in d-band transition metals, with a volume-dependent, real-space total-energy functional for the N-ion elemental bulk material in the form  \\[E_{\\rm tot}({\\bf R}_1 \\ldots {\\bf R}_N) = NE_{\\rm vol}(\\Omega ) + \\frac{1}{2} \\sum _{i,j} \\mbox{}^\\prime \\ v_2(ij;\\Omega ) + \\frac{1}{6} \\sum _{i,j,k} \\mbox{}^\\prime \\ v_3(ijk;\\Omega ) + \\frac{1}{24} \\sum _{i,j,k,l} \\mbox{}^\\prime \\ v_4(ijkl;\\Omega )\\] where the prime on each summation sign indicates the exclusion of all self-interaction terms from the summation",
    "description": "Within DFT quantum mechanics, generalized pseudopotential theory (GPT)\n(Moriarty1) provides a first-principles approach to\nmulti-ion interatomic potentials in d-band transition metals, with a\nvolume-dependent, real-space total-energy functional for the N-ion\nelemental bulk material in the form\n\n\\[E_{\\rm tot}({\\bf R}_1 \\ldots {\\bf R}_N) = NE_{\\rm vol}(\\Omega )\n+ \\frac{1}{2} \\sum _{i,j} \\mbox{}^\\prime \\ v_2(ij;\\Omega )\n+ \\frac{1}{6} \\sum _{i,j,k} \\mbox{}^\\prime \\ v_3(ijk;\\Omega )\n+ \\frac{1}{24} \\sum _{i,j,k,l} \\mbox{}^\\prime \\ v_4(ijkl;\\Omega )\\]\nwhere the prime on each summation sign indicates the exclusion of all\nself-interaction terms from the summation.  The leading volume term\nE_vol as well as the two-ion central-force pair potential v_2 and the\nthree- and four-ion angular-force potentials, v_3 and v_4, depend\nexplicitly on the atomic volume Omega, but are structure independent\nand transferable to all bulk ion configurations, either ordered or\ndisordered, and with of without the presence of point and line\ndefects.  The simplified model GPT or MGPT (Moriarty2,\nMoriarty3), which retains the form of E_tot and permits\nmore efficient large-scale atomistic simulations, derives from the GPT\nthrough a series of systematic approximations applied to E_vol and the\npotentials v_n that are valid for mid-period transition metals with\nnearly half-filled d bands.\nBoth analytic (Moriarty2) and matrix\n(Moriarty3) representations of MGPT have been developed.\nIn the more general matrix representation, which can also be applied\nto f-band actinide metals and permits both canonical and non-canonical\nd/f bands, the multi-ion potentials are evaluated on the fly during a\nsimulation through d- or f-state matrix multiplication, and the forces\nthat move the ions are determined analytically.  Fast matrix-MGPT\nalgorithms have been developed independently by Glosli\n(Glosli, Moriarty3) and by Oppelstrup\n(Oppelstrup)\nThe mgpt pair style calculates forces, energies, and the total\nenergy per atom, E_tot/N, using the Oppelstrup matrix-MGPT algorithm.\nInput potential and control data are entered through the\npair_coeff command.  Each material treated requires\ninput parmin and potin potential files, as shown in the above\nexamples, as well as specification by the user of the initial atomic\nvolume Omega through pair_coeff.  At the beginning of a time step in\nany simulation, the total volume of the simulation cell V should\nalways be equal to Omega*N, where N is the number of metal ions\npresent, taking into account the presence of any vacancies and/or\ninterstitials in the case of a solid.  In a constant-volume\nsimulation, which is the normal mode of operation for the mgpt pair\nstyle, Omega, V and N all remain constant throughout the simulation\nand thus are equal to their initial values.  In a constant-stress\nsimulation, the cell volume V will change (slowly) as the simulation\nproceeds.  After each time step, the atomic volume should be updated\nby the code as Omega = V/N.  In addition, the volume term E_vol and\nthe potentials v_2, v_3 and v_4 have to be removed at the end of the\ntime step, and then respecified at the new value of Omega.  In all\nsimulations, Omega must remain within the defined volume range for\nE_vol and the potentials for the given material.\nThe default option volpress yes in the pair_coeff\ncommand includes all volume derivatives of E_tot required to calculate\nthe stress tensor and pressure correctly.  The option volpress no\ndisregards the pressure contribution resulting from the volume term\nE_vol, and can be used for testing and analysis purposes.  The\nadditional optional variable nbody controls the specific terms in\nE_tot that are calculated.  The default option and the normal option\nfor mid-period transition and actinide metals is nbody 1234 for which\nall four terms in E_tot are retained.  The option nbody 12, for\nexample, retains only the volume term and the two-ion pair potential\nterm and can be used for GPT series-end transition metals that can be\nwell described without v_3 and v_4.  The nbody option can also be used\nto test or analyze the contribution of any of the four terms in E_tot\nto a given calculated property.\nThe mgpt pair style makes extensive use of matrix algebra and\nincludes optimized kernels for the BlueGene/Q architecture and the\nIntel/AMD (x86) architectures.  When compiled with the appropriate\ncompiler and compiler switches (-msse3 on x86, and using the IBM XL\ncompiler on BG/Q), these optimized routines are used automatically.\nFor BG/Q machines, building with the default Makefile for that\narchitecture (e.g., “make bgq”) should enable the optimized algebra\nroutines.  For x-86 machines, there is a provided Makefile.mgptfast\nwhich enables the fast algebra routines, i.e. build LAMMPS with “make\nmgptfast”.  The user will be informed in the output files of the\nmatrix kernels in use. To further improve speed, on x86 the option\nprecision single can be added to the pair_coeff\ncommand line, which improves speed (up to a factor of two) at the cost\nof doing matrix calculations with 7 digit precision instead of the\ndefault 16. For consistency the default option can be specified\nexplicitly by the option precision double.\nAll remaining potential and control data are contained with the parmin\nand potin files, including cutoffs, atomic mass, and other basic MGPT\nvariables.  Specific MGPT potential data for the transition metals\ntantalum (Ta4 and Ta6.8x potentials), molybdenum (Mo5.2 potentials),\nand vanadium (V6.1 potentials) are contained in the LAMMPS potentials\ndirectory.  The stored files are, respectively, Ta4.mgpt.parmin,\nTa4.mgpt.potin, Ta6.8x.mgpt.parmin, Ta6.8x.mgpt.potin,\nMo5.2.mgpt.parmin, Mo5.2.mgpt.potin, V6.1.mgpt.parmin, and\nV6.1.mgpt.potin .  Useful corresponding informational “README” files\non the Ta4, Ta6.8x, Mo5.2 and V6.1 potentials are also included in the\npotentials directory.  These latter files indicate the volume mesh and\nrange for each potential and give appropriate references for the\npotentials.  It is expected that MGPT potentials for additional\nmaterials will be added over time.\nUseful example MGPT scripts are given in the examples/USER/mgpt\ndirectory.  These scripts show the necessary steps to perform\nconstant-volume calculations and simulations.  It is strongly\nrecommended that the user work through and understand these examples\nbefore proceeding to more complex simulations.\n\nNote\nFor good performance, LAMMPS should be built with the compiler\nflags “-O3 -msse3 -funroll-loops” when including this pair style.  The\nsrc/MAKE/OPTIONS/Makefile.mgptfast is an example machine Makefile with\nthese options included as part of a standard MPI build.  Note that it\nas provided, it will build with whatever low-level compiler (g++, icc,\netc) is the default for your MPI installation.\n\n\nMixing, shift, table tail correction, restart:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneeds to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style mgpt",
    "parameters": " * ",
    "examples": "pair_style mgpt\npair_coeff * * Ta6.8x.mgpt.parmin Ta6.8x.mgpt.potin Omega\ncp ~/lammps/potentials/Ta6.8x.mgpt.parmin parmin\ncp ~/lammps/potentials/Ta6.8x.mgpt.potin potin\npair_coeff * * parmin potin Omega volpress yes nbody 1234 precision double\npair_coeff * * parmin potin Omega volpress yes nbody 12",
    "restrictions": "This pair style is part of the USER-MGPT package and is only enabled\nif LAMMPS is built with that package.  See the Build package doc page for more info.\nThe MGPT potentials require the newtion setting to be\n“on” for pair style interactions.\nThe stored parmin and potin potential files provided with LAMMPS in\nthe “potentials” directory are written in Rydberg atomic units, with\nenergies in Rydbergs and distances in Bohr radii. The mgpt pair\nstyle converts Rydbergs to Hartrees to make the potential files\ncompatible with LAMMPS electron units.\nThe form of E_tot used in the mgpt pair style is only appropriate\nfor elemental bulk solids and liquids.  This includes solids with\npoint and extended defects such as vacancies, interstitials, grain\nboundaries and dislocations.  Alloys and free surfaces, however,\nrequire significant modifications, which are not included in the\nmgpt pair style.  Likewise, the hybrid pair style is not allowed,\nwhere MGPT would be used for some atoms but not for others.\nElectron-thermal effects are not included in the standard MGPT\npotentials provided in the “potentials” directory, where the\npotentials have been constructed at zero electron temperature.\nPhysically, electron-thermal effects may be important in 3d (e.g., V)\nand 4d (e.g., Mo) transition metals at high temperatures near melt and\nabove.  It is expected that temperature-dependent MGPT potentials for\nsuch cases will be added over time."
},
{
    "command": "pair_style mie/cut",
    "html_filename": "pair_mie.html",
    "short_description": "The mie/cut style computes the Mie potential, given by  \\[E =  C \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{rep}} - \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{att}} \\right]                       \\qquad r < r_c\\] Rc is the cutoff and C is a function that depends on the repulsive and attractive exponents, given by:  \\[C = \\left(\\frac{\\gamma_{rep}}{\\gamma_{rep}-\\gamma_{att}}\\right) \\left(\\frac{\\gamma_{rep}}{\\gamma_{att}}\\right)^{\\left(\\frac{\\gamma_{att}}{\\gamma_{rep}-\\gamma_{att}}\\right)}\\] Note that for 12/6 exponents, C is equal to 4 and the formula is the same as the standard Lennard-Jones potential",
    "description": "The mie/cut style computes the Mie potential, given by\n\n\\[E =  C \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{rep}} - \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{att}} \\right]\n                      \\qquad r < r_c\\]\nRc is the cutoff and C is a function that depends on the repulsive and\nattractive exponents, given by:\n\n\\[C = \\left(\\frac{\\gamma_{rep}}{\\gamma_{rep}-\\gamma_{att}}\\right) \\left(\\frac{\\gamma_{rep}}{\\gamma_{att}}\\right)^{\\left(\\frac{\\gamma_{att}}{\\gamma_{rep}-\\gamma_{att}}\\right)}\\]\nNote that for 12/6 exponents, C is equal to 4 and the formula is the\nsame as the standard Lennard-Jones potential.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nepsilon (energy units)\nsigma (distance units)\ngammaR\ngammaA\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global\ncutoff specified in the pair_style command is used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the mie/cut pair styles can be mixed.\nIf not explicitly defined, both the repulsive and attractive gamma\nexponents for different atoms will be calculated following the same\nmixing rule defined for distances.  The default mix value is\ngeometric. See the “pair_modify” command for details.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThis pair style supports the pair_modify tail\noption for adding a long-range tail correction to the energy and\npressure of the pair interaction.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style supports the use of the inner, middle, and outer\nkeywords of the run_style respa command, meaning the\npairwise forces can be partitioned by distance at different levels of\nthe rRESPA hierarchy.  See the run_style command for\ndetails.",
    "syntax": "pair_style mie/cut cutoff",
    "parameters": " * cutoff = global cutoff for mie/cut interactions (distance units)",
    "examples": "pair_style mie/cut 10.0\npair_coeff 1 1 0.72 3.40 23.00 6.66\npair_coeff 2 2 0.30 3.55 12.65 6.00\npair_coeff 1 2 0.46 3.32 16.90 6.31",
    "restrictions": "none"
},
{
    "command": "pair_style mm3/switch3/coulgauss/long",
    "html_filename": "pair_mm3_switch3_coulgauss_long.html",
    "short_description": "The mm3/switch3/coulgauss/long style evaluates the MM3 vdW potential (Allinger)  \\[\\begin{split}E & = \\epsilon_{ij} \\left[ -2",
    "description": "The mm3/switch3/coulgauss/long style evaluates the MM3\nvdW potential (Allinger)\n\n\\[\\begin{split}E & = \\epsilon_{ij} \\left[ -2.25 \\left(\\frac{r_{v,ij}}{r_{ij}}\\right)^6 + 1.84(10)^5 \\exp\\left[-12.0 r_{ij}/r_{v,ij}\\right] \\right] S_3(r_{ij}) \\\\\nr_{v,ij} & =  r_{v,i} + r_{v,j} \\\\\n\\epsilon_{ij} & = \\sqrt{\\epsilon_i \\epsilon_j}\\end{split}\\]\n, which goes smoothly to zero at the cutoff r_c as defined\nby the switching function\n\n\\[\\begin{split}S_3(r) = \\left\\lbrace \\begin{array}{ll}\n                    1 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} - w \\\\\n                    3x^2 - 2x^3 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} \\quad\\mathrm{with\\quad} x=\\frac{r_\\mathrm{c} - r}{w} \\\\\n                    0 & \\quad\\mathrm{if}\\quad r >= r_\\mathrm{c}\n                \\end{array} \\right.\\end{split}\\]\nwhere w is the width defined in the arguments. This potential\nis combined with Coulomb interaction between Gaussian charge densities:\n\n\\[E = \\frac{q_i q_j \\mathrm{erf}\\left( r/\\sqrt{\\gamma_1^2+\\gamma_2^2} \\right) }{\\epsilon r_{ij}}\\]\nwhere \\(q_i\\) and \\(q_j\\) are the charges on the 2 atoms,\nepsilon is the dielectric constant which can be set by the\ndielectric command, :\\(\\gamma_i\\) and\n\\(\\gamma_j\\) are the widths of the Gaussian charge distribution and\nerf() is the error-function.  This style has to be used in conjunction\nwith the kspace_style command\nIf one cutoff is specified it is used for both the vdW and Coulomb\nterms.  If two cutoffs are specified, the first is used as the cutoff\nfor the vdW terms, and the second is the cutoff for the Coulombic term.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(\\epsilon\\) (energy)\n\\(r_v\\) (distance)\n\\(\\gamma\\) (distance)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nMixing rules are fixed for this style as defined above.\nShifting the potential energy is not necessary because the switching\nfunction ensures that the potential is zero at the cut-off.",
    "syntax": "pair_style style args",
    "parameters": " * style = mm3/switch3/coulgauss/long\n * args = list of arguments for a particular style\n * mm3/switch3/coulgauss/long args = cutoff (cutoff2) width\n *   cutoff  = global cutoff for MM3 (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n *   width  = width parameter of the smoothing function (distance units)",
    "examples": "pair_style mm3/switch3/coulgauss/long    12.0 3.0\npair_coeff 1  0.2 2.5 1.2\n\npair_style mm3/switch3/coulgauss/long   12.0 10.0 3.0\npair_coeff 1  0.2 2.5 1.2",
    "restrictions": "These styles are part of the USER-YAFF package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_modify",
    "html_filename": "pair_modify.html",
    "short_description": "Modify the parameters of the currently defined pair style",
    "description": "Modify the parameters of the currently defined pair style.  If the\npair style is hybrid or hybrid/overlay, then the\nspecified parameters are by default modified for all the hybrid sub-styles.\n\nNote\nThe behavior for hybrid pair styles can be changed by using the pair\nkeyword, which allows selection of a specific sub-style to apply all\nremaining keywords to.\nThe special and compute/tally keywords can only be\nused in conjunction with the pair keyword.  See further details about\nthese 3 keywords below.\n\nThe mix keyword affects pair coefficients for interactions between\natoms of type I and J, when I != J and the coefficients are not\nexplicitly set in the input script.  Note that coefficients for I = J\nmust be set explicitly, either in the input script via the\npair_coeff command or in the “Pair Coeffs” section of the\ndata file.  For some pair styles it is not\nnecessary to specify coefficients when I != J, since a “mixing” rule\nwill create them from the I,I and J,J settings.  The pair_modify\nmix value determines what formulas are used to compute the mixed\ncoefficients.  In each case, the cutoff distance is mixed the same way\nas sigma.\nNote that not all pair styles support mixing and some mix options\nare not available for certain pair styles. Also, there are additional\nrestrictions when using pair style hybrid or hybrid/overlay.\nSee the doc page for individual pair styles for those restrictions.  Note also that the\npair_coeff command also can be used to directly set\ncoefficients for a specific I != J pairing, in which case no mixing is\nperformed.\n\nmix geometric\n\n\\[\\begin{split}\\epsilon_{ij} = & \\sqrt{\\epsilon_i  \\epsilon_j} \\\\\n\\sigma_{ij}   = & \\sqrt{\\sigma_i  \\sigma_j}\\end{split}\\]\n\nmix arithmetic\n\n\\[\\begin{split}\\epsilon_{ij} = & \\sqrt{\\epsilon_i  \\epsilon_j} \\\\\n\\sigma_{ij}   = & \\frac{1}{2} (\\sigma_i + \\sigma_j)\\end{split}\\]\n\nmix sixthpower\n\n\\[\\begin{split}\\epsilon_{ij} = & \\frac{2 \\sqrt{\\epsilon_i \\epsilon_j} \\sigma_i^3 \\sigma_j^3}{\\sigma_i^6 + \\sigma_j^6} \\\\\n\\sigma_{ij} =   & \\left(\\frac{1}{2} (\\sigma_i^6 + \\sigma_j^6) \\right)^{\\frac{1}{6}}\\end{split}\\]\n\n\nThe shift keyword determines whether a Lennard-Jones potential is\nshifted at its cutoff to 0.0.  If so, this adds an energy term to each\npairwise interaction which will be included in the thermodynamic\noutput, but does not affect pair forces or atom trajectories.  See the\ndoc page for individual pair styles to see which ones support this\noption.\nThe table and table/disp keywords apply to pair styles with a\nlong-range Coulombic term or long-range dispersion term respectively;\nsee the doc page for individual styles to see which potentials support\nthese options.  If N is non-zero, a table of length 2^N is\npre-computed for forces and energies, which can shrink their\ncomputational cost by up to a factor of 2.  The table is indexed via a\nbit-mapping technique (Wolff) and a linear\ninterpolation is performed between adjacent table values.  In our\nexperiments with different table styles (lookup, linear, spline), this\nmethod typically gave the best performance in terms of speed and\naccuracy.\nThe choice of table length is a tradeoff in accuracy versus speed.  A\nlarger N yields more accurate force computations, but requires more\nmemory which can slow down the computation due to cache misses.  A\nreasonable value of N is between 8 and 16.  The default value of 12\n(table of length 4096) gives approximately the same accuracy as the\nno-table (N = 0) option.  For N = 0, forces and energies are computed\ndirectly, using a polynomial fit for the needed erfc() function\nevaluation, which is what earlier versions of LAMMPS did.  Values\ngreater than 16 typically slow down the simulation and will not\nimprove accuracy; values from 1 to 8 give unreliable results.\nThe tabinner and tabinner/disp keywords set an inner cutoff above\nwhich the pairwise computation is done by table lookup (if tables are\ninvoked), for the corresponding Coulombic and dispersion tables\ndiscussed with the table and table/disp keywords.  The smaller the\ncutoff is set, the less accurate the table becomes (for a given number\nof table values), which can require use of larger tables.  The default\ncutoff value is sqrt(2.0) distance units which means nearly all\npairwise interactions are computed via table lookup for simulations\nwith “real” units, but some close pairs may be computed directly\n(non-table) for simulations with “lj” units.\nWhen the tail keyword is set to yes, certain pair styles will\nadd a long-range VanderWaals tail “correction” to the energy and\npressure.  These corrections are bookkeeping terms which do not affect\ndynamics, unless a constant-pressure simulation is being performed.\nSee the doc page for individual styles to see which support this\noption.  These corrections are included in the calculation and\nprinting of thermodynamic quantities (see the thermo_style command).  Their effect will also be included in\nconstant NPT or NPH simulations where the pressure influences the\nsimulation box dimensions (e.g. the fix npt and\nfix nph commands).  The formulas used for the\nlong-range corrections come from equation 5 of (Sun).\n\nNote\nThe tail correction terms are computed at the beginning of each\nrun, using the current atom counts of each atom type.  If atoms are\ndeleted (or lost) or created during a simulation, e.g. via the\nfix gcmc command, the correction factors are not\nre-computed.  If you expect the counts to change dramatically, you\ncan break a run into a series of shorter runs so that the\ncorrection factors are re-computed more frequently.\n\nSeveral additional assumptions are inherent in using tail corrections,\nincluding the following:\n\nThe simulated system is a 3d bulk homogeneous liquid. This option\nshould not be used for systems that are non-liquid, 2d, have a slab\ngeometry (only 2d periodic), or inhomogeneous.\nG(r), the radial distribution function (rdf), is unity beyond the\ncutoff, so a fairly large cutoff should be used (i.e. 2.5 sigma for\nan LJ fluid), and it is probably a good idea to verify this\nassumption by checking the rdf.  The rdf is not exactly unity beyond\nthe cutoff for each pair of interaction types, so the tail\ncorrection is necessarily an approximation.\nThe tail corrections are computed at the beginning of each\nsimulation run.  If the number of atoms changes during the run,\ne.g. due to atoms leaving the simulation domain, or use of the\nfix gcmc command, then the corrections are not\nupdated to reflect the changed atom count.  If this is a large\neffect in your simulation, you should break the long run into\nseveral short runs, so that the correction factors are re-computed\nmultiple times.\n\nThermophysical properties obtained from calculations with this\noption enabled will not be thermodynamically consistent with the\ntruncated force-field that was used.  In other words, atoms do not\nfeel any LJ pair interactions beyond the cutoff, but the energy and\npressure reported by the simulation include an estimated\ncontribution from those interactions.\n\nThe compute keyword allows pairwise computations to be turned off,\neven though a pair_style is defined.  This is not\nuseful for running a real simulation, but can be useful for debugging\npurposes or for performing a rerun simulation, when you\nonly wish to compute partial forces that do not include the pairwise\ncontribution.\nTwo examples are as follows.  First, this option allows you to perform\na simulation with pair_style hybrid with only a\nsubset of the hybrid sub-styles enabled.  Second, this option allows\nyou to perform a simulation with only long-range interactions but no\nshort-range pairwise interactions.  Doing this by simply not defining\na pair style will not work, because the kspace_style command requires a Kspace-compatible pair style be\ndefined.\nThe nofdotr keyword allows to disable an optimization that computes\nthe global stress tensor from the total forces and atom positions\nrather than from summing forces between individual pairs of atoms.\n\nThe pair keyword can only be used with the hybrid and\nhybrid/overlay pair styles.  If used, it must appear\nfirst in the list of keywords.\nIts meaning is that all the following parameters will only be modified\nfor the specified sub-style.  If the sub-style is defined multiple\ntimes, then an additional numeric argument N must also be specified,\nwhich is a number from 1 to M where M is the number of times the\nsub-style was listed in the pair_style hybrid\ncommand.  The extra number indicates which instance of the sub-style\nthe remaining keywords will be applied to.\nThe special and compute/tally keywords can only be used in\nconjunction with the pair keyword and they must directly follow it.\nI.e. any other keyword, must appear after pair, special, and\ncompute/tally.\nThe special keyword overrides the global special_bonds\n1-2, 1-3, 1-4 exclusion settings (weights) for the sub-style selected\nby the pair keyword.\nSimilar to the special_bonds command, it takes\n4 arguments.  The which argument can be lj to change only the\nnon-Coulomb weights (e.g. Lennard-Jones or Buckingham), coul to change\nonly the Coulombic settings, or lj/coul to change both to the same\nvalues.  The wt1,wt2,wt3 values are numeric weights from 0.0 to 1.0\ninclusive, for the 1-2, 1-3, and 1-4 bond topology neighbors, respectively.\nThe special keyword can be used multiple times, e.g. to set the lj\nand coul settings to different values.\n\nNote\nThe special keyword is not compatible with pair styles from the\nGPU or the USER-INTEL package and attempting to use it will cause\nan error.\n\n\nNote\nWeights of exactly 0.0 or 1.0 in the special_bonds\ncommand have implications on the neighbor list construction, which\nmeans that they cannot be overridden by using the special keyword.\nOne workaround for this restriction is to use the special_bonds\ncommand with weights like 1.0e-10 or 0.999999999 instead of 0.0 or 1.0,\nrespectively, which enables to reset each them to any value between 0.0\nand 1.0 inclusively.  Otherwise you can set all global weights to\nan arbitrary number between 0.0 or 1.0, like 0.5, and then you have\nto override all special settings for all sub-styles which use\nthe 1-2, 1-3, and 1-4 exclusion weights in their force/energy computation.\n\nThe compute/tally keyword disables or enables registering compute\n*/tally computes for the sub-style specified by\nthe pair keyword.  Use no to disable, or yes to enable.\n\nNote\nThe “pair_modify pair compute/tally” command must be issued\nbefore the corresponding compute style is defined.",
    "syntax": "pair_modify keyword values ...",
    "parameters": " * one or more keyword/value pairs may be listed\n * keyword = pair or shift or mix or table or table/disp or tabinner\n * or tabinner/disp or tail or compute or nofdotr or special or\n * compute/tally\n * pair value = sub-style N\n *   sub-style = sub-style of pair hybrid\n *   N = which instance of sub-style (1 to M), only specify if sub-style is used multiple times\n * mix value = geometric or arithmetic or sixthpower\n * shift value = yes or no\n * table value = N\n *   2^N = # of values in table\n * table/disp value = N\n *   2^N = # of values in table\n * tabinner value = cutoff\n *   cutoff = inner cutoff at which to begin table (distance units)\n * tabinner/disp value = cutoff\n *   cutoff = inner cutoff at which to begin table (distance units)\n * tail value = yes or no\n * compute value = yes or no\n * nofdotr value = none\n * special values = which wt1 wt2 wt3\n *    which = lj/coul or lj or coul\n *    w1,w2,w3 = 1-2, 1-3, 1-4 weights from 0.0 to 1.0 inclusive\n * compute/tally value = yes or no",
    "examples": "pair_modify shift yes mix geometric\npair_modify tail yes\npair_modify table 12\npair_modify pair lj/cut compute no\npair_modify pair tersoff compute/tally no\npair_modify pair lj/cut/coul/long 1 special lj/coul 0.0 0.0 0.0\npair_modify pair lj/cut/coul/long special lj 0.0 0.0 0.5 special coul 0.0 0.0 0.8333333",
    "restrictions": "You cannot use shift yes with tail yes, since those are\nconflicting options.  You cannot use tail yes with 2d simulations.\nYou cannot use special with pair styles from the GPU or\nUSER-INTEL package."
},
{
    "command": "pair_style momb",
    "html_filename": "pair_momb.html",
    "short_description": "Style momb computes pairwise van der Waals (vdW) and short-range interactions using the Morse potential and (Grimme) method implemented in the Many-Body Metal-Organic (MOMB) force field described comprehensively in (Fichthorn) and (Zhou)",
    "description": "Style momb computes pairwise van der Waals (vdW) and short-range\ninteractions using the Morse potential and (Grimme) method\nimplemented in the Many-Body Metal-Organic (MOMB) force field\ndescribed comprehensively in (Fichthorn) and\n(Zhou). Grimme’s method is widely used to correct for\ndispersion in density functional theory calculations.\n\n\\[\\begin{split} E & = D_0 [\\exp^{-2 \\alpha (r-r_0)} - 2\\exp^{-\\alpha (r-r_0)}] - s_6 \\frac{C_6}{r^6} f_{damp}(r,R_r) \\\\\nf_{damp}(r,R_r) & = \\frac{1}{1 + \\exp^{-d(r/R_r - 1)}}\\end{split}\\]\nFor the momb pair style, the following coefficients must be defined\nfor each pair of atoms types via the pair_coeff\ncommand as in the examples above, or in the data file or restart files\nread by the read_data as described below:\n\n\\(D_0\\) (energy units)\n\\(\\alpha\\) (1/distance units)\n\\(r_0\\) (distance units)\n\\(C_6\\) (energy*distance^6 units)\n\\(R_r\\) (distance units, typically sum of atomic vdW radii)",
    "syntax": "pair_style momb cutoff s6 d",
    "parameters": " * cutoff = global cutoff (distance units)\n * s6 = global scaling factor of the exchange-correlation functional used (unitless)\n * d = damping scaling factor of Grimme’s method (unitless)",
    "examples": "pair_style momb 12.0 0.75 20.0\npair_style hybrid/overlay eam/fs lj/charmm/coul/long 10.0 12.0 momb 12.0 0.75 20.0 morse 5.5\n\npair_coeff 1 2 momb 0.0 1.0 1.0 10.2847 2.361",
    "restrictions": "This style is part of the USER-MISC package. It is only enabled if\nLAMMPS is built with that package. See the Build package doc page on for more info."
},
{
    "command": "pair_style morse",
    "html_filename": "pair_morse.html",
    "short_description": "Style morse computes pairwise interactions with the formula  \\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]     \\qquad r < r_c\\] Rc is the cutoff",
    "description": "Style morse computes pairwise interactions with the formula\n\n\\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n    \\qquad r < r_c\\]\nRc is the cutoff.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(D_0\\) (energy units)\n\\(\\alpha\\) (1/distance units)\n\\(r_0\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global morse\ncutoff is used.\n\nThe morse/smooth/linear variant is similar to the lj/smooth/linear\nvariant in that it adds to the potential a shift and a linear term\nso that both, potential energy and force, go to zero at the cut-off:\n\n\\[\\begin{split}\\phi\\left(r\\right) & =  D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] \\qquad r < r_c \\\\\nE\\left(r\\right) & =  \\phi\\left(r\\right)  - \\phi\\left(R_c\\right) - \\left(r - R_c\\right) \\left.\\frac{d\\phi}{d r} \\right|_{r=R_c}       \\qquad r < R_c\\end{split}\\]\nThe syntax of the pair_style and pair_coeff commands are the same for\nthe morse and morse/smooth/linear styles.\n\nA version of the morse style with a soft core, morse/soft,\nsuitable for use in free energy calculations, is part of the USER-FEP\npackage and is documented with the pair_style */soft styles. The version with soft core is only available if\nLAMMPS was built with that package. See the Build package doc page for more info.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nNone of these pair styles support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nAll of these pair styles support the pair_modify\nshift option for the energy of the pair interaction.\nThe pair_modify table options is not relevant for\nthe Morse pair styles.\nNone of these pair styles support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nAll of these pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = morse or morse/smooth/linear or morse/soft\n * args = list of arguments for a particular style\n * morse args = cutoff\n *   cutoff = global cutoff for Morse interactions (distance units)\n * morse/smooth/linear args = cutoff\n *   cutoff = global cutoff for Morse interactions (distance units)",
    "examples": "pair_style morse 2.5\npair_style morse/smooth/linear 2.5\npair_coeff * * 100.0 2.0 1.5\npair_coeff 1 1 100.0 2.0 1.5 3.0",
    "restrictions": "The morse/smooth/linear pair style is only enabled if LAMMPS was\nbuilt with the USER-MISC package.  See the Build package doc page for more info."
},
{
    "command": "pair_style multi/lucy",
    "html_filename": "pair_multi_lucy.html",
    "short_description": "Style multi/lucy computes a density-dependent force following from the many-body form described in (Moore) and (Warren) as  \\[F_{i}^{DD}(\\rho_i,\\rho_j,r_{ij}) = \\frac{1}{2} \\omega_{DD}\\left(r_{ij}\\right) \\left[A\\left(\\rho_i\\right) + A\\left(\\rho_j\\right)\\right]e_{ij}\\] which consists of a density-dependent function, \\(A(\\rho)\\), and a radial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\)",
    "description": "Style multi/lucy computes a density-dependent force following from\nthe many-body form described in (Moore) and\n(Warren) as\n\n\\[F_{i}^{DD}(\\rho_i,\\rho_j,r_{ij}) = \\frac{1}{2} \\omega_{DD}\\left(r_{ij}\\right)\n\\left[A\\left(\\rho_i\\right) + A\\left(\\rho_j\\right)\\right]e_{ij}\\]\nwhich consists of a density-dependent function, \\(A(\\rho)\\), and a\nradial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\).  The\nradial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\), is taken\nas the Lucy function:\n\n\\[\\omega_{DD}\\left(r_{ij}\\right) = \\left(1+\\frac{3r_{ij}}{r_{cut}}\\right)\\left(1+\\frac{r_{ij}}{r_{cut}}\\right)^3\\]\nThe density-dependent energy for a given particle is given by:\n\n\\[u_{i}^{DD}\\left(\\rho_{i}\\right) = \\frac{\\pi r_{cut}^4}{84} \\int_{\\rho_0}^{\\rho_i} A\\left(\\rho'\\right) d\\rho'\\]\nSee the supporting information of (Brennan) or the\npublication by (Moore) for more details on the functional\nform.\nAn interpolation table is used to evaluate the density-dependent energy\n(\\(\\int A(\\rho') d\\rho'\\)) and force (\\(A(\\rho')\\)).  Note that\nthe pre-factor to the energy is computed after the interpolation, thus\nthe \\(\\int A(\\rho') d \\rho'\\) will have units of energy / length^4.\nThe interpolation table is created as a pre-computation by fitting\ncubic splines to the file values and interpolating the\ndensity-dependent energy and force at each of N densities.  During a\nsimulation, the tables are used to interpolate the density-dependent\nenergy and force as needed for each pair of particles separated by a\ndistance R.  The interpolation is done in one of 2 styles: lookup\nand linear.\nFor the lookup style, the density is used to find the nearest table\nentry, which is the density-dependent energy and force.\nFor the linear style, the density is used to find the 2 surrounding\ntable values from which the density-dependent energy and force are\ncomputed by linear interpolation.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nfilename\nkeyword\ncutoff (distance units)\n\nThe filename specifies a file containing the tabulated\ndensity-dependent energy and force.  The keyword specifies a section\nof the file.  The cutoff is an optional coefficient.  If not\nspecified, the outer cutoff in the table itself (see below) will be\nused to build an interpolation table that extend to the largest\ntabulated distance.  If specified, only file values up to the cutoff\nare used to create the interpolation table.  The format of this file\nis described below.\n\nThe format of a tabulated file is a series of one or more sections,\ndefined as follows (without the parenthesized comments):\n# Density-dependent function (one or more comment or blank lines)\n\nDD-FUNCTION                (keyword is first text on line)\nN 500 R 1.0 10.0           (N, R, RSQ parameters)\n                           (blank)\n1 1.0 25.5 102.34          (index, density, energy/r^4, force)\n2 1.02 23.4 98.5\n...\n500 10.0 0.001 0.003\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the pair_coeff\ncommand.  The next line lists (in any order) one or more parameters\nfor the table.  Each parameter is a keyword followed by one or more\nnumeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the pair_style multi/lucy command.\nLet Ntable = N in the pair_style command, and Nfile = “N” in the\ntabulated file.  What LAMMPS does is a preliminary interpolation by\ncreating splines using the Nfile tabulated values as nodal points.  It\nuses these to interpolate the density-dependent energy and force at\nNtable different points.  The resulting tables of length Ntable are\nthen used as described above, when computing the density-dependent\nenergy and force.  This means that if you want the interpolation\ntables of length Ntable to match exactly what is in the tabulated file\n(with effectively no preliminary interpolation), you should set Ntable\n= Nfile, and use the “RSQ” parameter.  This is because the internal\ntable abscissa is always RSQ (separation distance squared), for\nefficient lookup.\nAll other parameters are optional.  If “R” or “RSQ” does\nnot appear, then the distances in each line of the table are used\nas-is to perform spline interpolation.  In this case, the table values\ncan be spaced in density uniformly or however you wish to position table\nvalues in regions of large gradients.\nIf used, the parameters “R” or “RSQ” are followed by 2 values rlo and\nrhi.  If specified, the density associated with each\ndensity-dependent energy and force value is computed from these 2 values\n(at high accuracy), rather than using the (low-accuracy) value listed in\neach line of the table.  The density values in the table file are\nignored in this case.  For “R”, distances uniformly spaced between rlo\nand rhi are computed; for “RSQ”, squared distances uniformly spaced\nbetween rlo*rlo and rhi*rhi are computed.\n\nNote\nIf you use “R” or “RSQ”, the tabulated distance values in the file\nare effectively ignored, and replaced by new values as described in\nthe previous paragraph.  If the density value in the table is not\nvery close to the new value (i.e. round-off difference), then you\nwill be assigning density-dependent energy and force values to a\ndifferent density, which is probably not what you want.  LAMMPS will\nwarn if this is occurring.\n\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nr (in density units), the 3rd value is the density-dependent function value\n(in energy units / length^4), and the 4th is the force (in force units).  The\ndensity values must increase from one line to the next.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThe pair_modify shift, table, and tail options are\nnot relevant for this pair style.\nThis pair style writes the settings for the “pair_style multi/lucy” command\nto binary restart files, so a pair_style command does\nnot need to specified in an input script that reads a restart file.\nHowever, the coefficient information is not stored in the restart\nfile, since it is tabulated in the potential files.  Thus, pair_coeff\ncommands do need to be specified in the restart input script.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style multi/lucy style N keyword ...",
    "parameters": " * style = lookup or linear = method of interpolation\n * N = use N values in lookup, linear tables",
    "examples": "pair_style multi/lucy linear 1000\npair_coeff * * multibody.table ENTRY1 7.0",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style multi/lucy/rx",
    "html_filename": "pair_multi_lucy_rx.html",
    "short_description": "Style multi/lucy/rx is used in reaction DPD simulations, where the coarse-grained (CG) particles are composed of m species whose reaction rate kinetics are determined from a set of n reaction rate equations through the fix rx command",
    "description": "Style multi/lucy/rx is used in reaction DPD simulations, where the\ncoarse-grained (CG) particles are composed of m species whose\nreaction rate kinetics are determined from a set of n reaction rate\nequations through the fix rx command.  The species of\none CG particle can interact with a species in a neighboring CG\nparticle through a site-site interaction potential model.  Style\nmulti/lucy/rx computes the site-site density-dependent force\nfollowing from the many-body form described in (Moore) and\n(Warren) as\n\n\\[F_{i}^{DD}(\\rho_i,\\rho_j,r_{ij}) = \\frac{1}{2} \\omega_{DD}\\left(r_{ij}\\right)\n\\left[A\\left(\\rho_i\\right) + A\\left(\\rho_j\\right)\\right]e_{ij}\\]\nwhich consists of a density-dependent function, \\(A(\\rho)\\), and a\nradial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\).  The\nradial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\), is taken\nas the Lucy function:\n\n\\[\\omega_{DD}\\left(r_{ij}\\right) = \\left(1+\\frac{3r_{ij}}{r_{cut}}\\right)\\left(1+\\frac{r_{ij}}{r_{cut}}\\right)^3\\]\nThe density-dependent energy for a given particle is given by:\n\n\\[u_{i}^{DD}\\left(\\rho_{i}\\right) = \\frac{\\pi r_{cut}^4}{84} \\int_{\\rho_0}^{\\rho_i} A\\left(\\rho'\\right) d\\rho'\\]\nSee the supporting information of (Brennan) or the\npublication by (Moore) for more details on the functional\nform.\nAn interpolation table is used to evaluate the density-dependent energy\n(\\(\\int A(\\rho') d \\rho'\\)) and force (\\(A(\\rho')\\)).  Note that\nthe pre-factor to the energy is computed after the interpolation, thus\nthe \\(\\int A(\\rho') d\\rho'\\) will have units of energy / length^4.\nThe interpolation table is created as a pre-computation by fitting\ncubic splines to the file values and interpolating the\ndensity-dependent energy and force at each of N densities.  During a\nsimulation, the tables are used to interpolate the density-dependent\nenergy and force as needed for each pair of particles separated by a\ndistance R.  The interpolation is done in one of 2 styles: lookup\nand linear.\nFor the lookup style, the density is used to find the nearest table\nentry, which is the density-dependent energy and force.\nFor the linear style, the density is used to find the 2 surrounding\ntable values from which the density-dependent energy and force are\ncomputed by linear interpolation.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nfilename\nkeyword\nspecies1\nspecies2\ncutoff (distance units)\n\nThe filename specifies a file containing the tabulated\ndensity-dependent energy and force.  The keyword specifies a section\nof the file.  The cutoff is an optional coefficient.  If not\nspecified, the outer cutoff in the table itself (see below) will be\nused to build an interpolation table that extend to the largest\ntabulated distance.  If specified, only file values up to the cutoff\nare used to create the interpolation table.  The format of this file\nis described below.\nThe species tags define the site-site interaction potential between\ntwo species contained within two different particles.  The species\ntags must either correspond to the species defined in the reaction\nkinetics files specified with the fix rx command or they\nmust correspond to the tag “1fluid”, signifying interaction with a\nproduct species mixture determined through a one-fluid approximation.\nThe interaction potential is weighted by the geometric average of\neither the mole fraction concentrations or the number of molecules\nassociated with the interacting coarse-grained particles (see the\nfractional or molecular weighting pair style options). The coarse-grained potential is\nstored before and after the reaction kinetics solver is applied, where\nthe difference is defined to be the internal chemical energy (uChem).\n\nThe format of a tabulated file is a series of one or more sections,\ndefined as follows (without the parenthesized comments):\n# Density-dependent function (one or more comment or blank lines)\n\nDD-FUNCTION                (keyword is first text on line)\nN 500 R 1.0 10.0           (N, R, RSQ parameters)\n                           (blank)\n1 1.0 25.5 102.34          (index, density, energy/r^4, force)\n2 1.02 23.4 98.5\n...\n500 10.0 0.001 0.003\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the pair_coeff\ncommand.  The next line lists (in any order) one or more parameters\nfor the table.  Each parameter is a keyword followed by one or more\nnumeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the pair_style multi/lucy/rx\ncommand.  Let Ntable = N in the pair_style command, and Nfile = “N”\nin the tabulated file.  What LAMMPS does is a preliminary\ninterpolation by creating splines using the Nfile tabulated values as\nnodal points.  It uses these to interpolate the density-dependent\nenergy and force at Ntable different points.  The resulting tables of\nlength Ntable are then used as described above, when computing the\ndensity-dependent energy and force.  This means that if you want the\ninterpolation tables of length Ntable to match exactly what is in the\ntabulated file (with effectively no preliminary interpolation), you\nshould set Ntable = Nfile, and use the “RSQ” parameter.  This is\nbecause the internal table abscissa is always RSQ (separation distance\nsquared), for efficient lookup.\nAll other parameters are optional.  If “R” or “RSQ” does not appear,\nthen the distances in each line of the table are used as-is to perform\nspline interpolation.  In this case, the table values can be spaced in\ndensity uniformly or however you wish to position table values in\nregions of large gradients.\nIf used, the parameters “R” or “RSQ” are followed by 2 values rlo\nand rhi.  If specified, the density associated with each\ndensity-dependent energy and force value is computed from these 2\nvalues (at high accuracy), rather than using the (low-accuracy) value\nlisted in each line of the table.  The density values in the table\nfile are ignored in this case.  For “R”, distances uniformly spaced\nbetween rlo and rhi are computed; for “RSQ”, squared distances\nuniformly spaced between rlo*rlo and rhi*rhi are computed.\n\nNote\nIf you use “R” or “RSQ”, the tabulated distance values in the\nfile are effectively ignored, and replaced by new values as described\nin the previous paragraph.  If the density value in the table is not\nvery close to the new value (i.e. round-off difference), then you will\nbe assigning density-dependent energy and force values to a different\ndensity, which is probably not what you want.  LAMMPS will warn if\nthis is occurring.\n\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nr (in density units), the 3rd value is the density-dependent function\nvalue (in energy units / length^4), and the 4th is the force (in force\nunits).  The density values must increase from one line to the next.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThe pair_modify shift, table, and tail options are\nnot relevant for this pair style.\nThis pair style writes the settings for the “pair_style multi/lucy/rx” command\nto binary restart files, so a pair_style command does\nnot need to specified in an input script that reads a restart file.\nHowever, the coefficient information is not stored in the restart\nfile, since it is tabulated in the potential files.  Thus, pair_coeff\ncommands do need to be specified in the restart input script.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style multi/lucy/rx style N keyword ...",
    "parameters": " * style = lookup or linear = method of interpolation\n * N = use N values in lookup, linear tables\n * weighting = fractional or molecular (optional)",
    "examples": "pair_style multi/lucy/rx linear 1000\npair_style multi/lucy/rx linear 1000 fractional\npair_style multi/lucy/rx linear 1000 molecular\npair_coeff * * multibody.table ENTRY1 h2o h2o 7.0\npair_coeff * * multibody.table ENTRY1 h2o 1fluid 7.0",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style nb3b/harmonic",
    "html_filename": "pair_nb3b_harmonic.html",
    "short_description": "This pair style computes a non-bonded 3-body harmonic potential for the energy E of a system of atoms as  \\[E = K (\\theta - \\theta_0)^2\\] where \\(\\theta_0\\) is the equilibrium value of the angle and K is a prefactor",
    "description": "This pair style computes a non-bonded 3-body harmonic potential for the\nenergy E of a system of atoms as\n\n\\[E = K (\\theta - \\theta_0)^2\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle and K is a\nprefactor. Note that the usual 1/2 factor is included in K. The form\nof the potential is identical to that used in angle_style harmonic,\nbut in this case, the atoms do not need to be explicitly bonded.\nOnly a single pair_coeff command is used with this style which\nspecifies a potential file with parameters for specified elements.\nThese are mapped to LAMMPS atom types by specifying N additional\narguments after the filename in the pair_coeff command, where N is the\nnumber of LAMMPS atom types:\n\nfilename\nN element names = mapping of elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine a file SiC.nb3b.harmonic has potential values\nfor Si and C.  If your LAMMPS simulation has 4 atoms types and you\nwant the 1st 3 to be Si, and the 4th to be C, you would use the\nfollowing pair_coeff command:\npair_coeff * * SiC.nb3b.harmonic Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the potential file.  The final C argument maps LAMMPS atom\ntype 4 to the C element in the potential file.  If a mapping value is\nspecified as NULL, the mapping is not performed.  This can be used\nwhen the potential is used as part of the hybrid pair style.  The\nNULL values are placeholders for atom types that will be used with\nother potentials. An example of a pair_coeff command for use with the\nhybrid pair style is:\npair_coeff * * nb3b/harmonic MgOH.nb3b.harmonic Mg O H\nThree-body non-bonded harmonic files in the potentials directory of\nthe LAMMPS distribution have a “.nb3b.harmonic” suffix.  Lines that\nare not blank or comments (starting with #) define parameters for a\ntriplet of elements.\nEach entry has six arguments. The first three are atom types as\nreferenced in the LAMMPS input file. The first argument specifies the\ncentral atom. The fourth argument indicates the K parameter. The\nfifth argument indicates \\(\\theta_0\\). The sixth argument indicates a\nseparation cutoff in Angstroms.\nFor a given entry, if the second and third arguments are identical,\nthen the entry is for a cutoff for the distance between types 1 and 2\n(values for K and \\(\\theta_0\\) are irrelevant in this case).\nFor a given entry, if the first three arguments are all different, then\nthe entry is for the K and \\(\\theta_0\\) parameters (the cutoff in\nthis case is irrelevant).\nIt is required that the potential file contains entries for all\npermutations of the elements listed in the pair_coeff command.\nIf certain combinations are not parameterized the corresponding\nparameters should be set to zero. The potential file can also\ncontain entries for additional elements which are not used in\na particular simulation; LAMMPS ignores those entries.",
    "syntax": "pair_style nb3b/harmonic",
    "parameters": " * ",
    "examples": "pair_style nb3b/harmonic\npair_coeff * * MgOH.nb3bharmonic Mg O H",
    "restrictions": "This pair style can only be used if LAMMPS was built with the MANYBODY\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "pair_style nm/cut",
    "html_filename": "pair_nm.html",
    "short_description": "Style nm computes site-site interactions based on the N-M potential by Clarke, mainly used for ionic liquids",
    "description": "Style nm computes site-site interactions based on the N-M potential\nby Clarke, mainly used for ionic liquids.  A site can\nrepresent a single atom or a united-atom site.  The energy of an\ninteraction has the following form:\n\n\\[E = \\frac{E_0}{(n-m)} \\left[ m \\left(\\frac{r_0}{r}\\right)^n - n\n\\left(\\frac{r_0}{r}\\right)^m \\right] \\qquad r < r_c\\]\nwhere \\(r_c\\) is the cutoff.\nStyle nm/cut/coul/cut adds a Coulombic pairwise interaction given by\n\n\\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\nwhere \\(C\\) is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\nare the charges on the 2 atoms, and epsilon is the dielectric constant which can\nbe set by the dielectric command.  If one cutoff is\nspecified in the pair_style command, it is used for both the N-M and Coulombic\nterms.  If two cutoffs are specified, they are used as cutoffs for the N-M and\nCoulombic terms respectively.\nStyles nm/cut/coul/long compute the same\nCoulombic interactions as style nm/cut/coul/cut except that an\nadditional damping factor is applied to the Coulombic term so it can\nbe used in conjunction with the kspace_style\ncommand and its ewald or pppm option.  The Coulombic cutoff\nspecified for this style means that pairwise interactions within this\ndistance are computed directly; interactions outside that distance are\ncomputed in reciprocal space.\nFor all of the nm pair styles, the following coefficients must\nbe defined for each pair of atoms types\nvia the pair_coeff command as in the\nexamples above, or in the data file or restart files read by the\nread_data or read_restart\ncommands.\n\n\\(E_0\\) (energy units)\n\\(r_0\\) (distance units)\n\\(n\\) (unitless)\n\\(m\\) (unitless)\ncutoff1 (distance units)\ncutoff2 (distance units)\n\nThe latter 2 coefficients are optional.  If not specified, the global\nN-M and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both N-M\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the N-M and Coulombic cutoffs for this\ntype pair.  You cannot specify 2 cutoffs for style nm, since it\nhas no Coulombic terms.\nFor nm/cut/coul/long only the N-M cutoff can be specified since a\nCoulombic cutoff cannot be specified for an individual I,J type pair.\nAll type pairs use the same global Coulombic cutoff specified in the\npair_style command.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing. Thus, coefficients for all\nI,J pairs must be specified explicitly.\nAll of the nm pair styles supports the\npair_modify shift option for the energy of the pair\ninteraction.\nThe nm/cut/coul/long pair styles support the\npair_modify table option since they can tabulate\nthe short-range portion of the long-range Coulombic interaction.\nAll of the nm pair styles support the pair_modify\ntail option for adding a long-range tail correction to the energy and\npressure for the N-M portion of the pair interaction.\nAll of the nm pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nAll of the nm pair styles can only be used via the pair keyword of\nthe run_style respa command.  They do not support the\ninner, middle, outer keywords.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style style args",
    "parameters": " * style = nm/cut or nm/cut/coul/cut or nm/cut/coul/long\n * args = list of arguments for a particular style\n * nm/cut args = cutoff\n *   cutoff = global cutoff for Pair interactions (distance units)\n * nm/cut/coul/cut args = cutoff (cutoff2)\n *   cutoff = global cutoff for Pair (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)\n * nm/cut/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for Pair (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style nm/cut 12.0\npair_coeff * * 0.01 5.4 8.0 7.0\npair_coeff 1 1 0.01 4.4 7.0 6.0\n\npair_style nm/cut/coul/cut 12.0 15.0\npair_coeff * * 0.01 5.4 8.0 7.0\npair_coeff 1 1 0.01 4.4 7.0 6.0\n\npair_style nm/cut/coul/long 12.0 15.0\npair_coeff * * 0.01 5.4 8.0 7.0\npair_coeff 1 1 0.01 4.4 7.0 6.0",
    "restrictions": "These pair styles are part of the MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style none",
    "html_filename": "pair_none.html",
    "short_description": "Using a pair style of none means pair forces and energies are not computed",
    "description": "Using a pair style of none means pair forces and energies are not\ncomputed.\nWith this choice, the force cutoff is 0.0, which means that only atoms\nwithin the neighbor skin distance (see the neighbor\ncommand) are communicated between processors.  You must insure the\nskin distance is large enough to acquire atoms needed for computing\nbonds, angles, etc.\nA pair style of none will also prevent pairwise neighbor lists from\nbeing built.  However if the neighbor style is bin,\ndata structures for binning are still allocated.  If the neighbor skin\ndistance is small, then these data structures can consume a large\namount of memory.  So you should either set the neighbor style to\nnsq or set the skin distance to a larger value.\nSee the pair_style zero for a way to trigger the\nbuilding of a neighbor lists, but compute no pairwise interactions.",
    "syntax": "pair_style none",
    "parameters": " * ",
    "examples": "pair_style none",
    "restrictions": "none"
},
{
    "command": "pair_style oxdna/excv",
    "html_filename": "pair_oxdna.html",
    "short_description": "The oxdna pair styles compute the pairwise-additive parts of the oxDNA force field for coarse-grained modelling of DNA",
    "description": "The oxdna pair styles compute the pairwise-additive parts of the oxDNA force field\nfor coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\nexcluded volume interaction oxdna/excv, the stacking oxdna/stk, cross-stacking oxdna/xstk\nand coaxial stacking interaction oxdna/coaxstk as well\nas the hydrogen-bonding interaction oxdna/hbond between complementary pairs of nucleotides on\nopposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\nare supported (Sulc). Quasi-unique base-pairing between nucleotides can be achieved by using\nmore complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\nThis prevents the hybridization of in principle complementary bases within Ntypes/4 bases\nup and down along the backbone.\nThe exact functional form of the pair styles is rather complex.\nThe individual potentials consist of products of modulation factors,\nwhich themselves are constructed from a number of more basic potentials\n(Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\nWe refer to (Ouldridge-DPhil) and (Ouldridge)\nfor a detailed description of the oxDNA force field.\n\nNote\nThese pair styles have to be used together with the related oxDNA bond style\noxdna/fene for the connectivity of the phosphate backbone (see also documentation of\nbond_style oxdna/fene). Most of the coefficients\nin the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\nExceptions are the first four coefficients after oxdna/stk (seq=seqdep, T=0.1, xi=1.3448 and kappa=2.6568 in the above example)\nand the first coefficient after oxdna/hbond (seq=seqdep in the above example).\nWhen using a Langevin thermostat, e.g. through fix langevin\nor fix nve/dotc/langevin\nthe temperature coefficients have to be matched to the one used in the fix.\n\nExample input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\nA simple python setup tool which creates single straight or helical DNA strands,\nDNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\nPlease cite (Henrich) in any publication that uses\nthis implementation.  The article contains general information\non the model, its implementation and performance as well as the structure of\nthe data and input file. The preprint version of the article can be found\nhere.\nPlease cite also the relevant oxDNA publications\n(Ouldridge),\n(Ouldridge-DPhil)\nand (Sulc).",
    "syntax": "pair_style style1",
    "parameters": " * pair_coeff * * style2 args\n * style1 = hybrid/overlay oxdna/excv oxdna/stk oxdna/hbond oxdna/xstk oxdna/coaxstk\n * style2 = oxdna/excv or oxdna/stk or oxdna/hbond or oxdna/xstk or oxdna/coaxstk\n * args = list of arguments for these particular styles\n * oxdna/stk args = seq T xi kappa 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n *   seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n *   T = temperature (oxDNA units, 0.1 = 300 K)\n *   xi = 1.3448 (temperature-independent coefficient in stacking strength)\n *   kappa = 2.6568 (coefficient of linear temperature dependence in stacking strength)\n * oxdna/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n *   seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n *   eps = 1.077 (between base pairs A-T and C-G) or 0 (all other pairs)",
    "examples": "pair_style hybrid/overlay oxdna/excv oxdna/stk oxdna/hbond oxdna/xstk oxdna/coaxstk\npair_coeff * * oxdna/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\npair_coeff * * oxdna/stk     seqdep 0.1 1.3448 2.6568 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\npair_coeff * * oxdna/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 1 4 oxdna/hbond   seqdep 1.077 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 2 3 oxdna/hbond   seqdep 1.077 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff * * oxdna/xstk    47.5 0.575 0.675 0.495 0.655 2.25 0.791592653589793 0.58 1.7 1.0 0.68 1.7 1.0 0.68 1.5 0 0.65 1.7 0.875 0.68 1.7 0.875 0.68\npair_coeff * * oxdna/coaxstk 46.0 0.4 0.6 0.22 0.58 2.0 2.541592653589793 0.65 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 -0.65 2.0 -0.65",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.  See the\nBuild package doc page for more info."
},
{
    "command": "pair_style oxdna2/excv",
    "html_filename": "pair_oxdna2.html",
    "short_description": "The oxdna2 pair styles compute the pairwise-additive parts of the oxDNA force field for coarse-grained modelling of DNA",
    "description": "The oxdna2 pair styles compute the pairwise-additive parts of the oxDNA force field\nfor coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\nexcluded volume interaction oxdna2/excv, the stacking oxdna2/stk, cross-stacking oxdna2/xstk\nand coaxial stacking interaction oxdna2/coaxstk, electrostatic Debye-Hueckel interaction oxdna2/dh\nas well as the hydrogen-bonding interaction oxdna2/hbond between complementary pairs of nucleotides on\nopposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\nare supported (Sulc). Quasi-unique base-pairing between nucleotides can be achieved by using\nmore complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\nThis prevents the hybridization of in principle complementary bases within Ntypes/4 bases\nup and down along the backbone.\nThe exact functional form of the pair styles is rather complex.\nThe individual potentials consist of products of modulation factors,\nwhich themselves are constructed from a number of more basic potentials\n(Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\nWe refer to (Snodin) and the original oxDNA publications (Ouldridge-DPhil)\nand  (Ouldridge) for a detailed description of the oxDNA2 force field.\n\nNote\nThese pair styles have to be used together with the related oxDNA2 bond style\noxdna2/fene for the connectivity of the phosphate backbone (see also documentation of\nbond_style oxdna2/fene). Most of the coefficients\nin the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\nExceptions are the first four coefficients after oxdna2/stk (seq=seqdep, T=0.1, xi=1.3523 and kappa=2.6717 in the above example),\nthe first coefficient after oxdna2/hbond (seq=seqdep in the above example) and the three coefficients\nafter oxdna2/dh (T=0.1, rhos=0.5, qeff=0.815 in the above example). When using a Langevin thermostat\ne.g. through fix langevin or fix nve/dotc/langevin\nthe temperature coefficients have to be matched to the one used in the fix.\n\nExample input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\nA simple python setup tool which creates single straight or helical DNA strands,\nDNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\nPlease cite (Henrich) in any publication that uses\nthis implementation.  The article contains general information\non the model, its implementation and performance as well as the structure of\nthe data and input file. The preprint version of the article can be found\nhere.\nPlease cite also the relevant oxDNA2 publications\n(Snodin) and (Sulc).",
    "syntax": "pair_style style1",
    "parameters": " * pair_coeff * * style2 args\n * style1 = hybrid/overlay oxdna2/excv oxdna2/stk oxdna2/hbond oxdna2/xstk oxdna2/coaxstk oxdna2/dh\n * style2 = oxdna2/excv or oxdna2/stk or oxdna2/hbond or oxdna2/xstk or oxdna2/coaxstk or oxdna2/dh\n * args = list of arguments for these particular styles\n * oxdna2/stk args = seq T xi kappa 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n *   seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n *   T = temperature (oxDNA units, 0.1 = 300 K)\n *   xi = 1.3523 (temperature-independent coefficient in stacking strength)\n *   kappa = 2.6717 (coefficient of linear temperature dependence in stacking strength)\n * oxdna2/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n *   seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n *   eps = 1.0678 (between base pairs A-T and C-G) or 0 (all other pairs)\n * oxdna2/dh args = T rhos qeff\n *   T = temperature (oxDNA units, 0.1 = 300 K)\n *   rhos = salt concentration (mole per litre)\n *   qeff = 0.815 (effective charge in elementary charges)",
    "examples": "pair_style hybrid/overlay oxdna2/excv oxdna2/stk oxdna2/hbond oxdna2/xstk oxdna2/coaxstk oxdna2/dh\npair_coeff * * oxdna2/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\npair_coeff * * oxdna2/stk     seqdep 0.1 1.3523 2.6717 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\npair_coeff * * oxdna2/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 1 4 oxdna2/hbond   seqdep 1.0678 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 2 3 oxdna2/hbond   seqdep 1.0678 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff * * oxdna2/xstk    47.5 0.575 0.675 0.495 0.655 2.25 0.791592653589793 0.58 1.7 1.0 0.68 1.7 1.0 0.68 1.5 0 0.65 1.7 0.875 0.68 1.7 0.875 0.68\npair_coeff * * oxdna2/coaxstk 58.5 0.4 0.6 0.22 0.58 2.0 2.891592653589793 0.65 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 40.0 3.116592653589793\npair_coeff * * oxdna2/dh      0.1 0.5 0.815",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.  See the\nBuild package doc page for more info."
},
{
    "command": "pair_style oxrna2/excv",
    "html_filename": "pair_oxrna2.html",
    "short_description": "The oxrna2 pair styles compute the pairwise-additive parts of the oxDNA force field for coarse-grained modelling of DNA",
    "description": "The oxrna2 pair styles compute the pairwise-additive parts of the oxDNA force field\nfor coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\nexcluded volume interaction oxrna2/excv, the stacking oxrna2/stk, cross-stacking oxrna2/xstk\nand coaxial stacking interaction oxrna2/coaxstk, electrostatic Debye-Hueckel interaction oxrna2/dh\nas well as the hydrogen-bonding interaction oxrna2/hbond between complementary pairs of nucleotides on\nopposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\nare supported (Sulc2). Quasi-unique base-pairing between nucleotides can be achieved by using\nmore complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\nThis prevents the hybridization of in principle complementary bases within Ntypes/4 bases\nup and down along the backbone.\nThe exact functional form of the pair styles is rather complex.\nThe individual potentials consist of products of modulation factors,\nwhich themselves are constructed from a number of more basic potentials\n(Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\nWe refer to (Sulc1) and the original oxDNA publications (Ouldridge-DPhil)\nand  (Ouldridge) for a detailed description of the oxRNA2 force field.\n\nNote\nThese pair styles have to be used together with the related oxDNA2 bond style\noxrna2/fene for the connectivity of the phosphate backbone (see also documentation of\nbond_style oxrna2/fene). Most of the coefficients\nin the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\nExceptions are the first four coefficients after oxrna2/stk (seq=seqdep, T=0.1, xi=1.40206 and kappa=2.77 in the above example),\nthe first coefficient after oxrna2/hbond (seq=seqdep in the above example) and the three coefficients\nafter oxrna2/dh (T=0.1, rhos=0.5, qeff=1.02455 in the above example). When using a Langevin thermostat\ne.g. through fix langevin or fix nve/dotc/langevin\nthe temperature coefficients have to be matched to the one used in the fix.\n\nExample input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\nA simple python setup tool which creates single straight or helical DNA strands,\nDNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\nPlease cite (Henrich) in any publication that uses\nthis implementation.  The article contains general information\non the model, its implementation and performance as well as the structure of\nthe data and input file. The preprint version of the article can be found\nhere.\nPlease cite also the relevant oxRNA2 publications\n(Sulc1) and (Sulc2).",
    "syntax": "pair_style style1",
    "parameters": " * pair_coeff * * style2 args\n * style1 = hybrid/overlay oxrna2/excv oxrna2/stk oxrna2/hbond oxrna2/xstk oxrna2/coaxstk oxrna2/dh\n * style2 = oxrna2/excv or oxrna2/stk or oxrna2/hbond or oxrna2/xstk or oxrna2/coaxstk or oxrna2/dh\n * args = list of arguments for these particular styles\n * oxrna2/stk args = seq T xi kappa 6.0 0.43 0.93 0.35 0.78 0.9 0 0.95 0.9 0 0.95 1.3 0 0.8 1.3 0 0.8 2.0 0.65 2.0 0.65\n *   seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n *   T = temperature (oxDNA units, 0.1 = 300 K)\n *   xi = 1.40206 (temperature-independent coefficient in stacking strength)\n *   kappa = 2.77 (coefficient of linear temperature dependence in stacking strength)\n * oxrna2/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n *   seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n *   eps = 0.870439 (between base pairs A-T, C-G and G-T) or 0 (all other pairs)\n * oxrna2/dh args = T rhos qeff\n *   T = temperature (oxDNA units, 0.1 = 300 K)\n *   rhos = salt concentration (mole per litre)\n *   qeff = 1.02455 (effective charge in elementary charges)",
    "examples": "pair_style hybrid/overlay oxrna2/excv oxrna2/stk oxrna2/hbond oxrna2/xstk oxrna2/coaxstk oxrna2/dh\npair_coeff * * oxrna2/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\npair_coeff * * oxrna2/stk     seqdep 0.1 1.40206 2.77 6.0 0.43 0.93 0.35 0.78 0.9 0 0.95 0.9 0 0.95 1.3 0 0.8 1.3 0 0.8 2.0 0.65 2.0 0.65\npair_coeff * * oxrna2/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 1 4 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 2 3 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff 3 4 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\npair_coeff * * oxrna2/xstk    59.9626 0.5 0.6 0.42 0.58 2.25 0.505 0.58 1.7 1.266 0.68 1.7 1.266 0.68 1.7 0.309 0.68 1.7 0.309 0.68\npair_coeff * * oxrna2/coaxstk 80 0.5 0.6 0.42 0.58 2.0 2.592 0.65 1.3 0.151 0.8 0.9 0.685 0.95 0.9 0.685 0.95 2.0 -0.65 2.0 -0.65\npair_coeff * * oxrna2/dh      0.1 0.5 1.02455",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.  See the\nBuild package doc page for more info."
},
{
    "command": "pair_style peri/pmb",
    "html_filename": "pair_peri.html",
    "short_description": "The peridynamic pair styles implement material models that can be used at the mesoscopic and macroscopic scales",
    "description": "The peridynamic pair styles implement material models that can be used\nat the mesoscopic and macroscopic scales.  See this document for an overview of LAMMPS commands\nfor Peridynamics modeling.\nStyle peri/pmb implements the Peridynamic bond-based prototype\nmicroelastic brittle (PMB) model.\nStyle peri/lps implements the Peridynamic state-based linear\nperidynamic solid (LPS) model.\nStyle peri/ves implements the Peridynamic state-based linear\nperidynamic viscoelastic solid (VES) model.\nStyle peri/eps implements the Peridynamic state-based elastic-plastic\nsolid (EPS) model.\nThe canonical papers on Peridynamics are (Silling 2000)\nand (Silling 2007).  The implementation of Peridynamics\nin LAMMPS is described in (Parks).  Also see the PDLAMMPS user guide for\nmore details about its implementation.\nThe peridynamic VES and EPS models in PDLAMMPS were implemented by\nR. Rahman and J. T. Foster at University of Texas at San Antonio.  The\noriginal VES formulation is described in “(Mitchell2011)” and the\noriginal EPS formulation is in “(Mitchell2011a)”.  Additional PDF docs\nthat describe the VES and EPS implementations are include in the\nLAMMPS distribution in doc/PDF/PDLammps_VES.pdf and\ndoc/PDF/PDLammps_EPS.pdf.  For questions\nregarding the VES and EPS models in LAMMPS you can contact R. Rahman\n(rezwanur.rahman at utsa.edu).\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below.\nFor the peri/pmb style:\n\nc (energy/distance/volume^2 units)\nhorizon (distance units)\ns00 (unitless)\n\\(\\alpha\\) (unitless)\n\nC is the effectively a spring constant for Peridynamic bonds, the\nhorizon is a cutoff distance for truncating interactions, and s00 and\n\\(\\alpha\\) are used as a bond breaking criteria.  The units of c are such\nthat c/distance = stiffness/volume^2, where stiffness is\nenergy/distance^2 and volume is distance^3.  See the users guide for\nmore details.\nFor the peri/lps style:\n\nK (force/area units)\nG (force/area units)\nhorizon (distance units)\ns00 (unitless)\n\\(\\alpha\\) (unitless)\n\nK is the bulk modulus and G is the shear modulus.  The horizon is a\ncutoff distance for truncating interactions, and s00 and \\(\\alpha\\) are\nused as a bond breaking criteria. See the users guide for more\ndetails.\nFor the peri/ves style:\n\nK (force/area units)\nG (force/area units)\nhorizon (distance units)\ns00 (unitless)\n\\(\\alpha\\) (unitless)\nm_lambdai (unitless)\nm_taubi (unitless)\n\nK is the bulk modulus and G is the shear modulus. The horizon is a\ncutoff distance for truncating interactions, and s00 and \\(\\alpha\\) are\nused as a bond breaking criteria. m_lambdai and m_taubi are the\nviscoelastic relaxation parameter and time constant,\nrespectively. m_lambdai varies within zero to one. For very small\nvalues of m_lambdai the viscoelastic model responds very similar to a\nlinear elastic model. For details please see the description in\n“(Mtchell2011)”.\nFor the peri/eps style:\n\nK (force/area units)\nG (force/area units)\nhorizon (distance units)\ns00 (unitless)\n\\(\\alpha\\) (unitless)\nm_yield_stress (force/area units)\n\nK is the bulk modulus and G is the shear modulus. The horizon is a\ncutoff distance and s00 and \\(\\alpha\\) are used as a bond breaking\ncriteria.  m_yield_stress is the yield stress of the material. For\ndetails please see the description in “(Mtchell2011a)”.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThese pair styles do not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThese pair styles do not support the pair_modify\nshift option.\nThe pair_modify table and tail options are not\nrelevant for these pair styles.\nThese pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThese pair styles can only be used via the pair keyword of the\nrun_style respa command.  They do not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style",
    "parameters": " * style = peri/pmb or peri/lps or peri/ves or peri/eps",
    "examples": "pair_style peri/pmb\npair_coeff * * 1.6863e22 0.0015001 0.0005 0.25\n\npair_style peri/lps\npair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25\n\npair_style peri/ves\npair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25 0.5 0.001\n\npair_style peri/eps\npair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25 118.43",
    "restrictions": "All of these styles are part of the PERI package. They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style polymorphic",
    "html_filename": "pair_polymorphic.html",
    "short_description": "The polymorphic pair style computes a 3-body free-form potential (Zhou) for the energy E of a system of atoms as  \\[\\begin{split}E & = \\frac{1}{2}\\sum_{i=1}^{i=N}\\sum_{j=1}^{j=N}\\left[\\left(1-\\delta_{ij}\\right)\\cdot U_{IJ}\\left(r_{ij}\\right)-\\left(1-\\eta_{ij}\\right)\\cdot F_{IJ}\\left(r_{ij}\\right)\\cdot V_{IJ}\\left(r_{ij}\\right)\\right] \\\\ X_{ij} & = \\sum_{k=i_1,k\\neq i,j}^{i_N}W_{IK}\\left(r_{ik}\\right)\\cdot G_{JIK}\\left(\\theta_{jik}\\right)\\cdot P_{IK}\\left(\\Delta r_{jik}\\right) \\\\ \\Delta r_{jik} & = r_{ij}-\\xi_{IJ}\\cdot r_{ik}\\end{split}\\] where I, J, K represent species of atoms i, j, and k, \\(i_1, ",
    "description": "The polymorphic pair style computes a 3-body free-form potential\n(Zhou) for the energy E of a system of atoms as\n\n\\[\\begin{split}E & = \\frac{1}{2}\\sum_{i=1}^{i=N}\\sum_{j=1}^{j=N}\\left[\\left(1-\\delta_{ij}\\right)\\cdot U_{IJ}\\left(r_{ij}\\right)-\\left(1-\\eta_{ij}\\right)\\cdot F_{IJ}\\left(r_{ij}\\right)\\cdot V_{IJ}\\left(r_{ij}\\right)\\right] \\\\\nX_{ij} & = \\sum_{k=i_1,k\\neq i,j}^{i_N}W_{IK}\\left(r_{ik}\\right)\\cdot G_{JIK}\\left(\\theta_{jik}\\right)\\cdot P_{IK}\\left(\\Delta r_{jik}\\right) \\\\\n\\Delta r_{jik} & = r_{ij}-\\xi_{IJ}\\cdot r_{ik}\\end{split}\\]\nwhere I, J, K represent species of atoms i, j, and k, \\(i_1, ...,\ni_N\\) represents a list of i’s neighbors, \\(\\delta_{ij}\\) is a\nDirac constant (i.e., \\(\\delta_{ij} = 1\\) when \\(i = j\\), and\n\\(\\delta_{ij} = 0\\) otherwise), \\(\\eta_{ij}\\) is similar\nconstant that can be set either to \\(\\eta_{ij} = \\delta_{ij}\\) or\n\\(\\eta_{ij} = 1 - \\delta_{ij}\\) depending on the potential type,\n\\(U_{IJ}(r_{ij})\\), \\(V_{IJ}(r_{ij})\\), \\(W_{IK}(r_{ik})\\)\nare pair functions, \\(G_{JIK}(\\cos(\\theta))\\) is an angular\nfunction, \\(P_{IK}(\\Delta r_{jik})\\) is a function of atomic spacing\ndifferential \\(\\Delta r_{jik} = r_{ij} - \\xi_{IJ} \\cdot r_{ik}\\)\nwith \\(\\xi_{IJ}\\) being a pair-dependent parameter, and\n\\(F_{IJ}(X_{ij})\\) is a function of the local environment variable\n\\(X_{ij}\\). This generic potential is fully defined once the\nconstants \\(\\eta_{ij}\\) and \\(\\xi_{IJ}\\), and the six functions\n\\(U_{IJ}(r_{ij})\\), \\(V_{IJ}(r_{ij})\\), \\(W_{IK}(r_{ik})\\),\n\\(G_{JIK}(\\cos(\\theta))\\), \\(P_{IK}(\\Delta r_{jik})\\), and\n\\(F_{IJ}(X_{ij})\\) are given. Note that these six functions are all\none dimensional, and hence can be provided in an analytic or tabular\nform. This allows users to design different potentials solely based on a\nmanipulation of these functions. For instance, the potential reduces to\nStillinger-Weber potential (SW) if we set\n\n\\[\\begin{split}\\left\\{\\begin{array}{l}\n\\eta_{ij} = \\delta_{ij},\\xi_{IJ}=0 \\\\\nU_{IJ}\\left(r\\right)=A_{IJ}\\cdot\\epsilon_{IJ}\\cdot \\left(\\frac{\\sigma_{IJ}}{r}\\right)^q\\cdot \\left[B_{IJ}\\cdot \\left(\\frac{\\sigma_{IJ}}{r}\\right)^{p-q}-1\\right]\\cdot exp\\left(\\frac{\\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\nV_{IJ}\\left(r\\right)=\\sqrt{\\lambda_{IJ}\\cdot \\epsilon_{IJ}}\\cdot exp\\left(\\frac{\\gamma_{IJ}\\cdot \\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\nF_{IJ}\\left(X\\right)=-X \\\\\nP_{IJ}\\left(\\Delta r\\right)=1 \\\\\nW_{IJ}\\left(r\\right)=\\sqrt{\\lambda_{IJ}\\cdot \\epsilon_{IJ}}\\cdot exp\\left(\\frac{\\gamma_{IJ}\\cdot \\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\nG_{JIK}\\left(\\theta\\right)=\\left(cos\\theta+\\frac{1}{3}\\right)^2\n\\end{array}\\right.\\end{split}\\]\nThe potential reduces to Tersoff types of potential\n(Tersoff or Albe) if we set\n\n\\[\\begin{split}\\left\\{\\begin{array}{l}\n\\eta_{ij}=\\delta_{ij},\\xi_{IJ}=1 \\\\\nU_{IJ}\\left(r\\right)=\\frac{D_{e,IJ}}{S_{IJ}-1}\\cdot exp\\left[-\\beta_{IJ}\\sqrt{2S_{IJ}\\left(r-r_{e,IJ}\\right)}\\right]\\cdot f_{c,IJ}\\left(r\\right) \\\\\nV_{IJ}\\left(r\\right)=\\frac{S_{IJ}\\cdot D_{e,IJ}}{S_{IJ}-1}\\cdot exp\\left[-\\beta_{IJ}\\sqrt{\\frac{2}{S_{IJ}}\\left(r-r_{e,IJ}\\right)}\\right]\\cdot f_{c,IJ}\\left(r\\right) \\\\\nF_{IJ}\\left(X\\right)=\\left(1+X\\right)^{-\\frac{1}{2}} \\\\\nP_{IJ}\\left(\\Delta r\\right)=exp\\left(2\\mu_{IK}\\cdot \\Delta r\\right) \\\\\nW_{IJ}\\left(r\\right)=f_{c,IK}\\left(r\\right) \\\\\nG_{JIK}\\left(\\theta\\right)=\\gamma_{IK}\\left[1+\\frac{c_{IK}^2}{d_{IK}^2}-\\frac{c_{IK}^2}{d_{IK}^2+\\left(h_{IK}+cos\\theta\\right)^2}\\right]\n\\end{array}\\right.\\end{split}\\]\n\n\\[\\begin{split}f_{c,IJ}=\\left\\{\\begin{array}{lr}\n1, & r\\leq r_{s,IJ} \\\\\n\\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,IJ}\\right)}{r_{c,IJ}-r_{s,IJ}}\\right], & r_{s,IJ}<r<r_{c,IJ} \\\\\n0, & r \\geq r_{c,IJ} \\\\\n\\end{array}\\right.\\end{split}\\]\nThe potential reduces to Rockett-Tersoff (Wang) type if we set\n\n\\[\\begin{split}\\left\\{\\begin{array}{l}\n\\eta_{ij}=\\delta_{ij},\\xi_{IJ}=1 \\\\\nU_{IJ}\\left(r\\right)=\\left\\{\\begin{array}{lr}\nA_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right), & r\\leq r_{s,1,IJ} \\\\\nA_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)\\cdot f_{c,1,IJ}\\left(r\\right), & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\n0, & r\\ge r_{c,1,IJ}\n\\end{array}\\right. \\\\\nV_{IJ}\\left(r\\right)=\\left\\{\\begin{array}{lr}\nB_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right), & r\\le r_{s,1,IJ} \\\\\nB_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)+A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot & \\\\ ~~~~~~ f_{c,IJ}\\left(r\\right)\\cdot \\left[1-f_{c,1,IJ}\\left(r\\right)\\right], & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\nB_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)+A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot & \\\\ ~~~~~~ f_{c,IJ}\\left(r\\right) & r \\ge r_{c,1,IJ}\n\\end{array}\\right. \\\\\nF_{IJ}\\left(X\\right)=\\left[1+\\left(\\beta_{IJ}\\cdot X\\right)^{n_{IJ}}\\right]^{-\\frac{1}{2n_{IJ}}} \\\\\nP_{IJ}\\left(\\Delta r\\right)=exp\\left(\\lambda_{3,IK}\\cdot \\Delta r^3\\right) \\\\\nW_{IJ}\\left(r\\right)=f_{c,IK}\\left(r\\right) \\\\\nG_{JIK}\\left(\\theta\\right)=1+\\frac{c_{IK}^2}{d_{IK}^2}-\\frac{c_{IK}^2}{d_{IK}^2+\\left(h_{IK}+cos\\theta\\right)^2}\n\\end{array}\\right.\\end{split}\\]\n\n\\[\\begin{split}f_{c,IJ}=\\left\\{\\begin{array}{lr}\n1, & r\\leq r_{s,IJ} \\\\\n\\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,IJ}\\right)}{r_{c,IJ}-r_{s,IJ}}\\right], & r_{s,IJ}<r<r_{c,IJ} \\\\\n0, & r \\geq r_{c,IJ} \\\\\n\\end{array}\\right.\\end{split}\\]\n\n\\[\\begin{split}f_{c,1,IJ}=\\left\\{\\begin{array}{lr}\n1, & r\\leq r_{s,1,IJ} \\\\\n\\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,1,IJ}\\right)}{r_{c,1,IJ}-r_{s,1,IJ}}\\right], & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\n0, & r \\geq r_{c,1,IJ} \\\\\n\\end{array}\\right.\\end{split}\\]\nThe potential becomes embedded atom method (Daw) if we set\n\n\\[\\begin{split}\\left\\{\\begin{array}{l}\n\\eta_{ij}=1-\\delta_{ij},\\xi_{IJ}=0 \\\\\nU_{IJ}\\left(r\\right)=\\phi_{IJ}\\left(r\\right) \\\\\nV_{IJ}\\left(r\\right)=1 \\\\\nF_{II}\\left(X\\right)=-2F_I\\left(X\\right) \\\\\nP_{IJ}\\left(\\Delta r\\right)=1 \\\\\nW_{IJ}\\left(r\\right)=f_{K}\\left(r\\right) \\\\\nG_{JIK}\\left(\\theta\\right)=1\n\\end{array}\\right.\\end{split}\\]\nIn the embedded atom method case, \\(\\phi_{IJ}(r_{ij})\\) is the pair\nenergy, \\(F_I(X)\\) is the embedding energy, X is the local\nelectron density, and \\(f_K(r)\\) is the atomic electron density function.\nIf the tabulated functions are created using the parameters of sw,\ntersoff, and eam potentials, the polymorphic pair style will produce\nthe same global properties (energies and stresses) and the same forces\nas the sw, tersoff, and eam pair styles. The polymorphic pair style\nalso produces the same atom properties (energies and stresses) as the\ncorresponding tersoff and eam pair styles. However, due to a different\npartition of global properties to atom properties, the polymorphic\npair style will produce different atom properties (energies and\nstresses) as the sw pair style. This does not mean that polymorphic\npair style is different from the sw pair style in this case. It just\nmeans that the definitions of the atom energies and atom stresses are\ndifferent.\nOnly a single pair_coeff command is used with the polymorphic style\nwhich specifies an potential file for all needed elements. These are\nmapped to LAMMPS atom types by specifying N additional arguments after\nthe filename in the pair_coeff command, where N is the number of\nLAMMPS atom types:\n\nfilename\nN element names = mapping of Tersoff elements to atom types\n\nSee the pair_coeff doc page for alternate ways to specify the path for\nthe potential file.  Several files for polymorphic potentials are\nincluded in the potentials directory of the LAMMPS distribution.  They\nhave a “poly” suffix.\nAs an example, imagine the SiC_tersoff.poly file has tabulated\nfunctions for Si-C tersoff potential. If your LAMMPS simulation has 4\natoms types and you want the 1st 3 to be Si, and the 4th to be C, you\nwould use the following pair_coeff command:\npair_coeff * * SiC_tersoff.poly Si Si Si C\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom\ntypes. The first three Si arguments map LAMMPS atom types 1,2,3 to the\nSi element in the polymorphic file. The final C argument maps LAMMPS\natom type 4 to the C element in the polymorphic file. If a mapping\nvalue is specified as NULL, the mapping is not performed. This can be\nused when an polymorphic potential is used as part of the hybrid pair\nstyle. The NULL values are placeholders for atom types that will be\nused with other potentials.\nPotential files in the potentials directory of the LAMMPS distribution\nhave a “.poly” suffix. At the beginning of the files, an unlimited\nnumber of lines starting with ‘#’ are used to describe the potential\nand are ignored by LAMMPS. The next line lists two numbers:\nntypes \\(\\eta\\)\nHere ntypes represent total number of species defined in the potential\nfile, and \\(\\eta = 0\\) or 1. The number ntypes must equal the total\nnumber of different species defined in the pair_coeff command. When\n\\(\\eta = 1\\), :math:eta_{ij}` defined in the potential functions\nabove is set to \\(1 - \\delta_{ij}\\), otherwise \\(\\eta_{ij}\\) is\nset to \\(\\delta_{ij}\\). The next ntypes lines each lists two numbers\nand a character string representing atomic number, atomic mass, and name\nof the species of the ntypes elements:\natomic_number atomic-mass element (1)\natomic_number atomic-mass element (2)\n...\natomic_number atomic-mass element (ntypes)\n\n\nThe next ntypes*(ntypes+1)/2 lines contain two numbers:\ncut \\(xi\\) (1)\ncut \\(xi\\) (2)\n...\ncut \\(xi\\) (ntypes*(ntypes+1)/2)\nHere cut means the cutoff distance of the pair functions, \\(\\xi\\) is\nthe same as defined in the potential functions above. The\nntypes*(ntypes+1)/2 lines are related to the pairs according to the\nsequence of first ii (self) pairs, i = 1, 2, …, ntypes, and then then\nij (cross) pairs, i = 1, 2, …, ntypes-1, and j = i+1, i+2, …, ntypes\n(i.e., the sequence of the ij pairs follows 11, 22, …, 12, 13, 14,\n…, 23, 24, …).\nThe final blocks of the potential file are the U, V, W, P, G, and F\nfunctions are listed sequentially. First, U functions are given for\neach of the ntypes*(ntypes+1)/2 pairs according to the sequence\ndescribed above. For each of the pairs, nr values are listed. Next,\nsimilar arrays are given for V, W, and P functions. Then G functions\nare given for all the ntypes*ntypes*ntypes ijk triplets in a natural\nsequence i from 1 to ntypes, j from 1 to ntypes, and k from 1 to\nntypes (i.e., ijk = 111, 112, 113, …, 121, 122, 123 …, 211, 212,\n…). Each of the ijk functions contains ng values. Finally, the F\nfunctions are listed for all ntypes*(ntypes+1)/2 pairs, each\ncontaining nx values. Either analytic or tabulated functions can be\nspecified. Currently, constant, exponential, sine and cosine analytic\nfunctions are available which are specified with: constant c1 , where\nf(x) = c1 exponential c1 c2 , where f(x) = c1 exp(c2*x) sine c1 c2 ,\nwhere f(x) = c1 sin(c2*x) cos c1 c2 , where f(x) = c1 cos(c2*x)\nTabulated functions are specified by spline n x1 x2, where n=number of\npoint, (x1,x2)=range and then followed by n values evaluated uniformly\nover these argument ranges.  The valid argument ranges of the\nfunctions are between 0 <= r <= cut for the U(r), V(r), W(r)\nfunctions, -cutmax <= delta_r <= cutmax for the P(delta_r) functions,\n-1 <= \\(\\cos\\theta\\) <= 1 for the G(\\(\\cos\\theta\\)) functions,\nand 0 <= X <= maxX for the F(X) functions.\nMixing, shift, table tail correction, restart:\nThis pair styles does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write their information to binary restart files, since it is stored in potential files. Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.",
    "syntax": "pair_style polymorphic",
    "parameters": " * style = polymorphic",
    "examples": "pair_style polymorphic\npair_coeff * * TlBr_msw.polymorphic Tl Br\npair_coeff * * AlCu_eam.polymorphic Al Cu\npair_coeff * * GaN_tersoff.polymorphic Ga N\npair_coeff * * GaN_sw.polymorphic GaN",
    "restrictions": "If using create_atoms command, atomic masses must be defined in the\ninput script. If using read_data, atomic masses must be defined in the\natomic structure data file.\nThis pair style is part of the MANYBODY package. It is only enabled if\nLAMMPS was built with that package. See the Build package doc page for more info.\nThis pair potential requires the newtion setting to be\n“on” for pair interactions.\nThe potential files provided with LAMMPS (see the potentials\ndirectory) are parameterized for metal units. You can use\nany LAMMPS units, but you would need to create your own potential\nfiles."
},
{
    "command": "pair_style python",
    "html_filename": "pair_python.html",
    "short_description": "The python pair style provides a way to define pairwise additive potential functions as python script code that is loaded into LAMMPS from a python file which must contain specific python class definitions",
    "description": "The python pair style provides a way to define pairwise additive\npotential functions as python script code that is loaded into LAMMPS\nfrom a python file which must contain specific python class definitions.\nThis allows to rapidly evaluate different potential functions without\nhaving to modify and re-compile LAMMPS. Due to python being an\ninterpreted language, however, the performance of this pair style is\ngoing to be significantly slower (often between 20x and 100x) than\ncorresponding compiled code. This penalty can be significantly reduced\nthrough generating tabulations from the python code through the\npair_write command, which is supported by this style.\nOnly a single pair_coeff command is used with the python pair style\nwhich specifies a python class inside a python module or file that\nLAMMPS will look up in the current directory, the folder pointed to by\nthe LAMMPS_POTENTIALS environment variable or somewhere in your python\npath.  A single python module can hold multiple python pair class\ndefinitions. The class definitions itself have to follow specific\nrules that are explained below.\nAtom types in the python class are specified through symbolic\nconstants, typically strings. These are mapped to LAMMPS atom types by\nspecifying N additional arguments after the class name in the\npair_coeff command, where N must be the number of currently defined\natom types:\nAs an example, imagine a file py_pot.py has a python potential class\nnames LJCutMelt with parameters and potential functions for a two\nLennard-Jones atom types labeled as ‘LJ1’ and ‘LJ2’. In your LAMMPS\ninput and you would have defined 3 atom types, out of which the first\ntwo are supposed to be using the ‘LJ1’ parameters and the third the\n‘LJ2’ parameters, then you would use the following pair_coeff command:\npair_coeff * * py_pot.LJCutMelt LJ1 LJ1 LJ2\n\n\nThe first two arguments must be * * so as to span all LAMMPS atom\ntypes.  The first two LJ1 arguments map LAMMPS atom types 1 and 2 to\nthe LJ1 atom type in the LJCutMelt class of the py_pot.py file.  The\nfinal LJ2 argument maps LAMMPS atom type 3 to the LJ2 atom type the\npython file.  If a mapping value is specified as NULL, the mapping is\nnot performed, any pair interaction with this atom type will be\nskipped. This can be used when a python potential is used as part of\nthe hybrid or hybrid/overlay pair style. The NULL values are then\nplaceholders for atom types that will be used with other potentials.\n\nThe python potential file has to start with the following code:\nfrom __future__ import print_function\n\nclass LAMMPSPairPotential(object):\n    def __init__(self):\n        self.pmap=dict()\n        self.units='lj'\n    def map_coeff(self,name,ltype):\n        self.pmap[ltype]=name\n    def check_units(self,units):\n        if (units != self.units):\n           raise Exception(\"Conflicting units: %s vs. %s\" % (self.units,units))\n\n\nAny classes with definitions of specific potentials have to be derived\nfrom this class and should be initialize in a similar fashion to the\nexample given below.\n\nNote\nThe class constructor has to set up a data structure containing\nthe potential parameters supported by this class.  It should also\ndefine a variable self.units containing a string matching one of the\noptions of LAMMPS’ units command, which is used to\nverify, that the potential definition in the python class and in the\nLAMMPS input match.\n\nHere is an example for a single type Lennard-Jones potential class\nLJCutMelt in reduced units, which defines an atom type lj for\nwhich the parameters epsilon and sigma are both 1.0:\nclass LJCutMelt(LAMMPSPairPotential):\n    def __init__(self):\n        super(LJCutMelt,self).__init__()\n        # set coeffs: 48\\*eps\\*sig\\*\\*12, 24\\*eps\\*sig\\*\\*6,\n        #              4\\*eps\\*sig\\*\\*12,  4\\*eps\\*sig\\*\\*6\n        self.units = 'lj'\n        self.coeff = {'lj'  : {'lj'  : (48.0,24.0,4.0,4.0)}}\n\n\nThe class also has to provide two methods for the computation of the\npotential energy and forces, which have be named compute_force,\nand compute_energy, which both take 3 numerical arguments:\n\nrsq   = the square of the distance between a pair of atoms (float)\nitype = the (numerical) type of the first atom\njtype = the (numerical) type of the second atom\n\nThis functions need to compute the force and the energy, respectively,\nand use the result as return value. The functions need to use the\npmap dictionary to convert the LAMMPS atom type number to the symbolic\nvalue of the internal potential parameter data structure. Following\nthe LJCutMelt example, here are the two functions:\ndef compute_force(self,rsq,itype,jtype):\n     coeff = self.coeff[self.pmap[itype]][self.pmap[jtype]]\n     r2inv  = 1.0/rsq\n     r6inv  = r2inv\\*r2inv\\*r2inv\n     lj1 = coeff[0]\n     lj2 = coeff[1]\n     return (r6inv \\* (lj1\\*r6inv - lj2))\\*r2inv\n\n def compute_energy(self,rsq,itype,jtype):\n     coeff = self.coeff[self.pmap[itype]][self.pmap[jtype]]\n     r2inv  = 1.0/rsq\n     r6inv  = r2inv\\*r2inv\\*r2inv\n     lj3 = coeff[2]\n     lj4 = coeff[3]\n     return (r6inv \\* (lj3\\*r6inv - lj4))\n\n\n\nNote\nfor consistency with the C++ pair styles in LAMMPS, the\ncompute_force function follows the conventions of the Pair::single()\nmethods and does not return the full force, but the force scaled by\nthe distance between the two atoms, so this value only needs to be\nmultiplied by delta x, delta y, and delta z to conveniently obtain the\nthree components of the force vector between these two atoms.\n\n\n\nNote\nThe evaluation of scripted python code will slow down the\ncomputation pair-wise interactions quite significantly. However, this\ncan be largely worked around through using the python pair style not\nfor the actual simulation, but to generate tabulated potentials on the\nfly using the pair_write command. Please see below\nfor an example LAMMPS input of how to build a table file:\n\npair_style python 2.5\npair_coeff * * py_pot.LJCutMelt lj\nshell rm -f melt.table\npair_write  1 1 2000 rsq 0.01 2.5 lj1_lj2.table lj\n\n\nNote that it is strongly recommended to try to delete the potential\ntable file before generating it. Since the pair_write command will\nalways append to a table file, while pair style table will use the\nfirst match. Thus when changing the potential function in the python\nclass, the table pair style will still read the old variant unless the\ntable file is first deleted.\nAfter switching the pair style to table, the potential tables need\nto be assigned to the LAMMPS atom types like this:\npair_style      table linear 2000\npair_coeff      1  1  melt.table lj\n\n\nThis can also be done for more complex systems.  Please see the\nexamples/python folders for a few more examples.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nMixing of potential parameters has to be handled inside the provided\npython module. The python pair style simply assumes that force and\nenergy computation can be correctly performed for all pairs of atom\ntypes as they are mapped to the atom type labels inside the python\npotential class.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style python cutoff",
    "parameters": " * cutoff = global cutoff for interactions in python potential classes",
    "examples": "pair_style python 2.5\npair_coeff * * py_pot.LJCutMelt lj\n\npair_style hybrid/overlay coul/long 12.0 python 12.0\npair_coeff * * coul/long\npair_coeff * * python py_pot.LJCutSPCE OW NULL",
    "restrictions": "This pair style is part of the PYTHON package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style quip",
    "html_filename": "pair_quip.html",
    "short_description": "Style quip provides an interface for calling potential routines from the QUIP package",
    "description": "Style quip provides an interface for calling potential routines from\nthe QUIP package. QUIP is built separately, and then linked to\nLAMMPS. The most recent version of the QUIP package can be downloaded\nfrom GitHub:\nhttps://github.com/libAtoms/QUIP. The\ninterface is chiefly intended to be used to run Gaussian Approximation\nPotentials (GAP), which are described in the following publications:\n(Bartok et al) and (PhD thesis of Bartok).\nOnly a single pair_coeff command is used with the quip style that\nspecifies a QUIP potential file containing the parameters of the\npotential for all needed elements in XML format. This is followed by a\nQUIP initialization string. Finally, the QUIP elements are mapped to\nLAMMPS atom types by specifying N atomic numbers, where N is the\nnumber of LAMMPS atom types:\n\nQUIP filename\nQUIP initialization string\nN atomic numbers = mapping of QUIP elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nA QUIP potential is fully specified by the filename which contains the\nparameters of the potential in XML format, the initialization string,\nand the map of atomic numbers.\nGAP potentials can be obtained from the Data repository section of\nhttp://www.libatoms.org, where the\nappropriate initialization strings are also advised. The list of\natomic numbers must be matched to the LAMMPS atom types specified in\nthe LAMMPS data file or elsewhere.\nTwo examples input scripts are provided in the examples/USER/quip\ndirectory.\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style quip",
    "parameters": " * ",
    "examples": "pair_style      quip\npair_coeff      * * gap_example.xml \"Potential xml_label=GAP_2014_5_8_60_17_10_38_466\" 14\npair_coeff      * * sw_example.xml \"IP SW\" 14",
    "restrictions": "This pair style is part of the USER-QUIP package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nQUIP potentials are parameterized in electron-volts and Angstroms and\ntherefore should be used with LAMMPS metal units.\nQUIP potentials are generally not designed to work with the scaling\nfactors set by the special_bonds command.  The\nrecommended setting in molecular systems is to include all\ninteractions, i.e. to use special_bonds lj/coul 1.0 1.0 1.0. Scaling\nfactors > 0.0 will be ignored and treated as 1.0. The only exception\nto this rule is if you know that your QUIP potential needs to exclude\nbonded, 1-3, or 1-4 interactions and does not already do this exclusion\nwithin QUIP. Then a factor 0.0 needs to be used which will remove such\npairs from the neighbor list. This needs to be very carefully tested,\nbecause it may remove pairs from the neighbor list that are still\nrequired."
},
{
    "command": "pair_style reax/c",
    "html_filename": "pair_reaxc.html",
    "short_description": "Style reax/c computes the ReaxFF potential of van Duin, Goddard and co-workers",
    "description": "Style reax/c computes the ReaxFF potential of van Duin, Goddard and\nco-workers.  ReaxFF uses distance-dependent bond-order functions to\nrepresent the contributions of chemical bonding to the potential\nenergy. There is more than one version of ReaxFF. The version\nimplemented in LAMMPS uses the functional forms documented in the\nsupplemental information of the following paper: (Chenoweth et al., 2008).  The version integrated into LAMMPS matches\nthe most up-to-date version of ReaxFF as of summer 2010.  For more\ntechnical details about the pair reax/c implementation of ReaxFF, see\nthe (Aktulga) paper. The reax/c style was initially\nimplemented as a stand-alone C code and is now integrated into LAMMPS\nas a package.\nThe reax/c/kk style is a Kokkos version of the ReaxFF potential that\nis derived from the reax/c style. The Kokkos version can run on GPUs\nand can also use OpenMP multithreading. For more information about the\nKokkos package, see Packages details and\nSpeed kokkos doc pages.  One important\nconsideration when using the reax/c/kk style is the choice of either\nhalf or full neighbor lists. This setting can be changed using the\nKokkos package command.\nThe reax/c style differs from the (obsolete) “pair_style reax”\ncommand in the implementation details.  The reax style was a\nFortran library, linked to LAMMPS.  The reax style has been removed\nfrom LAMMPS after the 12 December 2018 version.\nLAMMPS provides several different versions of ffield.reax in its\npotentials dir, each called potentials/ffield.reax.label.  These are\ndocumented in potentials/README.reax.  The default ffield.reax\ncontains parameterizations for the following elements: C, H, O, N.\nThe format of these files is identical to that used originally by van\nDuin.  We have tested the accuracy of pair_style reax/c potential\nagainst the original ReaxFF code for the systems mentioned above.  You\ncan use other ffield files for specific chemical systems that may be\navailable elsewhere (but note that their accuracy may not have been\ntested).\n\nNote\nWe do not distribute a wide variety of ReaxFF force field files\nwith LAMMPS.  Adri van Duin’s group at PSU is the central repository\nfor this kind of data as they are continuously deriving and updating\nparameterizations for different classes of materials.  You can submit\na contact request at the Materials Computation Center (MCC) website\nhttps://www.mri.psu.edu/materials-computation-center/connect-mcc,\ndescribing the material(s) you are interested in modeling with ReaxFF.\nThey can tell you what is currently available or what it would take to\ncreate a suitable ReaxFF parameterization.\n\nThe cfile setting can be specified as NULL, in which case default\nsettings are used. A control file can be specified which defines\nvalues of control variables. Some control variables are\nglobal parameters for the ReaxFF potential. Others define certain\nperformance and output settings.\nEach line in the control file specifies the value for\na control variable.  The format of the control file is described\nbelow.\n\nNote\nThe LAMMPS default values for the ReaxFF global parameters\ncorrespond to those used by Adri van Duin’s stand-alone serial\ncode. If these are changed by setting control variables in the control\nfile, the results from LAMMPS and the serial code will not agree.\n\nExamples using pair_style reax/c are provided in the examples/reax\nsub-directory.\nUse of this pair style requires that a charge be defined for every\natom.  See the atom_style and\nread_data commands for details on how to specify\ncharges.\nThe ReaxFF parameter files provided were created using a charge\nequilibration (QEq) model for handling the electrostatic interactions.\nTherefore, by default, LAMMPS requires that the fix qeq/reax command be used with pair_style reax/c\nwhen simulating a ReaxFF model, to equilibrate charge each timestep.\nUsing the keyword checkqeq with the value no\nturns off the check for fix qeq/reax,\nallowing a simulation to be run without charge equilibration.\nIn this case, the static charges you\nassign to each atom will be used for computing the electrostatic\ninteractions in the system.\nSee the fix qeq/reax command for details.\nUsing the optional keyword lgvdw with the value yes turns on the\nlow-gradient correction of the ReaxFF/C for long-range London\nDispersion, as described in the (Liu) paper. Force field\nfile ffield.reax.lg is designed for this correction, and is trained\nfor several energetic materials (see “Liu”). When using lg-correction,\nrecommended value for parameter thb is 0.01, which can be set in the\ncontrol file.  Note: Force field files are different for the original\nor lg corrected pair styles, using wrong ffield file generates an\nerror message.\nUsing the optional keyword enobonds with the value yes, the energy\nof atoms with no bonds (i.e. isolated atoms) is included in the total\npotential energy and the per-atom energy of that atom.  If the value\nno is specified then the energy of atoms with no bonds is set to\nzero.  The latter behavior is usual not desired, as it causes\ndiscontinuities in the potential energy when the bonding of an atom\ndrops to zero.\nOptional keywords safezone and mincap are used for allocating\nreax/c arrays.  Increasing these values can avoid memory problems,\nsuch as segmentation faults and bondchk failed errors, that could\noccur under certain conditions. These keywords aren’t used by the\nKokkos version, which instead uses a more robust memory allocation\nscheme that checks if the sizes of the arrays have been exceeded and\nautomatically allocates more memory.\nThe thermo variable evdwl stores the sum of all the ReaxFF potential\nenergy contributions, with the exception of the Coulombic and charge\nequilibration contributions which are stored in the thermo variable\necoul.  The output of these quantities is controlled by the\nthermo command.\nThis pair style tallies a breakdown of the total ReaxFF potential\nenergy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 14.\nThe 14 values correspond to the following sub-categories (the variable\nnames in italics match those used in the original FORTRAN ReaxFF\ncode):\n\neb = bond energy\nea = atom energy\nelp = lone-pair energy\nemol = molecule energy (always 0.0)\nev = valence angle energy\nepen = double-bond valence angle penalty\necoa = valence angle conjugation energy\nehb = hydrogen bond energy\net = torsion energy\neco = conjugation energy\new = van der Waals energy\nep = Coulomb energy\nefi = electric field energy (always 0.0)\neqeq = charge equilibration energy\n\nTo print these quantities to the log file (with descriptive column\nheadings) the following commands could be included in an input script:\ncompute reax all pair reax/c\nvariable eb      equal c_reax[1]\nvariable ea      equal c_reax[2]\n[...]\nvariable eqeq    equal c_reax[14]\nthermo_style custom step temp epair v_eb v_ea [...] v_eqeq\n\n\nOnly a single pair_coeff command is used with the reax/c style which\nspecifies a ReaxFF potential file with parameters for all needed\nelements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN indices = ReaxFF elements\n\nThe filename is the ReaxFF potential file.\nIn the ReaxFF potential file, near the top, after the general\nparameters, is the atomic parameters section that contains element\nnames, each with a couple dozen numeric parameters.  If there are M\nelements specified in the ffield file, think of these as numbered 1\nto M. Each of the N indices you specify for the N atom types of LAMMPS\natoms must be an integer from 1 to M.  Atoms with LAMMPS type 1 will\nbe mapped to whatever element you specify as the first index value,\netc.  If a mapping value is specified as NULL, the mapping is not\nperformed.  This can be used when the reax/c style is used as part\nof the hybrid pair style.  The NULL values are placeholders for atom\ntypes that will be used with other potentials.\nAs an example, say your LAMMPS simulation has 4 atom types and the\nelements are ordered as C, H, O, N in the ffield file.  If you want\nthe LAMMPS atom type 1 and 2 to be C, type 3 to be N, and type 4 to be\nH, you would use the following pair_coeff command:\npair_coeff * * ffield.reax C C N H\n\n\n\nThe format of a line in the control file is as follows:\nvariable_name value\n\n\nand it may be followed by an “!” character and a trailing comment.\nIf the value of a control variable is not specified, then default\nvalues are used.  What follows is the list of variables along with a\nbrief description of their use and default values.\nsimulation_name: Output files produced by pair_style reax/c carry\nthis name + extensions specific to their contents.  Partial energies\nare reported with a “.pot” extension, while the trajectory file has\n“.trj” extension.\ntabulate_long_range: To improve performance, long range interactions\ncan optionally be tabulated (0 means no tabulation). Value of this\nvariable denotes the size of the long range interaction table.  The\nrange from 0 to long range cutoff (defined in the ffield file) is\ndivided into tabulate_long_range points.  Then at the start of\nsimulation, we fill in the entries of the long range interaction table\nby computing the energies and forces resulting from van der Waals and\nCoulomb interactions between every possible atom type pairs present in\nthe input system.  During the simulation we consult to the long range\ninteraction table to estimate the energy and forces between a pair of\natoms. Linear interpolation is used for estimation. (default value =\n0)\nenergy_update_freq: Denotes the frequency (in number of steps) of\nwrites into the partial energies file. (default value = 0)\nnbrhood_cutoff: Denotes the near neighbors cutoff (in Angstroms)\nregarding the bonded interactions. (default value = 5.0)\nhbond_cutoff: Denotes the cutoff distance (in Angstroms) for hydrogen\nbond interactions.(default value = 7.5. A value of 0.0 turns off\nhydrogen bonds)\nbond_graph_cutoff: is the threshold used in determining what is a\nphysical bond, what is not. Bonds and angles reported in the\ntrajectory file rely on this cutoff. (default value = 0.3)\nthb_cutoff: cutoff value for the strength of bonds to be considered in\nthree body interactions. (default value = 0.001)\nthb_cutoff_sq: cutoff value for the strength of bond order products\nto be considered in three body interactions. (default value = 0.00001)\nwrite_freq: Frequency of writes into the trajectory file. (default\nvalue = 0)\ntraj_title: Title of the trajectory - not the name of the trajectory\nfile.\natom_info: 1 means print only atomic positions + charge (default = 0)\natom_forces: 1 adds net forces to atom lines in the trajectory file\n(default = 0)\natom_velocities: 1 adds atomic velocities to atoms line (default = 0)\nbond_info: 1 prints bonds in the trajectory file (default = 0)\nangle_info: 1 prints angles in the trajectory file (default = 0)\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nmix, shift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style reax/c cfile keyword value",
    "parameters": " * cfile = NULL or name of a control file\n * zero or more keyword/value pairs may be appended\n * keyword = checkqeq or lgvdw or safezone or mincap\n *   checkqeq value = yes or no = whether or not to require qeq/reax fix\n *   enobonds value = yes or no = whether or not to tally energy of atoms with no bonds\n *   lgvdw value = yes or no = whether or not to use a low gradient vdW correction\n *   safezone = factor used for array allocation\n *   mincap = minimum size for array allocation",
    "examples": "pair_style reax/c NULL\npair_style reax/c controlfile checkqeq no\npair_style reax/c NULL lgvdw yes\npair_style reax/c NULL safezone 1.6 mincap 100\npair_coeff * * ffield.reax C H O N",
    "restrictions": "This pair style is part of the USER-REAXC package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThe ReaxFF potential files provided with LAMMPS in the potentials\ndirectory are parameterized for real units.  You can use\nthe ReaxFF potential with any LAMMPS units, but you would need to\ncreate your own potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “real” units."
},
{
    "command": "pair_style resquared",
    "html_filename": "pair_resquared.html",
    "short_description": "Style resquared computes the RE-squared anisotropic interaction (Everaers), (Babadi) between pairs of ellipsoidal and/or spherical Lennard-Jones particles",
    "description": "Style resquared computes the RE-squared anisotropic interaction\n(Everaers), (Babadi) between pairs of\nellipsoidal and/or spherical Lennard-Jones particles.  For ellipsoidal\ninteractions, the potential considers the ellipsoid as being comprised\nof small spheres of size \\(\\sigma\\).  LJ particles are a single sphere of\nsize \\(\\sigma\\).  The distinction is made to allow the pair style to make\nefficient calculations of ellipsoid/solvent interactions.\nDetails for the equations used are given in the references below and\nin this supplementary document.\nUse of this pair style requires the NVE, NVT, or NPT fixes with the\nasphere extension (e.g. fix nve/asphere) in\norder to integrate particle rotation.  Additionally, atom_style ellipsoid should be used since it defines the\nrotational state and the size and shape of each ellipsoidal particle.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\nA12 = Energy Prefactor/Hamaker constant (energy units)\n\\(\\sigma\\) = atomic interaction diameter (distance units)\n\\(\\epsilon_{i,a}\\) = relative well depth of type I for side-to-side interactions\n\\(\\epsilon_{i,b}\\) = relative well depth of type I for face-to-face interactions\n\\(\\epsilon_{i,c}\\) = relative well depth of type I for end-to-end interactions\n\\(\\epsilon_{j,a}\\) = relative well depth of type J for side-to-side interactions\n\\(\\epsilon_{j,b}\\) = relative well depth of type J for face-to-face interactions\n\\(\\epsilon_{j,c}\\) = relative well depth of type J for end-to-end interactions\ncutoff (distance units)\n\nThe parameters used depend on the type of the interacting particles,\ni.e. ellipsoids or LJ spheres.  The type of a particle is determined\nby the diameters specified for its 3 shape parameters.  If all 3 shape\nparameters = 0.0, then the particle is treated as an LJ sphere.  The\n\\(\\epsilon_{i,*}\\) or \\(\\epsilon_{j,*}\\) parameters are ignored\nfor LJ spheres.  If\nthe 3 shape parameters are > 0.0, then the particle is treated as an\nellipsoid (even if the 3 parameters are equal to each other).\nA12 specifies the energy prefactor which depends on the types of the\ntwo interacting particles.\nFor ellipsoid/ellipsoid interactions, the interaction is computed by\nthe formulas in the supplementary document referenced above.  A12 is\nthe Hamaker constant as described in (Everaers). In LJ\nunits:\n\n\\[A_{12} = 4\\pi^2\\epsilon_{\\mathrm{LJ}}(\\rho\\sigma^3)^2\\]\nwhere \\(\\rho\\) gives the number density of the spherical particles\ncomposing the ellipsoids and \\(\\epsilon_{\\mathrm{LJ}}\\) determines\nthe interaction strength of the spherical particles.\nFor ellipsoid/LJ sphere interactions, the interaction is also computed\nby the formulas in the supplementary document referenced above.  A12\nhas a modified form (see here for\ndetails):\n\n\\[A_{12} = 4\\pi^2\\epsilon_{\\mathrm{LJ}}(\\rho\\sigma^3)\\]\nFor ellipsoid/LJ sphere interactions, a correction to the distance-\nof-closest approach equation has been implemented to reduce the error\nfrom two particles of disparate sizes; see this supplementary document.\nFor LJ sphere/LJ sphere interactions, the interaction is computed\nusing the standard Lennard-Jones formula, which is much cheaper to\ncompute than the ellipsoidal formulas.  A12 is used as epsilon in the\nstandard LJ formula:\n\n\\[A_{12} = \\epsilon_{\\mathrm{LJ}}\\]\nand the specified \\(\\sigma\\) is used as the \\(\\sigma\\) in the\nstandard LJ formula.\nWhen one of both of the interacting particles are ellipsoids, then\n\\(\\sigma\\) specifies the diameter of the continuous distribution of\nconstituent particles within each ellipsoid used to model the RE-squared\npotential.  Note that this is a different meaning for \\(\\sigma\\)\nthan the pair_style gayberne potential uses.\nThe \\(\\epsilon_i\\) and \\(\\epsilon_j\\) coefficients are defined\nfor atom types, not for pairs of atom types.  Thus, in a series of\npair_coeff commands, they only need to be specified once for each atom\ntype.\nSpecifically, if any of \\(\\epsilon_{i,a}\\), \\(\\epsilon_{i,b}\\),\n\\(\\epsilon_{i,c}\\) are non-zero, the three values are assigned to\natom type I.  If all the \\(\\epsilon_i\\) values are zero, they are\nignored.  If any of \\(\\epsilon_{j,a}\\), \\(\\epsilon_{j,b}\\),\n\\(\\epsilon_{j,c}\\) are non-zero, the three values are assigned to\natom type J.  If all three \\(\\epsilon_i\\) values are zero, they are\nignored.  Thus the typical way to define the \\(\\epsilon_i\\) and\n\\(\\epsilon_j\\) coefficients is to list their values in “pair_coeff\nI J” commands when I = J, but set them to 0.0 when I != J.  If you do\nlist them when I != J, you should insure they are consistent with their\nvalues in other pair_coeff commands.\nNote that if this potential is being used as a sub-style of\npair_style hybrid, and there is no “pair_coeff I I”\nsetting made for RE-squared for a particular type I (because I-I\ninteractions are computed by another hybrid pair potential), then you\nstill need to insure the epsilon a,b,c coefficients are assigned to\nthat type in a “pair_coeff I J” command.\nFor large uniform molecules it has been shown that the epsilon_*_*\nenergy parameters are approximately representable in terms of local\ncontact curvatures (Everaers):\n\n\\[\\epsilon_a = \\sigma \\cdot { \\frac{a}{ b \\cdot c } }; \\epsilon_b =\n\\sigma \\cdot { \\frac{b}{ a \\cdot c } }; \\epsilon_c = \\sigma \\cdot {\n\\frac{c}{ a \\cdot b } }\\]\nwhere a, b, and c give the particle diameters.\nThe last coefficient is optional.  If not specified, the global cutoff\nspecified in the pair_style command is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance can be mixed, but only for sphere pairs.  The\ndefault mix value is geometric.  See the “pair_modify” command for\ndetails.  Other type pairs cannot be mixed, due to the different\nmeanings of the energy prefactors used to calculate the interactions\nand the implicit dependence of the ellipsoid-sphere interaction on the\nequation for the Hamaker constant presented here.  Mixing of sigma and\nepsilon followed by calculation of the energy prefactors using the\nequations above is recommended.\nThis pair styles supports the pair_modify shift\noption for the energy of the Lennard-Jones portion of the pair\ninteraction, but only for sphere-sphere interactions.  There is no\nshifting performed for ellipsoidal interactions due to the anisotropic\ndependence of the interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords of the run_style command.",
    "syntax": "pair_style resquared cutoff",
    "parameters": " * cutoff = global cutoff for interactions (distance units)",
    "examples": "pair_style resquared 10.0\npair_coeff * * 1.0 1.0 1.7 3.4 3.4 1.0 1.0 1.0",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires that atoms be ellipsoids as defined by the\natom_style ellipsoid command.\nParticles acted on by the potential can be finite-size aspherical or\nspherical particles, or point particles.  Spherical particles have all\n3 of their shape parameters equal to each other.  Point particles have\nall 3 of their shape parameters equal to 0.0.\nThe distance-of-closest-approach approximation used by LAMMPS becomes\nless accurate when high-aspect ratio ellipsoids are used."
},
{
    "command": "pair_style lj/sdk",
    "html_filename": "pair_sdk.html",
    "short_description": "The lj/sdk styles compute a 9/6, 12/4, or 12/6 Lennard-Jones potential, given by  \\[\\begin{split}E = & \\frac{27}{4} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} -                       \\left(\\frac{\\sigma}{r}\\right)^6 \\right]                       \\qquad r < r_c \\\\ E = & \\frac{3\\sqrt{3}}{2} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -                       \\left(\\frac{\\sigma}{r}\\right)^4 \\right]                       \\qquad r < r_c \\\\ E = &  4 \\epsilon  \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -                       \\left(\\frac{\\sigma}{r}\\right)^6 \\right]                       \\qquad r < r_c\\end{split}\\] as required for the SDK Coarse-grained MD parameterization discussed in (Shinoda) and (DeVane)",
    "description": "The lj/sdk styles compute a 9/6, 12/4, or 12/6 Lennard-Jones potential,\ngiven by\n\n\\[\\begin{split}E = & \\frac{27}{4} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c \\\\\nE = & \\frac{3\\sqrt{3}}{2} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^4 \\right]\n                      \\qquad r < r_c \\\\\nE = &  4 \\epsilon  \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c\\end{split}\\]\nas required for the SDK Coarse-grained MD parameterization discussed in\n(Shinoda) and (DeVane).  Rc is the cutoff.\nStyle lj/sdk/coul/long computes the adds Coulombic interactions\nwith an additional damping factor applied so it can be used in\nconjunction with the kspace_style command and\nits ewald or pppm or pppm/cg option.  The Coulombic cutoff\nspecified for this style means that pairwise interactions within\nthis distance are computed directly; interactions outside that\ndistance are computed in reciprocal space.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncg_type (lj9_6, lj12_4, or lj12_6)\nepsilon (energy units)\nsigma (distance units)\ncutoff1 (distance units)\n\nNote that sigma is defined in the LJ formula as the zero-crossing\ndistance for the potential, not as the energy minimum. The prefactors\nare chosen so that the potential minimum is at -epsilon.\nThe latter 2 coefficients are optional.  If not specified, the global\nLJ and Coulombic cutoffs specified in the pair_style command are used.\nIf only one cutoff is specified, it is used as the cutoff for both LJ\nand Coulombic interactions for this type pair.  If both coefficients\nare specified, they are used as the LJ and Coulombic cutoffs for this\ntype pair.\nFor lj/sdk/coul/long and lj/sdk/coul/msm only the LJ cutoff can be\nspecified since a Coulombic cutoff cannot be specified for an\nindividual I,J type pair.  All type pairs use the same global\nCoulombic cutoff specified in the pair_style command.\n\nStyles with a gpu, intel, kk, omp or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP, and OPT packages respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, and rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of the lj/sdk pair styles cannot be mixed,\nsince different pairs may have different exponents. So all parameters\nfor all pairs have to be specified explicitly through the “pair_coeff”\ncommand. Defining then in a data file is also not supported, due to\nlimitations of that file format.\nAll of the lj/sdk pair styles support the\npair_modify shift option for the energy of the\nLennard-Jones portion of the pair interaction.\nThe lj/sdk/coul/long pair styles support the\npair_modify table option since they can tabulate\nthe short-range portion of the long-range Coulombic interaction.\nAll of the lj/sdk pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\nnot need to be specified in an input script that reads a restart file.\nThe lj/sdk and lj/cut/coul/long pair styles do not support\nthe use of the inner, middle, and outer keywords of the run_style respa command.",
    "syntax": "pair_style style args",
    "parameters": " * style = lj/sdk or lj/sdk/coul/long\n * args = list of arguments for a particular style\n * lj/sdk args = cutoff\n *   cutoff = global cutoff for Lennard Jones interactions (distance units)\n * lj/sdk/coul/long args = cutoff (cutoff2)\n *   cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Coulombic (optional) (distance units)",
    "examples": "pair_style lj/sdk 2.5\npair_coeff 1 1 lj12_6 1 1.1 2.8\n\npair_style lj/sdk/coul/long 10.0\npair_style lj/sdk/coul/long 10.0 12.0\npair_coeff 1 1 lj9_6 100.0 3.5 12.0\n\npair_style lj/sdk/coul/msm 10.0\npair_style lj/sdk/coul/msm 10.0 12.0\npair_coeff 1 1 lj9_6 100.0 3.5 12.0",
    "restrictions": "All of the lj/sdk pair styles are part of the USER-CGSDK package.  The\nlj/sdk/coul/long style also requires the KSPACE package to be built\n(which is enabled by default).  They are only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info."
},
{
    "command": "pair_style sdpd/taitwater/isothermal",
    "html_filename": "pair_sdpd_taitwater_isothermal.html",
    "short_description": "The sdpd/taitwater/isothermal style computes forces between mesoscopic particles according to the Smoothed Dissipative Particle Dynamics model described in this paper by (Espanol and Revenga) under the following assumptions:  The temperature is constant and uniform",
    "description": "The sdpd/taitwater/isothermal style computes forces between mesoscopic\nparticles according to the Smoothed Dissipative Particle Dynamics model\ndescribed in this paper by (Espanol and Revenga) under\nthe following assumptions:\n\nThe temperature is constant and uniform.\nThe shear viscosity is constant and uniform.\nThe volume viscosity is negligible before the shear viscosity.\nThe Boltzmann constant is negligible before the heat capacity of a\nsingle mesoscopic particle of fluid.\n\nThe third assumption is true for water in nearly incompressible flows.\nThe fourth holds true for water for any reasonable size one can\nimagine for a mesoscopic particle.\nThe pressure forces between particles will be computed according to\nTait’s equation of state:\n\n\\[p = B \\left[(\\frac{\\rho}{\\rho_0})^{\\gamma} - 1\\right]\\]\nwhere \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n\\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\nspeed of sound.\nThe laminar viscosity and the random forces will be computed according\nto formulas described in (Espanol and Revenga).\n\nWarning\nSimilar to brownian and\ndpd styles, the newton setting for\npairwise interactions needs to be on when running LAMMPS in parallel\nif you want to ensure linear momentum conservation. Otherwise random\nforces generated for pairs straddling processor boundary will not be\nequal and opposite.\n\n\nNote\nThe actual random seed used will be a mix of what you specify\nand other parameters like the MPI ranks. This is to ensure that\ndifferent MPI tasks have distinct seeds.\n\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\n\\(\\rho_0\\) reference density (mass/volume units)\n\\(c_0\\) reference soundspeed (distance/time units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sdpd/taitwater/isothermal temperature viscosity seed",
    "parameters": " * temperature = temperature of the fluid (temperature units)\n * viscosity = dynamic viscosity of the fluid (mass*distance/time units)\n * seed = random number generator seed (positive integer, optional)",
    "examples": "pair_style sdpd/taitwater/isothermal 300. 1. 28681\npair_coeff * * 1000.0 1430.0 2.4",
    "restrictions": "This pair style is part of the USER-SDPD package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style smd/hertz",
    "html_filename": "pair_smd_hertz.html",
    "short_description": "The smd/hertz style calculates contact forces between SPH particles belonging to different physical bodies",
    "description": "The smd/hertz style calculates contact forces between SPH particles\nbelonging to different physical bodies.\nThe contact forces are calculated using a Hertz potential, which\nevaluates the overlap between two particles (whose spatial extents are\ndefined via its contact radius).  The effect is that a particles\ncannot penetrate into each other.  The parameter <contact_stiffness>\nhas units of pressure and should equal roughly one half of the Young’s\nmodulus (or bulk modulus in the case of fluids) of the material model\nassociated with the SPH particles.\nThe parameter scale_factor can be used to scale the particles’\ncontact radii. This can be useful to control how close particles can\napproach each other. Usually, scale_factor =1.0.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nNo mixing is performed automatically.  Currently, no part of USER-SMD\nsupports restarting nor minimization.  rRESPA does not apply to this\npair style.",
    "syntax": "pair_style smd/hertz scale_factor",
    "parameters": " * ",
    "examples": "pair_style smd/hertz 1.0\npair_coeff 1 1 <contact_stiffness>",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style smd/tlsph",
    "html_filename": "pair_smd_tlsph.html",
    "short_description": "The smd/tlsph style computes particle interactions according to continuum mechanics constitutive laws and a Total-Lagrangian Smooth-Particle Hydrodynamics algorithm",
    "description": "The smd/tlsph style computes particle interactions according to\ncontinuum mechanics constitutive laws and a Total-Lagrangian\nSmooth-Particle Hydrodynamics algorithm.\nThis pair style is invoked with the following command:\npair_style smd/tlsph\npair_coeff i j *COMMON rho0 E nu Q1 Q2 hg Cp &\n               *END\n\n\nHere, i and j denote the LAMMPS particle types for which this\npair style is defined. Note that i and j must be equal, i.e., no\ntlsph cross interactions between different particle types are\nallowed.  In contrast to the usual LAMMPS pair coeff definitions,\nwhich are given solely a number of floats and integers, the tlsph\npair coeff definition is organized using keywords. These keywords\nmark the beginning of different sets of parameters for particle\nproperties, material constitutive models, and damage models. The pair\ncoeff line must be terminated with the *END keyword. The use the\nline continuation operator & is recommended. A typical invocation of\nthe tlsph for a solid body would consist of an equation of state for\ncomputing the pressure (the diagonal components of the stress tensor),\nand a material model to compute shear stresses (the off-diagonal\ncomponents of the stress tensor). Damage and failure models can also\nbe added.\nPlease see the SMD user guide for a\ncomplete listing of the possible keywords and material models.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nNo mixing is performed automatically.  Currently, no part of USER-SMD\nsupports restarting nor minimization.  rRESPA does not apply to this\npair style.",
    "syntax": "pair_style smd/tlsph args",
    "parameters": " * ",
    "examples": "pair_style smd/tlsph",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style smd/tri_surface",
    "html_filename": "pair_smd_triangulated_surface.html",
    "short_description": "The smd/tri_surface style calculates contact forces between SPH particles and a rigid wall boundary defined via the smd/wall_surface fix",
    "description": "The smd/tri_surface style calculates contact forces between SPH\nparticles and a rigid wall boundary defined via the\nsmd/wall_surface fix.\nThe contact forces are calculated using a Hertz potential, which\nevaluates the overlap between a particle (whose spatial extents are\ndefined via its contact radius) and the triangle.  The effect is that\na particle cannot penetrate into the triangular surface.  The\nparameter <contact_stiffness> has units of pressure and should equal\nroughly one half of the Young’s modulus (or bulk modulus in the case\nof fluids) of the material model associated with the SPH particle\nThe parameter scale_factor can be used to scale the particles’\ncontact radii. This can be useful to control how close particles can\napproach the triangulated surface. Usually, scale_factor =1.0.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nNo mixing is performed automatically.\nCurrently, no part of USER-SMD supports restarting nor minimization.\nrRESPA does not apply to this pair style.",
    "syntax": "pair_style smd/tri_surface scale_factor",
    "parameters": " * ",
    "examples": "pair_style smd/tri_surface 1.0\npair_coeff 1 1 <contact_stiffness>",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style smd/ulsph",
    "html_filename": "pair_smd_ulsph.html",
    "short_description": "The smd/ulsph style computes particle interactions according to continuum mechanics constitutive laws and an updated Lagrangian Smooth-Particle Hydrodynamics algorithm",
    "description": "The smd/ulsph style computes particle interactions according to\ncontinuum mechanics constitutive laws and an updated Lagrangian\nSmooth-Particle Hydrodynamics algorithm.\nThis pair style is invoked similar to the following command:\npair_style smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION\npair_coeff i j *COMMON rho0 c0 Q1 Cp hg &\n               *END\n\n\nHere, i and j denote the LAMMPS particle types for which this\npair style is defined. Note that i and j can be different, i.e.,\nulsph cross interactions between different particle types are\nallowed. However, i–i respectively j–j pair_coeff lines have\nto precede a cross interaction.  In contrast to the usual LAMMPS\npair coeff definitions, which are given solely a number of floats\nand integers, the ulsph pair coeff definition is organized using\nkeywords. These keywords mark the beginning of different sets of\nparameters for particle properties, material constitutive models, and\ndamage models. The pair coeff line must be terminated with the\n*END keyword. The use the line continuation operator & is\nrecommended. A typical invocation of the ulsph for a solid body\nwould consist of an equation of state for computing the pressure (the\ndiagonal components of the stress tensor), and a material model to\ncompute shear stresses (the off-diagonal components of the stress\ntensor).\nNote that the use of *GRADIENT_CORRECTION can lead to severe numerical\ninstabilities. For a general fluid simulation, *NO_GRADIENT_CORRECTION\nis recommended.\nPlease see the SMD user guide for a\ncomplete listing of the possible keywords and material models.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nNo mixing is performed automatically.  Currently, no part of USER-SMD\nsupports restarting nor minimization.  rRESPA does not apply to this\npair style.",
    "syntax": "pair_style smd/ulsph args",
    "parameters": " * these keywords must be given\n * keyword = *DENSITY_SUMMATION or *DENSITY_CONTINUITY and *VELOCITY_GRADIENT or *NO_VELOCITY_GRADIENT and *GRADIENT_CORRECTION or *NO_GRADIENT_CORRECTION",
    "examples": "pair_style smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style snap",
    "html_filename": "pair_snap.html",
    "short_description": "Pair style snap computes interactions using the spectral neighbor analysis potential (SNAP) (Thompson)",
    "description": "Pair style snap computes interactions using the spectral\nneighbor analysis potential (SNAP) (Thompson).\nLike the GAP framework of Bartok et al. (Bartok2010),\n(Bartok2013) which uses bispectrum components\nto characterize the local neighborhood of each atom\nin a very general way. The mathematical definition of the\nbispectrum calculation used by SNAP is identical\nto that used by compute sna/atom.\nIn SNAP, the total energy is decomposed into a sum over\natom energies. The energy of atom i is\nexpressed as a weighted sum over bispectrum components.\n\n\\[E^i_{SNAP}(B_1^i,...,B_K^i) = \\beta^{\\alpha_i}_0 + \\sum_{k=1}^K \\beta_k^{\\alpha_i} B_k^i\\]\nwhere \\(B_k^i\\) is the k-th bispectrum component of atom i,\nand \\(\\beta_k^{\\alpha_i}\\) is the corresponding linear coefficient\nthat depends on :math:alpha_i`, the SNAP element of atom i. The\nnumber of bispectrum components used and their definitions\ndepend on the value of twojmax\ndefined in the SNAP parameter file described below.\nThe bispectrum calculation is described in more detail\nin compute sna/atom.\nNote that unlike for other potentials, cutoffs for SNAP potentials are\nnot set in the pair_style or pair_coeff command; they are specified in\nthe SNAP potential files themselves.\nOnly a single pair_coeff command is used with the snap style which\nspecifies a SNAP coefficient file followed by a SNAP parameter file\nand then N additional arguments specifying the mapping of SNAP\nelements to LAMMPS atom types, where N is the number of\nLAMMPS atom types:\n\nSNAP coefficient file\nSNAP parameter file\nN element names = mapping of SNAP elements to atom types\n\nAs an example, if a LAMMPS indium phosphide simulation has 4 atoms\ntypes, with the first two being indium and the 3rd and 4th being\nphophorous, the pair_coeff command would look like this:\npair_coeff * * snap InP.snapcoeff InP.snapparam In In P P\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe two filenames are for the coefficient and parameter files, respectively.\nThe two trailing ‘In’ arguments map LAMMPS atom types 1 and 2 to the\nSNAP ‘In’ element. The two trailing ‘P’ arguments map LAMMPS atom types\n3 and 4 to the SNAP ‘P’ element.\nIf a SNAP mapping value is\nspecified as NULL, the mapping is not performed.\nThis can be used when a snap potential is used as part of the\nhybrid pair style.  The NULL values are placeholders for atom types\nthat will be used with other potentials.\nThe name of the SNAP coefficient file usually ends in the\n“.snapcoeff” extension. It may contain coefficients\nfor many SNAP elements. The only requirement is that it\ncontain at least those element names appearing in the\nLAMMPS mapping list.\nThe name of the SNAP parameter file usually ends in the “.snapparam”\nextension. It contains a small number\nof parameters that define the overall form of the SNAP potential.\nSee the pair_coeff doc page for alternate ways\nto specify the path for these files.\nQuite commonly,\nSNAP potentials are combined with one or more other LAMMPS pair styles\nusing the hybrid/overlay pair style. As an example, the SNAP\ntantalum potential provided in the LAMMPS potentials directory\ncombines the snap and zbl pair styles. It is invoked\nby the following commands:\nvariable zblcutinner equal 4\nvariable zblcutouter equal 4.8\nvariable zblz equal 73\npair_style hybrid/overlay &\nzbl ${zblcutinner} ${zblcutouter} snap\npair_coeff * * zbl 0.0\npair_coeff 1 1 zbl ${zblz}\npair_coeff * * snap Ta06A.snapcoeff Ta06A.snapparam Ta\n\n\nIt is convenient to keep these commands in a separate file that can\nbe inserted in any LAMMPS input script using the include\ncommand.\nThe top of the SNAP coefficient file can contain any number of blank and comment lines (start with #), but follows a strict\nformat after that. The first non-blank non-comment\nline must contain two integers:\n\nnelem  = Number of elements\nncoeff = Number of coefficients\n\nThis is followed by one block for each of the nelem elements.\nThe first line of each block contains three entries:\n\nElement symbol (text string)\nR = Element radius (distance units)\nw = Element weight (dimensionless)\n\nThis line is followed by ncoeff coefficients, one per line.\nThe SNAP parameter file can contain blank and comment lines (start\nwith #) anywhere. Each non-blank non-comment line must contain one\nkeyword/value pair. The required keywords are rcutfac and\ntwojmax. Optional keywords are rfac0, rmin0,\nswitchflag, bzeroflag, and chunksize.\nThe default values for these keywords are\n\nrfac0 = 0.99363\nrmin0 = 0.0\nswitchflag = 0\nbzeroflag = 1\nquadraticflag = 1\nchunksize = 2000\n\nThe keyword chunksize is only applicable when using the\npair style snap with the KOKKOS package and is ignored otherwise.\nThis keyword controls\nthe number of atoms in each pass used to compute the bispectrum\ncomponents and is used to avoid running out of memory. For example\nif there are 4000 atoms in the simulation and the chunksize\nis set to 2000, the bispectrum calculation will be broken up\ninto two passes.\nDetailed definitions for all the other keywords\nare given on the compute sna/atom doc page.\nIf quadraticflag is set to 1, then the SNAP energy expression includes the quadratic term, 0.5*B^t.alpha.B, where alpha is a symmetric K by K matrix.\nThe SNAP element file should contain K(K+1)/2 additional coefficients\nfor each element, the upper-triangular elements of alpha.\n\nNote\nThe previously used diagonalstyle keyword was removed in 2019,\nsince all known SNAP potentials use the default value of 3.\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS with\nuser-specifiable parameters as described above.  You never need to\nspecify a pair_coeff command with I != J arguments for this style.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style snap",
    "parameters": " * ",
    "examples": "pair_style snap\npair_coeff * * InP.snapcoeff InP.snapparam In In P P",
    "restrictions": "This style is part of the SNAP package.  It is only enabled if LAMMPS\nwas built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style soft",
    "html_filename": "pair_soft.html",
    "short_description": "Style soft computes pairwise interactions with the formula  \\[E = A \\left[ 1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right) \\right] \\qquad r < r_c\\] It is useful for pushing apart overlapping atoms, since it does not blow up as r goes to 0",
    "description": "Style soft computes pairwise interactions with the formula\n\n\\[E = A \\left[ 1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right) \\right]\n\\qquad r < r_c\\]\nIt is useful for pushing apart overlapping atoms, since it does not\nblow up as r goes to 0.  A is a pre-factor that can be made to vary in\ntime from the start to the end of the run (see discussion below),\ne.g. to start with a very soft potential and slowly harden the\ninteractions over time.  Rc is the cutoff.  See the fix nve/limit command for another way to push apart\noverlapping atoms.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nA (energy units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global soft\ncutoff is used.\n\nNote\nThe syntax for pair_coeff with a single A\ncoeff is different in the current version of LAMMPS than in older\nversions which took two values, Astart and Astop, to ramp between\nthem.  This functionality is now available in a more general form\nthrough the fix adapt command, as explained below.\nNote that if you use an old input script and specify Astart and Astop\nwithout a cutoff, then LAMMPS will interpret that as A and a cutoff,\nwhich is probably not what you want.\n\nThe fix adapt command can be used to vary A for one\nor more pair types over the course of a simulation, in which case\npair_coeff settings for A must still be specified, but will be\noverridden.  For example these commands will vary the prefactor A for\nall pairwise interactions from 0.0 at the beginning to 30.0 at the end\nof a run:\nvariable prefactor equal ramp(0,30)\nfix 1 all adapt 1 pair soft a * * v_prefactor\n\n\nNote that a formula defined by an equal-style variable\ncan use the current timestep, elapsed time in the current run, elapsed\ntime since the beginning of a series of runs, as well as access other\nvariables.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A coefficient and cutoff\ndistance for this pair style can be mixed.  A is always mixed via a\ngeometric rule.  The cutoff is mixed according to the pair_modify\nmix value.  The default mix value is geometric.  See the\n“pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift option, since the pair interaction goes to 0.0 at the cutoff.\nThe pair_modify table and tail options are not\nrelevant for this pair style.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style soft cutoff",
    "parameters": " * cutoff = global cutoff for soft interactions (distance units)",
    "examples": "pair_style soft 1.0\npair_coeff * * 10.0\npair_coeff 1 1 10.0 3.0\n\npair_style soft 1.0\npair_coeff * * 0.0\nvariable prefactor equal ramp(0,30)\nfix 1 all adapt 1 pair soft a * * v_prefactor",
    "restrictions": "\nnone"
},
{
    "command": "pair_style sph/heatconduction",
    "html_filename": "pair_sph_heatconduction.html",
    "short_description": "The sph/heatconduction style computes heat transport between SPH particles",
    "description": "The sph/heatconduction style computes heat transport between SPH particles.\nThe transport model is the diffusion equation for the internal energy.\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nD diffusion coefficient (length^2/time units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/heatconduction",
    "parameters": " * ",
    "examples": "pair_style sph/heatconduction\npair_coeff * * 1.0 2.4",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style sph/idealgas",
    "html_filename": "pair_sph_idealgas.html",
    "short_description": "The sph/idealgas style computes pressure forces between particles according to the ideal gas equation of state:  \\[p = (\\gamma - 1) \\rho e\\] where \\(\\gamma = 1",
    "description": "The sph/idealgas style computes pressure forces between particles\naccording to the ideal gas equation of state:\n\n\\[p = (\\gamma - 1) \\rho e\\]\nwhere \\(\\gamma = 1.4\\) is the heat capacity ratio, \\(\\rho\\) is\nthe local density, and e is the internal energy per unit mass.  This\npair style also computes Monaghan’s artificial viscosity to prevent\nparticles from interpenetrating (Monaghan).\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\n\\(\\nu\\) artificial viscosity (no units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/idealgas",
    "parameters": " * ",
    "examples": "pair_style sph/idealgas\npair_coeff * * 1.0 2.4",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style sph/lj",
    "html_filename": "pair_sph_lj.html",
    "short_description": "The sph/lj style computes pressure forces between particles according to the Lennard-Jones equation of state, which is computed according to Ree’s 1980 polynomial fit (Ree)",
    "description": "The sph/lj style computes pressure forces between particles according\nto the Lennard-Jones equation of state, which is computed according to\nRee’s 1980 polynomial fit (Ree). The Lennard-Jones parameters\nepsilon and sigma are set to unity.  This pair style also computes\nMonaghan’s artificial viscosity to prevent particles from\ninterpenetrating (Monaghan).\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\n\\(\\nu\\) artificial viscosity (no units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/lj",
    "parameters": " * ",
    "examples": "pair_style sph/lj\npair_coeff * * 1.0 2.4",
    "restrictions": "As noted above, the Lennard-Jones parameters epsilon and sigma are set\nto unity.\nThis pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style sph/rhosum",
    "html_filename": "pair_sph_rhosum.html",
    "short_description": "The sph/rhosum style computes the local particle mass density rho for SPH particles by kernel function interpolation, every Nstep timesteps",
    "description": "The sph/rhosum style computes the local particle mass density rho for\nSPH particles by kernel function interpolation, every Nstep timesteps.\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nh (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/rhosum Nstep",
    "parameters": " * Nstep = timestep interval",
    "examples": "pair_style sph/rhosum 10\npair_coeff * * 2.4",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style sph/taitwater",
    "html_filename": "pair_sph_taitwater.html",
    "short_description": "The sph/taitwater style computes pressure forces between SPH particles according to Tait’s equation of state:  \\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\] where \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with \\(\\rho_0\\) being the reference density and \\(c_0\\) the reference speed of sound",
    "description": "The sph/taitwater style computes pressure forces between SPH particles\naccording to Tait’s equation of state:\n\n\\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\]\nwhere \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n\\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\nspeed of sound.\nThis pair style also computes Monaghan’s artificial viscosity to\nprevent particles from interpenetrating (Monaghan).\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\n\\(\\rho_0\\) reference density (mass/volume units)\n\\(c_0\\) reference soundspeed (distance/time units)\n\\(\\nu\\) artificial viscosity (no units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/taitwater",
    "parameters": " * ",
    "examples": "pair_style sph/taitwater\npair_coeff * * 1000.0 1430.0 1.0 2.4",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style sph/taitwater/morris",
    "html_filename": "pair_sph_taitwater_morris.html",
    "short_description": "The sph/taitwater/morris style computes pressure forces between SPH particles according to Tait’s equation of state:  \\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\] where \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with \\(\\rho_0\\) being the reference density and \\(c_0\\) the reference speed of sound",
    "description": "The sph/taitwater/morris style computes pressure forces between SPH\nparticles according to Tait’s equation of state:\n\n\\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\]\nwhere \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n\\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\nspeed of sound.\nThis pair style also computes laminar viscosity (Morris).\nSee this PDF guide to using SPH in\nLAMMPS.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\n\\(\\rho_0\\) reference density (mass/volume units)\n\\(c_0\\) reference soundspeed (distance/time units)\n\\(\\nu\\) dynamic viscosity (mass*distance/time units)\nh kernel function cutoff (distance units)\n\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThis style does not support the pair_modify\nshift, table, and tail options.\nThis style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\npair_coeff commands in an input script that reads a restart file.\nThis style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\nmiddle, outer keywords.",
    "syntax": "pair_style sph/taitwater/morris",
    "parameters": " * ",
    "examples": "pair_style sph/taitwater/morris\npair_coeff * * 1000.0 1430.0 1.0 2.4",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style spin/dipole/cut",
    "html_filename": "pair_spin_dipole.html",
    "short_description": "Style spin/dipole/cut computes a short-range dipole-dipole interaction between pairs of magnetic particles that each have a magnetic spin",
    "description": "Style spin/dipole/cut computes a short-range dipole-dipole\ninteraction between pairs of magnetic particles that each\nhave a magnetic spin.\nThe magnetic dipole-dipole interactions are computed by the\nfollowing formulas for the magnetic energy, magnetic precession\nvector omega and mechanical force between particles I and J.\n\n\\[\\begin{split}\\mathcal{H}_{\\rm long} & =\n-\\frac{\\mu_{0} \\left( \\mu_B\\right)^2}{4\\pi}\n\\sum_{i,j,i\\neq j}^{N}\n \\frac{g_i g_j}{r_{ij}^3}\n \\biggl(3\n \\left(\\vec{e}_{ij}\\cdot \\vec{s}_{i}\\right)\n \\left(\\vec{e}_{ij}\\cdot \\vec{s}_{j}\\right)\n -\\vec{s}_i\\cdot\\vec{s}_j \\biggr) \\\\\n \\mathbf{\\omega}_i & =\n \\frac{\\mu_0 (\\mu_B)^2}{4\\pi\\hbar}\\sum_{j}\n \\frac{g_i g_j}{r_{ij}^3}\n \\, \\biggl(\n 3\\,(\\vec{e}_{ij}\\cdot\\vec{s}_{j})\\vec{e}_{ij}\n -\\vec{s}_{j} \\biggr) \\\\\n \\mathbf{F}_i & =\n \\frac{3\\, \\mu_0 (\\mu_B)^2}{4\\pi} \\sum_j\n \\frac{g_i g_j}{r_{ij}^4}\n \\biggl[\\bigl( (\\vec{s}_i\\cdot\\vec{s}_j)\n -5(\\vec{e}_{ij}\\cdot\\vec{s}_i)\n (\\vec{e}_{ij}\\cdot\\vec{s}_j)\\bigr) \\vec{e}_{ij}+\n \\bigl(\n (\\vec{e}_{ij}\\cdot\\vec{s}_i)\\vec{s}_j+\n (\\vec{e}_{ij}\\cdot\\vec{s}_j)\\vec{s}_i\n \\bigr)\n \\biggr]\\end{split}\\]\nwhere \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are the spin on two magnetic\nparticles, r is their separation distance, and the vector \\(\\vec{e}_{ij}\n= \\frac{r_i - r_j}{\\left| r_i - r_j \\right|}\\) is the direction vector\nbetween the two particles.\nStyle spin/dipole/long computes long-range magnetic dipole-dipole\ninteraction.\nA kspace_style must be defined to\nuse this pair style.  Currently, kspace_style ewald/dipole/spin and kspace_style pppm/dipole/spin support long-range magnetic\ndipole-dipole interactions.\n\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.",
    "syntax": "pair_style spin/dipole/cut cutoff",
    "parameters": " * pair_style spin/dipole/long cutoff\n * cutoff = global cutoff for magnetic dipole energy and forces\n * (optional) (distance units)",
    "examples": "pair_style spin/dipole/cut 10.0\npair_coeff * * 10.0\npair_coeff 2 3 8.0\n\npair_style spin/dipole/long 9.0\npair_coeff * * 10.0\npair_coeff 2 3 6.0",
    "restrictions": "The spin/dipole/cut and spin/dipole/long styles are part of\nthe SPIN package.  They are only enabled if LAMMPS was built with that\npackage.  See the Build package doc page for more\ninfo.\nUsing dipole/spin pair styles with electron units is not\ncurrently supported."
},
{
    "command": "pair_style spin/dmi",
    "html_filename": "pair_spin_dmi.html",
    "short_description": "Style spin/dmi computes the Dzyaloshinskii-Moriya (DM) interaction between pairs of magnetic spins",
    "description": "Style spin/dmi computes the Dzyaloshinskii-Moriya (DM) interaction\nbetween pairs of magnetic spins.\nAccording to the expression reported in (Rohart), one has\nthe following DM energy:\n\n\\[\\mathbf{H}_{dm} = \\sum_{{ i,j}=1,i\\neq j}^{N}\n\\left( \\vec{e}_{ij} \\times \\vec{D} \\right)\n\\cdot\\left(\\vec{s}_{i}\\times \\vec{s}_{j}\\right),\\]\nwhere \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are two neighboring magnetic spins of\ntwo particles, \\(\\vec{e}_ij = \\frac{r_i - r_j}{\\left| r_i - r_j \\right|}\\)\nis the unit vector between sites i and j, and \\(\\vec{D}\\) is the\nDM vector defining the intensity (in eV) and the direction of the\ninteraction.\nIn (Rohart), \\(\\vec{D}\\) is defined as the direction normal to the film oriented\nfrom the high spin-orbit layer to the magnetic ultra-thin film.\nThe application of a spin-lattice Poisson bracket to this energy (as described\nin (Tranchida)) allows to derive a magnetic torque omega, and a\nmechanical force F (for spin-lattice calculations only) for each magnetic\nparticle i:\n\n\\[\\vec{\\omega}_i = -\\frac{1}{\\hbar} \\sum_{j}^{Neighb} \\vec{s}_{j}\\times \\left(\\vec{e}_{ij}\\times \\vec{D} \\right)\n~~{\\rm and}~~\n\\vec{F}_i = -\\sum_{j}^{Neighb} \\frac{1}{r_{ij}} \\vec{D} \\times \\left( \\vec{s}_{i}\\times \\vec{s}_{j} \\right)\\]\nMore details about the derivation of these torques/forces are reported in\n(Tranchida).\nFor the spin/dmi pair style, the following coefficients must be defined for\neach pair of atoms types via the pair_coeff command as in\nthe examples above, or in the data file or restart files read by the\nread_data or read_restart commands, and\nset in the following order:\n\nrc (distance units)\n|D| (energy units)\nDx, Dy, Dz  (direction of D)\n\nNote that rc is the radius cutoff of the considered DM interaction, |D| is\nthe norm of the DM vector (in eV), and Dx, Dy and Dz define its direction.\nNone of those coefficients is optional.  If not specified, the spin/dmi\npair style cannot be used.",
    "syntax": "pair_style spin/dmi cutoff",
    "parameters": " * cutoff = global cutoff pair (distance in metal units)",
    "examples": "pair_style spin/dmi 4.0\npair_coeff * * dmi 2.6 0.001 1.0 0.0 0.0\npair_coeff 1 2 dmi 4.0 0.00109 0.0 0.0 1.0",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\nare only enabled if LAMMPS was built with this package, and if the\natom_style “spin” was declared.  See the Build package doc page for more info."
},
{
    "command": "pair_style spin/exchange",
    "html_filename": "pair_spin_exchange.html",
    "short_description": "Style spin/exchange computes the exchange interaction between pairs of magnetic spins:  \\[H_{ex} = -\\sum_{i,j}^N J_{ij} (r_{ij}) \\,\\vec{s}_i \\cdot \\vec{s}_j\\] where \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are two neighboring magnetic spins of two particles, \\(r_{ij} = \\vert \\vec{r}_i - \\vec{r}_j \\vert\\) is the inter-atomic distance between the two particles",
    "description": "Style spin/exchange computes the exchange interaction between\npairs of magnetic spins:\n\n\\[H_{ex} = -\\sum_{i,j}^N J_{ij} (r_{ij}) \\,\\vec{s}_i \\cdot \\vec{s}_j\\]\nwhere \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are two neighboring magnetic spins of two particles,\n\\(r_{ij} = \\vert \\vec{r}_i - \\vec{r}_j \\vert\\) is the inter-atomic distance between the two\nparticles. The summation is over pairs of nearest neighbors.\n\\(J(r_{ij})\\) is a function defining the intensity and the sign of the exchange\ninteraction for different neighboring shells. This function is defined as:\n\n\\[{J}\\left( r_{ij} \\right) = 4 a \\left( \\frac{r_{ij}}{d}  \\right)^2 \\left( 1 - b \\left( \\frac{r_{ij}}{d}  \\right)^2 \\right) e^{-\\left( \\frac{r_{ij}}{d} \\right)^2 }\\Theta (R_c - r_{ij})\\]\nwhere \\(a\\), \\(b\\) and \\(d\\) are the three constant coefficients defined in the associated\n“pair_coeff” command, and \\(R_c\\) is the radius cutoff associated to\nthe pair interaction (see below for more explanations).\nThe coefficients \\(a\\), \\(b\\), and \\(d\\) need to be fitted so that the function above matches with\nthe value of the exchange interaction for the \\(N\\) neighbor shells taken into account.\nExamples and more explanations about this function and its parameterization are reported\nin (Tranchida).\nFrom this exchange interaction, each spin \\(i\\) will be submitted\nto a magnetic torque \\(\\vec{\\omega}\\), and its associated atom can be submitted to a\nforce \\(\\vec{F}\\) for spin-lattice calculations (see fix nve/spin),\nsuch as:\n\n\\[\\vec{\\omega}_{i} = \\frac{1}{\\hbar} \\sum_{j}^{Neighb} {J}\n\\left(r_{ij} \\right)\\,\\vec{s}_{j}\n~~{\\rm and}~~\n\\vec{F}_{i} = \\sum_{j}^{Neighb} \\frac{\\partial {J} \\left(r_{ij} \\right)}{ \\partial r_{ij}} \\left( \\vec{s}_{i}\\cdot \\vec{s}_{j} \\right) \\vec{e}_{ij}\\]\nwith \\(\\hbar\\) the Planck constant (in metal units), and \\(\\vec{e}_{ij} = \\frac{\\vec{r}_i - \\vec{r}_j}{\\vert \\vec{r}_i-\\vec{r}_j \\vert}\\) the unit\nvector between sites \\(i\\) and \\(j\\).\nMore details about the derivation of these torques/forces are reported in\n(Tranchida).\nFor the spin/exchange pair style, the following coefficients must be defined\nfor each pair of atoms types via the pair_coeff command as in\nthe examples above, or in the data file or restart files read by the\nread_data or read_restart commands, and\nset in the following order:\n\n\\(R_c\\) (distance units)\n\\(a\\)  (energy units)\n\\(b\\)  (adim parameter)\n\\(d\\)  (distance units)\n\nNote that \\(R_c\\) is the radius cutoff of the considered exchange interaction,\nand \\(a\\), \\(b\\) and \\(d\\) are the three coefficients performing the parameterization\nof the function \\(J(r_{ij})\\) defined above.\nNone of those coefficients is optional. If not specified, the\nspin/exchange pair style cannot be used.",
    "syntax": "pair_style spin/exchange cutoff",
    "parameters": " * cutoff = global cutoff pair (distance in metal units)",
    "examples": "pair_style spin/exchange 4.0\npair_coeff * * exchange 4.0 0.0446928 0.003496 1.4885\npair_coeff 1 2 exchange 6.0 -0.01575 0.0 1.965",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\nare only enabled if LAMMPS was built with this package, and if the\natom_style “spin” was declared.  See the Build package doc page for more info."
},
{
    "command": "pair_style spin/magelec",
    "html_filename": "pair_spin_magelec.html",
    "short_description": "Style spin/me computes a magneto-electric interaction between pairs of magnetic spins",
    "description": "Style spin/me computes a magneto-electric interaction between\npairs of magnetic spins. According to the derivation reported in\n(Katsura), this interaction is defined as:\n\n\\[\\begin{split}\\vec{\\omega}_i & = -\\frac{1}{\\hbar} \\sum_{j}^{Neighb} \\vec{s}_{j}\\times\\vec{D}(r_{ij}) \\\\\n\\vec{F}_i & = -\\sum_{j}^{Neighb} \\frac{\\partial D(r_{ij})}{\\partial r_{ij}} \\left(\\vec{s}_{i}\\times \\vec{s}_{j} \\right) \\cdot \\vec{r}_{ij}\\end{split}\\]\nwhere \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are neighboring magnetic\nspins of two particles.\nFrom this magneto-electric interaction, each spin i will be submitted\nto a magnetic torque omega, and its associated atom can be submitted to a\nforce F for spin-lattice calculations (see fix nve/spin),\nsuch as:\n\n\\[\\begin{split}\\vec{F}^{i} & = -\\sum_{j}^{Neighbor} \\left( \\vec{s}_{i}\\times \\vec{s}_{j} \\right) \\times \\vec{E} \\\\\n\\vec{\\omega}^{i} = -\\frac{1}{\\hbar} \\sum_{j}^{Neighbor} \\vec{s}_j \\times \\left(\\vec{E}\\times r_{ij} \\right)\\end{split}\\]\nwith h the Planck constant (in metal units) and \\(\\vec{E}\\) an\nelectric polarization vector.  The norm and direction of E are giving\nthe intensity and the direction of a screened dielectric atomic\npolarization (in eV).\nMore details about the derivation of these torques/forces are reported in\n(Tranchida).",
    "syntax": "pair_style spin/magelec cutoff",
    "parameters": " * cutoff = global cutoff pair (distance in metal units)",
    "examples": "pair_style spin/magelec 4.5\npair_coeff \\* \\* magelec 4.5 0.00109 1.0 1.0 1.0",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\nare only enabled if LAMMPS was built with this package, and if the\natom_style “spin” was declared.  See the Build package doc page for more info."
},
{
    "command": "pair_style spin/neel",
    "html_filename": "pair_spin_neel.html",
    "short_description": "Style spin/neel computes the Neel pair anisotropy model between pairs of magnetic spins:  \\[\\mathcal{H}_{N\\acute{e}el}=-\\sum_{{ i,j=1,i\\neq j}}^N g_1(r_{ij})\\left(({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})({\\mathbf{e}}_{ij} \\cdot {\\mathbf{s}}_{j})-\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right) +q_1(r_{ij})\\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3}\\right) \\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right) + q_2(r_{ij}) \\Big( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{j})^3 + ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{j}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^3\\Big)\\] where \\(\\mathbf{s}_i\\) and \\(\\mathbf{s}_j\\) are two neighboring magnetic spins of two particles, \\(r_{ij} = \\vert \\mathbf{r}_i - \\mathbf{r}_j \\vert\\) is the inter-atomic distance between the two particles, \\(\\mathbf{e}_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\vert \\mathbf{r}_i - \\mathbf{r}_j\\vert}\\) is their normalized separation vector and \\(g_1\\), \\(q_1\\) and \\(q_2\\) are three functions defining the intensity of the dipolar and quadrupolar contributions, with:  \\[\\begin{split}g_1(r_{ij}) &= g(r_{ij}) + \\frac{12}{35} q(r_{ij}) \\\\ q_1(r_{ij}) &= \\frac{9}{5} q(r_{ij}) \\\\ q_2(r_{ij}) &= - \\frac{2}{5} q(r_{ij})\\end{split}\\] With the functions \\(g(r_{ij})\\) and \\(q(r_{ij})\\) defined and fitted according to the same Bethe-Slater function used to fit the exchange interaction:  \\[{J}\\left( r_{ij} \\right) = 4 a \\left( \\frac{r_{ij}}{d}  \\right)^2 \\left( 1 - b \\left( \\frac{r_{ij}}{d}  \\right)^2 \\right) e^{-\\left( \\frac{r_{ij}}{d} \\right)^2 }\\Theta (R_c - r_{ij})\\] where \\(a\\), \\(b\\) and \\(d\\) are the three constant coefficients defined in the associated “pair_coeff” command",
    "description": "Style spin/neel computes the Neel pair anisotropy model\nbetween pairs of magnetic spins:\n\n\\[\\mathcal{H}_{N\\acute{e}el}=-\\sum_{{ i,j=1,i\\neq j}}^N g_1(r_{ij})\\left(({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})({\\mathbf{e}}_{ij}\n\\cdot {\\mathbf{s}}_{j})-\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right)\n+q_1(r_{ij})\\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3}\\right)\n\\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right)\n+ q_2(r_{ij}) \\Big( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{j})^3 + ({\\mathbf{e}}_{ij}\\cdot\n{\\mathbf{s}}_{j}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^3\\Big)\\]\nwhere \\(\\mathbf{s}_i\\) and \\(\\mathbf{s}_j\\) are two neighboring magnetic spins of two particles,\n\\(r_{ij} = \\vert \\mathbf{r}_i - \\mathbf{r}_j \\vert\\) is the inter-atomic distance between the two particles,\n\\(\\mathbf{e}_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\vert \\mathbf{r}_i - \\mathbf{r}_j\\vert}\\) is their normalized separation vector and \\(g_1\\),\n\\(q_1\\) and \\(q_2\\) are three functions defining the intensity of the dipolar\nand quadrupolar contributions, with:\n\n\\[\\begin{split}g_1(r_{ij}) &= g(r_{ij}) + \\frac{12}{35} q(r_{ij}) \\\\\nq_1(r_{ij}) &= \\frac{9}{5} q(r_{ij}) \\\\\nq_2(r_{ij}) &= - \\frac{2}{5} q(r_{ij})\\end{split}\\]\nWith the functions \\(g(r_{ij})\\) and \\(q(r_{ij})\\) defined and fitted according to\nthe same Bethe-Slater function used to fit the exchange interaction:\n\n\\[{J}\\left( r_{ij} \\right) = 4 a \\left( \\frac{r_{ij}}{d}  \\right)^2 \\left( 1 - b \\left( \\frac{r_{ij}}{d}  \\right)^2 \\right) e^{-\\left( \\frac{r_{ij}}{d} \\right)^2 }\\Theta (R_c - r_{ij})\\]\nwhere \\(a\\), \\(b\\) and \\(d\\) are the three constant coefficients defined in the\nassociated “pair_coeff” command.\nThe coefficients \\(a\\), \\(b\\), and \\(d\\) need to be fitted so that the function\nabove matches with the values of the magneto-elastic constant of the\nmaterials at stake.\nExamples and more explanations about this function and its\nparameterization are reported in (Tranchida). More\nexamples of parameterization will be provided in future work.\nFrom this DM interaction, each spin \\(i\\) will be submitted to a magnetic\ntorque \\(\\mathbf{\\omega}\\) and its associated atom to a force \\(\\mathbf{F}\\) (for spin-lattice\ncalculations only).\nMore details about the derivation of these torques/forces are reported\nin (Tranchida).",
    "syntax": "pair_style spin/neel cutoff",
    "parameters": " * cutoff = global cutoff pair (distance in metal units)",
    "examples": "pair_style spin/neel 4.0\npair_coeff * * neel 4.0 0.0048 0.234 1.168 2.6905 0.705 0.652\npair_coeff 1 2 neel 4.0 0.0048 0.234 1.168 0.0 0.0 1.0",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\nare only enabled if LAMMPS was built with this package, and if the\natom_style “spin” was declared.  See the Build package doc page for more info."
},
{
    "command": "pair_style srp",
    "html_filename": "pair_srp.html",
    "short_description": "Style srp computes a soft segmental repulsive potential (SRP) that acts between pairs of bonds",
    "description": "Style srp computes a soft segmental repulsive potential (SRP) that\nacts between pairs of bonds. This potential is useful for preventing\nbonds from passing through one another when a soft non-bonded\npotential acts between beads in, for example, DPD polymer chains.  An\nexample input script that uses this command is provided in\nexamples/USER/srp.\nBonds of specified type btype interact with one another through a\nbond-pairwise potential, such that the force on bond i due to bond\nj is as follows\n\n\\[F^{SRP}_{ij} & = C(1-r/r_c)\\hat{r}_{ij} \\qquad r < r_c\\]\nwhere r and \\(\\hat{r}_{ij}\\) are the distance and unit vector\nbetween the two bonds.  Note that btype can be specified as an\nasterisk “*”, which case the interaction is applied to all bond types.\nThe mid option computes r and \\(\\hat{r}_{ij}\\) from the midpoint\ndistance between bonds. The min option computes r and\n\\(\\hat{r}_{ij}\\) from the minimum distance between bonds. The force\nacting on a bond is mapped onto the two bond atoms according to the\nlever rule,\n\n\\[\\begin{split}F_{i1}^{SRP} & = F^{SRP}_{ij}(L) \\\\\nF_{i2}^{SRP} & = F^{SRP}_{ij}(1-L)\\end{split}\\]\nwhere L is the normalized distance from the atom to the point of\nclosest approach of bond i and j. The mid option takes L as\n0.5 for each interaction as described in (Sirk).\nThe following coefficients must be defined via the\npair_coeff command as in the examples above, or in\nthe data file or restart file read by the read_data\nor read_restart commands:\n\nC (force units)\n\\(r_c\\) (distance units)\n\nThe last coefficient is optional. If not specified, the global cutoff\nis used.\n\nNote\nPair style srp considers each bond of type btype to be a\nfictitious “particle” of type bptype, where bptype is either the\nlargest atom type in the system, or the type set by the bptype flag.\nAny actual existing particles with this atom type will be deleted at\nthe beginning of a run. This means you must specify the number of\ntypes in your system accordingly; usually to be one larger than what\nwould normally be the case, e.g. via the create_box\nor by changing the header in your data file.  The\nfictitious “bond particles” are inserted at the beginning of the run,\nand serve as placeholders that define the position of the bonds.  This\nallows neighbor lists to be constructed and pairwise interactions to\nbe computed in almost the same way as is done for actual particles.\nBecause bonds interact only with other bonds, pair_style hybrid should be used to turn off interactions\nbetween atom type bptype and all other types of atoms.  An error\nwill be flagged if pair_style hybrid is not used.\n\nThe optional exclude keyword determines if forces are computed\nbetween first neighbor (directly connected) bonds.  For a setting of\nno, first neighbor forces are computed; for yes they are not\ncomputed. A setting of no cannot be used with the min option for\ndistance calculation because the minimum distance between directly\nconnected bonds is zero.\nPair style srp turns off normalization of thermodynamic properties\nby particle number, as if the command thermo_modify norm no had been issued.\nThe pairwise energy associated with style srp is shifted to be zero\nat the cutoff distance \\(r_c\\).\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair styles does not support mixing.\nThis pair style does not support the pair_modify\nshift option for the energy of the pair interaction. Note that as\ndiscussed above, the energy term is already shifted to be 0.0 at the\ncutoff distance \\(r_c\\).\nThe pair_modify table option is not relevant for\nthis pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes global and per-atom information to binary restart files. Pair srp should be used with pair_style hybrid, thus the pair_coeff commands need to be\nspecified in the input script when reading a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style srp cutoff btype dist keyword value ...",
    "parameters": " * cutoff = global cutoff for SRP interactions (distance units)\n * btype = bond type to apply SRP interactions to (can be wildcard, see below)\n * distance = min or mid\n * zero or more keyword/value pairs may be appended\n * keyword = exclude\n * bptype value = atom type for bond particles\n * exclude value = yes or no",
    "examples": "pair_style hybrid dpd 1.0 1.0 12345 srp 0.8 1 mid exclude yes\npair_coeff 1 1 dpd 60.0 4.5 1.0\npair_coeff 1 2 none\npair_coeff 2 2 srp 100.0 0.8\n\npair_style hybrid dpd 1.0 1.0 12345 srp 0.8 \\* min exclude yes\npair_coeff 1 1 dpd 60.0 50 1.0\npair_coeff 1 2 none\npair_coeff 2 2 srp 40.0\n\npair_style hybrid srp 0.8 2 mid\npair_coeff 1 1 none\npair_coeff 1 2 none\npair_coeff 2 2 srp 100.0 0.8",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled\nif LAMMPS was built with that package. See the Making LAMMPS section\nfor more info.\nThis pair style must be used with pair_style hybrid.\nThis pair style requires the newton command to be on\nfor non-bonded interactions.\nThis pair style is not compatible with rigid body integrators"
},
{
    "command": "pair_style",
    "html_filename": "pair_style.html",
    "short_description": "Set the formula(s) LAMMPS uses to compute pairwise interactions",
    "description": "Set the formula(s) LAMMPS uses to compute pairwise interactions.  In\nLAMMPS, pair potentials are defined between pairs of atoms that are\nwithin a cutoff distance and the set of active interactions typically\nchanges over time.  See the bond_style command to\ndefine potentials between pairs of bonded atoms, which typically\nremain in place for the duration of a simulation.\nIn LAMMPS, pairwise force fields encompass a variety of interactions,\nsome of which include many-body effects, e.g. EAM, Stillinger-Weber,\nTersoff, REBO potentials.  They are still classified as “pairwise”\npotentials because the set of interacting atoms changes with time\n(unlike molecular bonds) and thus a neighbor list is used to find\nnearby interacting atoms.\nHybrid models where specified pairs of atom types interact via\ndifferent pair potentials can be setup using the hybrid pair style.\nThe coefficients associated with a pair style are typically set for\neach pair of atom types, and are specified by the\npair_coeff command or read from a file by the\nread_data or read_restart\ncommands.\nThe pair_modify command sets options for mixing of\ntype I-J interaction coefficients and adding energy offsets or tail\ncorrections to Lennard-Jones potentials.  Details on these options as\nthey pertain to individual potentials are described on the doc page\nfor the potential.  Likewise, info on whether the potential\ninformation is stored in a restart file is listed\non the potential doc page.\nIn the formulas listed for each pair style, E is the energy of a\npairwise interaction between two atoms separated by a distance r.\nThe force between the atoms is the negative derivative of this\nexpression.\nIf the pair_style command has a cutoff argument, it sets global\ncutoffs for all pairs of atom types.  The distance(s) can be smaller\nor larger than the dimensions of the simulation box.\nTypically, the global cutoff value can be overridden for a specific\npair of atom types by the pair_coeff command.  The\npair style settings (including global cutoffs) can be changed by a\nsubsequent pair_style command using the same style.  This will reset\nthe cutoffs for all atom type pairs, including those previously set\nexplicitly by a pair_coeff command.  The exceptions\nto this are that pair_style table and hybrid settings cannot be\nreset.  A new pair_style command for these styles will wipe out all\npreviously specified pair_coeff values.\n\nHere is an alphabetic list of pair styles defined in LAMMPS.  They are\nalso listed in more compact form on the Commands pair doc page.\nClick on the style to display the formula it computes, any additional\narguments specified in the pair_style command, and coefficients\nspecified by the associated pair_coeff command.\nThere are also additional accelerated pair styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands pair\ndoc page are followed by one or more of (g,i,k,o,t) to indicate which\naccelerated styles exist.\n\nnone - turn off pairwise interactions\nhybrid - multiple styles of pairwise interactions\nhybrid/overlay - multiple styles of superposed pairwise interactions\nzero - neighbor list but no interactions\nadp - angular dependent potential (ADP) of Mishin\nagni - machine learned potential mapping atomic environment to forces\nairebo - AIREBO potential of Stuart\nairebo/morse - AIREBO with Morse instead of LJ\natm - Axilrod-Teller-Muto potential\nawpmd/cut - Antisymmetrized Wave Packet MD potential for atoms and electrons\nbeck - Beck potential\nbody/nparticle - interactions between body particles\nbody/rounded/polygon - granular-style 2d polygon potential\nbody/rounded/polyhedron - granular-style 3d polyhedron potential\nbop - BOP potential of Pettifor\nborn - Born-Mayer-Huggins potential\nborn/coul/dsf - Born with damped-shifted-force model\nborn/coul/dsf/cs - Born with damped-shifted-force and core/shell model\nborn/coul/long - Born with long-range Coulombics\nborn/coul/long/cs - Born with long-range Coulombics and core/shell\nborn/coul/msm - Born with long-range MSM Coulombics\nborn/coul/wolf - Born with Wolf potential for Coulombics\nborn/coul/wolf/cs - Born with Wolf potential for Coulombics and core/shell model\nbrownian - Brownian potential for Fast Lubrication Dynamics\nbrownian/poly - Brownian potential for Fast Lubrication Dynamics with polydispersity\nbuck - Buckingham potential\nbuck/coul/cut - Buckingham with cutoff Coulomb\nbuck/coul/long - Buckingham with long-range Coulombics\nbuck/coul/long/cs - Buckingham with long-range Coulombics and core/shell\nbuck/coul/msm - Buckingham with long-range MSM Coulombics\nbuck/long/coul/long - long-range Buckingham with long-range Coulombics\nbuck/mdf - Buckingham with a taper function\nbuck6d/coul/gauss/dsf - dispersion-damped Buckingham with damped-shift-force model\nbuck6d/coul/gauss/long - dispersion-damped Buckingham with long-range Coulombics\ncolloid - integrated colloidal potential\ncomb - charge-optimized many-body (COMB) potential\ncomb3 - charge-optimized many-body (COMB3) potential\ncosine/squared - Cooke-Kremer-Deserno membrane model potential\ncoul/cut - cutoff Coulombic potential\ncoul/cut/soft - Coulombic potential with a soft core\ncoul/debye - cutoff Coulombic potential with Debye screening\ncoul/diel - Coulomb potential with dielectric permittivity\ncoul/dsf - Coulombics with damped-shifted-force model\ncoul/long - long-range Coulombic potential\ncoul/long/cs - long-range Coulombic potential and core/shell\ncoul/long/soft - long-range Coulombic potential with a soft core\ncoul/msm - long-range MSM Coulombics\ncoul/shield - Coulombics for boron nitride for use with ilp/graphene/hbn potential\ncoul/streitz - Coulombics via Streitz/Mintmire Slater orbitals\ncoul/wolf - Coulombics via Wolf potential\ncoul/wolf/cs - ditto with core/shell adjustments\ndpd - dissipative particle dynamics (DPD)\ndpd/fdt - DPD for constant temperature and pressure\ndpd/fdt/energy - DPD for constant energy and enthalpy\ndpd/tstat - pair-wise DPD thermostatting\ndsmc - Direct Simulation Monte Carlo (DSMC)\ne3b - Explicit-three body (E3B) water model\ndrip - Dihedral-angle-corrected registry-dependent interlayer potential (DRIP)\neam - embedded atom method (EAM)\neam/alloy - alloy EAM\neam/cd - concentration-dependent EAM\neam/cd/old - older two-site model for concentration-dependent EAM\neam/fs - Finnis-Sinclair EAM\nedip - three-body EDIP potential\nedip/multi - multi-element EDIP potential\nedpd - eDPD particle interactions\neff/cut - electron force field with a cutoff\neim - embedded ion method (EIM)\nexp6/rx - reactive DPD potential\nextep - extended Tersoff potential\ngauss - Gaussian potential\ngauss/cut - generalized Gaussian potential\ngayberne - Gay-Berne ellipsoidal potential\ngranular - Generalized granular potential\ngran/hertz/history - granular potential with Hertzian interactions\ngran/hooke - granular potential with history effects\ngran/hooke/history - granular potential without history effects\ngw - Gao-Weber potential\ngw/zbl - Gao-Weber potential with a repulsive ZBL core\nhbond/dreiding/lj - DREIDING hydrogen bonding LJ potential\nhbond/dreiding/morse - DREIDING hydrogen bonding Morse potential\nilp/graphene/hbn - registry-dependent interlayer potential (ILP)\nkim - interface to potentials provided by KIM project\nkolmogorov/crespi/full - Kolmogorov-Crespi (KC) potential with no simplifications\nkolmogorov/crespi/z - Kolmogorov-Crespi (KC) potential with normals along z-axis\nlcbop - long-range bond-order potential (LCBOP)\nlebedeva/z - Lebedeva interlayer potential for graphene with normals along z-axis\nlennard/mdf - LJ potential in A/B form with a taper function\nline/lj - LJ potential between line segments\nlist - potential between pairs of atoms explicitly listed in an input file\nlj/charmm/coul/charmm - CHARMM potential with cutoff Coulomb\nlj/charmm/coul/charmm/implicit - CHARMM for implicit solvent\nlj/charmm/coul/long - CHARMM with long-range Coulomb\nlj/charmm/coul/long/soft - CHARMM with long-range Coulomb and a soft core\nlj/charmm/coul/msm - CHARMM with long-range MSM Coulombics\nlj/charmmfsw/coul/charmmfsh - CHARMM with force switching and shifting\nlj/charmmfsw/coul/long - CHARMM with force switching and long-rnage Coulombics\nlj/class2 - COMPASS (class 2) force field with no Coulomb\nlj/class2/coul/cut - COMPASS with cutoff Coulomb\nlj/class2/coul/cut/soft - COMPASS with cutoff Coulomb with a soft core\nlj/class2/coul/long - COMPASS with long-range Coulomb\nlj/class2/coul/long/soft - COMPASS with long-range Coulomb with a soft core\nlj/class2/soft - COMPASS (class 2) force field with no Coulomb with a soft core\nlj/cubic - LJ with cubic after inflection point\nlj/cut - cutoff Lennard-Jones potential with no Coulomb\nlj/cut/coul/cut - LJ with cutoff Coulomb\nlj/cut/coul/cut/soft - LJ with cutoff Coulomb with a soft core\nlj/cut/coul/debye - LJ with Debye screening added to Coulomb\nlj/cut/coul/dsf - LJ with Coulombics via damped shifted forces\nlj/cut/coul/long - LJ with long-range Coulombics\nlj/cut/coul/long/cs - ditto with core/shell adjustments\nlj/cut/coul/long/soft - LJ with long-range Coulombics with a soft core\nlj/cut/coul/msm - LJ with long-range MSM Coulombics\nlj/cut/coul/wolf - LJ with Coulombics via Wolf potential\nlj/cut/dipole/cut - point dipoles with cutoff\nlj/cut/dipole/long - point dipoles with long-range Ewald\nlj/cut/soft - LJ with a soft core\nlj/cut/thole/long - LJ with Coulombics with thole damping\nlj/cut/tip4p/cut - LJ with cutoff Coulomb for TIP4P water\nlj/cut/tip4p/long - LJ with long-range Coulomb for TIP4P water\nlj/cut/tip4p/long/soft - LJ with cutoff Coulomb for TIP4P water with a soft core\nlj/expand - Lennard-Jones for variable size particles\nlj/expand/coul/long - Lennard-Jones for variable size particles with long-range Coulombics\nlj/gromacs - GROMACS-style Lennard-Jones potential\nlj/gromacs/coul/gromacs - GROMACS-style LJ and Coulombic potential\nlj/long/coul/long - long-range LJ and long-range Coulombics\nlj/long/dipole/long - long-range LJ and long-range point dipoles\nlj/long/tip4p/long - long-range LJ and long-range Coulombics for TIP4P water\nlj/mdf - LJ potential with a taper function\nlj/sdk - LJ for SDK coarse-graining\nlj/sdk/coul/long - LJ for SDK coarse-graining with long-range Coulombics\nlj/sdk/coul/msm - LJ for SDK coarse-graining with long-range Coulombics via MSM\nlj/sf/dipole/sf - LJ with dipole interaction with shifted forces\nlj/smooth - smoothed Lennard-Jones potential\nlj/smooth/linear - linear smoothed LJ potential\nlj/switch3/coulgauss/long - smoothed LJ vdW potential with Gaussian electrostatics\nlj96/cut - Lennard-Jones 9/6 potential\nlocal/density - generalized basic local density potential\nlubricate - hydrodynamic lubrication forces\nlubricate/poly - hydrodynamic lubrication forces with polydispersity\nlubricateU - hydrodynamic lubrication forces for Fast Lubrication Dynamics\nlubricateU/poly - hydrodynamic lubrication forces for Fast Lubrication with polydispersity\nmdpd - mDPD particle interactions\nmdpd/rhosum - mDPD particle interactions for mass density\nmeam/c - modified embedded atom method (MEAM) in C\nmeam/spline - splined version of MEAM\nmeam/sw/spline - splined version of MEAM with a Stillinger-Weber term\nmesocnt - mesoscale model for (carbon) nanotubes\nmgpt - simplified model generalized pseudopotential theory (MGPT) potential\nmie/cut - Mie potential\nmm3/switch3/coulgauss/long - smoothed MM3 vdW potential with Gaussian electrostatics\nmomb - Many-Body Metal-Organic (MOMB) force field\nmorse - Morse potential\nmorse/smooth/linear - linear smoothed Morse potential\nmorse/soft - Morse potential with a soft core\nmulti/lucy - DPD potential with density-dependent force\nmulti/lucy/rx - reactive DPD potential with density-dependent force\nnb3b/harmonic - non-bonded 3-body harmonic potential\nnm/cut - N-M potential\nnm/cut/coul/cut - N-M potential with cutoff Coulomb\nnm/cut/coul/long - N-M potential with long-range Coulombics\noxdna/coaxstk -\noxdna/excv -\noxdna/hbond -\noxdna/stk -\noxdna/xstk -\noxdna2/coaxstk -\noxdna2/dh -\noxdna2/excv -\noxdna2/hbond -\noxdna2/stk -\noxdna2/xstk -\noxrna2/coaxstk -\noxrna2/dh -\noxrna2/excv -\noxrna2/hbond -\noxrna2/stk -\noxrna2/xstk -\nperi/eps - peridynamic EPS potential\nperi/lps - peridynamic LPS potential\nperi/pmb - peridynamic PMB potential\nperi/ves - peridynamic VES potential\npolymorphic - polymorphic 3-body potential\npython -\nquip -\nreax/c - ReaxFF potential in C\nrebo - 2nd generation REBO potential of Brenner\nresquared - Everaers RE-Squared ellipsoidal potential\nsdpd/taitwater/isothermal - smoothed dissipative particle dynamics for water at isothermal conditions\nsmd/hertz -\nsmd/tlsph -\nsmd/tri_surface -\nsmd/ulsph -\nsmtbq -\nsnap - SNAP quantum-accurate potential\nsoft - Soft (cosine) potential\nsph/heatconduction -\nsph/idealgas -\nsph/lj -\nsph/rhosum -\nsph/taitwater -\nsph/taitwater/morris -\nspin/dipole/cut -\nspin/dipole/long -\nspin/dmi -\nspin/exchange -\nspin/magelec -\nspin/neel -\nsrp -\nsw - Stillinger-Weber 3-body potential\ntable - tabulated pair potential\ntable/rx -\ntdpd - tDPD particle interactions\ntersoff - Tersoff 3-body potential\ntersoff/mod - modified Tersoff 3-body potential\ntersoff/mod/c -\ntersoff/table -\ntersoff/zbl - Tersoff/ZBL 3-body potential\nthole - Coulomb interactions with thole damping\ntip4p/cut - Coulomb for TIP4P water w/out LJ\ntip4p/long - long-range Coulombics for TIP4P water w/out LJ\ntip4p/long/soft -\ntri/lj - LJ potential between triangles\nufm -\nvashishta - Vashishta 2-body and 3-body potential\nvashishta/table -\nyukawa - Yukawa potential\nyukawa/colloid - screened Yukawa potential for finite-size particles\nzbl - Ziegler-Biersack-Littmark potential",
    "syntax": "pair_style style args",
    "parameters": " * style = one of the styles from the list below\n * args = arguments used by a particular style",
    "examples": "pair_style lj/cut 2.5\npair_style eam/alloy\npair_style hybrid lj/charmm/coul/long 10.0 eam\npair_style table linear 1000\npair_style none",
    "restrictions": "This command must be used before any coefficients are set by the\npair_coeff, read_data, or\nread_restart commands.\nSome pair styles are part of specific packages.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual pair potentials tell if it is part of a package."
},
{
    "command": "pair_style sw",
    "html_filename": "pair_sw.html",
    "short_description": "The sw style computes a 3-body Stillinger-Weber potential for the energy E of a system of atoms as  \\[\\begin{split} E & =  \\sum_i \\sum_{j > i} \\phi_2 (r_{ij}) +         \\sum_i \\sum_{j \\neq i} \\sum_{k > j}         \\phi_3 (r_{ij}, r_{ik}, \\theta_{ijk}) \\\\ \\phi_2(r_{ij}) & =  A_{ij} \\epsilon_{ij} \\left[ B_{ij} (\\frac{\\sigma_{ij}}{r_{ij}})^{p_{ij}} -                   (\\frac{\\sigma_{ij}}{r_{ij}})^{q_{ij}} \\right]                   \\exp \\left( \\frac{\\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right) \\\\ \\phi_3(r_{ij},r_{ik},\\theta_{ijk}) & = \\lambda_{ijk} \\epsilon_{ijk} \\left[ \\cos \\theta_{ijk} -                   \\cos \\theta_{0ijk} \\right]^2                   \\exp \\left( \\frac{\\gamma_{ij} \\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right)                   \\exp \\left( \\frac{\\gamma_{ik} \\sigma_{ik}}{r_{ik} - a_{ik} \\sigma_{ik}} \\right)\\end{split}\\] where \\(\\phi_2\\) is a two-body term and \\(\\phi_3\\) is a three-body term",
    "description": "The sw style computes a 3-body Stillinger-Weber\npotential for the energy E of a system of atoms as\n\n\\[\\begin{split} E & =  \\sum_i \\sum_{j > i} \\phi_2 (r_{ij}) +\n        \\sum_i \\sum_{j \\neq i} \\sum_{k > j}\n        \\phi_3 (r_{ij}, r_{ik}, \\theta_{ijk}) \\\\\n\\phi_2(r_{ij}) & =  A_{ij} \\epsilon_{ij} \\left[ B_{ij} (\\frac{\\sigma_{ij}}{r_{ij}})^{p_{ij}} -\n                  (\\frac{\\sigma_{ij}}{r_{ij}})^{q_{ij}} \\right]\n                  \\exp \\left( \\frac{\\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right) \\\\\n\\phi_3(r_{ij},r_{ik},\\theta_{ijk}) & = \\lambda_{ijk} \\epsilon_{ijk} \\left[ \\cos \\theta_{ijk} -\n                  \\cos \\theta_{0ijk} \\right]^2\n                  \\exp \\left( \\frac{\\gamma_{ij} \\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right)\n                  \\exp \\left( \\frac{\\gamma_{ik} \\sigma_{ik}}{r_{ik} - a_{ik} \\sigma_{ik}} \\right)\\end{split}\\]\nwhere \\(\\phi_2\\) is a two-body term and \\(\\phi_3\\) is a\nthree-body term.  The summations in the formula are over all neighbors J\nand K of atom I within a cutoff distance \\(a \\).\nOnly a single pair_coeff command is used with the sw style which\nspecifies a Stillinger-Weber potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of SW elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine a file SiC.sw has Stillinger-Weber values for\nSi and C.  If your LAMMPS simulation has 4 atoms types and you want\nthe 1st 3 to be Si, and the 4th to be C, you would use the following\npair_coeff command:\npair_coeff * * SiC.sw Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the SW file.  The final C argument maps LAMMPS atom type 4\nto the C element in the SW file.  If a mapping value is specified as\nNULL, the mapping is not performed.  This can be used when a sw\npotential is used as part of the hybrid pair style.  The NULL values\nare placeholders for atom types that will be used with other\npotentials.\nStillinger-Weber files in the potentials directory of the LAMMPS\ndistribution have a “.sw” suffix.  Lines that are not blank or\ncomments (starting with #) define parameters for a triplet of\nelements.  The parameters in a single entry correspond to the two-body\nand three-body coefficients in the formula above:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2\nelement 3\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\na\n\\(\\lambda\\)\n\\(\\gamma\\)\n\\(\\cos\\theta_0\\)\nA\nB\np\nq\ntol\n\nThe A, B, p, and q parameters are used only for two-body interactions.\nThe \\(\\lambda\\) and \\(\\cos\\theta_0\\) parameters are used only\nfor three-body interactions. The \\(\\epsilon\\), \\(\\sigma\\) and\na parameters are used for both two-body and three-body\ninteractions. \\(\\gamma\\) is used only in the three-body\ninteractions, but is defined for pairs of atoms.  The non-annotated\nparameters are unitless.\nLAMMPS introduces an additional performance-optimization parameter tol\nthat is used for both two-body and three-body interactions.  In the\nStillinger-Weber potential, the interaction energies become negligibly\nsmall at atomic separations substantially less than the theoretical\ncutoff distances.  LAMMPS therefore defines a virtual cutoff distance\nbased on a user defined tolerance tol.  The use of the virtual cutoff\ndistance in constructing atom neighbor lists can significantly reduce\nthe neighbor list sizes and therefore the computational cost.  LAMMPS\nprovides a tol value for each of the three-body entries so that they\ncan be separately controlled. If tol = 0.0, then the standard\nStillinger-Weber cutoff is used.\nThe Stillinger-Weber potential file must contain entries for all the\nelements listed in the pair_coeff command.  It can also contain\nentries for additional elements not being used in a particular\nsimulation; LAMMPS ignores those entries.\nFor a single-element simulation, only a single entry is required\n(e.g. SiSiSi).  For a two-element simulation, the file must contain 8\nentries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\nspecify SW parameters for all permutations of the two elements\ninteracting in three-body configurations.  Thus for 3 elements, 27\nentries would be required, etc.\nAs annotated above, the first element in the entry is the center atom\nin a three-body interaction.  Thus an entry for SiCC means a Si atom\nwith 2 C atoms as neighbors.  The parameter values used for the\ntwo-body interaction come from the entry where the 2nd and 3rd\nelements are the same.  Thus the two-body parameters for Si\ninteracting with C, comes from the SiCC entry.  The three-body\nparameters can in principle be specific to the three elements of the\nconfiguration. In the literature, however, the three-body parameters\nare usually defined by simple formulas involving two sets of pair-wise\nparameters, corresponding to the ij and ik pairs, where i is the\ncenter atom. The user must ensure that the correct combining rule is\nused to calculate the values of the three-body parameters for\nalloys. Note also that the function \\(\\phi_3\\) contains two exponential\nscreening factors with parameter values from the ij pair and ik\npairs. So \\(\\phi_3\\) for a C atom bonded to a Si atom and a second C atom\nwill depend on the three-body parameters for the CSiC entry, and also\non the two-body parameters for the CCC and CSiSi entries. Since the\norder of the two neighbors is arbitrary, the three-body parameters for\nentries CSiC and CCSi should be the same.  Similarly, the two-body\nparameters for entries SiCC and CSiSi should also be the same.  The\nparameters used only for two-body interactions (A, B, p, and q) in\nentries whose 2nd and 3rd element are different (e.g. SiCSi) are not\nused for anything and can be set to 0.0 if desired.\nThis is also true for the parameters in \\(\\phi_3\\) that are\ntaken from the ij and ik pairs (\\(\\sigma\\), a, \\(\\gamma\\))\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nWhen using the USER-INTEL package with this style, there is an\nadditional 5 to 10 percent performance improvement when the\nStillinger-Weber parameters p and q are set to 4 and 0 respectively.\nThese parameters are common for modeling silicon and water.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style sw",
    "parameters": " * ",
    "examples": "pair_style sw\npair_coeff * * si.sw Si\npair_coeff * * GaN.sw Ga N Ga",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe Stillinger-Weber potential files provided with LAMMPS (see the\npotentials directory) are parameterized for metal units.\nYou can use the SW potential with any LAMMPS units, but you would need\nto create your own SW potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style table",
    "html_filename": "pair_table.html",
    "short_description": "Style table creates interpolation tables from potential energy and force values listed in a file(s) as a function of distance",
    "description": "Style table creates interpolation tables from potential energy and\nforce values listed in a file(s) as a function of distance.  When\nperforming dynamics or minimization, the interpolation tables are used\nto evaluate energy and forces for pairwise interactions between\nparticles, similar to how analytic formulas are used for other pair\nstyles.\nThe interpolation tables are created as a pre-computation by fitting\ncubic splines to the file values and interpolating energy and force\nvalues at each of N distances.  During a simulation, the tables are\nused to interpolate energy and force values as needed for each pair of\nparticles separated by a distance R.  The interpolation is done in\none of 4 styles: lookup, linear, spline, or bitmap.\nFor the lookup style, the distance R is used to find the nearest\ntable entry, which is the energy or force.\nFor the linear style, the distance R is used to find the 2\nsurrounding table values from which an energy or force is computed by\nlinear interpolation.\nFor the spline style, a cubic spline coefficients are computed and\nstored for each of the N values in the table, one set of splines for\nenergy, another for force.  Note that these splines are different than\nthe ones used to pre-compute the N values.  Those splines were fit\nto the Nfile values in the tabulated file, where often Nfile <\nN.  The distance R is used to find the appropriate set of spline\ncoefficients which are used to evaluate a cubic polynomial which\ncomputes the energy or force.\nFor the bitmap style, the specified N is used to create\ninterpolation tables that are 2^N in length.  The distance R is used\nto index into the table via a fast bit-mapping technique due to\n(Wolff), and a linear interpolation is performed between\nadjacent table values.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nfilename\nkeyword\ncutoff (distance units)\n\nThe filename specifies a file containing tabulated energy and force\nvalues.  The keyword specifies a section of the file.  The cutoff is\nan optional coefficient.  If not specified, the outer cutoff in the\ntable itself (see below) will be used to build an interpolation table\nthat extend to the largest tabulated distance.  If specified, only\nfile values up to the cutoff are used to create the interpolation\ntable.  The format of this file is described below.\nIf your tabulated potential(s) are designed to be used as the\nshort-range part of one of the long-range solvers specified by the\nkspace_style command, then you must use one or\nmore of the optional keywords listed above for the pair_style command.\nThese are ewald or pppm or msm or dispersion or tip4p.  This\nis so LAMMPS can insure the short-range potential and long-range\nsolver are compatible with each other, as it does for other\nshort-range pair styles, such as pair_style lj/cut/coul/long.  Note that it is up to you to insure\nthe tabulated values for each pair of atom types has the correct\nfunctional form to be compatible with the matching long-range solver.\n\nHere are some guidelines for using the pair_style table command to\nbest effect:\n\nVary the number of table points; you may need to use more than you think\nto get good resolution.\nAlways use the pair_write command to produce a plot\nof what the final interpolated potential looks like.  This can show up\ninterpolation “features” you may not like.\nStart with the linear style; it’s the style least likely to have problems.\nUse N in the pair_style command equal to the “N” in the tabulation\nfile, and use the “RSQ” or “BITMAP” parameter, so additional interpolation\nis not needed.  See discussion below.\nMake sure that your tabulated forces and tabulated energies are\nconsistent (dE/dr = -F) over the entire range of r values.  LAMMPS\nwill warn if this is not the case.\nUse as large an inner cutoff as possible.  This avoids fitting splines\nto very steep parts of the potential.\n\n\nThe format of a tabulated file is a series of one or more sections,\ndefined as follows (without the parenthesized comments):\n# Morse potential for Fe   (one or more comment or blank lines)\n\nMORSE_FE                   (keyword is first text on line)\nN 500 R 1.0 10.0           (N, R, RSQ, BITMAP, FPRIME parameters)\n                           (blank)\n1 1.0 25.5 102.34          (index, r, energy, force)\n2 1.02 23.4 98.5\n...\n500 10.0 0.001 0.003\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the pair_coeff\ncommand.  The next line lists (in any order) one or more parameters\nfor the table.  Each parameter is a keyword followed by one or more\nnumeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the pair_style table command.  Let\nNtable = N in the pair_style command, and Nfile = “N” in the\ntabulated file.  What LAMMPS does is a preliminary interpolation by\ncreating splines using the Nfile tabulated values as nodal points.  It\nuses these to interpolate energy and force values at Ntable different\npoints.  The resulting tables of length Ntable are then used as\ndescribed above, when computing energy and force for individual pair\ndistances.  This means that if you want the interpolation tables of\nlength Ntable to match exactly what is in the tabulated file (with\neffectively no preliminary interpolation), you should set Ntable =\nNfile, and use the “RSQ” or “BITMAP” parameter.  This is because the\ninternal table abscissa is always RSQ (separation distance squared),\nfor efficient lookup.\nAll other parameters are optional.  If “R” or “RSQ” or “BITMAP” does\nnot appear, then the distances in each line of the table are used\nas-is to perform spline interpolation.  In this case, the table values\ncan be spaced in r uniformly or however you wish to position table\nvalues in regions of large gradients.\nIf used, the parameters “R” or “RSQ” are followed by 2 values rlo\nand rhi.  If specified, the distance associated with each energy and\nforce value is computed from these 2 values (at high accuracy), rather\nthan using the (low-accuracy) value listed in each line of the table.\nThe distance values in the table file are ignored in this case.\nFor “R”, distances uniformly spaced between rlo and rhi are\ncomputed; for “RSQ”, squared distances uniformly spaced between\nrlo*rlo and rhi*rhi are computed.\n\nNote\nIf you use “R” or “RSQ”, the tabulated distance values in the\nfile are effectively ignored, and replaced by new values as described\nin the previous paragraph.  If the distance value in the table is not\nvery close to the new value (i.e. round-off difference), then you will\nbe assigning energy/force values to a different distance, which is\nprobably not what you want.  LAMMPS will warn if this is occurring.\n\nIf used, the parameter “BITMAP” is also followed by 2 values rlo and\nrhi.  These values, along with the “N” value determine the ordering\nof the N lines that follow and what distance is associated with each.\nThis ordering is complex, so it is not documented here, since this\nfile is typically produced by the pair_write command\nwith its bitmap option.  When the table is in BITMAP format, the “N”\nparameter in the file must be equal to 2^M where M is the value\nspecified in the pair_style command.  Also, a cutoff parameter cannot\nbe used as an optional 3rd argument in the pair_coeff command; the\nentire table extent as specified in the file must be used.\nIf used, the parameter “FPRIME” is followed by 2 values fplo and\nfphi which are the derivative of the force at the innermost and\noutermost distances listed in the table.  These values are needed by\nthe spline construction routines.  If not specified by the “FPRIME”\nparameter, they are estimated (less accurately) by the first 2 and\nlast 2 force values in the table.  This parameter is not used by\nBITMAP tables.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nr (in distance units), the 3rd value is the energy (in energy units),\nand the 4th is the force (in force units).  The r values must increase\nfrom one line to the next (unless the BITMAP parameter is specified).\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThe pair_modify shift, table, and tail options are\nnot relevant for this pair style.\nThis pair style writes the settings for the “pair_style table” command\nto binary restart files, so a pair_style command does\nnot need to specified in an input script that reads a restart file.\nHowever, the coefficient information is not stored in the restart\nfile, since it is tabulated in the potential files.  Thus, pair_coeff\ncommands do need to be specified in the restart input script.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style table style N keyword ...",
    "parameters": " * style = lookup or linear or spline or bitmap = method of interpolation\n * N = use N values in lookup, linear, spline tables\n * N = use 2^N values in bitmap tables\n * zero or more keywords may be appended\n * keyword = ewald or pppm or msm or dispersion or tip4p",
    "examples": "pair_style table linear 1000\npair_style table linear 1000 pppm\npair_style table bitmap 12\npair_coeff * 3 morse.table ENTRY1\npair_coeff * 3 morse.table ENTRY1 7.0",
    "restrictions": "none"
},
{
    "command": "pair_style table/rx",
    "html_filename": "pair_table_rx.html",
    "short_description": "Style table/rx is used in reaction DPD simulations,where the coarse-grained (CG) particles are composed of m species whose reaction rate kinetics are determined from a set of n reaction rate equations through the fix rx command",
    "description": "Style table/rx is used in reaction DPD simulations,where the\ncoarse-grained (CG) particles are composed of m species whose\nreaction rate kinetics are determined from a set of n reaction rate\nequations through the fix rx command.  The species of\none CG particle can interact with a species in a neighboring CG\nparticle through a site-site interaction potential model. Style\ntable/rx creates interpolation tables of length N from pair\npotential and force values listed in a file(s) as a function of\ndistance.  The files are read by the pair_coeff\ncommand.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy and force values at each of N\ndistances.  During a simulation, these tables are used to interpolate\nenergy and force values as needed.  The interpolation is done in one\nof 4 styles: lookup, linear, spline, or bitmap.\nFor the lookup style, the distance between 2 atoms is used to find\nthe nearest table entry, which is the energy or force.\nFor the linear style, the pair distance is used to find 2\nsurrounding table values from which an energy or force is computed by\nlinear interpolation.\nFor the spline style, a cubic spline coefficients are computed and\nstored at each of the N values in the table.  The pair distance is\nused to find the appropriate set of coefficients which are used to\nevaluate a cubic polynomial which computes the energy or force.\nFor the bitmap style, the N means to create interpolation tables\nthat are 2^N in length.  The pair distance is used to index into the\ntable via a fast bit-mapping technique (Wolff) and a linear\ninterpolation is performed between adjacent table values.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove.\n\nfilename\nkeyword\nspecies1\nspecies2\ncutoff (distance units)\n\nThe filename specifies a file containing tabulated energy and force\nvalues.  The keyword specifies a section of the file.  The cutoff is\nan optional coefficient.  If not specified, the outer cutoff in the\ntable itself (see below) will be used to build an interpolation table\nthat extend to the largest tabulated distance.  If specified, only\nfile values up to the cutoff are used to create the interpolation\ntable.  The format of this file is described below.\nThe species tags define the site-site interaction potential between\ntwo species contained within two different particles.  The species\ntags must either correspond to the species defined in the reaction\nkinetics files specified with the fix rx command or they\nmust correspond to the tag “1fluid”, signifying interaction with a\nproduct species mixture determined through a one-fluid approximation.\nThe interaction potential is weighted by the geometric average of\neither the mole fraction concentrations or the number of molecules\nassociated with the interacting coarse-grained particles (see the\nfractional or molecular weighting pair style options). The coarse-grained potential is\nstored before and after the reaction kinetics solver is applied, where\nthe difference is defined to be the internal chemical energy (uChem).\n\nHere are some guidelines for using the pair_style table/rx command to\nbest effect:\n\nVary the number of table points; you may need to use more than you think\nto get good resolution.\nAlways use the pair_write command to produce a plot\nof what the final interpolated potential looks like.  This can show up\ninterpolation “features” you may not like.\nStart with the linear style; it’s the style least likely to have problems.\nUse N in the pair_style command equal to the “N” in the tabulation\nfile, and use the “RSQ” or “BITMAP” parameter, so additional interpolation\nis not needed.  See discussion below.\nMake sure that your tabulated forces and tabulated energies are consistent\n(dE/dr = -F) along the entire range of r values.\nUse as large an inner cutoff as possible.  This avoids fitting splines\nto very steep parts of the potential.\n\n\nThe format of a tabulated file is a series of one or more sections,\ndefined as follows (without the parenthesized comments):\n# Morse potential for Fe   (one or more comment or blank lines)\n\nMORSE_FE                   (keyword is first text on line)\nN 500 R 1.0 10.0           (N, R, RSQ, BITMAP, FPRIME parameters)\n                           (blank)\n1 1.0 25.5 102.34          (index, r, energy, force)\n2 1.02 23.4 98.5\n...\n500 10.0 0.001 0.003\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the pair_coeff\ncommand.  The next line lists (in any order) one or more parameters\nfor the table.  Each parameter is a keyword followed by one or more\nnumeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the pair_style table/rx command.  Let\nNtable = N in the pair_style command, and Nfile = “N” in the\ntabulated file.  What LAMMPS does is a preliminary interpolation by\ncreating splines using the Nfile tabulated values as nodal points.  It\nuses these to interpolate as needed to generate energy and force\nvalues at Ntable different points.  The resulting tables of length\nNtable are then used as described above, when computing energy and\nforce for individual pair distances.  This means that if you want the\ninterpolation tables of length Ntable to match exactly what is in the\ntabulated file (with effectively no preliminary interpolation), you\nshould set Ntable = Nfile, and use the “RSQ” or “BITMAP” parameter.\nThe internal table abscissa is RSQ (separation distance squared).\nAll other parameters are optional.  If “R” or “RSQ” or “BITMAP” does\nnot appear, then the distances in each line of the table are used\nas-is to perform spline interpolation.  In this case, the table values\ncan be spaced in r uniformly or however you wish to position table\nvalues in regions of large gradients.\nIf used, the parameters “R” or “RSQ” are followed by 2 values rlo\nand rhi.  If specified, the distance associated with each energy and\nforce value is computed from these 2 values (at high accuracy), rather\nthan using the (low-accuracy) value listed in each line of the table.\nThe distance values in the table file are ignored in this case.\nFor “R”, distances uniformly spaced between rlo and rhi are\ncomputed; for “RSQ”, squared distances uniformly spaced between\nrlo*rlo and rhi*rhi are computed.\nIf used, the parameter “BITMAP” is also followed by 2 values rlo and\nrhi.  These values, along with the “N” value determine the ordering\nof the N lines that follow and what distance is associated with each.\nThis ordering is complex, so it is not documented here, since this\nfile is typically produced by the pair_write command\nwith its bitmap option.  When the table is in BITMAP format, the “N”\nparameter in the file must be equal to 2^M where M is the value\nspecified in the pair_style command.  Also, a cutoff parameter cannot\nbe used as an optional 3rd argument in the pair_coeff command; the\nentire table extent as specified in the file must be used.\nIf used, the parameter “FPRIME” is followed by 2 values fplo and\nfphi which are the derivative of the force at the innermost and\noutermost distances listed in the table.  These values are needed by\nthe spline construction routines.  If not specified by the “FPRIME”\nparameter, they are estimated (less accurately) by the first 2 and\nlast 2 force values in the table.  This parameter is not used by\nBITMAP tables.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nr (in distance units), the 3rd value is the energy (in energy units),\nand the 4th is the force (in force units).  The r values must increase\nfrom one line to the next (unless the BITMAP parameter is specified).\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support mixing.  Thus, coefficients for all\nI,J pairs must be specified explicitly.\nThe pair_modify shift, table, and tail options are\nnot relevant for this pair style.\nThis pair style writes the settings for the “pair_style table/rx” command\nto binary restart files, so a pair_style command does\nnot need to specified in an input script that reads a restart file.\nHowever, the coefficient information is not stored in the restart\nfile, since it is tabulated in the potential files.  Thus, pair_coeff\ncommands do need to be specified in the restart input script.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "pair_style table style N ...",
    "parameters": " * style = lookup or linear or spline or bitmap = method of interpolation\n * N = use N values in lookup, linear, spline tables\n * weighting = fractional or molecular (optional)",
    "examples": "pair_style table/rx linear 1000\npair_style table/rx linear 1000 fractional\npair_style table/rx linear 1000 molecular\npair_coeff * * rxn.table ENTRY1 h2o h2o 10.0\npair_coeff * * rxn.table ENTRY1 1fluid 1fluid 10.0\npair_coeff * 3 rxn.table ENTRY1 h2o no2 10.0",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "pair_style tersoff",
    "html_filename": "pair_tersoff.html",
    "short_description": "The tersoff style computes a 3-body Tersoff potential (Tersoff_1) for the energy E of a system of atoms as  \\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\ V_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\ f_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}   1 & r < R - D \\\\   \\frac{1}{2} - \\frac{1}{2} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) &     R-D < r < R + D \\\\   0 & r > R + D   \\end{array} \\right",
    "description": "The tersoff style computes a 3-body Tersoff potential\n(Tersoff_1) for the energy E of a system of atoms as\n\n\\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\nV_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\nf_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n  1 & r < R - D \\\\\n  \\frac{1}{2} - \\frac{1}{2} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) &\n    R-D < r < R + D \\\\\n  0 & r > R + D\n  \\end{array} \\right. \\\\\nf_R(r) & =  A \\exp (-\\lambda_1 r) \\\\\nf_A(r) & =  -B \\exp (-\\lambda_2 r) \\\\\nb_{ij} & =  \\left( 1 + \\beta^n {\\zeta_{ij}}^n \\right)^{-\\frac{1}{2n}} \\\\\n\\zeta_{ij} & =  \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                 \\exp \\left[ {\\lambda_3}^m (r_{ij} - r_{ik})^m \\right] \\\\\ng(\\theta) & =  \\gamma_{ijk} \\left( 1 + \\frac{c^2}{d^2} -\n                \\frac{c^2}{\\left[ d^2 + (\\cos \\theta - \\cos \\theta_0)^2\\right]} \\right)\\end{split}\\]\nwhere \\(f_R\\) is a two-body term and \\(f_A\\) includes three-body\ninteractions.  The summations in the formula are over all neighbors\nJ and K of atom I within a cutoff distance = R + D.\nThe tersoff/table style uses tabulated forms for the two-body,\nenvironment and angular functions. Linear interpolation is performed\nbetween adjacent table entries. The table length is chosen to be\naccurate within 10^-6 with respect to the tersoff style energy.\nThe tersoff/table should give better performance in terms of speed.\nOnly a single pair_coeff command is used with the tersoff style\nwhich specifies a Tersoff potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of Tersoff elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine the SiC.tersoff file has Tersoff values for Si\nand C.  If your LAMMPS simulation has 4 atoms types and you want the\n1st 3 to be Si, and the 4th to be C, you would use the following\npair_coeff command:\npair_coeff * * SiC.tersoff Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the Tersoff file.  The final C argument maps LAMMPS atom\ntype 4 to the C element in the Tersoff file.  If a mapping value is\nspecified as NULL, the mapping is not performed.  This can be used\nwhen a tersoff potential is used as part of the hybrid pair style.\nThe NULL values are placeholders for atom types that will be used with\nother potentials.\nTersoff files in the potentials directory of the LAMMPS distribution\nhave a “.tersoff” suffix.  Lines that are not blank or comments\n(starting with #) define parameters for a triplet of elements.  The\nparameters in a single entry correspond to coefficients in the formula\nabove:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2 (the atom bonded to the center atom)\nelement 3 (the atom influencing the 1-2 bond in a bond-order sense)\nm\n\\(\\gamma\\)\n\\(\\lambda_3\\) (1/distance units)\nc\nd\n\\(\\cos\\theta_0\\) (can be a value < -1 or > 1)\nn\n\\(\\beta\\)\n\\(\\lambda_2\\) (1/distance units)\nB (energy units)\nR (distance units)\nD (distance units)\n\\(\\lambda_1\\) (1/distance units)\nA (energy units)\n\nThe n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A\nparameters are only used for\ntwo-body interactions.  The m, \\(\\gamma\\), \\(\\lambda_3\\), c, d,\nand \\(\\cos\\theta_0\\)\nparameters are only used for three-body interactions. The R and D\nparameters are used for both two-body and three-body interactions. The\nnon-annotated parameters are unitless.  The value of m must be 3 or 1.\nThe Tersoff potential file must contain entries for all the elements\nlisted in the pair_coeff command.  It can also contain entries for\nadditional elements not being used in a particular simulation; LAMMPS\nignores those entries.\nFor a single-element simulation, only a single entry is required\n(e.g. SiSiSi).  For a two-element simulation, the file must contain 8\nentries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\nspecify Tersoff parameters for all permutations of the two elements\ninteracting in three-body configurations.  Thus for 3 elements, 27\nentries would be required, etc.\nAs annotated above, the first element in the entry is the center atom\nin a three-body interaction and it is bonded to the 2nd atom and the\nbond is influenced by the 3rd atom.  Thus an entry for SiCC means Si\nbonded to a C with another C atom influencing the bond.  Thus\nthree-body parameters for SiCSi and SiSiC entries will not, in\ngeneral, be the same.  The parameters used for the two-body\ninteraction come from the entry where the 2nd element is repeated.\nThus the two-body parameters for Si interacting with C, comes from the\nSiCC entry.\nThe parameters used for a particular\nthree-body interaction come from the entry with the corresponding\nthree elements.  The parameters used only for two-body interactions\n(n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A)\nin entries whose 2nd and 3rd\nelement are different (e.g. SiCSi) are not used for anything and can\nbe set to 0.0 if desired.\nNote that the twobody parameters in entries such as SiCC and CSiSi\nare often the same, due to the common use of symmetric mixing rules,\nbut this is not always the case. For example, the beta and n parameters in\nTersoff_2 (Tersoff_2) are not symmetric.\nWe chose the above form so as to enable users to define all commonly\nused variants of the Tersoff potential.  In particular, our form\nreduces to the original Tersoff form when m = 3 and gamma = 1, while\nit reduces to the form of Albe et al. when beta = 1 and m = 1.\nNote that in the current Tersoff implementation in LAMMPS, m must be\nspecified as either 3 or 1.  Tersoff used a slightly different but\nequivalent form for alloys, which we will refer to as Tersoff_2\npotential (Tersoff_2).\nThe tersoff/table style implements\nTersoff_2 parameterization only.\nLAMMPS parameter values for Tersoff_2 can be obtained as follows:\n\\(\\gamma_{ijk} = \\omega_{ik}\\), \\(\\lambda_3 = 0\\) and the value of\nm has no effect.  The parameters for species i and j can be calculated\nusing the Tersoff_2 mixing rules:\n\n\\[\\begin{split}\\lambda_1^{i,j} & = \\frac{1}{2}(\\lambda_1^i + \\lambda_1^j)\\\\\n\\lambda_2^{i,j} & = \\frac{1}{2}(\\lambda_2^i + \\lambda_2^j)\\\\\nA_{i,j} & = (A_{i}A_{j})^{1/2}\\\\\nB_{i,j} & = \\chi_{ij}(B_{i}B_{j})^{1/2}\\\\\nR_{i,j} & = (R_{i}R_{j})^{1/2}\\\\\nS_{i,j} & = (S_{i}S_{j})^{1/2}\\end{split}\\]\nTersoff_2 parameters R and S must be converted to the LAMMPS\nparameters R and D (R is different in both forms), using the following\nrelations: R=(R’+S’)/2 and D=(S’-R’)/2, where the primes indicate the\nTersoff_2 parameters.\nIn the potentials directory, the file SiCGe.tersoff provides the\nLAMMPS parameters for Tersoff’s various versions of Si, as well as his\nalloy parameters for Si, C, and Ge. This file can be used for pure Si,\n(three different versions), pure C, pure Ge, binary SiC, and binary\nSiGe.  LAMMPS will generate an error if this file is used with any\ncombination involving C and Ge, since there are no entries for the GeC\ninteractions (Tersoff did not publish parameters for this\ncross-interaction.)  Tersoff files are also provided for the SiC alloy\n(SiC.tersoff) and the GaN (GaN.tersoff) alloys.\nMany thanks to Rutuparna Narulkar, David Farrell, and Xiaowang Zhou\nfor helping clarify how Tersoff parameters for alloys have been\ndefined in various papers.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style",
    "parameters": " * style = tersoff or tersoff/table or tersoff/gpu or tersoff/omp or tersoff/table/omp",
    "examples": "pair_style tersoff\npair_coeff * * Si.tersoff Si\npair_coeff * * SiC.tersoff Si C Si\n\npair_style tersoff/table\npair_coeff * * SiCGe.tersoff Si(D)",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe Tersoff potential files provided with LAMMPS (see the potentials\ndirectory) are parameterized for metal units.  You can\nuse the Tersoff potential with any LAMMPS units, but you would need to\ncreate your own Tersoff potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style tersoff/mod",
    "html_filename": "pair_tersoff_mod.html",
    "short_description": "The tersoff/mod and tersoff/mod/c styles computes a bond-order type interatomic potential (Kumagai) based on a 3-body Tersoff potential (Tersoff_1), (Tersoff_2) with modified cutoff function and angular-dependent term, giving the energy E of a system of atoms as  \\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\ V_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\ f_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}   1 & r < R - D \\\\   \\frac{1}{2} - \\frac{9}{16} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) - \\frac{1}{16} \\sin \\left( \\frac{3\\pi}{2} \\frac{r-R}{D} \\right) &     R-D < r < R + D \\\\   0 & r > R + D   \\end{array} \\right",
    "description": "The tersoff/mod and tersoff/mod/c styles computes a bond-order type\ninteratomic potential (Kumagai) based on a 3-body Tersoff\npotential (Tersoff_1), (Tersoff_2) with\nmodified cutoff function and angular-dependent term, giving the energy\nE of a system of atoms as\n\n\\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\nV_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\nf_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n  1 & r < R - D \\\\\n  \\frac{1}{2} - \\frac{9}{16} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) - \\frac{1}{16} \\sin \\left( \\frac{3\\pi}{2} \\frac{r-R}{D} \\right) &\n    R-D < r < R + D \\\\\n  0 & r > R + D\n  \\end{array} \\right. \\\\\nf_R(r) & = A \\exp (-\\lambda_1 r) \\\\\nf_A(r) & = -B \\exp (-\\lambda_2 r) \\\\\nb_{ij} & = \\left( 1 + {\\zeta_{ij}}^\\eta \\right)^{-\\frac{1}{2n}} \\\\\n\\zeta_{ij} & = \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                 \\exp \\left[ \\alpha (r_{ij} - r_{ik})^\\beta \\right] \\\\\ng(\\theta) & = c_1 + g_o(\\theta) g_a(\\theta) \\\\\ng_o(\\theta) & = \\frac{c_2 (h - \\cos \\theta)^2}{c_3 + (h - \\cos \\theta)^2} \\\\\ng_a(\\theta) & = 1 + c_4 \\exp \\left[ -c_5 (h - \\cos \\theta)^2 \\right] \\\\\\end{split}\\]\nwhere \\(f_R\\) is a two-body term and \\(f_A\\) includes three-body interactions.\nThe summations in the formula are over all neighbors J and K of atom I\nwithin a cutoff distance = R + D.\nThe tersoff/mod/c style differs from tersoff/mod only in the\nformulation of the V_ij term, where it contains an additional c0 term.\n\n\\[V_{ij}  & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) + c_0 \\right]\\]\nThe modified cutoff function \\(f_C\\) proposed by (Murty) and\nhaving a continuous second-order differential is employed. The\nangular-dependent term \\(g(\\theta)\\) was modified to increase the\nflexibility of the potential.\nThe tersoff/mod potential is fitted to both the elastic constants\nand melting point by employing the modified Tersoff potential function\nform in which the angular-dependent term is improved. The model\nperforms extremely well in describing the crystalline, liquid, and\namorphous phases (Schelling).\nOnly a single pair_coeff command is used with the tersoff/mod style\nwhich specifies a Tersoff/MOD potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of Tersoff/MOD elements to atom types\n\nAs an example, imagine the Si.tersoff_mod file has Tersoff values for Si.\nIf your LAMMPS simulation has 3 Si atoms types, you would use the following\npair_coeff command:\npair_coeff * * Si.tersoff_mod Si Si Si\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe three Si arguments map LAMMPS atom types 1,2,3 to the Si element\nin the Tersoff/MOD file. If a mapping value is specified as NULL, the\nmapping is not performed.  This can be used when a tersoff/mod\npotential is used as part of the hybrid pair style. The NULL values\nare placeholders for atom types that will be used with other\npotentials.\nTersoff/MOD file in the potentials directory of the LAMMPS\ndistribution have a “.tersoff.mod” suffix. Potential files for the\ntersoff/mod/c style have the suffix “.tersoff.modc”. Lines that are\nnot blank or comments (starting with #) define parameters for a triplet\nof elements.  The parameters in a single entry correspond to\ncoefficients in the formulae above:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2 (the atom bonded to the center atom)\nelement 3 (the atom influencing the 1-2 bond in a bond-order sense)\n\\(\\beta\\)\n\\(\\alpha\\)\nh\n\\(\\eta\\)\n\\(\\beta_{ters}\\) = 1 (dummy parameter)\n\\(\\lambda_2\\) (1/distance units)\nB (energy units)\nR (distance units)\nD (distance units)\n\\(\\lambda_1\\) (1/distance units)\nA (energy units)\nn\nc1\nc2\nc3\nc4\nc5\nc0 (energy units, tersoff/mod/c only):ul\n\nThe n, \\(\\eta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A parameters are only used for\ntwo-body interactions.  The \\(\\beta\\), \\(\\alpha\\), c1, c2, c3, c4, c5, h\nparameters are only used for three-body interactions. The R and D\nparameters are used for both two-body and three-body interactions.\nThe c0 term applies to tersoff/mod/c only. The non-annotated\nparameters are unitless.\nThe Tersoff/MOD potential file must contain entries for all the elements\nlisted in the pair_coeff command.  It can also contain entries for\nadditional elements not being used in a particular simulation; LAMMPS\nignores those entries.\nFor a single-element simulation, only a single entry is required\n(e.g. SiSiSi). As annotated above, the first element in the entry is\nthe center atom in a three-body interaction and it is bonded to the\n2nd atom and the bond is influenced by the 3rd atom.  Thus an entry\nfor SiSiSi means Si bonded to a Si with another Si atom influencing the bond.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style tersoff/mod",
    "parameters": " * pair_style tersoff/mod/c",
    "examples": "pair_style tersoff/mod\npair_coeff * * Si.tersoff.mod Si Si\n\npair_style tersoff/mod/c\npair_coeff * * Si.tersoff.modc Si Si",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe Tersoff/MOD potential files provided with LAMMPS (see the potentials\ndirectory) are parameterized for metal units.  You can\nuse the Tersoff/MOD potential with any LAMMPS units, but you would need to\ncreate your own Tersoff/MOD potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_style tersoff/zbl",
    "html_filename": "pair_tersoff_zbl.html",
    "short_description": "The tersoff/zbl style computes a 3-body Tersoff potential (Tersoff_1) with a close-separation pairwise modification based on a Coulomb potential and the Ziegler-Biersack-Littmark universal screening function (ZBL), giving the energy E of a system of atoms as  \\[\\begin{split} E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\  V_{ij} & =  (1 - f_F(r_{ij})) V^{ZBL}_{ij} + f_F(r_{ij}) V^{Tersoff}_{ij} \\\\  f_F(r_{ij}) & =  \\frac{1}{1 + e^{-A_F(r_{ij} - r_C)}}\\\\  \\\\  \\\\  V^{ZBL}_{ij} & = \\frac{1}{4\\pi\\epsilon_0} \\frac{Z_1 Z_2 \\,e^2}{r_{ij}} \\phi(r_{ij}/a) \\\\ a & = \\frac{0",
    "description": "The tersoff/zbl style computes a 3-body Tersoff potential\n(Tersoff_1) with a close-separation pairwise modification\nbased on a Coulomb potential and the Ziegler-Biersack-Littmark\nuniversal screening function (ZBL), giving the energy E of a\nsystem of atoms as\n\n\\[\\begin{split} E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n V_{ij} & =  (1 - f_F(r_{ij})) V^{ZBL}_{ij} + f_F(r_{ij}) V^{Tersoff}_{ij} \\\\\n f_F(r_{ij}) & =  \\frac{1}{1 + e^{-A_F(r_{ij} - r_C)}}\\\\\n \\\\\n \\\\\n V^{ZBL}_{ij} & = \\frac{1}{4\\pi\\epsilon_0} \\frac{Z_1 Z_2 \\,e^2}{r_{ij}} \\phi(r_{ij}/a) \\\\\na & = \\frac{0.8854\\,a_0}{Z_{1}^{0.23} + Z_{2}^{0.23}}\\\\\n\\phi(x) & =  0.1818e^{-3.2x} + 0.5099e^{-0.9423x} + 0.2802e^{-0.4029x} + 0.02817e^{-0.2016x}\\\\\n\\\\\n\\\\\nV^{Tersoff}_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\nf_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n  1 & r < R - D \\\\\n  \\frac{1}{2} - \\frac{1}{2} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) &\n    R-D < r < R + D \\\\\n  0 & r > R + D\n  \\end{array} \\right. \\\\\nf_R(r) & = A \\exp (-\\lambda_1 r) \\\\\nf_A(r) & = -B \\exp (-\\lambda_2 r) \\\\\nb_{ij} & = \\left( 1 + \\beta^n {\\zeta_{ij}}^n \\right)^{-\\frac{1}{2n}} \\\\\n\\zeta_{ij} & = \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                 \\exp \\left[ {\\lambda_3}^m (r_{ij} - r_{ik})^m \\right] \\\\\ng(\\theta) & =  \\gamma_{ijk} \\left( 1 + \\frac{c^2}{d^2} -\n                \\frac{c^2}{\\left[ d^2 + (\\cos \\theta - \\cos \\theta_0)^2\\right]} \\right)\\end{split}\\]\nThe \\(f_F\\) term is a fermi-like function used to smoothly connect the ZBL\nrepulsive potential with the Tersoff potential.  There are 2\nparameters used to adjust it: \\(A_F\\) and \\(r_C\\).  \\(A_F\\)\ncontrols how “sharp”\nthe transition is between the two, and \\(r_C\\) is essentially the cutoff\nfor the ZBL potential.\nFor the ZBL portion, there are two terms. The first is the Coulomb\nrepulsive term, with Z1, Z2 as the number of protons in each nucleus,\ne as the electron charge (1 for metal and real units) and \\(\\epsilon_0\\)\nas the permittivity of vacuum.  The second part is the ZBL universal\nscreening function, with a0 being the Bohr radius (typically 0.529\nAngstroms), and the remainder of the coefficients provided by the\noriginal paper.  This screening function should be applicable to most\nsystems.  However, it is only accurate for small separations\n(i.e. less than 1 Angstrom).\nFor the Tersoff portion, \\(f_R\\) is a two-body term and \\(f_A\\)\nincludes\nthree-body interactions. The summations in the formula are over all\nneighbors J and K of atom I within a cutoff distance = R + D.\nOnly a single pair_coeff command is used with the tersoff/zbl style\nwhich specifies a Tersoff/ZBL potential file with parameters for all\nneeded elements.  These are mapped to LAMMPS atom types by specifying\nN additional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of Tersoff/ZBL elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine the SiC.tersoff.zbl file has Tersoff/ZBL values\nfor Si and C.  If your LAMMPS simulation has 4 atoms types and you\nwant the 1st 3 to be Si, and the 4th to be C, you would use the\nfollowing pair_coeff command:\npair_coeff * * SiC.tersoff Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the Tersoff/ZBL file.  The final C argument maps LAMMPS\natom type 4 to the C element in the Tersoff/ZBL file.  If a mapping\nvalue is specified as NULL, the mapping is not performed.  This can be\nused when a tersoff/zbl potential is used as part of the hybrid\npair style.  The NULL values are placeholders for atom types that will\nbe used with other potentials.\nTersoff/ZBL files in the potentials directory of the LAMMPS\ndistribution have a “.tersoff.zbl” suffix.  Lines that are not blank\nor comments (starting with #) define parameters for a triplet of\nelements.  The parameters in a single entry correspond to coefficients\nin the formula above:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2 (the atom bonded to the center atom)\nelement 3 (the atom influencing the 1-2 bond in a bond-order sense)\nm\n\\(\\gamma\\)\n\\(\\lambda_3\\) (1/distance units)\nc\nd\n\\(\\cos\\theta_0\\) (can be a value < -1 or > 1)\nn\n\\(\\beta\\)\n\\(\\lambda_2\\) (1/distance units)\nB (energy units)\nR (distance units)\nD (distance units)\n\\(\\lambda_1\\) (1/distance units)\nA (energy units)\n\\(Z_i\\)\n\\(Z_j\\)\nZBLcut (distance units)\nZBLexpscale (1/distance units)\n\nThe n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A\nparameters are only used for\ntwo-body interactions.  The m, \\(\\gamma\\), \\(\\lambda_3\\), c, d,\nand \\(\\cos\\theta_0\\)\nparameters are only used for three-body interactions. The R and D\nparameters are used for both two-body and three-body interactions. The\n\\(Z_i\\), \\(Z_j\\), ZBLcut, ZBLexpscale parameters are used in the\nZBL repulsive\nportion of the potential and in the Fermi-like function.  The\nnon-annotated parameters are unitless.  The value of m must be 3 or 1.\nThe Tersoff/ZBL potential file must contain entries for all the\nelements listed in the pair_coeff command.  It can also contain\nentries for additional elements not being used in a particular\nsimulation; LAMMPS ignores those entries.\nFor a single-element simulation, only a single entry is required\n(e.g. SiSiSi).  For a two-element simulation, the file must contain 8\nentries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\nspecify Tersoff parameters for all permutations of the two elements\ninteracting in three-body configurations.  Thus for 3 elements, 27\nentries would be required, etc.\nAs annotated above, the first element in the entry is the center atom\nin a three-body interaction and it is bonded to the 2nd atom and the\nbond is influenced by the 3rd atom.  Thus an entry for SiCC means Si\nbonded to a C with another C atom influencing the bond.  Thus\nthree-body parameters for SiCSi and SiSiC entries will not, in\ngeneral, be the same.  The parameters used for the two-body\ninteraction come from the entry where the 2nd element is repeated.\nThus the two-body parameters for Si interacting with C, comes from the\nSiCC entry.\nThe parameters used for a particular\nthree-body interaction come from the entry with the corresponding\nthree elements.  The parameters used only for two-body interactions\n(n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A)\nin entries whose 2nd and 3rd\nelement are different (e.g. SiCSi) are not used for anything and can\nbe set to 0.0 if desired.\nNote that the twobody parameters in entries such as SiCC and CSiSi\nare often the same, due to the common use of symmetric mixing rules,\nbut this is not always the case. For example, the beta and n parameters in\nTersoff_2 (Tersoff_2) are not symmetric.\nWe chose the above form so as to enable users to define all commonly\nused variants of the Tersoff portion of the potential.  In particular,\nour form reduces to the original Tersoff form when m = 3 and gamma =\n1, while it reduces to the form of Albe et al. when beta = 1\nand m = 1.  Note that in the current Tersoff implementation in LAMMPS,\nm must be specified as either 3 or 1.  Tersoff used a slightly\ndifferent but equivalent form for alloys, which we will refer to as\nTersoff_2 potential (Tersoff_2).\nLAMMPS parameter values for Tersoff_2 can be obtained as follows:\n\\(\\gamma = \\omega_{ijk}\\), \\(\\lambda_3 = 0\\) and the value of\nm has no effect.  The parameters for species i and j can be calculated\nusing the Tersoff_2 mixing rules:\n\n\\[\\begin{split}\\lambda_1^{i,j} & = \\frac{1}{2}(\\lambda_1^i + \\lambda_1^j)\\\\\n\\lambda_2^{i,j} & = \\frac{1}{2}(\\lambda_2^i + \\lambda_2^j)\\\\\nA_{i,j} & = (A_{i}A_{j})^{1/2}\\\\\nB_{i,j} & = \\chi_{ij}(B_{i}B_{j})^{1/2}\\\\\nR_{i,j} & = (R_{i}R_{j})^{1/2}\\\\\nS_{i,j} & = (S_{i}S_{j})^{1/2}\\\\\\end{split}\\]\nTersoff_2 parameters R and S must be converted to the LAMMPS\nparameters R and D (R is different in both forms), using the following\nrelations: R=(R’+S’)/2 and D=(S’-R’)/2, where the primes indicate the\nTersoff_2 parameters.\nIn the potentials directory, the file SiCGe.tersoff provides the\nLAMMPS parameters for Tersoff’s various versions of Si, as well as his\nalloy parameters for Si, C, and Ge. This file can be used for pure Si,\n(three different versions), pure C, pure Ge, binary SiC, and binary\nSiGe.  LAMMPS will generate an error if this file is used with any\ncombination involving C and Ge, since there are no entries for the GeC\ninteractions (Tersoff did not publish parameters for this\ncross-interaction.)  Tersoff files are also provided for the SiC alloy\n(SiC.tersoff) and the GaN (GaN.tersoff) alloys.\nMany thanks to Rutuparna Narulkar, David Farrell, and Xiaowang Zhou\nfor helping clarify how Tersoff parameters for alloys have been\ndefined in various papers.  Also thanks to Ram Devanathan for\nproviding the base ZBL implementation.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style tersoff/zbl",
    "parameters": " * ",
    "examples": "pair_style tersoff/zbl\npair_coeff * * SiC.tersoff.zbl Si C Si",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires the newton setting to be “on”\nfor pair interactions.\nThe Tersoff/ZBL potential files provided with LAMMPS (see the\npotentials directory) are parameterized for metal units.\nYou can use the Tersoff potential with any LAMMPS units, but you would\nneed to create your own Tersoff potential file with coefficients\nlisted in the appropriate units if your simulation doesn’t use “metal”\nunits."
},
{
    "command": "pair_style tri/lj",
    "html_filename": "pair_tri_lj.html",
    "short_description": "Style tri/lj treats particles which are triangles as a set of small spherical particles that tile the triangle surface as explained below",
    "description": "Style tri/lj treats particles which are triangles as a set of small\nspherical particles that tile the triangle surface as explained below.\nInteractions between two triangles, each with N1 and N2 spherical\nparticles, are calculated as the pairwise sum of N1*N2 Lennard-Jones\ninteractions.  Interactions between a triangle with N spherical\nparticles and a point particle are treated as the pairwise sum of N\nLennard-Jones interactions.  See the pair_style lj/cut\ndoc page for the definition of Lennard-Jones interactions.\nThe cutoff distance for an interaction between 2 triangles, or between\na triangle and a point particle, is calculated from the position of\nthe triangle (its centroid), not between pairs of individual spheres\ncomprising the triangle.  Thus an interaction is either calculated in\nits entirety or not at all.\nThe set of non-overlapping spherical particles that represent a\ntriangle, for purposes of this pair style, are generated in the\nfollowing manner.  Assume the triangle is of type I, and sigma_II has\nbeen specified.  We want a set of spheres with centers in the plane of\nthe triangle, none of them larger in diameter than sigma_II, which\ncompletely cover the triangle’s area, but with minimal overlap and a\nminimal total number of spheres.  This is done in a recursive manner.\nPlace a sphere at the centroid of the original triangle.  Calculate\nwhat diameter it must have to just cover all 3 corner points of the\ntriangle.  If that diameter is equal to or smaller than sigma_II, then\ninclude a sphere of the calculated diameter in the set of covering\nspheres.  It the diameter is larger than sigma_II, then split the\ntriangle into 2 triangles by bisecting its longest side.  Repeat the\nprocess on each sub-triangle, recursing as far as needed to generate a\nset of covering spheres.  When finished, the original criteria are\nmet, and the set of covering spheres should be near minimal in number\nand overlap, at least for input triangles with a reasonable\naspect-ratio.\nThe LJ interaction between 2 spheres on different triangles of types\nI,J is computed with an arithmetic mixing of the sigma values of the 2\nspheres and using the specified epsilon value for I,J atom types.\nNote that because the sigma values for triangles spheres is computed\nusing only sigma_II values, specific to the triangles’s type, this\nmeans that any specified sigma_IJ values (for I != J) are effectively\nignored.\nFor style tri/lj, the following coefficients must be defined for\neach pair of atoms types via the pair_coeff command\nas in the examples above, or in the data file or restart files read by\nthe read_data or read_restart\ncommands:\n\nepsilon (energy units)\nsigma (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global cutoff\nis used.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the epsilon and sigma coefficients\nand cutoff distance for all of this pair style can be mixed.  The\ndefault mix value is geometric.  See the “pair_modify” command for\ndetails.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style tri/lj cutoff",
    "parameters": " * cutoff = global cutoff for interactions (distance units)",
    "examples": "pair_style tri/lj 3.0\npair_coeff * * 1.0 1.0\npair_coeff 1 1 1.0 1.5 2.5",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nDefining particles to be triangles so they participate in tri/tri or\ntri/particle interactions requires the use the atom_style tri command."
},
{
    "command": "pair_style ufm",
    "html_filename": "pair_ufm.html",
    "short_description": "Style ufm computes pairwise interactions using the Uhlenbeck-Ford model (UFM) potential (Paula Leite2016) which is given by  \\[\\begin{split}E & = -\\varepsilon\\, \\ln{\\left[1-\\exp{\\left(-r^{2}/\\sigma^{2}\\right)}\\right]} \\qquad  r < r_c \\\\ \\varepsilon & = p\\,k_B\\,T\\end{split}\\] where \\(r_c\\) is the cutoff, \\(\\sigma\\) is a distance-scale and \\(\\epsilon\\) is an energy-scale, i",
    "description": "Style ufm computes pairwise interactions using the Uhlenbeck-Ford model (UFM) potential (Paula Leite2016) which is given by\n\n\\[\\begin{split}E & = -\\varepsilon\\, \\ln{\\left[1-\\exp{\\left(-r^{2}/\\sigma^{2}\\right)}\\right]} \\qquad  r < r_c \\\\\n\\varepsilon & = p\\,k_B\\,T\\end{split}\\]\nwhere \\(r_c\\) is the cutoff, \\(\\sigma\\) is a distance-scale and\n\\(\\epsilon\\) is an energy-scale, i.e., a product of Boltzmann constant\n\\(k_B\\), temperature T and the Uhlenbeck-Ford p-parameter which\nis responsible\nto control the softness of the interactions (Paula Leite2017).\nThis model is useful as a reference system for fluid-phase free-energy calculations (Paula Leite2016).\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global ufm\ncutoff is used.\nThe fix adapt command can be used to vary epsilon and sigma for this pair style over the course of a simulation, in which case\npair_coeff settings for epsilon and sigma must still be specified, but will be\noverridden.  For example these commands will vary the prefactor epsilon for\nall pairwise interactions from 10.0 at the beginning to 100.0 at the end\nof a run:\nvariable prefactor equal ramp(10,100)\nfix 1 all adapt 1 pair ufm epsilon * * v_prefactor\n\n\n\nNote\nThe thermodynamic integration procedure can be performed with this\npotential using fix adapt. This command will\nrescale the force on each atom by varying a scale variable, which\nalways starts with value 1.0. The syntax is the same described above,\nhowever, changing epsilon to scale. A detailed explanation of how to\nuse this command and perform nonequilibrium thermodynamic integration\nin LAMMPS is given in the paper by (Freitas).\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A coefficient and cutoff\ndistance for this pair style can be mixed.  A is always mixed via a\ngeometric rule.  The cutoff is mixed according to the pair_modify\nmix value.  The default mix value is geometric.  See the\n“pair_modify” command for details.\nThis pair style support the pair_modify shift option for the energy of the pair interaction.\nThe pair_modify table and tail are not relevant for this\npair style.\nThis pair style does not support the pair_modify tail option for adding long-range tail corrections to energy and pressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style ufm cutoff",
    "parameters": " * cutoff = global cutoff for ufm interactions (distance units)",
    "examples": "pair_style ufm 4.0\npair_coeff 1 1 100.0 1.0 2.5\npair_coeff * * 100.0 1.0\n\npair_style ufm 4.0\npair_coeff * * 10.0 1.0\nvariable prefactor equal ramp(10,100)\nfix 1 all adapt 1 pair ufm epsilon * * v_prefactor",
    "restrictions": "none"
},
{
    "command": "pair_style vashishta",
    "html_filename": "pair_vashishta.html",
    "short_description": "The vashishta and vashishta/table styles compute the combined 2-body and 3-body family of potentials developed in the group of Priya Vashishta and collaborators",
    "description": "The vashishta and vashishta/table styles compute the combined\n2-body and 3-body family of potentials developed in the group of Priya\nVashishta and collaborators.  By combining repulsive, screened\nCoulombic, screened charge-dipole, and dispersion interactions with a\nbond-angle energy based on the Stillinger-Weber potential, this\npotential has been used to describe a variety of inorganic compounds,\nincluding SiO2 Vashishta1990, SiC\nVashishta2007, and InP Branicio2009.\nThe potential for the energy U of a system of atoms is\n\n\\[\\begin{split}U & =  \\sum_i^N \\sum_{j > i}^N U_{ij}^{(2)} (r_{ij}) + \\sum_i^N \\sum_{j \\neq i}^N \\sum_{k > j, k \\neq i}^N U_{ijk}^{(3)} (r_{ij}, r_{ik}, \\theta_{ijk}) \\\\\nU_{ij}^{(2)} (r) & =   \\frac{H_{ij}}{r^{\\eta_{ij}}} + \\frac{Z_i Z_j}{r}\\exp(-r/\\lambda_{1,ij}) - \\frac{D_{ij}}{r^4}\\exp(-r/\\lambda_{4,ij}) - \\frac{W_{ij}}{r^6}, r < r_{c,{ij}} \\\\\nU_{ijk}^{(3)}(r_{ij},r_{ik},\\theta_{ijk}) & =  B_{ijk} \\frac{\\left[ \\cos \\theta_{ijk} - \\cos \\theta_{0ijk} \\right]^2} {1+C_{ijk}\\left[ \\cos \\theta_{ijk} - \\cos \\theta_{0ijk} \\right]^2} \\times \\\\\n                 &  \\exp \\left( \\frac{\\gamma_{ij}}{r_{ij} - r_{0,ij}} \\right) \\exp \\left( \\frac{\\gamma_{ik}}{r_{ik} - r_{0,ik}} \\right), r_{ij} < r_{0,ij}, r_{ik} < r_{0,ik}\\end{split}\\]\nwhere we follow the notation used in Branicio2009.\n\\(U^2\\) is a two-body term and U3 is a three-body term.  The\nsummation over two-body terms is over all neighbors J within\na cutoff distance = \\(r_c\\).  The twobody terms are shifted and\ntilted by a linear function so that the energy and force are\nboth zero at \\(r_c\\). The summation over three-body terms\nis over all neighbors i and k within a cut-off distance \\(= r_0\\),\nwhere the exponential screening function becomes zero.\nThe vashishta style computes these formulas analytically.  The\nvashishta/table style tabulates the analytic values for Ntable\npoints from cutinner to the cutoff of the potential.  The points are\nequally spaced in R^2 space from cutinner^2 to cutoff^2.  For the\ntwo-body term in the above equation, a linear interpolation for each\npairwise distance between adjacent points in the table.  In practice\nthe tabulated version can run 3-5x faster than the analytic version\nwith moderate to little loss of accuracy for Ntable values\nbetween 10000 and 1000000. It is not recommended to use less than\n5000 tabulation points.\nOnly a single pair_coeff command is used with either style which\nspecifies a Vashishta potential file with parameters for all needed\nelements.  These are mapped to LAMMPS atom types by specifying N\nadditional arguments after the filename in the pair_coeff command,\nwhere N is the number of LAMMPS atom types:\n\nfilename\nN element names = mapping of Vashishta elements to atom types\n\nSee the pair_coeff doc page for alternate ways\nto specify the path for the potential file.\nAs an example, imagine a file SiC.vashishta has parameters for\nSi and C.  If your LAMMPS simulation has 4 atoms types and you want\nthe 1st 3 to be Si, and the 4th to be C, you would use the following\npair_coeff command:\npair_coeff * * SiC.vashishta Si Si Si C\n\n\nThe 1st 2 arguments must be * * so as to span all LAMMPS atom types.\nThe first three Si arguments map LAMMPS atom types 1,2,3 to the Si\nelement in the file.  The final C argument maps LAMMPS atom type 4\nto the C element in the file.  If a mapping value is specified as\nNULL, the mapping is not performed.  This can be used when a vashishta\npotential is used as part of the hybrid pair style.  The NULL values\nare placeholders for atom types that will be used with other\npotentials.\nVashishta files in the potentials directory of the LAMMPS\ndistribution have a “.vashishta” suffix.  Lines that are not blank or\ncomments (starting with #) define parameters for a triplet of\nelements.  The parameters in a single entry correspond to the two-body\nand three-body coefficients in the formulae above:\n\nelement 1 (the center atom in a 3-body interaction)\nelement 2\nelement 3\nH (energy units)\n\\(\\eta\\)\n\\(Z_i\\) (electron charge units)\n\\(Z_j\\) (electron charge units)\n\\(\\lambda_1\\) (distance units)\nD (energy units)\n\\(\\lambda_4\\) (distance units)\nW (energy units)\n\\(r_c\\) (distance units)\nB (energy units)\n\\(\\gamma\\)\n\\(r_0\\) (distance units)\nC\n\\(\\cos\\theta_0\\)\n\nThe non-annotated parameters are unitless.  The Vashishta potential\nfile must contain entries for all the elements listed in the\npair_coeff command.  It can also contain entries for additional\nelements not being used in a particular simulation; LAMMPS ignores\nthose entries.  For a single-element simulation, only a single entry\nis required (e.g. SiSiSi).  For a two-element simulation, the file\nmust contain 8 entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC,\nCCSi, CCC), that specify parameters for all permutations of the two\nelements interacting in three-body configurations.  Thus for 3\nelements, 27 entries would be required, etc.\nDepending on the particular version of the Vashishta potential, the\nvalues of these parameters may be keyed to the identities of zero,\none, two, or three elements.  In order to make the input file format\nunambiguous, general, and simple to code, LAMMPS uses a slightly\nconfusing method for specifying parameters.  All parameters are\ndivided into two classes: two-body and three-body.  Two-body and\nthree-body parameters are handled differently, as described below.\nThe two-body parameters are H, \\(\\eta\\), \\(\\lambda_1\\),\nD, \\(\\lambda_4\\), W, \\(r_c\\), \\(\\gamma\\),\nand \\(r_0\\).  They appear in the above formulae with two subscripts.\nThe parameters \\(Z_i\\) and \\(Z_j\\) are also classified\nas two-body parameters, even\nthough they only have 1 subscript.  The three-body parameters are B,\nC, \\(\\cos\\theta_0\\).  They appear in the above formulae with\nthree subscripts.  Two-body and three-body parameters are handled\ndifferently, as described below.\nThe first element in each entry is the center atom in a three-body\ninteraction, while the second and third elements are two neighbor\natoms. Three-body parameters for a central atom I and two neighbors J\nand K are taken from the IJK entry.  Note that even though three-body\nparameters do not depend on the order of J and K, LAMMPS stores\nthree-body parameters for both IJK and IKJ.  The user must ensure that\nthese values are equal.  Two-body parameters for an atom I interacting\nwith atom J are taken from the IJJ entry, where the 2nd and 3rd\nelements are the same. Thus the two-body parameters for Si interacting\nwith C come from the SiCC entry. Note that even though two-body\nparameters (except possibly gamma and r0 in U3) do not depend on the\norder of the two elements, LAMMPS will get the Si-C value from the\nSiCC entry and the C-Si value from the CSiSi entry. The user must\nensure that these values are equal. Two-body parameters appearing in\nentries where the 2nd and 3rd elements are different are stored but\nnever used. It is good practice to enter zero for these values. Note\nthat the three-body function U3 above contains the two-body parameters\n\\(\\gamma\\) and \\(r_0\\). So U3 for a central C atom bonded to\nan Si atom and a\nsecond C atom will take three-body parameters from the CSiC entry, but\ntwo-body parameters from the CCC and CSiSi entries.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, where types I and J correspond to\ntwo different element types, mixing is performed by LAMMPS as\ndescribed above from values in the potential file.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\nneed to re-specify the pair_style and pair_coeff commands in an input\nscript that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style style args",
    "parameters": " * style = vashishta or vashishta/table or vashishta/omp or vashishta/table/omp\n * args = list of arguments for a particular style\n * vashishta or vashishta/omp args = none\n * vashishta/table or vashishta/table/omp args = Ntable cutinner\n *   Ntable = # of tabulation points\n *   cutinner = tablulate from cutinner to cutoff",
    "examples": "pair_style vashishta\npair_coeff * * SiC.vashishta Si C\n\npair_style vashishta/table 100000 0.2\npair_coeff * * SiC.vashishta Si C",
    "restrictions": "These pair style are part of the MANYBODY package.  They is only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nThese pair styles requires the newton setting to be “on”\nfor pair interactions.\nThe Vashishta potential files provided with LAMMPS (see the potentials\ndirectory) are parameterized for metal units.  You can\nuse the Vashishta potential with any LAMMPS units, but you would need\nto create your own potential file with coefficients listed in the\nappropriate units if your simulation doesn’t use “metal” units."
},
{
    "command": "pair_write",
    "html_filename": "pair_write.html",
    "short_description": "Write energy and force values to a file as a function of distance for the currently defined pair potential",
    "description": "Write energy and force values to a file as a function of distance for\nthe currently defined pair potential.  This is useful for plotting the\npotential function or otherwise debugging its values.  If the file\nalready exists, the table of values is appended to the end of the file\nto allow multiple tables of energy and force to be included in one\nfile.\nThe energy and force values are computed at distances from inner to\nouter for 2 interacting atoms of type itype and jtype, using the\nappropriate pair_coeff coefficients.  If the style\nis r, then N distances are used, evenly spaced in r; if the style is\nrsq, N distances are used, evenly spaced in r^2.\nFor example, for N = 7, style = r, inner = 1.0, and outer = 4.0,\nvalues are computed at r = 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0.\nIf the style is bitmap, then 2^N values are written to the file in a\nformat and order consistent with how they are read in by the\npair_coeff command for pair style table.  For\nreasonable accuracy in a bitmapped table, choose N >= 12, an inner\nvalue that is smaller than the distance of closest approach of 2\natoms, and an outer value <= cutoff of the potential.\nIf the pair potential is computed between charged atoms, the charges\nof the pair of interacting atoms can optionally be specified.  If not\nspecified, values of Qi = Qj = 1.0 are used.\nThe file is written in the format used as input for the\npair_style table option with keyword as the\nsection name.  Each line written to the file lists an index number\n(1-N), a distance (in distance units), an energy (in energy units),\nand a force (in force units).",
    "syntax": "pair_write itype jtype N style inner outer file keyword Qi Qj",
    "parameters": " * itype,jtype = 2 atom types\n * N = # of values\n * style = r or rsq or bitmap\n * inner,outer = inner and outer cutoff (distance units)\n * file = name of file to write values to\n * keyword = section name in file for this set of tabulated values\n * Qi,Qj = 2 atom charges (charge units) (optional)",
    "examples": "pair_write 1 3 500 r 1.0 10.0 table.txt LJ\npair_write 1 1 1000 rsq 2.0 8.0 table.txt Yukawa_1_1 -0.5 0.5",
    "restrictions": "All force field coefficients for pair and other kinds of interactions\nmust be set before this command can be invoked.\nDue to how the pairwise force is computed, an inner value > 0.0 must\nbe specified even if the potential has a finite value at r = 0.0.\nFor EAM potentials, the pair_write command only tabulates the\npairwise portion of the potential, not the embedding portion."
},
{
    "command": "pair_style yukawa",
    "html_filename": "pair_yukawa.html",
    "short_description": "Style yukawa computes pairwise interactions with the formula  \\[E = A \\frac{e^{- \\kappa r}}{r} \\qquad r < r_c\\] \\(r_c\\) is the cutoff",
    "description": "Style yukawa computes pairwise interactions with the formula\n\n\\[E = A \\frac{e^{- \\kappa r}}{r} \\qquad r < r_c\\]\n\\(r_c\\) is the cutoff.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nA (energy*distance units)\ncutoff (distance units)\n\nThe last coefficient is optional.  If not specified, the global yukawa\ncutoff is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A coefficient and cutoff\ndistance for this pair style can be mixed.  A is an energy value mixed\nlike a LJ epsilon.  The default mix value is geometric.  See the\n“pair_modify” command for details.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style yukawa kappa cutoff",
    "parameters": " * kappa = screening length (inverse distance units)\n * cutoff = global cutoff for Yukawa interactions (distance units)",
    "examples": "pair_style yukawa 2.0 2.5\npair_coeff 1 1 100.0 2.3\npair_coeff * * 100.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style yukawa/colloid",
    "html_filename": "pair_yukawa_colloid.html",
    "short_description": "Style yukawa/colloid computes pairwise interactions with the formula  \\[E = \\frac{A}{\\kappa} e^{- \\kappa (r - (r_i + r_j))} \\qquad r < r_c\\] where \\(r_i\\) and \\(r_j\\) are the radii of the two particles and \\(r_c\\) is the cutoff",
    "description": "Style yukawa/colloid computes pairwise interactions with the formula\n\n\\[E = \\frac{A}{\\kappa} e^{- \\kappa (r - (r_i + r_j))} \\qquad r < r_c\\]\nwhere \\(r_i\\) and \\(r_j\\) are the radii of the two particles\nand \\(r_c\\) is the cutoff.\nIn contrast to pair_style yukawa, this functional\nform arises from the Coulombic interaction between two colloid\nparticles, screened due to the presence of an electrolyte, see the\nbook by Safran for a derivation in the context of DLVO\ntheory.  Pair_style yukawa is a screened Coulombic\npotential between two point-charges and uses no such approximation.\nThis potential applies to nearby particle pairs for which the Derjagin\napproximation holds, meaning \\(h << r_i + r_j\\), where h is the\nsurface-to-surface separation of the two particles.\nWhen used in combination with pair_style colloid,\nthe two terms become the so-called DLVO potential, which combines\nelectrostatic repulsion and van der Waals attraction.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\nA (energy/distance units)\ncutoff (distance units)\n\nThe prefactor A is determined from the relationship between surface\ncharge and surface potential due to the presence of electrolyte.  Note\nthat the A for this potential style has different units than the A\nused in pair_style yukawa.  For low surface\npotentials, i.e. less than about 25 mV, A can be written as:\n\n\\[A = 2 \\pi R\\varepsilon\\varepsilon_0 \\kappa \\psi^2\\]\nwhere\n\nR = colloid radius (distance units)\n\\(\\varepsilon_0\\) = permittivity of free space (charge^2/energy/distance units)\n\\(\\varepsilon\\) = relative permittivity of fluid medium (dimensionless)\n\\(\\kappa\\) = inverse screening length (1/distance units)\n\\(\\psi\\) = surface potential (energy/charge units)\n\nThe last coefficient is optional.  If not specified, the global\nyukawa/colloid cutoff is used.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs I,J and I != J, the A coefficient and cutoff\ndistance for this pair style can be mixed.  A is an energy value mixed\nlike a LJ epsilon.  The default mix value is geometric.  See the\n“pair_modify” command for details.\nThis pair style supports the pair_modify shift\noption for the energy of the pair interaction.\nThe pair_modify table option is not relevant\nfor this pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style yukawa/colloid kappa cutoff",
    "parameters": " * kappa = screening length (inverse distance units)\n * cutoff = global cutoff for colloidal Yukawa interactions (distance units)",
    "examples": "pair_style yukawa/colloid 2.0 2.5\npair_coeff 1 1 100.0 2.3\npair_coeff * * 100.0",
    "restrictions": "This style is part of the COLLOID package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nThis pair style requires that atoms be finite-size spheres with a\ndiameter, as defined by the atom_style sphere\ncommand.\nPer-particle polydispersity is not yet supported by this pair style;\nper-type polydispersity is allowed.  This means all particles of the\nsame type must have the same diameter.  Each type can have a different\ndiameter."
},
{
    "command": "pair_style zbl",
    "html_filename": "pair_zbl.html",
    "short_description": "Style zbl computes the Ziegler-Biersack-Littmark (ZBL) screened nuclear repulsion for describing high-energy collisions between atoms",
    "description": "Style zbl computes the Ziegler-Biersack-Littmark (ZBL) screened nuclear\nrepulsion for describing high-energy collisions between atoms.\n(Ziegler). It includes an additional switching function\nthat ramps the energy, force, and curvature smoothly to zero\nbetween an inner and outer cutoff. The potential\nenergy due to a pair of atoms at a distance r_ij is given by:\n\n\\[\\begin{split}E^{ZBL}_{ij} & = \\frac{1}{4\\pi\\epsilon_0} \\frac{Z_i Z_j \\,e^2}{r_{ij}} \\phi(r_{ij}/a)+ S(r_{ij})\\\\\na & =  \\frac{0.46850}{Z_{i}^{0.23} + Z_{j}^{0.23}}\\\\\n\\phi(x) & =  0.18175e^{-3.19980x} + 0.50986e^{-0.94229x} + 0.28022e^{-0.40290x} + 0.02817e^{-0.20162x}\\\\\\end{split}\\]\nwhere e is the electron charge, \\(\\epsilon_0\\) is the electrical\npermittivity of vacuum, and \\(Z_i\\) and \\(Z_j\\) are the nuclear\ncharges of the\ntwo atoms.  The switching function \\(S(r)\\) is identical to that used by\npair_style lj/gromacs.  Here, the inner and outer\ncutoff are the same for all pairs of atom types.\nThe following coefficients must be defined for each pair of atom types\nvia the pair_coeff command as in the examples above,\nor in the LAMMPS data file.\n\n\\(Z_i\\) (atomic number for first atom type, e.g. 13.0 for aluminum)\n\\(Z_j\\) (ditto for second atom type)\n\nThe values of \\(Z_i\\) and \\(Z_j\\) are normally equal to the atomic\nnumbers of the two atom types. Thus, the user may optionally\nspecify only the coefficients for each \\(i==i\\) pair, and rely\non the obvious mixing rule for cross interactions (see below).\nNote that when \\(i==i\\) it is required that \\(Z_i == Z_j\\).\nWhen used with hybrid/overlay and pairs are\nassigned\nto more than one sub-style, the mixing rule is not used and\neach pair of types interacting with the ZBL sub-style must\nbe included in a pair_coeff command.\n\nNote\nThe numerical values of the exponential decay constants in the\nscreening function depend on the unit of distance. In the above\nequation they are given for units of angstroms. LAMMPS will\nautomatically convert these values to the distance unit of the\nspecified LAMMPS units setting.  The values of Z should\nalways be given as multiples of a proton’s charge, e.g. 29.0 for\ncopper.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nFor atom type pairs i,j and \\(i \\neq i\\), the \\(Z_i\\) and\n\\(Z_j\\) coefficients\ncan be mixed by taking \\(Z_i\\) and \\(Z_j\\) from the values\nspecified for\n\\(i == i\\) and \\(j == j\\) cases. When used\nwith hybrid/overlay and pairs are assigned\nto more than one sub-style, the mixing rule is not used and\neach pair of types interacting with the ZBL sub-style\nmust be included in a pair_coeff command.\nThe pair_modify mix option has no effect on\nthe mixing behavior\nThe ZBL pair style does not support the pair_modify\nshift option, since the ZBL interaction is already smoothed to 0.0 at\nthe cutoff.\nThe pair_modify table option is not relevant for\nthis pair style.\nThis pair style does not support the pair_modify\ntail option for adding long-range tail corrections to energy and\npressure, since there are no corrections for a potential that goes to\n0.0 at the cutoff.\nThis pair style does not write information to binary restart files, so pair_style and pair_coeff commands must be\nspecified in an input script that reads a restart file.\nThis pair style can only be used via the pair keyword of the\nrun_style respa command.  It does not support the\ninner, middle, outer keywords.",
    "syntax": "pair_style zbl inner outer",
    "parameters": " * inner = distance where switching function begins\n * outer = global cutoff for ZBL interaction",
    "examples": "pair_style zbl 3.0 4.0\npair_coeff * * 73.0 73.0\npair_coeff 1 1 14.0 14.0",
    "restrictions": "\nnone"
},
{
    "command": "pair_style zero",
    "html_filename": "pair_zero.html",
    "short_description": "Define a global or per-type cutoff length for the purpose of building a neighbor list and acquiring ghost atoms, but do not compute any pairwise forces or energies",
    "description": "Define a global or per-type cutoff length for the purpose of\nbuilding a neighbor list and acquiring ghost atoms, but do\nnot compute any pairwise forces or energies.\nThis can be useful for fixes or computes which require a neighbor list\nto enumerate pairs of atoms within some cutoff distance, but when\npairwise forces are not otherwise needed.  Examples are the fix bond/create, compute rdf,\ncompute voronoi/atom commands.\nNote that the comm_modify cutoff command can be\nused to insure communication of ghost atoms even when a pair style is\nnot defined, but it will not trigger neighbor list generation.\nThe optional nocoeff flag allows to read data files with a PairCoeff\nsection for any pair style. Similarly, any pair_coeff commands\nwill only be checked for the atom type numbers and the rest ignored.\nIn this case, only the global cutoff will be used.\nThe following coefficients must be defined for each pair of atoms\ntypes via the pair_coeff command as in the examples\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands, or by mixing as described below:\n\ncutoff (distance units)\n\nThis coefficient is optional.  If not specified, the global cutoff\nspecified in the pair_style command is used. If the pair_style has\nbeen specified with the optional nocoeff flag, then a cutoff\npair coefficient is ignored.\n\nMixing, shift, table, tail correction, restart, rRESPA info:\nThe cutoff distance for this pair style can be mixed.  The default mix\nvalue is geometric.  See the “pair_modify” command for details.\nThis pair style does not support the pair_modify\nshift, table, and tail options.\nThis pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\nto be specified in an input script that reads a restart file.\nThis pair style supports the use of the inner, middle,\nand outer keywords of the run_style respa command.",
    "syntax": "pair_style zero cutoff [nocoeff]",
    "parameters": " * zero = style name of this pair style\n * cutoff = global cutoff (distance units)\n * nocoeff = ignore all pair_coeff parameters (optional)",
    "examples": "pair_style zero 10.0\npair_style zero 5.0 nocoeff\npair_coeff * *\npair_coeff 1 2*4 3.0",
    "restrictions": "none"
},
{
    "command": "pair_style thole",
    "html_filename": "pair_thole.html",
    "short_description": "The thole pair styles are meant to be used with force fields that include explicit polarization through Drude dipoles",
    "description": "The thole pair styles are meant to be used with force fields that\ninclude explicit polarization through Drude dipoles.  This link\ndescribes how to use the thermalized Drude oscillator model in LAMMPS and polarizable models in LAMMPS are\ndiscussed on the Howto polarizable doc page.\nThe thole pair style should be used as a sub-style within in the\npair_style hybrid/overlay command, in conjunction with a\nmain pair style including Coulomb interactions, i.e. any pair style\ncontaining coul/cut or coul/long in its style name.\nThe lj/cut/thole/long pair style is equivalent to, but more convenient that\nthe frequent combination hybrid/overlay lj/cut/coul/long cutoff thole damp\ncutoff2. It is not only a shorthand for this pair_style combination, but\nit also allows for mixing pair coefficients instead of listing them all.\nThe lj/cut/thole/long pair style is also a bit faster because it avoids an\noverlay and can benefit from OMP acceleration. Moreover, it uses a more\nprecise approximation of the direct Coulomb interaction at short range similar\nto coul/long/cs, which stabilizes the temperature of\nDrude particles.\nThe thole pair styles compute the Coulomb interaction damped at\nshort distances by a function\n\n\\[T_{ij}(r_{ij}) = 1 - \\left( 1 +\n\\frac{s_{ij} r_{ij} }{2} \\right)\n\\exp \\left( - s_{ij} r_{ij} \\right)\\]\nThis function results from an adaptation to point charges\n(Noskov) of the dipole screening scheme originally proposed\nby Thole. The scaling coefficient \\(s_{ij}\\) is determined\nby the polarizability of the atoms, \\(\\alpha_i\\), and by a Thole\ndamping parameter \\(a\\).  This Thole damping parameter usually takes\na value of 2.6, but in certain force fields the value can depend upon\nthe atom types. The mixing rule for Thole damping parameters is the\narithmetic average, and for polarizabilities the geometric average\nbetween the atom-specific values.\n\n\\[s_{ij} = \\frac{ a_{ij} }{\n(\\alpha_{ij})^{1/3} } = \\frac{ (a_i + a_j)/2 }{\n[(\\alpha_i\\alpha_j)^{1/2}]^{1/3} }\\]\nThe damping function is only applied to the interactions between the\npoint charges representing the induced dipoles on polarizable sites,\nthat is, charges on Drude particles, \\(q_{D,i}\\), and opposite\ncharges, \\(-q_{D,i}\\), located on the respective core particles\n(to which each Drude particle is bonded). Therefore, Thole screening\nis not applied to the full charge of the core particle \\(q_i\\), but\nonly to the \\(-q_{D,i}\\) part of it.\nThe interactions between core charges are subject to the weighting\nfactors set by the special_bonds command. The\ninteractions between Drude particles and core charges or\nnon-polarizable atoms are also subject to these weighting factors. The\nDrude particles inherit the 1-2, 1-3 and 1-4 neighbor relations from\ntheir respective cores.\nFor pair_style thole, the following coefficients must be defined for\neach pair of atoms types via the pair_coeff command\nas in the example above.\n\n\\(\\alpha\\) (distance units^3)\ndamp\ncutoff (distance units)\n\nThe last two coefficients are optional.  If not specified the global\nThole damping parameter or global cutoff specified in the pair_style\ncommand are used. In order to specify a cutoff (third argument) a damp\nparameter (second argument) must also be specified.\nFor pair style lj/cut/thole/long, the following coefficients must be\ndefined for each pair of atoms types via the pair_coeff\ncommand.\n\n\\(\\epsilon\\) (energy units)\n\\(\\sigma\\) (length units)\n\\(\\alpha\\) (distance units^3)\ndamp\nLJ cutoff (distance units)\n\nThe last two coefficients are optional and default to the global values from\nthe pair_style command line.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\nMixing:\nThe thole pair style does not support mixing.  Thus, coefficients\nfor all I,J pairs must be specified explicitly.\nThe lj/cut/thole/long pair style does support mixing. Mixed coefficients\nare defined using\n\n\\[\\begin{split}\\alpha_{ij} = & \\sqrt{\\alpha_i\\alpha_j} \\\\\n& \\\\\na_{ij} = & \\frac 1 2 (a_i + a_j)\\end{split}\\]",
    "syntax": "pair_style style args",
    "parameters": " * style = thole or lj/cut/thole/long or lj/cut/thole/long/omp\n * args = list of arguments for a particular style\n * thole args = damp cutoff\n *   damp = global damping parameter\n *   cutoff = global cutoff (distance units)\n * lj/cut/thole/long or lj/cut/thole/long/omp args = damp cutoff (cutoff2)\n *   damp = global damping parameter\n *   cutoff = global cutoff for LJ (and Thole if only 1 arg) (distance units)\n *   cutoff2 = global cutoff for Thole (optional) (distance units)",
    "examples": "pair_style hybrid/overlay ... thole 2.6 12.0\npair_coeff 1 1 thole 1.0\npair_coeff 1 2 thole 1.0 2.6 10.0\npair_coeff * 2 thole 1.0 2.6\n\npair_style lj/cut/thole/long 2.6 12.0",
    "restrictions": "These pair styles are part of the USER-DRUDE package. They are only\nenabled if LAMMPS was built with that package. See the Build package doc page for more info.\nThis pair_style should currently not be used with the charmm dihedral style if the latter has non-zero 1-4 weighting\nfactors. This is because the thole pair style does not know which\npairs are 1-4 partners of which dihedrals.\nThe lj/cut/thole/long pair style should be used with a Kspace solver\nlike PPPM or Ewald, which is only enabled if LAMMPS was built with the kspace\npackage."
},
{
    "command": "dihedral_style spherical",
    "html_filename": "dihedral_spherical.html",
    "short_description": "The spherical dihedral style uses the potential:   \\[\\begin{split}E(\\phi,\\theta_1,\\theta_2) & = \\sum_{i=1}^N\\nolimits\\ C_i\\ \\Phi_i(\\phi)\\ \\Theta_{1i}(\\theta_1)\\ \\Theta_{2i}(\\theta_2) \\\\ \\Phi_{i}(\\phi)            & = u_i - \\mathrm{cos}((\\phi   - a_i)K_i) \\\\ \\Theta_{1i}(\\theta_1)     & = v_i - \\mathrm{cos}((\\theta_1-b_i)L_i) \\\\ \\Theta_{2i}(\\theta_2)     & = w_i - \\mathrm{cos}((\\theta_2-c_i)M_i)\\end{split}\\] For this dihedral style, the energy can be any function that combines the 4-body dihedral-angle (\\(\\phi\\)) and the two 3-body bond-angles (\\(\\theta_1\\), \\(\\theta_2\\))",
    "description": "The spherical dihedral style uses the potential:\n\n\n\\[\\begin{split}E(\\phi,\\theta_1,\\theta_2) & = \\sum_{i=1}^N\\nolimits\\ C_i\\ \\Phi_i(\\phi)\\ \\Theta_{1i}(\\theta_1)\\ \\Theta_{2i}(\\theta_2) \\\\\n\\Phi_{i}(\\phi)            & = u_i - \\mathrm{cos}((\\phi   - a_i)K_i) \\\\\n\\Theta_{1i}(\\theta_1)     & = v_i - \\mathrm{cos}((\\theta_1-b_i)L_i) \\\\\n\\Theta_{2i}(\\theta_2)     & = w_i - \\mathrm{cos}((\\theta_2-c_i)M_i)\\end{split}\\]\nFor this dihedral style, the energy can be any function that combines the\n4-body dihedral-angle (\\(\\phi\\)) and the two 3-body bond-angles\n(\\(\\theta_1\\), \\(\\theta_2\\)).\nFor this reason, there is usually no need to define 3-body “angle” forces\nseparately for the atoms participating in these interactions.\nIt is probably more efficient to incorporate 3-body angle forces into\nthe dihedral interaction even if it requires adding additional terms to\nthe expansion (as was done in the second example).  A careful choice of\nparameters can prevent singularities that occur with traditional\nforce-fields whenever theta1 or theta2 approach 0 or 180 degrees.\nThe last example above corresponds to an interaction with a single energy\nminima located near \\(\\phi=93.9\\), \\(\\theta_1=74.4\\),\n\\(\\theta_2=48.1\\) degrees, and it remains numerically stable at all\nangles (\\(\\phi\\), \\(\\theta_1\\), \\(\\theta_2\\)). In this example,\nthe coefficients 49.1, and 25.2 can be physically interpreted as the\nharmonic spring constants for theta1 and theta2 around their minima.\nThe coefficient 69.3 is the harmonic spring constant for phi after\ndivision by sin(74.4)*sin(48.1) (the minima positions for theta1 and theta2).\nThe following coefficients must be defined for each dihedral type via the\ndihedral_coeff command as in the example above, or in\nthe Dihedral Coeffs section of a data file read by the\nread_data command:\n\n\\(n\\) (integer >= 1)\n\\(C_1\\) (energy)\n\\(K_1\\) (typically an integer)\n\\(a_1\\) (degrees)\n\\(u_1\\) (typically 0.0 or 1.0)\n\\(L_1\\) (typically an integer)\n\\(b_1\\) (degrees, typically 0.0 or 90.0)\n\\(v_1\\) (typically 0.0 or 1.0)\n\\(M_1\\) (typically an integer)\n\\(c_1\\) (degrees, typically 0.0 or 90.0)\n\\(w_1\\) (typically 0.0 or 1.0)\n[…]\n\\(C_n\\) (energy)\n\\(K_n\\) (typically an integer)\n\\(a_n\\) (degrees)\n\\(u_n\\) (typically 0.0 or 1.0)\n\\(L_n\\) (typically an integer)\n\\(b_n\\) (degrees, typically 0.0 or 90.0)\n\\(v_n\\) (typically 0.0 or 1.0)\n\\(M_n\\) (typically an integer)\n\\(c_n\\) (degrees, typically 0.0 or 90.0)\n\\(w_n\\) (typically 0.0 or 1.0)",
    "syntax": "dihedral_style spherical",
    "parameters": " * ",
    "examples": "dihedral_coeff 1 1  286.1  1 124  1    1 90.0 0    1 90.0 0\ndihedral_coeff 1 3  69.3   1 93.9 1    1 90   0    1 90   0  &\n                    49.1   0 0.00 0    1 74.4 1    0 0.00 0  &\n                    25.2   0 0.00 0    0 0.00 0    1 48.1 1",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "compute entropy/atom",
    "html_filename": "compute_entropy_atom.html",
    "short_description": "Define a computation that calculates the pair entropy fingerprint for each atom in the group",
    "description": "Define a computation that calculates the pair entropy fingerprint for\neach atom in the group. The fingerprint is useful to distinguish between\nordered and disordered environments, for instance liquid and solid-like\nenvironments, or glassy and crystalline-like environments. Some\napplications could be the identification of grain boundaries, a\nmelt-solid interface, or a solid cluster emerging from the melt.\nThe advantage of this parameter over others is that no a priori\ninformation about the solid structure is required.\nThis parameter for atom i is computed using the following formula from\n(Piaggi) and (Nettleton) ,\n\n\\[s_S^i=-2\\pi\\rho k_B \\int\\limits_0^{r_m} \\left [ g(r) \\ln g(r) - g(r) + 1 \\right ] r^2 dr\\]\nwhere r is a distance, g(r) is the radial distribution function of atom\ni and rho is the density of the system. The g(r) computed for each\natom i can be noisy and therefore it is smoothed using:\n\n\\[g_m^i(r) = \\frac{1}{4 \\pi \\rho r^2} \\sum\\limits_{j} \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} e^{-(r-r_{ij})^2/(2\\sigma^2)}\\]\nwhere the sum in j goes through the neighbors of atom i, and \\(\\sigma\\)\nis a parameter to control the smoothing.\nThe input parameters are sigma the smoothing parameter \\(\\sigma\\),\nand the cutoff for the calculation of g(r).\nIf the keyword avg has the setting yes, then this compute also\naverages the parameter over the neighbors  of atom i according to:\n\n\\[\\left< s_S^i \\right>  = \\frac{\\sum_j s_S^j + s_S^i}{N + 1}\\]\nwhere the sum j goes over the neighbors of atom i and N is the number\nof neighbors. This procedure provides a sharper distinction between\norder and disorder environments. In this case the input parameter\ncutoff2 is the cutoff for the averaging over the neighbors and\nmust also be specified.\nIf the avg yes option is used, the effective cutoff of the neighbor\nlist should be cutoff+cutoff2 and therefore it might be necessary\nto increase the skin of the neighbor list with:\nneighbor skin bin\n\n\nSee neighbor for details.\nIf the local yes option is used, the g(r) is normalized by the\nlocal density around each atom, that is to say the density around each\natom  is the number of neighbors within the neighbor list cutoff divided\nby the corresponding volume. This option can be useful when dealing with\ninhomogeneous systems such as those that have surfaces.\nHere are typical input parameters for fcc aluminum (lattice\nconstant 4.05 Angstroms),\ncompute 1 all entropy/atom 0.25 5.7 avg yes 3.7\n\n\nand for bcc sodium (lattice constant 4.23 Angstroms),\ncompute 1 all entropy/atom 0.25 7.3 avg yes 5.1\n\n\nOutput info:\nBy default, this compute calculates the pair entropy value for each\natom as a per-atom vector, which can be accessed by any command that\nuses per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\noptions.\nThe pair entropy values have units of the Boltzmann constant. They are\nalways negative, and lower values (lower entropy) correspond to more\nordered environments.",
    "syntax": "compute ID group-ID entropy/atom sigma cutoff keyword value ...",
    "parameters": " * ID, group-ID are documented in compute command\n * entropy/atom = style name of this compute command\n * sigma = width of gaussians used in the g(r) smoothing\n * cutoff = cutoff for the g(r) calculation\n * one or more keyword/value pairs may be appended\n * keyword = avg or local\n *   avg values = yes or no cutoff2\n *     yes = average the pair entropy over neighbors\n *     no = do not average the pair entropy over neighbors\n *     cutoff2 = cutoff for the averaging over neighbors\n *   local values = yes or no = use the local density around each atom to normalize the g(r)",
    "examples": "compute 1 all entropy/atom 0.25 5.\ncompute 1 all entropy/atom 0.25 5. avg yes 5.\ncompute 1 all entropy/atom 0.125 7.3 avg yes 5.1 local yes",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "angle_coeff",
    "html_filename": "angle_coeff.html",
    "short_description": "Specify the angle force field coefficients for one or more angle types",
    "description": "Specify the angle force field coefficients for one or more angle types.\nThe number and meaning of the coefficients depends on the angle style.\nAngle coefficients can also be set in the data file read by the\nread_data command or in a restart file.\nN can be specified in one of two ways.  An explicit numeric value can\nbe used, as in the 1st example above.  Or a wild-card asterisk can be\nused to set the coefficients for multiple angle types.  This takes the\nform “*” or “*n” or “n*” or “m*n”.  If N = the number of angle types,\nthen an asterisk with no numeric values means all types from 1 to N.  A\nleading asterisk means all types from 1 to n (inclusive).  A trailing\nasterisk means all types from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).\nNote that using an angle_coeff command can override a previous setting\nfor the same angle type.  For example, these commands set the coeffs\nfor all angle types, then overwrite the coeffs for just angle type 2:\nangle_coeff * 200.0 107.0 1.2\nangle_coeff 2 50.0 107.0\n\n\nA line in a data file that specifies angle coefficients uses the exact\nsame format as the arguments of the angle_coeff command in an input\nscript, except that wild-card asterisks should not be used since\ncoefficients for all N types must be listed in the file.  For example,\nunder the “Angle Coeffs” section of a data file, the line that\ncorresponds to the 1st example above would be listed as\n1 300.0 107.0\n\n\nThe angle_style class2 is an exception to this\nrule, in that an additional argument is used in the input script to\nallow specification of the cross-term coefficients.   See its\ndoc page for details.\n\nThe list of all angle styles defined in LAMMPS is given on the\nangle_style doc page.  They are also listed in more\ncompact form on the Commands angle doc\npage.\nOn either of those pages, click on the style to display the formula it\ncomputes and its coefficients as specified by the associated\nangle_coeff command.",
    "syntax": "angle_coeff N args",
    "parameters": " * N = angle type (see asterisk form below)\n * args = coefficients for one or more angle types",
    "examples": "angle_coeff 1 300.0 107.0\nangle_coeff * 5.0\nangle_coeff 2*10 5.0",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command.\nAn angle style must be defined before any angle coefficients are\nset, either in the input script or in a data file."
},
{
    "command": "angle_style",
    "html_filename": "angle_style.html",
    "short_description": "Set the formula(s) LAMMPS uses to compute angle interactions between triplets of atoms, which remain in force for the duration of the simulation",
    "description": "Set the formula(s) LAMMPS uses to compute angle interactions between\ntriplets of atoms, which remain in force for the duration of the\nsimulation.  The list of angle triplets is read in by a\nread_data or read_restart command\nfrom a data or restart file.\nHybrid models where angles are computed using different angle\npotentials can be setup using the hybrid angle style.\nThe coefficients associated with a angle style can be specified in a\ndata or restart file or via the angle_coeff command.\nAll angle potentials store their coefficient data in binary restart\nfiles which means angle_style and angle_coeff\ncommands do not need to be re-specified in an input script that\nrestarts a simulation.  See the read_restart\ncommand for details on how to do this.  The one exception is that\nangle_style hybrid only stores the list of sub-styles in the restart\nfile; angle coefficients need to be re-specified.\n\nNote\nWhen both an angle and pair style is defined, the\nspecial_bonds command often needs to be used to\nturn off (or weight) the pairwise interaction that would otherwise\nexist between 3 bonded atoms.\n\nIn the formulas listed for each angle style, theta is the angle\nbetween the 3 atoms in the angle.\n\nHere is an alphabetic list of angle styles defined in LAMMPS.  Click on\nthe style to display the formula it computes and coefficients\nspecified by the associated angle_coeff command.\nClick on the style to display the formula it computes, any additional\narguments specified in the angle_style command, and coefficients\nspecified by the associated angle_coeff command.\nThere are also additional accelerated pair styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands angle doc page are followed by one or more\nof (g,i,k,o,t) to indicate which accelerated styles exist.\n\nnone - turn off angle interactions\nzero - topology but no interactions\nhybrid - define multiple styles of angle interactions\ncharmm - CHARMM angle\nclass2 - COMPASS (class 2) angle\nclass2/p6 - COMPASS (class 2) angle expanded to 6th order\ncosine - angle with cosine term\ncosine/buck6d - same as cosine with Buckingham term between 1-3 atoms\ncosine/delta - angle with difference of cosines\ncosine/periodic - DREIDING angle\ncosine/shift - angle cosine with a shift\ncosine/shift/exp - cosine with shift and exponential term in spring constant\ncosine/squared - angle with cosine squared term\ncross - cross term coupling angle and bond lengths\ndipole - angle that controls orientation of a point dipole\nfourier - angle with multiple cosine terms\nfourier/simple - angle with a single cosine term\nharmonic - harmonic angle\nmm3 - anharmonic angle\nquartic - angle with cubic and quartic terms\nsdk - harmonic angle with repulsive SDK pair style between 1-3 atoms\ntable - tabulated by angle",
    "syntax": "angle_style style",
    "parameters": " * style = none or hybrid or charmm or class2 or cosine or         cosine/squared or harmonic",
    "examples": "angle_style harmonic\nangle_style charmm\nangle_style hybrid harmonic cosine",
    "restrictions": "Angle styles can only be set for atom_styles that allow angles to be\ndefined.\nMost angle styles are part of the MOLECULE package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual bond potentials tell if it is part of a package."
},
{
    "command": "atom_modify",
    "html_filename": "atom_modify.html",
    "short_description": "Modify certain attributes of atoms defined and stored within LAMMPS, in addition to what is specified by the atom_style command",
    "description": "Modify certain attributes of atoms defined and stored within LAMMPS,\nin addition to what is specified by the atom_style\ncommand.  The id and map keywords must be specified before a\nsimulation box is defined; other keywords can be specified any time.\nThe id keyword determines whether non-zero atom IDs can be assigned\nto each atom.  If the value is yes, which is the default, IDs are\nassigned, whether you use the create atoms or\nread_data or read_restart\ncommands to initialize atoms.  If the value is no the IDs for all\natoms are assumed to be 0.\nIf atom IDs are used, they must all be positive integers.  They should\nalso be unique, though LAMMPS does not check for this.  Typically they\nshould also be consecutively numbered (from 1 to Natoms), though this\nis not required.  Molecular atom styles are those\nthat store bond topology information (styles bond, angle, molecular,\nfull).  These styles require atom IDs since the IDs are used to encode\nthe topology.  Some other LAMMPS commands also require the use of atom\nIDs.  E.g. some many-body pair styles use them to avoid double\ncomputation of the I-J interaction between two atoms.\nThe only reason not to use atom IDs is if you are running an atomic\nsimulation so large that IDs cannot be uniquely assigned.  For a\ndefault LAMMPS build this limit is 2^31 or about 2 billion atoms.\nHowever, even in this case, you can use 64-bit atom IDs, allowing 2^63\nor about 9e18 atoms, if you build LAMMPS with the - DLAMMPS_BIGBIG\nswitch.  This is described on the Build_settings\ndoc page.  If atom IDs are not used, they must be specified as 0 for\nall atoms, e.g. in a data or restart file.\nThe map keyword determines how atoms with specific IDs are found\nwhen required.  An example are the bond (angle, etc) methods which\nneed to find the local index of an atom with a specific global ID\nwhich is a bond (angle, etc) partner.  LAMMPS performs this operation\nefficiently by creating a “map”, which is either an array or hash\ntable, as described below.\nWhen the map keyword is not specified in your input script, LAMMPS\nonly creates a map for atom_styles for molecular\nsystems which have permanent bonds (angles, etc).  No map is created\nfor atomic systems, since it is normally not needed.  However some\nLAMMPS commands require a map, even for atomic systems, and will\ngenerate an error if one does not exist.  The map keyword thus\nallows you to force the creation of a map.  The yes value will\ncreate either an array or hash style map, as explained in the next\nparagraph.  The array and hash values create an atom-style or\nhash-style map respectively.\nFor an array-style map, each processor stores a lookup table of\nlength N, where N is the largest atom ID in the system.  This is a\nfast, simple method for many simulations, but requires too much memory\nfor large simulations.  For a hash-style map, a hash table is\ncreated on each processor, which finds an atom ID in constant time\n(independent of the global number of atom IDs).  It can be slightly\nslower than the array map, but its memory cost is proportional to\nthe number of atoms owned by a processor, i.e. N/P when N is the total\nnumber of atoms in the system and P is the number of processors.\nThe first keyword allows a group to be specified whose\natoms will be maintained as the first atoms in each processor’s list\nof owned atoms.  This in only useful when the specified group is a\nsmall fraction of all the atoms, and there are other operations LAMMPS\nis performing that will be sped-up significantly by being able to loop\nover the smaller set of atoms.  Otherwise the reordering required by\nthis option will be a net slow-down.  The neigh_modify include and comm_modify group\ncommands are two examples of commands that require this setting to\nwork efficiently.  Several fixes, most notably time\nintegration fixes like fix nve, also take advantage of\nthis setting if the group they operate on is the group specified by\nthis command.  Note that specifying “all” as the group-ID effectively\nturns off the first option.\nIt is OK to use the first keyword with a group that has not yet been\ndefined, e.g. to use the atom_modify first command at the beginning of\nyour input script.  LAMMPS does not use the group until a simulation\nis run.\nThe sort keyword turns on a spatial sorting or reordering of atoms\nwithin each processor’s sub-domain every Nfreq timesteps.  If\nNfreq is set to 0, then sorting is turned off.  Sorting can improve\ncache performance and thus speed-up a LAMMPS simulation, as discussed\nin a paper by (Meloni).  Its efficacy depends on the problem\nsize (atoms/processor), how quickly the system becomes disordered, and\nvarious other factors.  As a general rule, sorting is typically more\neffective at speeding up simulations of liquids as opposed to solids.\nIn tests we have done, the speed-up can range from zero to 3-4x.\nReordering is performed every Nfreq timesteps during a dynamics run\nor iterations during a minimization.  More precisely, reordering\noccurs at the first reneighboring that occurs after the target\ntimestep.  The reordering is performed locally by each processor,\nusing bins of the specified binsize.  If binsize is set to 0.0,\nthen a binsize equal to half the neighbor cutoff\ndistance (force cutoff plus skin distance) is used, which is a\nreasonable value.  After the atoms have been binned, they are\nreordered so that atoms in the same bin are adjacent to each other in\nthe processor’s 1d list of atoms.\nThe goal of this procedure is for atoms to put atoms close to each\nother in the processor’s one-dimensional list of atoms that are also\nnear to each other spatially.  This can improve cache performance when\npairwise interactions and neighbor lists are computed.  Note that if\nbins are too small, there will be few atoms/bin.  Likewise if bins are\ntoo large, there will be many atoms/bin.  In both cases, the goal of\ncache locality will be undermined.\n\nNote\nRunning a simulation with sorting on versus off should not\nchange the simulation results in a statistical sense.  However, a\ndifferent ordering will induce round-off differences, which will lead\nto diverging trajectories over time when comparing two simulations.\nVarious commands, particularly those which use random numbers\n(e.g. velocity create, and fix langevin), may generate (statistically identical)\nresults which depend on the order in which atoms are processed.  The\norder of atoms in a dump file will also typically change\nif sorting is enabled.",
    "syntax": "atom_modify keyword values ...",
    "parameters": " * one or more keyword/value pairs may be appended\n * keyword = id or map or first or sort\n * id value = yes or no\n * map value = yes or array or hash\n * first value = group-ID = group whose atoms will appear first in internal atom lists\n * sort values = Nfreq binsize\n *   Nfreq = sort atoms spatially every this many time steps\n *   binsize = bin size for spatial sorting (distance units)",
    "examples": "atom_modify map yes\natom_modify map hash sort 10000 2.0\natom_modify first colloid",
    "restrictions": "The first and sort options cannot be used together.  Since sorting\nis on by default, it will be turned off if the first keyword is\nused with a group-ID that is not “all”.\nRelated commands: none"
},
{
    "command": "atom_style",
    "html_filename": "atom_style.html",
    "short_description": "Define what style of atoms to use in a simulation",
    "description": "Define what style of atoms to use in a simulation.  This determines\nwhat attributes are associated with the atoms.  This command must be\nused before a simulation is setup via a read_data,\nread_restart, or create_box\ncommand.\n\nNote\nMany of the atom styles discussed here are only enabled if\nLAMMPS was built with a specific package, as listed below in the\nRestrictions section.\n\nOnce a style is assigned, it cannot be changed, so use a style general\nenough to encompass all attributes.  E.g. with style bond, angular\nterms cannot be used or added later to the model.  It is OK to use a\nstyle more general than needed, though it may be slightly inefficient.\nThe choice of style affects what quantities are stored by each atom,\nwhat quantities are communicated between processors to enable forces\nto be computed, and what quantities are listed in the data file read\nby the read_data command.\nThese are the additional attributes of each style and the typical\nkinds of physical systems they are used to model.  All styles store\ncoordinates, velocities, atom IDs and types.  See the\nread_data, create_atoms, and\nset commands for info on how to set these various\nquantities.\n\n\n\n\n\n\n\nangle\nbonds and angles\nbead-spring polymers with stiffness\n\natomic\nonly the default values\ncoarse-grain liquids, solids, metals\n\nbody\nmass, inertia moments, quaternion, angular momentum\narbitrary bodies\n\nbond\nbonds\nbead-spring polymers\n\ncharge\ncharge\natomic system with charges\n\ndipole\ncharge and dipole moment\nsystem with dipolar particles\n\ndpd\ninternal temperature and internal energies\nDPD particles\n\nedpd\ntemperature and heat capacity\neDPD particles\n\nmdpd\ndensity\nmDPD particles\n\ntdpd\nchemical concentration\ntDPD particles\n\nelectron\ncharge and spin and eradius\nelectronic force field\n\nellipsoid\nshape, quaternion, angular momentum\naspherical particles\n\nfull\nmolecular + charge\nbio-molecules\n\nline\nend points, angular velocity\nrigid bodies\n\nmeso\nrho, e, cv\nSPH particles\n\nmolecular\nbonds, angles, dihedrals, impropers\nuncharged molecules\n\nperi\nmass, volume\nmesoscopic Peridynamic models\n\nsmd\nvolume, kernel diameter, contact radius, mass\nsolid and fluid SPH particles\n\nsphere\ndiameter, mass, angular velocity\ngranular models\n\nspin\nmagnetic moment\nsystem with magnetic particles\n\ntemplate\ntemplate index, template atom\nsmall molecules with fixed topology\n\ntri\ncorner points, angular momentum\nrigid bodies\n\nwavepacket\ncharge, spin, eradius, etag, cs_re, cs_im\nAWPMD\n\n\n\n\nNote\nIt is possible to add some attributes, such as a molecule ID, to\natom styles that do not have them via the fix property/atom command.  This command also\nallows new custom attributes consisting of extra integer or\nfloating-point values to be added to atoms.  See the fix property/atom doc page for examples of cases\nwhere this is useful and details on how to initialize, access, and\noutput the custom values.\n\nAll of the above styles define point particles, except the sphere,\nellipsoid, electron, peri, wavepacket, line, tri, and\nbody styles, which define finite-size particles.  See the Howto spherical doc page for an overview of using\nfinite-size particle models with LAMMPS.\nAll of the point-particle styles assign mass to particles on a\nper-type basis, using the mass command, The finite-size\nparticle styles assign mass to individual particles on a per-particle\nbasis.\nFor the sphere style, the particles are spheres and each stores a\nper-particle diameter and mass.  If the diameter > 0.0, the particle\nis a finite-size sphere.  If the diameter = 0.0, it is a point\nparticle.  Note that by use of the disc keyword with the fix nve/sphere, fix nvt/sphere,\nfix nph/sphere, fix npt/sphere commands, spheres can be effectively\ntreated as 2d discs for a 2d simulation if desired.  See also the set density/disc command.\nFor the ellipsoid style, the particles are ellipsoids and each\nstores a flag which indicates whether it is a finite-size ellipsoid or\na point particle.  If it is an ellipsoid, it also stores a shape\nvector with the 3 diameters of the ellipsoid and a quaternion 4-vector\nwith its orientation.\nFor the dipole style, a point dipole is defined for each point\nparticle.  Note that if you wish the particles to be finite-size\nspheres as in a Stockmayer potential for a dipolar fluid, so that the\nparticles can rotate due to dipole-dipole interactions, then you need\nto use atom_style hybrid sphere dipole, which will assign both a\ndiameter and dipole moment to each particle.\nFor the electron style, the particles representing electrons are 3d\nGaussians with a specified position and bandwidth or uncertainty in\nposition, which is represented by the eradius = electron size.\nFor the peri style, the particles are spherical and each stores a\nper-particle mass and volume.\nThe dpd style is for dissipative particle dynamics (DPD) particles.\nNote that it is part of the USER-DPD package, and is not for use with\nthe pair_style dpd or dpd/stat commands, which can\nsimply use atom_style atomic.  Atom_style dpd extends DPD particle\nproperties with internal temperature (dpdTheta), internal conductive\nenergy (uCond), internal mechanical energy (uMech), and internal\nchemical energy (uChem).\nThe edpd style is for energy-conserving dissipative particle\ndynamics (eDPD) particles which store a temperature (edpd_temp), and\nheat capacity(edpd_cv).\nThe mdpd style is for many-body dissipative particle dynamics (mDPD)\nparticles which store a density (rho) for considering\ndensity-dependent many-body interactions.\nThe tdpd style is for transport dissipative particle dynamics (tDPD)\nparticles which store a set of chemical concentration. An integer\n“cc_species” is required to specify the number of chemical species\ninvolved in a tDPD system.\nThe meso style is for smoothed particle hydrodynamics (SPH)\nparticles which store a density (rho), energy (e), and heat capacity\n(cv).\nThe smd style is for a general formulation of Smooth Particle\nHydrodynamics.  Both fluids and solids can be modeled.  Particles\nstore the mass and volume of an integration point, a kernel diameter\nused for calculating the field variables (e.g. stress and deformation)\nand a contact radius for calculating repulsive forces which prevent\nindividual physical bodies from penetrating each other.\nFor the spin style, a magnetic spin is associated to each atom.\nThose spins have a norm (their magnetic moment) and a direction.\nThe wavepacket style is similar to electron, but the electrons may\nconsist of several Gaussian wave packets, summed up with coefficients\ncs= (cs_re,cs_im).  Each of the wave packets is treated as a separate\nparticle in LAMMPS, wave packets belonging to the same electron must\nhave identical etag values.\nFor the line style, the particles are idealized line segments and\neach stores a per-particle mass and length and orientation (i.e. the\nend points of the line segment).\nFor the tri style, the particles are planar triangles and each\nstores a per-particle mass and size and orientation (i.e. the corner\npoints of the triangle).\nThe template style allows molecular topology (bonds,angles,etc) to be\ndefined via a molecule template using the molecule\ncommand.  The template stores one or more molecules with a single copy\nof the topology info (bonds,angles,etc) of each.  Individual atoms\nonly store a template index and template atom to identify which\nmolecule and which atom-within-the-molecule they represent.  Using the\ntemplate style instead of the bond, angle, molecular styles\ncan save memory for systems comprised of a large number of small\nmolecules, all of a single type (or small number of types).  See the\npaper by Grime and Voth, in (Grime), for examples of how this\ncan be advantageous for large-scale coarse-grained systems.\n\nNote\nWhen using the template style with a molecule template that contains multiple molecules, you should\ninsure the atom types, bond types, angle_types, etc in all the\nmolecules are consistent.  E.g. if one molecule represents H2O and\nanother CO2, then you probably do not want each molecule file to\ndefine 2 atom types and a single bond type, because they will conflict\nwith each other when a mixture system of H2O and CO2 molecules is\ndefined, e.g. by the read_data command.  Rather the\nH2O molecule should define atom types 1 and 2, and bond type 1.  And\nthe CO2 molecule should define atom types 3 and 4 (or atom types 3 and\n2 if a single oxygen type is desired), and bond type 2.\n\nFor the body style, the particles are arbitrary bodies with internal\nattributes defined by the “style” of the bodies, which is specified by\nthe bstyle argument.  Body particles can represent complex entities,\nsuch as surface meshes of discrete points, collections of\nsub-particles, deformable objects, etc.\nThe Howto body doc page describes the body styles\nLAMMPS currently supports, and provides more details as to the kind of\nbody particles they represent.  For all styles, each body particle\nstores moments of inertia and a quaternion 4-vector, so that its\norientation and position can be time integrated due to forces and\ntorques.\nNote that there may be additional arguments required along with the\nbstyle specification, in the atom_style body command.  These\narguments are described on the Howto body doc page.\n\nTypically, simulations require only a single (non-hybrid) atom style.\nIf some atoms in the simulation do not have all the properties defined\nby a particular style, use the simplest style that defines all the\nneeded properties by any atom.  For example, if some atoms in a\nsimulation are charged, but others are not, use the charge style.\nIf some atoms have bonds, but others do not, use the bond style.\nThe only scenario where the hybrid style is needed is if there is no\nsingle style which defines all needed properties of all atoms.  For\nexample, as mentioned above, if you want dipolar particles which will\nrotate due to torque, you need to use “atom_style hybrid sphere\ndipole”.  When a hybrid style is used, atoms store and communicate the\nunion of all quantities implied by the individual styles.\nWhen using the hybrid style, you cannot combine the template style\nwith another molecular style that stores bond,angle,etc info on a\nper-atom basis.\nLAMMPS can be extended with new atom styles as well as new body\nstyles; see the Modify doc page.\n\nStyles with a kk suffix are functionally the same as the\ncorresponding style without the suffix.  They have been optimized to\nrun faster, depending on your available hardware, as discussed in on\nthe Speed packages doc page.  The accelerated\nstyles take the same arguments and should produce the same results,\nexcept for round-off and precision issues.\nNote that other acceleration packages in LAMMPS, specifically the GPU,\nUSER-INTEL, USER-OMP, and OPT packages do not use accelerated atom\nstyles.\nThe accelerated styles are part of the KOKKOS package.  They are only\nenabled if LAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "atom_style style args",
    "parameters": " * style = angle or atomic or body or bond or charge or dipole or         dpd or edpd or mdpd or tdpd or electron or ellipsoid or         full or line or meso or molecular or peri or smd or         sphere or spin or tri or template or hybrid\n * args = none for any style except the following\n *   body args = bstyle bstyle-args\n *     bstyle = style of body particles\n *     bstyle-args = additional arguments specific to the bstyle\n *                   see the Howto body doc page for details\n *   tdpd arg = Nspecies\n *     Nspecies = # of chemical species\n *   template arg = template-ID\n *     template-ID = ID of molecule template specified in a separate molecule command\n *   hybrid args = list of one or more sub-styles, each with their args\n * accelerated styles (with same args) = angle/kk or atomic/kk or bond/kk or charge/kk or full/kk or molecular/kk",
    "examples": "atom_style atomic\natom_style bond\natom_style full\natom_style body nparticle 2 10\natom_style hybrid charge bond\natom_style hybrid charge body nparticle 2 5\natom_style spin\natom_style template myMols\natom_style tdpd 2",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command.\nMany of the styles listed above are only enabled if LAMMPS was built\nwith a specific package, as listed below.  See the Build package doc page for more info.\nThe angle, bond, full, molecular, and template styles are\npart of the MOLECULE package.\nThe line and tri styles are part of the ASPHERE package.\nThe body style is part of the BODY package.\nThe dipole style is part of the DIPOLE package.\nThe peri style is part of the PERI package for Peridynamics.\nThe electron style is part of the USER-EFF package for electronic force fields.\nThe dpd style is part of the USER-DPD package for dissipative\nparticle dynamics (DPD).\nThe edpd, mdpd, and tdpd styles are part of the USER-MESO package\nfor energy-conserving dissipative particle dynamics (eDPD), many-body\ndissipative particle dynamics (mDPD), and transport dissipative particle\ndynamics (tDPD), respectively.\nThe meso style is part of the USER-SPH package for smoothed particle\nhydrodynamics (SPH).  See this PDF guide to using SPH in LAMMPS.\nThe spin style is part of the SPIN package.\nThe wavepacket style is part of the USER-AWPMD package for the\nantisymmetrized wave packet MD method."
},
{
    "command": "balance",
    "html_filename": "balance.html",
    "short_description": "This command adjusts the size and shape of processor sub-domains within the simulation box, to attempt to balance the number of atoms or particles and thus indirectly the computational cost (load) more evenly across processors",
    "description": "This command adjusts the size and shape of processor sub-domains\nwithin the simulation box, to attempt to balance the number of atoms\nor particles and thus indirectly the computational cost (load) more\nevenly across processors.  The load balancing is “static” in the sense\nthat this command performs the balancing once, before or between\nsimulations.  The processor sub-domains will then remain static during\nthe subsequent run.  To perform “dynamic” balancing, see the fix balance command, which can adjust processor\nsub-domain sizes and shapes on-the-fly during a run.\nLoad-balancing is typically most useful if the particles in the\nsimulation box have a spatially-varying density distribution or when\nthe computational cost varies significantly between different\nparticles.  E.g. a model of a vapor/liquid interface, or a solid with\nan irregular-shaped geometry containing void regions, or hybrid pair style simulations which combine pair styles with\ndifferent computational cost.  In these cases, the LAMMPS default of\ndividing the simulation box volume into a regular-spaced grid of 3d\nbricks, with one equal-volume sub-domain per processor, may assign\nnumbers of particles per processor in a way that the computational\neffort varies significantly.  This can lead to poor performance when\nthe simulation is run in parallel.\nThe balancing can be performed with or without per-particle weighting.\nWith no weighting, the balancing attempts to assign an equal number of\nparticles to each processor.  With weighting, the balancing attempts\nto assign an equal aggregate computational weight to each processor,\nwhich typically induces a different number of atoms assigned to each\nprocessor.  Details on the various weighting options and examples for\nhow they can be used are given below.\nNote that the processors command allows some control\nover how the box volume is split across processors.  Specifically, for\na Px by Py by Pz grid of processors, it allows choice of Px, Py, and\nPz, subject to the constraint that Px * Py * Pz = P, the total number\nof processors.  This is sufficient to achieve good load-balance for\nsome problems on some processor counts.  However, all the processor\nsub-domains will still have the same shape and same volume.\nThe requested load-balancing operation is only performed if the\ncurrent “imbalance factor” in particles owned by each processor\nexceeds the specified thresh parameter.  The imbalance factor is\ndefined as the maximum number of particles (or weight) owned by any\nprocessor, divided by the average number of particles (or weight) per\nprocessor.  Thus an imbalance factor of 1.0 is perfect balance.\nAs an example, for 10000 particles running on 10 processors, if the\nmost heavily loaded processor has 1200 particles, then the factor is\n1.2, meaning there is a 20% imbalance.  Note that a re-balance can be\nforced even if the current balance is perfect (1.0) be specifying a\nthresh < 1.0.\n\nNote\nBalancing is performed even if the imbalance factor does not\nexceed the thresh parameter if a “grid” style is specified when the\ncurrent partitioning is “tiled”.  The meaning of “grid” vs “tiled” is\nexplained below.  This is to allow forcing of the partitioning to\n“grid” so that the comm_style brick command can then\nbe used to replace a current comm_style tiled\nsetting.\n\nWhen the balance command completes, it prints statistics about the\nresult, including the change in the imbalance factor and the change in\nthe maximum number of particles on any processor.  For “grid” methods\n(defined below) that create a logical 3d grid of processors, the\npositions of all cutting planes in each of the 3 dimensions (as\nfractions of the box length) are also printed.\n\nNote\nThis command attempts to minimize the imbalance factor, as\ndefined above.  But depending on the method a perfect balance (1.0)\nmay not be achieved.  For example, “grid” methods (defined below) that\ncreate a logical 3d grid cannot achieve perfect balance for many\nirregular distributions of particles.  Likewise, if a portion of the\nsystem is a perfect lattice, e.g. the initial system is generated by\nthe create_atoms command, then “grid” methods may\nbe unable to achieve exact balance.  This is because entire lattice\nplanes will be owned or not owned by a single processor.\n\n\nNote\nThe imbalance factor is also an estimate of the maximum speed-up\nyou can hope to achieve by running a perfectly balanced simulation\nversus an imbalanced one.  In the example above, the 10000 particle\nsimulation could run up to 20% faster if it were perfectly balanced,\nversus when imbalanced.  However, computational cost is not strictly\nproportional to particle count, and changing the relative size and\nshape of processor sub-domains may lead to additional computational\nand communication overheads, e.g. in the PPPM solver used via the\nkspace_style command.  Thus you should benchmark\nthe run times of a simulation before and after balancing.\n\n\nThe method used to perform a load balance is specified by one of the\nlisted styles (or more in the case of x,y,z), which are\ndescribed in detail below.  There are 2 kinds of styles.\nThe x, y, z, and shift styles are “grid” methods which produce\na logical 3d grid of processors.  They operate by changing the cutting\nplanes (or lines) between processors in 3d (or 2d), to adjust the\nvolume (area in 2d) assigned to each processor, as in the following 2d\ndiagram where processor sub-domains are shown and particles are\ncolored by the processor that owns them.  The leftmost diagram is the\ndefault partitioning of the simulation box across processors (one\nsub-box for each of 16 processors); the middle diagram is after a\n“grid” method has been applied.\n\n\n\nThe rcb style is a “tiling” method which does not produce a logical\n3d grid of processors.  Rather it tiles the simulation domain with\nrectangular sub-boxes of varying size and shape in an irregular\nfashion so as to have equal numbers of particles (or weight) in each\nsub-box, as in the rightmost diagram above.\nThe “grid” methods can be used with either of the\ncomm_style command options, brick or tiled.  The\n“tiling” methods can only be used with comm_style tiled.  Note that it can be useful to use a “grid”\nmethod with comm_style tiled to return the domain\npartitioning to a logical 3d grid of processors so that “comm_style\nbrick” can afterwords be specified for subsequent run\ncommands.\nWhen a “grid” method is specified, the current domain partitioning can\nbe either a logical 3d grid or a tiled partitioning.  In the former\ncase, the current logical 3d grid is used as a starting point and\nchanges are made to improve the imbalance factor.  In the latter case,\nthe tiled partitioning is discarded and a logical 3d grid is created\nwith uniform spacing in all dimensions.  This becomes the starting\npoint for the balancing operation.\nWhen a “tiling” method is specified, the current domain partitioning\n(“grid” or “tiled”) is ignored, and a new partitioning is computed\nfrom scratch.\n\nThe x, y, and z styles invoke a “grid” method for balancing, as\ndescribed above.  Note that any or all of these 3 styles can be\nspecified together, one after the other, but they cannot be used with\nany other style.  This style adjusts the position of cutting planes\nbetween processor sub-domains in specific dimensions.  Only the\nspecified dimensions are altered.\nThe uniform argument spaces the planes evenly, as in the left\ndiagrams above.  The numeric argument requires listing Ps-1 numbers\nthat specify the position of the cutting planes.  This requires\nknowing Ps = Px or Py or Pz = the number of processors assigned by\nLAMMPS to the relevant dimension.  This assignment is made (and the\nPx, Py, Pz values printed out) when the simulation box is created by\nthe “create_box” or “read_data” or “read_restart” command and is\ninfluenced by the settings of the processors\ncommand.\nEach of the numeric values must be between 0 and 1, and they must be\nlisted in ascending order.  They represent the fractional position of\nthe cutting place.  The left (or lower) edge of the box is 0.0, and\nthe right (or upper) edge is 1.0.  Neither of these values is\nspecified.  Only the interior Ps-1 positions are specified.  Thus is\nthere are 2 processors in the x dimension, you specify a single value\nsuch as 0.75, which would make the left processor’s sub-domain 3x\nlarger than the right processor’s sub-domain.\n\nThe shift style invokes a “grid” method for balancing, as\ndescribed above.  It changes the positions of cutting planes between\nprocessors in an iterative fashion, seeking to reduce the imbalance\nfactor, similar to how the fix balance shift\ncommand operates.\nThe dimstr argument is a string of characters, each of which must be\nan “x” or “y” or “z”.  Eacn character can appear zero or one time,\nsince there is no advantage to balancing on a dimension more than\nonce.  You should normally only list dimensions where you expect there\nto be a density variation in the particles.\nBalancing proceeds by adjusting the cutting planes in each of the\ndimensions listed in dimstr, one dimension at a time.  For a single\ndimension, the balancing operation (described below) is iterated on up\nto Niter times.  After each dimension finishes, the imbalance factor\nis re-computed, and the balancing operation halts if the stopthresh\ncriterion is met.\nA re-balance operation in a single dimension is performed using a\nrecursive multisectioning algorithm, where the position of each\ncutting plane (line in 2d) in the dimension is adjusted independently.\nThis is similar to a recursive bisectioning for a single value, except\nthat the bounds used for each bisectioning take advantage of\ninformation from neighboring cuts if possible.  At each iteration, the\ncount of particles on either side of each plane is tallied.  If the\ncounts do not match the target value for the plane, the position of\nthe cut is adjusted to be halfway between a low and high bound.  The\nlow and high bounds are adjusted on each iteration, using new count\ninformation, so that they become closer together over time.  Thus as\nthe recursion progresses, the count of particles on either side of the\nplane gets closer to the target value.\nOnce the re-balancing is complete and final processor sub-domains\nassigned, particles are migrated to their new owning processor, and\nthe balance procedure ends.\n\nNote\nAt each re-balance operation, the bisectioning for each cutting\nplane (line in 2d) typically starts with low and high bounds separated\nby the extent of a processor’s sub-domain in one dimension.  The size\nof this bracketing region shrinks by 1/2 every iteration.  Thus if\nNiter is specified as 10, the cutting plane will typically be\npositioned to 1 part in 1000 accuracy (relative to the perfect target\nposition).  For Niter = 20, it will be accurate to 1 part in a\nmillion.  Thus there is no need ot set Niter to a large value.\nLAMMPS will check if the threshold accuracy is reached (in a\ndimension) is less iterations than Niter and exit early.  However,\nNiter should also not be set too small, since it will take roughly\nthe same number of iterations to converge even if the cutting plane is\ninitially close to the target value.\n\n\nThe rcb style invokes a “tiled” method for balancing, as described\nabove.  It performs a recursive coordinate bisectioning (RCB) of the\nsimulation domain. The basic idea is as follows.\nThe simulation domain is cut into 2 boxes by an axis-aligned cut in\none of the dimensions, leaving one new sub-box on either side of the\ncut.  Which dimension is chosen for the cut depends on the particle\n(weight) distribution within the parent box.  Normally the longest\ndimension of the box is cut, but if all (or most) of the particles are\nat one end of the box, a cut may be performed in another dimension to\ninduce sub-boxes that are more cube-ish (3d) or square-ish (2d) in\nshape.\nAfter the cut is made, all the processors are also partitioned into 2\ngroups, half assigned to the box on the lower side of the cut, and\nhalf to the box on the upper side.  (If the processor count is odd,\none side gets an extra processor.)  The cut is positioned so that the\nnumber of (weighted) particles in the lower box is exactly the number\nthat the processors assigned to that box should own for load balance\nto be perfect.  This also makes load balance for the upper box\nperfect.  The positioning of the cut is done iteratively, by a\nbisectioning method (median search).  Note that counting particles on\neither side of the cut requires communication between all processors\nat each iteration.\nThat is the procedure for the first cut.  Subsequent cuts are made\nrecursively, in exactly the same manner.  The subset of processors\nassigned to each box make a new cut in one dimension of that box,\nsplitting the box, the subset of processors, and the particles in the\nbox in two.  The recursion continues until every processor is assigned\na sub-box of the entire simulation domain, and owns the (weighted)\nparticles in that sub-box.\n\nThis sub-section describes how to perform weighted load balancing\nusing the weight keyword.\nBy default, all particles have a weight of 1.0, which means each\nparticle is assumed to require the same amount of computation during a\ntimestep.  There are, however, scenarios where this is not a good\nassumption.  Measuring the computational cost for each particle\naccurately would be impractical and slow down the computation.\nInstead the weight keyword implements several ways to influence the\nper-particle weights empirically by properties readily available or\nusing the user’s knowledge of the system.  Note that the absolute\nvalue of the weights are not important; only their relative ratios\naffect which particle is assigned to which processor.  A particle with\na weight of 2.5 is assumed to require 5x more computational than a\nparticle with a weight of 0.5.  For all the options below the weight\nassigned to a particle must be a positive value; an error will be be\ngenerated if a weight is <= 0.0.\nBelow is a list of possible weight options with a short description of\ntheir usage and some example scenarios where they might be applicable.\nIt is possible to apply multiple weight flags and the weightings they\ninduce will be combined through multiplication.  Most of the time,\nhowever, it is sufficient to use just one method.\nThe group weight style assigns weight factors to specified\ngroups of particles.  The group style keyword is\nfollowed by the number of groups, then pairs of group IDs and the\ncorresponding weight factor.  If a particle belongs to none of the\nspecified groups, its weight is not changed.  If it belongs to\nmultiple groups, its weight is the product of the weight factors.\nThis weight style is useful in combination with pair style\nhybrid, e.g. when combining a more costly many-body\npotential with a fast pair-wise potential.  It is also useful when\nusing run_style respa where some portions of the\nsystem have many bonded interactions and others none.  It assumes that\nthe computational cost for each group remains constant over time.\nThis is a purely empirical weighting, so a series test runs to tune\nthe assigned weight factors for optimal performance is recommended.\nThe neigh weight style assigns the same weight to each particle\nowned by a processor based on the total count of neighbors in the\nneighbor list owned by that processor.  The motivation is that more\nneighbors means a higher computational cost.  The style does not use\nneighbors per atom to assign a unique weight to each atom, because\nthat value can vary depending on how the neighbor list is built.\nThe factor setting is applied as an overall scale factor to the\nneigh weights which allows adjustment of their impact on the\nbalancing operation.  The specified factor value must be positive.\nA value > 1.0 will increase the weights so that the ratio of max\nweight to min weight increases by factor.  A value < 1.0 will\ndecrease the weights so that the ratio of max weight to min weight\ndecreases by factor.  In both cases the intermediate weight values\nincrease/decrease proportionally as well.  A value = 1.0 has no effect\non the neigh weights.  As a rule of thumb, we have found a factor\nof about 0.8 often results in the best performance, since the number\nof neighbors is likely to overestimate the ideal weight.\nThis weight style is useful for systems where there are different\ncutoffs used for different pairs of interactions, or the density\nfluctuates, or a large number of particles are in the vicinity of a\nwall, or a combination of these effects.  If a simulation uses\nmultiple neighbor lists, this weight style will use the first suitable\nneighbor list it finds.  It will not request or compute a new list.  A\nwarning will be issued if there is no suitable neighbor list available\nor if it is not current, e.g. if the balance command is used before a\nrun or minimize command is used, in which\ncase the neighbor list may not yet have been built.  In this case no\nweights are computed.  Inserting a run 0 post no command\nbefore issuing the balance command, may be a workaround for this\ncase, as it will induce the neighbor list to be built.\nThe time weight style uses timer data to estimate\nweights.  It assigns the same weight to each particle owned by a\nprocessor based on the total computational time spent by that\nprocessor.  See details below on what time window is used.  It uses\nthe same timing information as is used for the MPI task timing breakdown, namely, for sections Pair, Bond,\nKspace, and Neigh.  The time spent in those portions of the\ntimestep are measured for each MPI rank, summed, then divided by the\nnumber of particles owned by that processor.  I.e. the weight is an\neffective CPU time/particle averaged over the particles on that\nprocessor.\nThe factor setting is applied as an overall scale factor to the\ntime weights which allows adjustment of their impact on the\nbalancing operation.  The specified factor value must be positive.\nA value > 1.0 will increase the weights so that the ratio of max\nweight to min weight increases by factor.  A value < 1.0 will\ndecrease the weights so that the ratio of max weight to min weight\ndecreases by factor.  In both cases the intermediate weight values\nincrease/decrease proportionally as well.  A value = 1.0 has no effect\non the time weights.  As a rule of thumb, effective values to use\nare typically between 0.5 and 1.2.  Note that the timer quantities\nmentioned above can be affected by communication which occurs in the\nmiddle of the operations, e.g. pair styles with intermediate exchange\nof data witin the force computation, and likewise for KSpace solves.\nWhen using the time weight style with the balance command, the\ntiming data is taken from the preceding run command, i.e. the timings\nare for the entire previous run.  For the fix balance command the\ntiming data is for only the timesteps since the last balancing\noperation was performed.  If timing information for the required\nsections is not available, e.g. at the beginning of a run, or when the\ntimer command is set to either loop or off, a warning\nis issued.  In this case no weights are computed.\n\nNote\nThe time weight style is the most generic option, and should\nbe tried first, unless the group style is easily applicable.\nHowever, since the computed cost function is averaged over all\nparticles on a processor, the weights may not be highly accurate.\nThis style can also be effective as a secondary weight in combination\nwith either group or neigh to offset some of inaccuracies in\neither of those heuristics.\n\nThe var weight style assigns per-particle weights by evaluating an\natom-style variable specified by name.  This is\nprovided as a more flexible alternative to the group weight style,\nallowing definition of a more complex heuristics based on information\n(global and per atom) available inside of LAMMPS.  For example,\natom-style variables can reference the position of a particle, its\nvelocity, the volume of its Voronoi cell, etc.\nThe store weight style does not compute a weight factor.  Instead it\nstores the current accumulated weights in a custom per-atom property\nspecified by name.  This must be a property defined as d_name via\nthe fix property/atom command.  Note that\nthese custom per-atom properties can be output in a dump\nfile, so this is a way to examine, debug, or visualize the\nper-particle weights computed during the load-balancing operation.\n\nThe out keyword writes a text file to the specified filename with\nthe results of the balancing operation.  The file contains the bounds\nof the sub-domain for each processor after the balancing operation\ncompletes.  The format of the file is compatible with the\nPizza.py mdump tool which has support for manipulating and\nvisualizing mesh files.  An example is shown here for a balancing by 4\nprocessors for a 2d problem:\nITEM: TIMESTEP\n0\nITEM: NUMBER OF NODES\n16\nITEM: BOX BOUNDS\n0 10\n0 10\n0 10\nITEM: NODES\n1 1 0 0 0\n2 1 5 0 0\n3 1 5 5 0\n4 1 0 5 0\n5 1 5 0 0\n6 1 10 0 0\n7 1 10 5 0\n8 1 5 5 0\n9 1 0 5 0\n10 1 5 5 0\n11 1 5 10 0\n12 1 10 5 0\n13 1 5 5 0\n14 1 10 5 0\n15 1 10 10 0\n16 1 5 10 0\nITEM: TIMESTEP\n0\nITEM: NUMBER OF SQUARES\n4\nITEM: SQUARES\n1 1 1 2 3 4\n2 1 5 6 7 8\n3 1 9 10 11 12\n4 1 13 14 15 16\n\n\nThe coordinates of all the vertices are listed in the NODES section, 5\nper processor.  Note that the 4 sub-domains share vertices, so there\nwill be duplicate nodes in the list.\nThe “SQUARES” section lists the node IDs of the 4 vertices in a\nrectangle for each processor (1 to 4).\nFor a 3d problem, the syntax is similar with 8 vertices listed for\neach processor, instead of 4, and “SQUARES” replaced by “CUBES”.",
    "syntax": "balance thresh style args ... keyword args ...",
    "parameters": " * thresh = imbalance threshold that must be exceeded to perform a re-balance\n * one style/arg pair can be used (or multiple for x,y,z)\n * style = x or y or z or shift or rcb\n * x args = uniform or Px-1 numbers between 0 and 1\n *   uniform = evenly spaced cuts between processors in x dimension\n *   numbers = Px-1 ascending values between 0 and 1, Px - # of processors in x dimension\n *   x can be specified together with y or z\n * y args = uniform or Py-1 numbers between 0 and 1\n *   uniform = evenly spaced cuts between processors in y dimension\n *   numbers = Py-1 ascending values between 0 and 1, Py - # of processors in y dimension\n *   y can be specified together with x or z\n * z args = uniform or Pz-1 numbers between 0 and 1\n *   uniform = evenly spaced cuts between processors in z dimension\n *   numbers = Pz-1 ascending values between 0 and 1, Pz - # of processors in z dimension\n *   z can be specified together with x or y\n * shift args = dimstr Niter stopthresh\n *   dimstr = sequence of letters containing \"x\" or \"y\" or \"z\", each not more than once\n *   Niter = # of times to iterate within each dimension of dimstr sequence\n *   stopthresh = stop balancing when this imbalance threshold is reached\n * rcb args = none\n * zero or more keyword/arg pairs may be appended\n * keyword = weight or out\n * weight style args = use weighted particle counts for the balancing\n *   style = group or neigh or time or var or store\n *     group args = Ngroup group1 weight1 group2 weight2 ...\n *       Ngroup = number of groups with assigned weights\n *       group1, group2, ... = group IDs\n *       weight1, weight2, ...   = corresponding weight factors\n *     neigh factor = compute weight based on number of neighbors\n *       factor = scaling factor (> 0)\n *     time factor = compute weight based on time spend computing\n *       factor = scaling factor (> 0)\n *     var name = take weight from atom-style variable\n *       name = name of the atom-style variable\n *     store name = store weight in custom atom property defined by fix property/atom command\n *       name = atom property name (without d_ prefix)\n * out arg = filename\n *   filename = write each processor's sub-domain to a file",
    "examples": "balance 0.9 x uniform y 0.4 0.5 0.6\nbalance 1.2 shift xz 5 1.1\nbalance 1.0 shift xz 5 1.1\nbalance 1.1 rcb\nbalance 1.0 shift x 10 1.1 weight group 2 fast 0.5 slow 2.0\nbalance 1.0 shift x 10 1.1 weight time 0.8 weight neigh 0.5 weight store balance\nbalance 1.0 shift x 20 1.0 out tmp.balance",
    "restrictions": "For 2d simulations, the z style cannot be used.  Nor can a “z”\nappear in dimstr for the shift style.\nBalancing through recursive bisectioning (rcb style) requires\ncomm_style tiled"
},
{
    "command": "bond_coeff",
    "html_filename": "bond_coeff.html",
    "short_description": "Specify the bond force field coefficients for one or more bond types",
    "description": "Specify the bond force field coefficients for one or more bond types.\nThe number and meaning of the coefficients depends on the bond style.\nBond coefficients can also be set in the data file read by the\nread_data command or in a restart file.\nN can be specified in one of two ways.  An explicit numeric value can\nbe used, as in the 1st example above.  Or a wild-card asterisk can be\nused to set the coefficients for multiple bond types.  This takes the\nform “*” or “*n” or “n*” or “m*n”.  If N = the number of bond types,\nthen an asterisk with no numeric values means all types from 1 to N.  A\nleading asterisk means all types from 1 to n (inclusive).  A trailing\nasterisk means all types from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).\nNote that using a bond_coeff command can override a previous setting\nfor the same bond type.  For example, these commands set the coeffs\nfor all bond types, then overwrite the coeffs for just bond type 2:\nbond_coeff * 100.0 1.2\nbond_coeff 2 200.0 1.2\n\n\nA line in a data file that specifies bond coefficients uses the exact\nsame format as the arguments of the bond_coeff command in an input\nscript, except that wild-card asterisks should not be used since\ncoefficients for all N types must be listed in the file.  For example,\nunder the “Bond Coeffs” section of a data file, the line that\ncorresponds to the 1st example above would be listed as\n5 80.0 1.2\n\n\n\nThe list of all bond styles defined in LAMMPS is given on the\nbond_style doc page.  They are also listed in more\ncompact form on the Commands bond doc page.\nOn either of those pages, click on the style to display the formula it\ncomputes and its coefficients as specified by the associated\nbond_coeff command.",
    "syntax": "bond_coeff N args",
    "parameters": " * N = bond type (see asterisk form below)\n * args = coefficients for one or more bond types",
    "examples": "bond_coeff 5 80.0 1.2\nbond_coeff * 30.0 1.5 1.0 1.0\nbond_coeff 1*4 30.0 1.5 1.0 1.0\nbond_coeff 1 harmonic 200.0 1.0",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command.\nA bond style must be defined before any bond coefficients are set,\neither in the input script or in a data file."
},
{
    "command": "bond_style",
    "html_filename": "bond_style.html",
    "short_description": "Set the formula(s) LAMMPS uses to compute bond interactions between pairs of atoms",
    "description": "Set the formula(s) LAMMPS uses to compute bond interactions between\npairs of atoms.  In LAMMPS, a bond differs from a pairwise\ninteraction, which are set via the pair_style\ncommand.  Bonds are defined between specified pairs of atoms and\nremain in force for the duration of the simulation (unless the bond\nbreaks which is possible in some bond potentials).  The list of bonded\natoms is read in by a read_data or\nread_restart command from a data or restart file.\nBy contrast, pair potentials are typically defined between all pairs\nof atoms within a cutoff distance and the set of active interactions\nchanges over time.\nHybrid models where bonds are computed using different bond potentials\ncan be setup using the hybrid bond style.\nThe coefficients associated with a bond style can be specified in a\ndata or restart file or via the bond_coeff command.\nAll bond potentials store their coefficient data in binary restart\nfiles which means bond_style and bond_coeff commands\ndo not need to be re-specified in an input script that restarts a\nsimulation.  See the read_restart command for\ndetails on how to do this.  The one exception is that bond_style\nhybrid only stores the list of sub-styles in the restart file; bond\ncoefficients need to be re-specified.\n\nNote\nWhen both a bond and pair style is defined, the\nspecial_bonds command often needs to be used to\nturn off (or weight) the pairwise interaction that would otherwise\nexist between 2 bonded atoms.\n\nIn the formulas listed for each bond style, r is the distance\nbetween the 2 atoms in the bond.\n\nHere is an alphabetic list of bond styles defined in LAMMPS.  Click on\nthe style to display the formula it computes and coefficients\nspecified by the associated bond_coeff command.\nClick on the style to display the formula it computes, any additional\narguments specified in the bond_style command, and coefficients\nspecified by the associated bond_coeff command.\nThere are also additional accelerated pair styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands bond\ndoc page are followed by one or more of (g,i,k,o,t) to indicate which\naccelerated styles exist.\n\nnone - turn off bonded interactions\nzero - topology but no interactions\nhybrid - define multiple styles of bond interactions\nclass2 - COMPASS (class 2) bond\nfene - FENE (finite-extensible non-linear elastic) bond\nfene/expand - FENE bonds with variable size particles\ngromos - GROMOS force field bond\nharmonic - harmonic bond\nharmonic/shift - shifted harmonic bond\nharmonic/shift/cut - shifted harmonic bond with a cutoff\nmm3 - MM3 anharmonic bond\nmorse - Morse bond\nnonlinear - nonlinear bond\noxdna/fene - modified FENE bond suitable for DNA modeling\noxdna2/fene - same as oxdna but used with different pair styles\noxrna2/fene - modified FENE bond suitable for RNA modeling\nquartic - breakable quartic bond\ntable - tabulated by bond length",
    "syntax": "bond_style style args",
    "parameters": " * style = none or hybrid or class2 or fene or fene/expand or         harmonic or morse or nonlinear or quartic\n * args = none for any style except hybrid\n * hybrid args = list of one or more styles",
    "examples": "bond_style harmonic\nbond_style fene\nbond_style hybrid harmonic fene",
    "restrictions": "Bond styles can only be set for atom styles that allow bonds to be\ndefined.\nMost bond styles are part of the MOLECULE package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual bond potentials tell if it is part of a package."
},
{
    "command": "bond_write",
    "html_filename": "bond_write.html",
    "short_description": "Write energy and force values to a file as a function of distance for the currently defined bond potential",
    "description": "Write energy and force values to a file as a function of distance for\nthe currently defined bond potential.  This is useful for plotting the\npotential function or otherwise debugging its values.  If the file\nalready exists, the table of values is appended to the end of the file\nto allow multiple tables of energy and force to be included in one\nfile.\nThe energy and force values are computed at distances from inner to\nouter for 2 interacting atoms forming a bond of type btype, using the\nappropriate bond_coeff coefficients. N evenly spaced\ndistances are used.\nFor example, for N = 7, inner = 1.0, and outer = 4.0,\nvalues are computed at r = 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0.\nThe file is written in the format used as input for the\nbond_style table option with keyword as the\nsection name.  Each line written to the file lists an index number\n(1-N), a distance (in distance units), an energy (in energy units),\nand a force (in force units).",
    "syntax": "bond_write btype N inner outer file keyword itype jtype",
    "parameters": " * btype = bond types\n * N = # of values\n * inner,outer = inner and outer bond length (distance units)\n * file = name of file to write values to\n * keyword = section name in file for this set of tabulated values\n * itype,jtype = 2 atom types (optional)",
    "examples": "bond_write 1 500 0.5 3.5 table.txt Harmonic_1\nbond_write 3 1000 0.1 6.0 table.txt Morse",
    "restrictions": "All force field coefficients for bond and other kinds of interactions\nmust be set before this command can be invoked.\nDue to how the bond force is computed, an inner value > 0.0 must\nbe specified even if the potential has a finite value at r = 0.0."
},
{
    "command": "boundary",
    "html_filename": "boundary.html",
    "short_description": "Set the style of boundaries for the global simulation box in each dimension",
    "description": "Set the style of boundaries for the global simulation box in each\ndimension.  A single letter assigns the same style to both the lower\nand upper face of the box.  Two letters assigns the first style to the\nlower face and the second style to the upper face.  The initial size\nof the simulation box is set by the read_data,\nread_restart, or create_box\ncommands.\nThe style p means the box is periodic, so that particles interact\nacross the boundary, and they can exit one end of the box and re-enter\nthe other end.  A periodic dimension can change in size due to\nconstant pressure boundary conditions or box deformation (see the fix npt and fix deform commands).  The p\nstyle must be applied to both faces of a dimension.\nThe styles f, s, and m mean the box is non-periodic, so that\nparticles do not interact across the boundary and do not move from one\nside of the box to the other.\nFor style f, the position of the face is fixed.  If an atom moves\noutside the face it will be deleted on the next timestep that\nreneighboring occurs.  This will typically generate an error unless\nyou have set the thermo_modify lost option to\nallow for lost atoms.\nFor style s, the position of the face is set so as to encompass the\natoms in that dimension (shrink-wrapping), no matter how far they\nmove. Note that when the difference between the current box dimensions\nand the shrink-wrap box dimensions is large, this can lead to lost\natoms at the beginning of a run when running in parallel. This is due\nto the large change in the (global) box dimensions also causing\nsignificant changes in the individual sub-domain sizes. If these\nchanges are farther than the communication cutoff, atoms will be lost.\nThis is best addressed by setting initial box dimensions to match the\nshrink-wrapped dimensions more closely, by using m style boundaries\n(see below).\nFor style m, shrink-wrapping occurs, but is bounded by the value\nspecified in the data or restart file or set by the\ncreate_box command.  For example, if the upper z\nface has a value of 50.0 in the data file, the face will always be\npositioned at 50.0 or above, even if the maximum z-extent of all the\natoms becomes less than 50.0.  This can be useful if you start a\nsimulation with an empty box or if you wish to leave room on one side\nof the box, e.g. for atoms to evaporate from a surface.\nFor triclinic (non-orthogonal) simulation boxes, if the 2nd dimension\nof a tilt factor (e.g. y for xy) is periodic, then the periodicity is\nenforced with the tilt factor offset.  If the 1st dimension is\nshrink-wrapped, then the shrink wrapping is applied to the tilted box\nface, to encompass the atoms.  E.g. for a positive xy tilt, the xlo\nand xhi faces of the box are planes tilting in the +y direction as y\nincreases.  These tilted planes are shrink-wrapped around the atoms to\ndetermine the x extent of the box.\nSee the Howto triclinic doc page for a\ngeometric description of triclinic boxes, as defined by LAMMPS, and\nhow to transform these parameters to and from other commonly used\ntriclinic representations.",
    "syntax": "boundary x y z",
    "parameters": " * x,y,z = p or s or f or m, one or two letters\n * p is periodic\n * f is non-periodic and fixed\n * s is non-periodic and shrink-wrapped\n * m is non-periodic and shrink-wrapped with a minimum value",
    "examples": "boundary p p f\nboundary p fs p\nboundary s f fm",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command or\nread_restart command.  See the\nchange_box command for how to change the simulation\nbox boundaries after it has been defined.\nFor 2d simulations, the z dimension must be periodic."
},
{
    "command": "box",
    "html_filename": "box.html",
    "short_description": "Set attributes of the simulation box",
    "description": "Set attributes of the simulation box.\nFor triclinic (non-orthogonal) simulation boxes, the tilt keyword\nallows simulation domains to be created with arbitrary tilt factors,\ne.g. via the create_box or\nread_data commands.  Tilt factors determine how\nskewed the triclinic box is; see the Howto triclinic doc page for a discussion of triclinic\nboxes in LAMMPS.\nLAMMPS normally requires that no tilt factor can skew the box more\nthan half the distance of the parallel box length, which is the 1st\ndimension in the tilt factor (x for xz).  If tilt is set to\nsmall, which is the default, then an error will be\ngenerated if a box is created which exceeds this limit.  If tilt\nis set to large, then no limit is enforced.  You can create\na box with any tilt factors you wish.\nNote that if a simulation box has a large tilt factor, LAMMPS will run\nless efficiently, due to the large volume of communication needed to\nacquire ghost atoms around a processor’s irregular-shaped sub-domain.\nFor extreme values of tilt, LAMMPS may also lose atoms and generate an\nerror.",
    "syntax": "box keyword value ...",
    "parameters": " * one or more keyword/value pairs may be appended\n * keyword = tilt\n * tilt value = small or large",
    "examples": "box tilt large\nbox tilt small",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command or\nread_restart command.\nRelated commands: none"
},
{
    "command": "change_box",
    "html_filename": "change_box.html",
    "short_description": "Change the volume and/or shape and/or boundary conditions for the simulation box",
    "description": "Change the volume and/or shape and/or boundary conditions for the\nsimulation box.  Orthogonal simulation boxes have 3 adjustable size\nparameters (x,y,z).  Triclinic (non-orthogonal) simulation boxes have\n6 adjustable size/shape parameters (x,y,z,xy,xz,yz).  Any or all of\nthem can be adjusted independently by this command.  Thus it can be\nused to expand or contract a box, or to apply a shear strain to a\nnon-orthogonal box.  It can also be used to change the boundary\nconditions for the simulation box, similar to the\nboundary command.\nThe size and shape of the initial simulation box are specified by the\ncreate_box or read_data or\nread_restart command used to setup the simulation.\nThe size and shape may be altered by subsequent runs, e.g. by use of\nthe fix npt or fix deform commands.\nThe create_box, read data, and\nread_restart commands also determine whether the\nsimulation box is orthogonal or triclinic and their doc pages explain\nthe meaning of the xy,xz,yz tilt factors.\nSee the Howto triclinic doc page for a\ngeometric description of triclinic boxes, as defined by LAMMPS, and\nhow to transform these parameters to and from other commonly used\ntriclinic representations.\nThe keywords used in this command are applied sequentially to the\nsimulation box and the atoms in it, in the order specified.\nBefore the sequence of keywords are invoked, the current box\nsize/shape is stored, in case a remap keyword is used to map the\natom coordinates from a previously stored box size/shape to the\ncurrent one.\nAfter all the keywords have been processed, any shrink-wrap boundary\nconditions are invoked (see the boundary command)\nwhich may change simulation box boundaries, and atoms are migrated to\nnew owning processors.\n\nNote\nThis means that you cannot use the change_box command to enlarge\na shrink-wrapped box, e.g. to make room to insert more atoms via the\ncreate_atoms command, because the simulation box\nwill be re-shrink-wrapped before the change_box command completes.\nInstead you could do something like this, assuming the simulation box\nis non-periodic and atoms extend from 0 to 20 in all dimensions:\n\nchange_box all x final -10 20\ncreate_atoms 1 single -5 5 5       # this will fail to insert an atom\n\nchange_box all x final -10 20 boundary f s s\ncreate_atoms 1 single -5 5 5\nchange_box all boundary s s s      # this will work\n\n\n\nNote\nUnlike the earlier “displace_box” version of this command, atom\nremapping is NOT performed by default.  This command allows remapping\nto be done in a more general way, exactly when you specify it (zero or\nmore times) in the sequence of transformations.  Thus if you do not\nuse the remap keyword, atom coordinates will not be changed even if\nthe box size/shape changes.  If a uniformly strained state is desired,\nthe remap keyword should be specified.\n\n\nNote\nIt is possible to lose atoms with this command.  E.g. by\nchanging the box without remapping the atoms, and having atoms end up\noutside of non-periodic boundaries.  It is also possible to alter\nbonds between atoms straddling a boundary in bad ways.  E.g. by\nconverting a boundary from periodic to non-periodic.  It is also\npossible when remapping atoms to put them (nearly) on top of each\nother.  E.g. by converting a boundary from non-periodic to periodic.\nAll of these will typically lead to bad dynamics and/or generate error\nmessages.\n\n\nNote\nThe simulation box size/shape can be changed by arbitrarily\nlarge amounts by this command.  This is not a problem, except that the\nmapping of processors to the simulation box is not changed from its\ninitial 3d configuration; see the processors\ncommand.  Thus, if the box size/shape changes dramatically, the\nmapping of processors to the simulation box may not end up as optimal\nas the initial mapping attempted to be.\n\n\nNote\nBecause the keywords used in this command are applied one at a\ntime to the simulation box and the atoms in it, care must be taken\nwith triclinic cells to avoid exceeding the limits on skew after each\ntransformation in the sequence.  If skew is exceeded before the final\ntransformation this can be avoided by changing the order of the\nsequence, or breaking the transformation into two or more smaller\ntransformations.  For more information on the allowed limits for box\nskew see the discussion on triclinic boxes on Howto triclinic doc page.\n\n\nFor the x, y, and z parameters, this is the meaning of their\nstyles and values.\nFor style final, the final lo and hi box boundaries of a dimension\nare specified.  The values can be in lattice or box distance units.\nSee the discussion of the units keyword below.\nFor style delta, plus or minus changes in the lo/hi box boundaries\nof a dimension are specified.  The values can be in lattice or box\ndistance units.  See the discussion of the units keyword below.\nFor style scale, a multiplicative factor to apply to the box length\nof a dimension is specified.  For example, if the initial box length\nis 10, and the factor is 1.1, then the final box length will be 11.  A\nfactor less than 1.0 means compression.\nThe volume style changes the specified dimension in such a way that\nthe overall box volume remains constant with respect to the operation\nperformed by the preceding keyword.  The volume style can only be\nused following a keyword that changed the volume, which is any of the\nx, y, z keywords.  If the preceding keyword “key” had a volume\nstyle, then both it and the current keyword apply to the keyword\npreceding “key”.  I.e. this sequence of keywords is allowed:\nchange_box all x scale 1.1 y volume z volume\n\n\nThe volume style changes the associated dimension so that the\noverall box volume is unchanged relative to its value before the\npreceding keyword was invoked.\nIf the following command is used, then the z box length will shrink by\nthe same 1.1 factor the x box length was increased by:\nchange_box all x scale 1.1 z volume\n\n\nIf the following command is used, then the y,z box lengths will each\nshrink by sqrt(1.1) to keep the volume constant.  In this case, the\ny,z box lengths shrink so as to keep their relative aspect ratio\nconstant:\nchange_box all x scale 1.1 y volume z volume\n\n\nIf the following command is used, then the final box will be a factor\nof 10% larger in x and y, and a factor of 21% smaller in z, so as to\nkeep the volume constant:\nchange_box all x scale 1.1 z volume y scale 1.1 z volume\n\n\n\nNote\nFor solids or liquids, when one dimension of the box is\nexpanded, it may be physically undesirable to hold the other 2 box\nlengths constant since that implies a density change.  For solids,\nadjusting the other dimensions via the volume style may make\nphysical sense (just as for a liquid), but may not be correct for\nmaterials and potentials whose Poisson ratio is not 0.5.\n\nFor the scale and volume styles, the box length is expanded or\ncompressed around its mid point.\n\nFor the xy, xz, and yz parameters, this is the meaning of their\nstyles and values.  Note that changing the tilt factors of a triclinic\nbox does not change its volume.\nFor style final, the final tilt factor is specified.  The value\ncan be in lattice or box distance units.  See the discussion of the\nunits keyword below.\nFor style delta, a plus or minus change in the tilt factor is\nspecified.  The value can be in lattice or box distance units.  See\nthe discussion of the units keyword below.\nAll of these styles change the xy, xz, yz tilt factors.  In LAMMPS,\ntilt factors (xy,xz,yz) for triclinic boxes are required to be no more\nthan half the distance of the parallel box length.  For example, if\nxlo = 2 and xhi = 12, then the x box length is 10 and the xy tilt\nfactor must be between -5 and 5.  Similarly, both xz and yz must be\nbetween -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a\nlimitation, since if the maximum tilt factor is 5 (as in this\nexample), then configurations with tilt = …, -15, -5, 5, 15, 25,\n… are all equivalent.  Any tilt factor specified by this command\nmust be within these limits.\n\nThe boundary keyword takes arguments that have exactly the same\nmeaning as they do for the boundary command.  In each\ndimension, a single letter assigns the same style to both the lower\nand upper face of the box.  Two letters assigns the first style to the\nlower face and the second style to the upper face.\nThe style p means the box is periodic; the other styles mean\nnon-periodic. For style f, the position of the face is fixed.  For\nstyle s, the position of the face is set so as to encompass the\natoms in that dimension (shrink-wrapping), no matter how far they\nmove.  For style m, shrink-wrapping occurs, but is bounded by the\ncurrent box edge in that dimension, so that the box will become no\nsmaller.  See the boundary command for more\nexplanation of these style options.\nNote that the “boundary” command itself can only be used before the\nsimulation box is defined via a read_data or\ncreate_box or read_restart\ncommand.  This command allows the boundary conditions to be changed\nlater in your input script.  Also note that the\nread_restart will change boundary conditions to\nmatch what is stored in the restart file.  So if you wish to change\nthem, you should use the change_box command after the read_restart\ncommand.\n\nThe ortho and triclinic keywords convert the simulation box to be\northogonal or triclinic (non-orthogonal).\nThe simulation box is defined as either orthogonal or triclinic when\nit is created via the create_box,\nread_data, or read_restart\ncommands.\nThese keywords allow you to toggle the existing simulation box from\northogonal to triclinic and vice versa.  For example, an initial\nequilibration simulation can be run in an orthogonal box, the box can\nbe toggled to triclinic, and then a non-equilibrium MD (NEMD) simulation can be run with deformation via the fix deform command.\nIf the simulation box is currently triclinic and has non-zero tilt in\nxy, yz, or xz, then it cannot be converted to an orthogonal box.\n\nThe set keyword saves the current box size/shape.  This can be\nuseful if you wish to use the remap keyword more than once or if you\nwish it to be applied to an intermediate box size/shape in a sequence\nof keyword operations.  Note that the box size/shape is saved before\nany of the keywords are processed, i.e. the box size/shape at the time\nthe create_box command is encountered in the input script.\nThe remap keyword remaps atom coordinates from the last saved box\nsize/shape to the current box state.  For example, if you stretch the\nbox in the x dimension or tilt it in the xy plane via the x and xy\nkeywords, then the remap command will dilate or tilt the atoms to\nconform to the new box size/shape, as if the atoms moved with the box\nas it deformed.\nNote that this operation is performed without regard to periodic\nboundaries.  Also, any shrink-wrapping of non-periodic boundaries (see\nthe boundary command) occurs after all keywords,\nincluding this one, have been processed.\nOnly atoms in the specified group are remapped.\n\nThe units keyword determines the meaning of the distance units used\nto define various arguments.  A box value selects standard distance\nunits as defined by the units command, e.g. Angstroms for\nunits = real or metal.  A lattice value means the distance units are\nin lattice spacings.  The lattice command must have\nbeen previously used to define the lattice spacing.",
    "syntax": "change_box group-ID parameter args ... keyword args ...",
    "parameters": " * group-ID = ID of group of atoms to (optionally) displace\n * one or more parameter/arg pairs may be appended\n * parameter = x or y or z or xy or xz or yz or boundary or ortho or triclinic or set or remap\n *   x, y, z args = style value(s)\n *     style = final or delta or scale or volume\n *       final values = lo hi\n *         lo hi = box boundaries after displacement (distance units)\n *       delta values = dlo dhi\n *         dlo dhi = change in box boundaries after displacement (distance units)\n *       scale values = factor\n *         factor = multiplicative factor for change in box length after displacement\n *       volume value = none = adjust this dim to preserve volume of system\n *   xy, xz, yz args = style value\n *     style = final or delta\n *       final value = tilt\n *         tilt = tilt factor after displacement (distance units)\n *       delta value = dtilt\n *         dtilt = change in tilt factor after displacement (distance units)\n *   boundary args = x y z\n *     x,y,z = p or s or f or m, one or two letters\n *     p is periodic\n *     f is non-periodic and fixed\n *     s is non-periodic and shrink-wrapped\n *     m is non-periodic and shrink-wrapped with a minimum value\n *   ortho args = none = change box to orthogonal\n *   triclinic args = none = change box to triclinic\n *   set args = none = store state of current box\n *   remap args = none = remap atom coords from last saved state to current box\n * zero or more keyword/value pairs may be appended\n * keyword = units\n * units value = lattice or box\n *   lattice = distances are defined in lattice units\n *   box = distances are defined in simulation box units",
    "examples": "change_box all xy final -2.0 z final 0.0 5.0 boundary p p f remap units box\nchange_box all x scale 1.1 y volume z volume remap",
    "restrictions": "If you use the ortho or triclinic keywords, then at the point in\nthe input script when this command is issued, no dumps can\nbe active, nor can a fix deform be active.  This is\nbecause these commands test whether the simulation box is orthogonal\nwhen they are first issued.  Note that these commands can be used in\nyour script before a change_box command is issued, so long as an\nundump or unfix command is also used to\nturn them off."
},
{
    "command": "clear",
    "html_filename": "clear.html",
    "short_description": "This command deletes all atoms, restores all settings to their default values, and frees all memory allocated by LAMMPS",
    "description": "This command deletes all atoms, restores all settings to their default\nvalues, and frees all memory allocated by LAMMPS.  Once a clear\ncommand has been executed, it is almost as if LAMMPS were starting\nover, with only the exceptions noted below.  This command enables\nmultiple jobs to be run sequentially from one input script.\nThese settings are not affected by a clear command: the working\ndirectory (shell command), log file status\n(log command), echo status (echo command), and\ninput script variables (variable command).",
    "syntax": "clear",
    "parameters": " * ",
    "examples": "(commands for 1st simulation)\nclear\n(commands for 2nd simulation)",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "comm_modify",
    "html_filename": "comm_modify.html",
    "short_description": "This command sets parameters that affect the inter-processor communication of atom information that occurs each timestep as coordinates and other properties are exchanged between neighboring processors and stored as properties of ghost atoms",
    "description": "This command sets parameters that affect the inter-processor\ncommunication of atom information that occurs each timestep as\ncoordinates and other properties are exchanged between neighboring\nprocessors and stored as properties of ghost atoms.\n\nNote\nThese options apply to the currently defined comm style.  When\nyou specify a comm_style or\nread_restart command, all communication settings\nare restored to their default or stored values, including those\npreviously reset by a comm_modify command.  Thus if your input script\nspecifies a comm_style or read_restart command, you should use the\ncomm_modify command after it.\n\nThe mode keyword determines whether a single or multiple cutoff\ndistances are used to determine which atoms to communicate.\nThe default mode is single which means each processor acquires\ninformation for ghost atoms that are within a single distance from its\nsub-domain.  The distance is by default the maximum of the neighbor\ncutoff across all atom type pairs.\nFor many systems this is an efficient algorithm, but for systems with\nwidely varying cutoffs for different type pairs, the multi mode can\nbe faster.  In this case, each atom type is assigned its own distance\ncutoff for communication purposes, and fewer atoms will be\ncommunicated.  See the neighbor multi command for a\nneighbor list construction option that may also be beneficial for\nsimulations of this kind.\nThe cutoff keyword allows you to extend the ghost cutoff distance\nfor communication mode single, which is the distance from the borders\nof a processor’s sub-domain at which ghost atoms are acquired from other\nprocessors.  By default the ghost cutoff = neighbor cutoff = pairwise\nforce cutoff + neighbor skin.  See the neighbor command\nfor more information about the skin distance.  If the specified Rcut is\ngreater than the neighbor cutoff, then extra ghost atoms will be acquired.\nIf the provided cutoff is smaller, the provided value will be ignored,\nthe ghost cutoff is set to the neighbor cutoff and a warning will be\nprinted. Specifying a cutoff value of 0.0 will reset any previous value\nto the default. If bonded interactions exist and equilibrium bond length\ninformation is available, then also a heuristic based on that bond length\nis computed. It is used as communication cutoff, if there is no pair\nstyle present and no comm_modify cutoff command used. Otherwise a\nwarning is printed, if this bond based estimate is larger than the\ncommunication cutoff used. A\nThe cutoff/multi option is equivalent to cutoff, but applies to\ncommunication mode multi instead. Since in this case the communication\ncutoffs are determined per atom type, a type specifier is needed and\ncutoff for one or multiple types can be extended. Also ranges of types\nusing the usual asterisk notation can be given.\nThese are simulation scenarios in which it may be useful or even\nnecessary to set a ghost cutoff > neighbor cutoff:\n\na single polymer chain with bond interactions, but no pairwise interactions\nbonded interactions (e.g. dihedrals) extend further than the pairwise cutoff\nghost atoms beyond the pairwise cutoff are needed for some computation\n\nIn the first scenario, a pairwise potential is not defined.  Thus the\npairwise neighbor cutoff will be 0.0.  But ghost atoms are still\nneeded for computing bond, angle, etc interactions between atoms on\ndifferent processors, or when the interaction straddles a periodic\nboundary.\nThe appropriate ghost cutoff depends on the newton bond\nsetting.  For newton bond off, the distance needs to be the furthest\ndistance between any two atoms in the bond, angle, etc.  E.g. the\ndistance between 1-4 atoms in a dihedral.  For newton bond on, the\ndistance between the central atom in the bond, angle, etc and any\nother atom is sufficient.  E.g. the distance between 2-4 atoms in a\ndihedral.\nIn the second scenario, a pairwise potential is defined, but its\nneighbor cutoff is not sufficiently long enough to enable bond, angle,\netc terms to be computed.  As in the previous scenario, an appropriate\nghost cutoff should be set.\nIn the last scenario, a fix or compute or\npairwise potential needs to calculate with ghost\natoms beyond the normal pairwise cutoff for some computation it\nperforms (e.g. locate neighbors of ghost atoms in a multibody pair\npotential).  Setting the ghost cutoff appropriately can insure it will\nfind the needed atoms.\n\nNote\nIn these scenarios, if you do not set the ghost cutoff long\nenough, and if there is only one processor in a periodic dimension\n(e.g. you are running in serial), then LAMMPS may “find” the atom it\nis looking for (e.g. the partner atom in a bond), that is on the far\nside of the simulation box, across a periodic boundary.  This will\ntypically lead to bad dynamics (i.e. the bond length is now the\nsimulation box length).  To detect if this is happening, see the\nneigh_modify cluster command.\n\nThe group keyword will limit communication to atoms in the specified\ngroup.  This can be useful for models where no ghost atoms are needed\nfor some kinds of particles.  All atoms (not just those in the\nspecified group) will still migrate to new processors as they move.\nThe group specified with this option must also be specified via the\natom_modify first command.\nThe vel keyword enables velocity information to be communicated with\nghost particles.  Depending on the atom_style,\nvelocity info includes the translational velocity, angular velocity,\nand angular momentum of a particle.  If the vel option is set to\nyes, then ghost atoms store these quantities; if no then they do\nnot.  The yes setting is needed by some pair styles which require\nthe velocity state of both the I and J particles to compute a pairwise\nI,J interaction, as well as by some compute and fix commands.\nNote that if the fix deform command is being used\nwith its “remap v” option enabled, then the velocities for ghost atoms\n(in the fix deform group) mirrored across a periodic boundary will\nalso include components due to any velocity shift that occurs across\nthat boundary (e.g. due to dilation or shear).",
    "syntax": "comm_modify keyword value ...",
    "parameters": " * zero or more keyword/value pairs may be appended\n * keyword = mode or cutoff or cutoff/multi or group or vel\n * mode value = single or multi = communicate atoms within a single or multiple distances\n * cutoff value = Rcut (distance units) = communicate atoms from this far away\n * cutoff/multi type value\n *    type = atom type or type range (supports asterisk notation)\n *    value = Rcut (distance units) = communicate atoms for selected types from this far away\n * group value = group-ID = only communicate atoms in the group\n * vel value = yes or no = do or do not communicate velocity info with ghost atoms",
    "examples": "comm_modify mode multi\ncomm_modify mode multi group solvent\ncomm_modift mode multi cutoff/multi 1 10.0 cutoff/multi 2*4 15.0\ncomm_modify vel yes\ncomm_modify mode single cutoff 5.0 vel yes\ncomm_modify cutoff/multi * 0.0",
    "restrictions": "Communication mode multi is currently only available for\ncomm_style brick."
},
{
    "command": "comm_style",
    "html_filename": "comm_style.html",
    "short_description": "This command sets the style of inter-processor communication of atom information that occurs each timestep as coordinates and other properties are exchanged between neighboring processors and stored as properties of ghost atoms",
    "description": "This command sets the style of inter-processor communication of atom\ninformation that occurs each timestep as coordinates and other\nproperties are exchanged between neighboring processors and stored as\nproperties of ghost atoms.\nFor the default brick style, the domain decomposition used by LAMMPS\nto partition the simulation box must be a regular 3d grid of bricks,\none per processor.  Each processor communicates with its 6 Cartesian\nneighbors in the grid to acquire information for nearby atoms.\nFor the tiled style, a more general domain decomposition can be\nused, as triggered by the balance or fix balance commands.  The simulation box can be\npartitioned into non-overlapping rectangular-shaped “tiles” or varying\nsizes and shapes.  Again there is one tile per processor.  To acquire\ninformation for nearby atoms, communication must now be done with a\nmore complex pattern of neighboring processors.\nNote that this command does not actually define a partitioning of the\nsimulation box (a domain decomposition), rather it determines what\nkinds of decompositions are allowed and the pattern of communication\nused to enable the decomposition.  A decomposition is created when the\nsimulation box is first created, via the create_box\nor read_data or read_restart\ncommands.  For both the brick and tiled styles, the initial\ndecomposition will be the same, as described by\ncreate_box and processors\ncommands.  The decomposition can be changed via the\nbalance or fix balance commands.",
    "syntax": "comm_style style",
    "parameters": " * style = brick or tiled",
    "examples": "comm_style brick\ncomm_style tiled",
    "restrictions": "Communication style tiled cannot be used with triclinic simulation\ncells."
},
{
    "command": "compute",
    "html_filename": "compute.html",
    "short_description": "Define a computation that will be performed on a group of atoms",
    "description": "Define a computation that will be performed on a group of atoms.\nQuantities calculated by a compute are instantaneous values, meaning\nthey are calculated from information about atoms on the current\ntimestep or iteration, though a compute may internally store some\ninformation about a previous state of the system.  Defining a compute\ndoes not perform a computation.  Instead computes are invoked by other\nLAMMPS commands as needed, e.g. to calculate a temperature needed for\na thermostat fix or to generate thermodynamic or dump file output.\nSee the Howto output doc page for a summary of\nvarious LAMMPS output options, many of which involve computes.\nThe ID of a compute can only contain alphanumeric characters and\nunderscores.\n\nComputes calculate one of three styles of quantities: global,\nper-atom, or local.  A global quantity is one or more system-wide\nvalues, e.g. the temperature of the system.  A per-atom quantity is\none or more values per atom, e.g. the kinetic energy of each atom.\nPer-atom values are set to 0.0 for atoms not in the specified compute\ngroup.  Local quantities are calculated by each processor based on the\natoms it owns, but there may be zero or more per atom, e.g. a list of\nbond distances.  Computes that produce per-atom quantities have the\nword “atom” in their style, e.g. ke/atom.  Computes that produce\nlocal quantities have the word “local” in their style,\ne.g. bond/local.  Styles with neither “atom” or “local” in their\nstyle produce global quantities.\nNote that a single compute can produce either global or per-atom or\nlocal quantities, but not both global and per-atom.  It can produce\nlocal quantities in tandem with global or per-atom quantities.  The\ncompute doc page will explain.\nGlobal, per-atom, and local quantities each come in three kinds: a\nsingle scalar value, a vector of values, or a 2d array of values.  The\ndoc page for each compute describes the style and kind of values it\nproduces, e.g. a per-atom vector.  Some computes produce more than one\nkind of a single style, e.g. a global scalar and a global vector.\nWhen a compute quantity is accessed, as in many of the output commands\ndiscussed below, it can be referenced via the following bracket\nnotation, where ID is the ID of the compute:\n\n\n\n\n\n\nc_ID\nentire scalar, vector, or array\n\nc_ID[I]\none element of vector, one column of array\n\nc_ID[I][J]\none element of array\n\n\n\nIn other words, using one bracket reduces the dimension of the\nquantity once (vector -> scalar, array -> vector).  Using two brackets\nreduces the dimension twice (array -> scalar).  Thus a command that\nuses scalar compute values as input can also process elements of a\nvector or array.\nNote that commands and variables which use compute\nquantities typically do not allow for all kinds, e.g. a command may\nrequire a vector of values, not a scalar.  This means there is no\nambiguity about referring to a compute quantity as c_ID even if it\nproduces, for example, both a scalar and vector.  The doc pages for\nvarious commands explain the details.\n\nIn LAMMPS, the values generated by a compute can be used in several\nways:\n\nThe results of computes that calculate a global temperature or\npressure can be used by fixes that do thermostatting or barostatting\nor when atom velocities are created.\nGlobal values can be output via the thermo_style custom or fix ave/time command.\nOr the values can be referenced in a variable equal or\nvariable atom command.\nPer-atom values can be output via the dump custom command.\nOr they can be time-averaged via the fix ave/atom\ncommand or reduced by the compute reduce\ncommand.  Or the per-atom values can be referenced in an atom-style variable.\nLocal values can be reduced by the compute reduce command, or histogrammed by the fix ave/histo command, or output by the dump local command.\n\nThe results of computes that calculate global quantities can be either\n“intensive” or “extensive” values.  Intensive means the value is\nindependent of the number of atoms in the simulation,\ne.g. temperature.  Extensive means the value scales with the number of\natoms in the simulation, e.g. total rotational kinetic energy.\nThermodynamic output will normalize extensive\nvalues by the number of atoms in the system, depending on the\n“thermo_modify norm” setting.  It will not normalize intensive values.\nIf a compute value is accessed in another way, e.g. by a\nvariable, you may want to know whether it is an\nintensive or extensive value.  See the doc page for individual\ncomputes for further info.\n\nLAMMPS creates its own computes internally for thermodynamic output.\nThree computes are always created, named “thermo_temp”,\n“thermo_press”, and “thermo_pe”, as if these commands had been invoked\nin the input script:\ncompute thermo_temp all temp\ncompute thermo_press all pressure thermo_temp\ncompute thermo_pe all pe\n\n\nAdditional computes for other quantities are created if the thermo\nstyle requires it.  See the documentation for the\nthermo_style command.\nFixes that calculate temperature or pressure, i.e. for thermostatting\nor barostatting, may also create computes.  These are discussed in the\ndocumentation for specific fix commands.\nIn all these cases, the default computes LAMMPS creates can be\nreplaced by computes defined by the user in the input script, as\ndescribed by the thermo_modify and fix modify commands.\nProperties of either a default or user-defined compute can be modified\nvia the compute_modify command.\nComputes can be deleted with the uncompute command.\nCode for new computes can be added to LAMMPS; see the\nModify doc page for details.  The results of their\ncalculations accessed in the various ways described above.\n\nEach compute style has its own doc page which describes its arguments\nand what it does.  Here is an alphabetic list of compute styles\navailable in LAMMPS.  They are also listed in more compact form on the\nCommands compute doc page.\nThere are also additional accelerated compute styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands compute doc page are followed by one or more of\n(g,i,k,o,t) to indicate which accelerated styles exist.\n\nackland/atom - determines the local lattice structure based on the Ackland formulation\nadf - angular distribution function of triples of atoms\naggregate/atom - aggregate ID for each atom\nangle - energy of each angle sub-style\nangle/local - theta and energy of each angle\nangmom/chunk - angular momentum for each chunk\nbasal/atom - calculates the hexagonal close-packed “c” lattice vector of each atom\nbody/local - attributes of body sub-particles\nbond - energy of each bond sub-style\nbond/local - distance and energy of each bond\ncentro/atom - centro-symmetry parameter for each atom\ncentroid/stress/atom - centroid based stress tensor for each atom\nchunk/atom - assign chunk IDs to each atom\nchunk/spread/atom - spreads chunk values to each atom in chunk\ncluster/atom - cluster ID for each atom\ncna/atom - common neighbor analysis (CNA) for each atom\ncnp/atom - common neighborhood parameter (CNP) for each atom\ncom - center-of-mass of group of atoms\ncom/chunk - center-of-mass for each chunk\ncontact/atom - contact count for each spherical particle\ncoord/atom - coordination number for each atom\ndamage/atom - Peridynamic damage for each atom\ndihedral - energy of each dihedral sub-style\ndihedral/local - angle of each dihedral\ndilatation/atom - Peridynamic dilatation for each atom\ndipole/chunk - dipole vector and total dipole for each chunk\ndisplace/atom - displacement of each atom\ndpd -\ndpd/atom -\nedpd/temp/atom - per-atom temperature for each eDPD particle in a group\nentropy/atom - pair entropy fingerprint of each atom\nerotate/asphere - rotational energy of aspherical particles\nerotate/rigid - rotational energy of rigid bodies\nerotate/sphere - rotational energy of spherical particles\nerotate/sphere/atom - rotational energy for each spherical particle\nevent/displace - detect event on atom displacement\nfep -\nforce/tally -\nfragment/atom - fragment ID for each atom\nglobal/atom -\ngroup/group - energy/force between two groups of atoms\ngyration - radius of gyration of group of atoms\ngyration/chunk - radius of gyration for each chunk\ngyration/shape - shape parameters from gyration tensor\ngyration/shape/chunk - shape parameters from gyration tensor for each chunk\nheat/flux - heat flux through a group of atoms\nheat/flux/tally -\nhexorder/atom - bond orientational order parameter q6\nhma - harmonically mapped averaging for atomic crystals\nimproper - energy of each improper sub-style\nimproper/local - angle of each improper\ninertia/chunk - inertia tensor for each chunk\nke - translational kinetic energy\nke/atom - kinetic energy for each atom\nke/atom/eff - per-atom translational and radial kinetic energy in the electron force field model\nke/eff - kinetic energy of a group of nuclei and electrons in the electron force field model\nke/rigid - translational kinetic energy of rigid bodies\nmeso/e/atom - per-atom internal energy of Smooth-Particle Hydrodynamics atoms\nmeso/rho/atom - per-atom mesoscopic density of Smooth-Particle Hydrodynamics atoms\nmeso/t/atom - per-atom internal temperature of Smooth-Particle Hydrodynamics atoms\nmomentum - translational momentum\nmsd - mean-squared displacement of group of atoms\nmsd/chunk - mean-squared displacement for each chunk\nmsd/nongauss - MSD and non-Gaussian parameter of group of atoms\nomega/chunk - angular velocity for each chunk\norientorder/atom - Steinhardt bond orientational order parameters Ql\npair - values computed by a pair style\npair/local - distance/energy/force of each pairwise interaction\npe - potential energy\npe/atom - potential energy for each atom\npe/mol/tally -\npe/tally -\nplasticity/atom - Peridynamic plasticity for each atom\npressure - total pressure and pressure tensor\npressure/cylinder - pressure tensor in cylindrical coordinates\npressure/uef - pressure tensor in the reference frame of an applied flow field\nproperty/atom - convert atom attributes to per-atom vectors/arrays\nproperty/chunk - extract various per-chunk attributes\nproperty/local - convert local attributes to localvectors/arrays\nptm/atom - determines the local lattice structure based on the Polyhedral Template Matching method\nrdf - radial distribution function g(r) histogram of group of atoms\nreduce - combine per-atom quantities into a single global value\nreduce/chunk - reduce per-atom quantities within each chunk\nreduce/region - same as compute reduce, within a region\nrigid/local - extract rigid body attributes\nsaed - electron diffraction intensity on a mesh of reciprocal lattice nodes\nslice - extract values from global vector or array\nsmd/contact/radius -\nsmd/damage - damage status of SPH particles in Smooth Mach Dynamics\nsmd/hourglass/error -\nsmd/internal/energy - per-particle enthalpy in Smooth Mach Dynamics\nsmd/plastic/strain - equivalent plastic strain per particle in Smooth Mach Dynamics\nsmd/plastic/strain/rate - time rate of the equivalent plastic strain in Smooth Mach Dynamics\nsmd/rho - per-particle mass density in Smooth Mach Dynamics\nsmd/tlsph/defgrad - deformation gradient in Smooth Mach Dynamics\nsmd/tlsph/dt - CFL-stable time increment per particle in Smooth Mach Dynamics\nsmd/tlsph/num/neighs -\nsmd/tlsph/shape -\nsmd/tlsph/strain -\nsmd/tlsph/strain/rate -\nsmd/tlsph/stress - per-particle Cauchy stress tensor for SPH particles\nsmd/triangle/vertices -\nsmd/ulsph/num/neighs -\nsmd/ulsph/strain -\nsmd/ulsph/strain/rate -\nsmd/ulsph/stress - per-particle Cauchy stress tensor and von Mises equivalent stress in Smooth Mach Dynamics\nsmd/vol - per-particle volumes and their sum in Smooth Mach Dynamics\nsnap - bispectrum components and related quantities for a group of atoms\nsna/atom - bispectrum components for each atom\nsnad/atom - derivative of bispectrum components for each atom\nsnav/atom - virial contribution from bispectrum components for each atom\nspin - magnetic quantities for a system of atoms having spins\nstress/atom - stress tensor for each atom\nstress/mop - normal components of the local stress tensor using the method of planes\nstress/mop/profile - profile of the normal components of the local stress tensor using the method of planes\nstress/tally -\ntdpd/cc/atom - per-atom chemical concentration of a specified species for each tDPD particle\ntemp - temperature of group of atoms\ntemp/asphere - temperature of aspherical particles\ntemp/body - temperature of body particles\ntemp/chunk - temperature of each chunk\ntemp/com - temperature after subtracting center-of-mass velocity\ntemp/cs - temperature based on the center-of-mass velocity of atom pairs that are bonded to each other\ntemp/deform - temperature excluding box deformation velocity\ntemp/deform/eff - temperature excluding box deformation velocity in the electron force field model\ntemp/drude - temperature of Core-Drude pairs\ntemp/eff - temperature of a group of nuclei and electrons in the electron force field model\ntemp/partial - temperature excluding one or more dimensions of velocity\ntemp/profile - temperature excluding a binned velocity profile\ntemp/ramp - temperature excluding ramped velocity component\ntemp/region - temperature of a region of atoms\ntemp/region/eff - temperature of a region of nuclei and electrons in the electron force field model\ntemp/rotate - temperature of a group of atoms after subtracting out their center-of-mass and angular velocities\ntemp/sphere - temperature of spherical particles\ntemp/uef - kinetic energy tensor in the reference frame of an applied flow field\nti - thermodynamic integration free energy values\ntorque/chunk - torque applied on each chunk\nvacf - velocity auto-correlation function of group of atoms\nvcm/chunk - velocity of center-of-mass for each chunk\nvoronoi/atom - Voronoi volume and neighbors for each atom\nxrd - x-ray diffraction intensity on a mesh of reciprocal lattice nodes",
    "syntax": "compute ID group-ID style args",
    "parameters": " * ID = user-assigned name for the computation\n * group-ID = ID of the group of atoms to perform the computation on\n * style = one of a list of possible style names (see below)\n * args = arguments used by a particular style",
    "examples": "compute 1 all temp\ncompute newtemp flow temp/partial 1 1 0\ncompute 3 all ke/atom",
    "restrictions": "\nnone"
},
{
    "command": "create_atoms",
    "html_filename": "create_atoms.html",
    "short_description": "This command creates atoms (or molecules) on a lattice, or a single atom (or molecule), or a random collection of atoms (or molecules), as an alternative to reading in their coordinates explicitly via a read_data or read_restart command",
    "description": "This command creates atoms (or molecules) on a lattice, or a single\natom (or molecule), or a random collection of atoms (or molecules), as\nan alternative to reading in their coordinates explicitly via a\nread_data or read_restart\ncommand.  A simulation box must already exist, which is typically\ncreated via the create_box command.  Before using\nthis command, a lattice must also be defined using the\nlattice command, unless you specify the single style\nwith units = box or the random style.  For the remainder of this doc\npage, a created atom or molecule is referred to as a “particle”.\nIf created particles are individual atoms, they are assigned the\nspecified atom type, though this can be altered via the basis\nkeyword as discussed below.  If molecules are being created, the type\nof each atom in the created molecule is specified in the file read by\nthe molecule command, and those values are added to\nthe specified atom type.  E.g. if type = 2, and the file specifies\natom types 1,2,3, then each created molecule will have atom types\n3,4,5.\nFor the box style, the create_atoms command fills the entire\nsimulation box with particles on the lattice.  If your simulation box\nis periodic, you should insure its size is a multiple of the lattice\nspacings, to avoid unwanted atom overlaps at the box boundaries.  If\nyour box is periodic and a multiple of the lattice spacing in a\nparticular dimension, LAMMPS is careful to put exactly one particle at\nthe boundary (on either side of the box), not zero or two.\nFor the region style, a geometric volume is filled with particles on\nthe lattice.  This volume what is inside the simulation box and is\nalso consistent with the region volume.  See the region\ncommand for details.  Note that a region can be specified so that its\n“volume” is either inside or outside a geometric boundary.  Also note\nthat if your region is the same size as a periodic simulation box (in\nsome dimension), LAMMPS does not implement the same logic described\nabove as for the box style, to insure exactly one particle at\nperiodic boundaries.  if this is what you desire, you should either\nuse the box style, or tweak the region size to get precisely the\nparticles you want.\nFor the single style, a single particle is added to the system at\nthe specified coordinates.  This can be useful for debugging purposes\nor to create a tiny system with a handful of particles at specified\npositions.\nFor the random style, N particles are added to the system at\nrandomly generated coordinates, which can be useful for generating an\namorphous system.  The particles are created one by one using the\nspecified random number seed, resulting in the same set of particles\ncoordinates, independent of how many processors are being used in the\nsimulation.  If the region-ID argument is specified as NULL, then\nthe created particles will be anywhere in the simulation box.  If a\nregion-ID is specified, a geometric volume is filled which is both\ninside the simulation box and is also consistent with the region\nvolume.  See the region command for details.  Note that\na region can be specified so that its “volume” is either inside or\noutside a geometric boundary.\n\nNote\nParticles generated by the random style will typically be\nhighly overlapped which will cause many interatomic potentials to\ncompute large energies and forces.  Thus you should either perform an\nenergy minimization or run dynamics with fix nve/limit to equilibrate such a system, before\nrunning normal dynamics.\n\nNote that this command adds particles to those that already exist.\nThis means it can be used to add particles to a system previously read\nin from a data or restart file.  Or the create_atoms command can be\nused multiple times, to add multiple sets of particles to the\nsimulation.  For example, grain boundaries can be created, by\ninterleaving create_atoms with lattice commands\nspecifying different orientations.  By using the create_atoms command\nin conjunction with the delete_atoms command,\nreasonably complex geometries can be created, or a protein can be\nsolvated with a surrounding box of water molecules.\nIn all these cases, care should be taken to insure that new atoms do\nnot overlap existing atoms inappropriately, especially if molecules\nare being added.  The delete_atoms command can be\nused to remove overlapping atoms or molecules.\n\nNote\nYou cannot use any of the styles explained above to create atoms\nthat are outside the simulation box; they will just be ignored by\nLAMMPS.  This is true even if you are using shrink-wrapped box\nboundaries, as specified by the boundary command.\nHowever, you can first use the change_box command to\ntemporarily expand the box, then add atoms via create_atoms, then\nfinally use change_box command again if needed to re-shrink-wrap the\nnew atoms.  See the change_box doc page for an\nexample of how to do this, using the create_atoms single style to\ninsert a new atom outside the current simulation box.\n\n\nIndividual atoms are inserted by this command, unless the mol\nkeyword is used.  It specifies a template-ID previously defined\nusing the molecule command, which reads a file that\ndefines the molecule.  The coordinates, atom types, charges, etc, as\nwell as any bond/angle/etc and special neighbor information for the\nmolecule can be specified in the molecule file.  See the\nmolecule command for details.  The only settings\nrequired to be in this file are the coordinates and types of atoms in\nthe molecule.\nUsing a lattice to add molecules, e.g. via the box or region or\nsingle styles, is exactly the same as adding atoms on lattice\npoints, except that entire molecules are added at each point, i.e. on\nthe point defined by each basis atom in the unit cell as it tiles the\nsimulation box or region.  This is done by placing the geometric\ncenter of the molecule at the lattice point, and giving the molecule a\nrandom orientation about the point.  The random seed specified with\nthe mol keyword is used for this operation, and the random numbers\ngenerated by each processor are different.  This means the coordinates\nof individual atoms (in the molecules) will be different when running\non different numbers of processors, unlike when atoms are being\ncreated in parallel.\nAlso note that because of the random rotations, it may be important to\nuse a lattice with a large enough spacing that adjacent molecules will\nnot overlap, regardless of their relative orientations.\n\nNote\nIf the create_box command is used to create\nthe simulation box, followed by the create_atoms command with its\nmol option for adding molecules, then you typically need to use the\noptional keywords allowed by the create_box command\nfor extra bonds (angles,etc) or extra special neighbors.  This is\nbecause by default, the create_box command sets up a\nnon-molecular system which doesn’t allow molecules to be added.\n\n\nThis is the meaning of the other allowed keywords.\nThe basis keyword is only used when atoms (not molecules) are being\ncreated.  It specifies an atom type that will be assigned to specific\nbasis atoms as they are created.  See the lattice\ncommand for specifics on how basis atoms are defined for the unit cell\nof the lattice.  By default, all created atoms are assigned the\nargument type as their atom type.\nThe ratio and subset keywords can be used in conjunction with the\nbox or region styles to limit the total number of particles\ninserted.  The lattice defines a set of Nlatt eligible sites for\ninserting particles, which may be limited by the region style or the\nvar and set keywords.  For the ratio keyword only the specified\nfraction of them (0 <= frac <= 1) will be assigned particles.  For\nthe subset keyword only the specified Nsubset of them will be\nassigned particles.  In both cases the assigned lattice sites are\nchosen randomly.  An iterative algorithm is used which insures the\ncorrect number of particles are inserted, in a perfectly random\nfashion.  Which lattice sites are selected will change with the number\nof processors used.\nThe remap keyword only applies to the single style.  If it is set\nto yes, then if the specified position is outside the simulation\nbox, it will mapped back into the box, assuming the relevant\ndimensions are periodic.  If it is set to no, no remapping is done\nand no particle is created if its position is outside the box.\nThe var and set keywords can be used together to provide a\ncriterion for accepting or rejecting the addition of an individual\natom, based on its coordinates.  The name specified for the var\nkeyword is the name of an equal-style variable which\nshould evaluate to a zero or non-zero value based on one or two or\nthree variables which will store the x, y, or z coordinates of an atom\n(one variable per coordinate).  If used, these other variables must be\ninternal-style variables defined in the input script;\ntheir initial numeric value can be anything.  They must be\ninternal-style variables, because this command resets their values\ndirectly.  The set keyword is used to identify the names of these\nother variables, one variable for the x-coordinate of a created atom,\none for y, and one for z.\nWhen an atom is created, its x,y,z coordinates become the values for\nany set variable that is defined.  The var variable is then\nevaluated.  If the returned value is 0.0, the atom is not created.  If\nit is non-zero, the atom is created.\nAs an example, these commands can be used in a 2d simulation, to\ncreate a sinusoidal surface.  Note that the surface is “rough” due to\nindividual lattice points being “above” or “below” the mathematical\nexpression for the sinusoidal curve.  If a finer lattice were used,\nthe sinusoid would appear to be “smoother”.  Also note the use of the\n“xlat” and “ylat” thermo_style keywords which\nconverts lattice spacings to distance.  Click on the image for a\nlarger version.\ndimension       2\nvariable        x equal 100\nvariable        y equal 25\nlattice         hex 0.8442\nregion          box block 0 $x 0 $y -0.5 0.5\ncreate_box      1 box\n\nvariable        xx internal 0.0\nvariable        yy internal 0.0\nvariable        v equal \"(0.2*v_y*ylat * cos(v_xx/xlat * 2.0*PI*4.0/v_x) + 0.5*v_y*ylat - v_yy) > 0.0\"\ncreate_atoms    1 box var v set x xx set y yy\nwrite_dump      all atom sinusoid.lammpstrj\n\n\n\nThe rotate keyword allows specification of the orientation\nat which molecules are inserted.  The axis of rotation is\ndetermined by the rotation vector (Rx,Ry,Rz) that goes through the\ninsertion point.  The specified theta determines the angle of\nrotation around that axis.  Note that the direction of rotation for\nthe atoms around the rotation axis is consistent with the right-hand\nrule: if your right-hand’s thumb points along R, then your fingers\nwrap around the axis in the direction of rotation.\nThe units keyword determines the meaning of the distance units used\nto specify the coordinates of the one particle created by the single\nstyle.  A box value selects standard distance units as defined by\nthe units command, e.g. Angstroms for units = real or\nmetal.  A lattice value means the distance units are in lattice\nspacings.\n\nAtom IDs are assigned to created atoms in the following way.  The\ncollection of created atoms are assigned consecutive IDs that start\nimmediately following the largest atom ID existing before the\ncreate_atoms command was invoked.  This is done by the processor’s\ncommunicating the number of atoms they each own, the first processor\nnumbering its atoms from 1 to N1, the second processor from N1+1 to\nN2, etc.  Where N1 = number of atoms owned by the first processor, N2\n= number owned by the second processor, etc.  Thus when the same\nsimulation is performed on different numbers of processors, there is\nno guarantee a particular created atom will be assigned the same ID in\nboth simulations.  If molecules are being created, molecule IDs are\nassigned to created molecules in a similar fashion.\nAside from their ID, atom type, and xyz position, other properties of\ncreated atoms are set to default values, depending on which quantities\nare defined by the chosen atom style.  See the atom style command for more details.  See the\nset and velocity commands for info on how\nto change these values.\n\ncharge = 0.0\ndipole moment magnitude = 0.0\ndiameter = 1.0\nshape = 0.0 0.0 0.0\ndensity = 1.0\nvolume = 1.0\nvelocity = 0.0 0.0 0.0\nangular velocity = 0.0 0.0 0.0\nangular momentum = 0.0 0.0 0.0\nquaternion = (1,0,0,0)\nbonds, angles, dihedrals, impropers = none\n\nIf molecules are being created, these defaults can be overridden by\nvalues specified in the file read by the molecule\ncommand.  E.g. the file typically defines bonds (angles,etc) between\natoms in the molecule, and can optionally define charges on each atom.\nNote that the sphere atom style sets the default particle diameter\nto 1.0 as well as the density.  This means the mass for the particle\nis not 1.0, but is PI/6 * diameter^3 = 0.5236.\nNote that the ellipsoid atom style sets the default particle shape\nto (0.0 0.0 0.0) and the density to 1.0 which means it is a point\nparticle, not an ellipsoid, and has a mass of 1.0.\nNote that the peri style sets the default volume and density to 1.0\nand thus also set the mass for the particle to 1.0.\nThe set command can be used to override many of these\ndefault settings.",
    "syntax": "create_atoms type style args keyword values ...",
    "parameters": " * type = atom type (1-Ntypes) of atoms to create (offset for molecule creation)\n * style = box or region or single or random\n * box args = none\n * region args = region-ID\n *   region-ID = particles will only be created if contained in the region\n * single args = x y z\n *   x,y,z = coordinates of a single particle (distance units)\n * random args = N seed region-ID\n *   N = number of particles to create\n *   seed = random # seed (positive integer)\n *   region-ID = create atoms within this region, use NULL for entire simulation box\n * zero or more keyword/value pairs may be appended\n * keyword = mol or basis or ratio or subset or remap or var or set or rotate or units\n * *mol* value = template-ID seed\n *   template-ID = ID of molecule template specified in a separate :doc:`molecule <molecule>` command\n *   seed = random # seed (positive integer)\n * *basis* values = M itype\n *   M = which basis atom\n *   itype = atom type (1-N) to assign to this basis atom\n * *ratio* values = frac seed\n *   frac = fraction of lattice sites (0 to 1) to populate randomly\n *   seed = random # seed (positive integer)\n * *subset* values = Nsubset seed\n *   Nsubset = # of lattice sites to populate randomly\n *   seed = random # seed (positive integer)\n * *remap* value = *yes* or *no*\n * *var* value = name = variable name to evaluate for test of atom creation\n * *set* values = dim name\n *   dim = *x* or *y* or *z*\n *   name = name of variable to set with x, y, or z atom position\n * *rotate* values = theta Rx Ry Rz\n *   theta = rotation angle for single molecule (degrees)\n *   Rx,Ry,Rz = rotation vector for single molecule\n * *units* value = *lattice* or *box*\n *   *lattice* = the geometry is defined in lattice units\n *   *box* = the geometry is defined in simulation box units",
    "examples": "create_atoms 1 box\ncreate_atoms 3 region regsphere basis 2 3\ncreate_atoms 3 region regsphere basis 2 3 ratio 0.5 74637\ncreate_atoms 3 single 0 0 5\ncreate_atoms 1 box var v set x xpos set y ypos",
    "restrictions": "An atom_style must be previously defined to use this\ncommand.\nA rotation vector specified for a single molecule must be in\nthe z-direction for a 2d model."
},
{
    "command": "create_bonds",
    "html_filename": "create_bonds.html",
    "short_description": "Create bonds between pairs of atoms that meet a specified distance criteria",
    "description": "Create bonds between pairs of atoms that meet a specified distance\ncriteria.  Or create a single bond, angle, dihedral or improper between 2, 3,\nor 4 specified atoms.\nThe new bond (angle, dihedral, improper) interactions will then be computed\nduring a simulation by the bond (angle, dihedral, improper) potential defined by\nthe bond_style, bond_coeff,\nangle_style, angle_coeff,\ndihedral_style,\ndihedral_coeff, improper_style,\nimproper_coeff commands.\nThe many style is useful for adding bonds to a system, e.g. between\nnearest neighbors in a lattice of atoms, without having to enumerate\nall the bonds in the data file read by the read_data\ncommand.\nThe single styles are useful for adding bonds, angles, dihedrals, impropers\nto a system incrementally, then continuing a simulation.\nNote that this command does not auto-create any angle, dihedral or improper\ninteractions when a bond is added.  Nor does it auto-create any bonds\nwhen an angle, dihedral or improper is added.  Or auto-create any angles when a\ndihedral or improper is added.  Thus the flexibility of this command is limited.\nIt can be used several times to create different types of bond at\ndifferent distances.  But it cannot typically auto-create all the\nbonds or angles or dihedrals or impropers that would normally be defined in a\ndata file for a complex system of molecules.\n\nNote\nIf the system has no bonds (angles, dihedrals, impropers) to begin with,\nor if more bonds per atom are being added than currently exist, then you\nmust insure that the number of bond types and the maximum number of\nbonds per atom are set to large enough values.  And similarly for\nangles, dihedrals and impropers.  Otherwise an error may occur when too many\nbonds (angles, dihedrals, impropers) are added to an atom.  If the\nread_data command is used to define the system, these\nparameters can be set via the “bond types” and “extra bond per atom”\nfields in the header section of the data file.  If the\ncreate_box command is used to define the system,\nthese 2 parameters can be set via its optional “bond/types” and\n“extra/bond/per/atom” arguments.  And similarly for angles, dihedrals and\nimpropers.  See the doc pages for these 2 commands for details.\n\n\nThe many style will create bonds between pairs of atoms I,J where I\nis in one of the two specified groups, and J is in the other.  The two\ngroups can be the same, e.g. group “all”.  The created bonds will be\nof bond type btype, where btype must be a value between 1 and the\nnumber of bond types defined.\nFor a bond to be created, an I,J pair of atoms must be a distance D\napart such that rmin <= D <= rmax.\nThe following settings must have been made in an input script before\nthis style is used:\n\nspecial_bonds weight for 1-2 interactions must be 0.0\na pair_style must be defined\nno kspace_style defined\nminimum pair_style cutoff + neighbor skin >= rmax\n\nThese settings are required so that a neighbor list can be created to\nsearch for nearby atoms.  Pairs of atoms that are already bonded\ncannot appear in the neighbor list, to avoid creation of duplicate\nbonds.  The neighbor list for all atom type pairs must also extend to\na distance that encompasses the rmax for new bonds to create.\nAn additional requirement for this style is that your system must be\nready to perform a simulation.  This means, for example, that all\npair_style coefficients be set via the\npair_coeff command.  A bond_style\ncommand and all bond coefficients must also be set, even if no bonds\nexist before this command is invoked.  This is because the building of\nneighbor list requires initialization and setup of a simulation,\nsimilar to what a run command would require.\nNote that you can change any of these settings after this command\nexecutes, e.g. if you wish to use long-range Coulombic interactions\nvia the kspace_style command for your subsequent\nsimulation.\n\nThe single/bond style creates a single bond of type btype between\ntwo atoms with IDs batom1 and batom2.  Btype must be a value\nbetween 1 and the number of bond types defined.\nThe single/angle style creates a single angle of type atype\nbetween three atoms with IDs aatom1, aatom2, and aatom3.  The\nordering of the atoms is the same as in the Angles section of a data\nfile read by the read_data command.  I.e. the 3 atoms are\nordered linearly within the angle; the central atom is aatom2.\nAtype must be a value between 1 and the number of angle types\ndefined.\nThe single/dihedral style creates a single dihedral of type dtype\nbetween four atoms with IDs datom1, datom2, datom3, and datom4.  The\nordering of the atoms is the same as in the Dihedrals section of a data file\nread by the read_data command.  I.e. the 4 atoms are ordered\nlinearly within the dihedral.  dtype must be a value between 1 and\nthe number of dihedral types defined.\nThe single/improper style creates a single improper of type itype\nbetween four atoms with IDs iatom1, iatom2, iatom3, and iatom4.  The\nordering of the atoms is the same as in the Impropers section of a data file\nread by the read_data command.  I.e. the 4 atoms are ordered\nlinearly within the improper.  itype must be a value between 1 and\nthe number of improper types defined.\n\nThe keyword special controls whether an internal list of special\nbonds is created after one or more bonds, or a single angle, dihedral or\nimproper is added to the system.\nThe default value is yes.  A value of no cannot be used\nwith the many style.\nThis is an expensive operation since the bond topology for the system\nmust be walked to find all 1-2, 1-3, 1-4 interactions to store in an\ninternal list, which is used when pairwise interactions are weighted;\nsee the special_bonds command for details.\nThus if you are adding a few bonds or a large list of angles all at\nthe same time, by using this command repeatedly, it is more efficient\nto only trigger the internal list to be created once, after the last\nbond (or angle, or dihedral, or improper) is added:\ncreate_bonds single/bond 5 52 98 special no\ncreate_bonds single/bond 5 73 74 special no\n...\ncreate_bonds single/bond 5 17 386 special no\ncreate_bonds single/bond 4 112 183 special yes\n\n\nNote that you MUST insure the internal list is re-built after the last\nbond (angle, dihedral, improper) is added, before performing a simulation.\nOtherwise pairwise interactions will not be properly excluded or\nweighted.  LAMMPS does NOT check that you have done this correctly.",
    "syntax": "create_bonds style args ... keyword value ...",
    "parameters": " * style = many or single/bond or single/angle or single/dihedral\n * many args = group-ID group2-ID btype rmin rmax\n *   group-ID = ID of first group\n *   group2-ID = ID of second group, bonds will be between atoms in the 2 groups\n *   btype = bond type of created bonds\n *   rmin = minimum distance between pair of atoms to bond together\n *   rmax = maximum distance between pair of atoms to bond together\n * single/bond args = btype batom1 batom2\n *   btype = bond type of new bond\n *   batom1,batom2 = atom IDs for two atoms in bond\n * single/angle args = atype aatom1 aatom2 aatom3\n *   atype = angle type of new angle\n *   aatom1,aatom2,aatom3 = atom IDs for three atoms in angle\n * single/dihedral args = dtype datom1 datom2 datom3 datom4\n *   dtype = dihedral type of new dihedral\n *   datom1,datom2,datom3,datom4 = atom IDs for four atoms in dihedral\n * single/improper args = itype iatom1 iatom2 iatom3 iatom4\n *   itype = improper type of new improper\n *   iatom1,iatom2,iatom3,iatom4 = atom IDs for four atoms in improper\n * zero or more keyword/value pairs may be appended\n * keyword = special\n * special value = yes or no",
    "examples": "create_bonds many all all 1 1.0 1.2\ncreate_bonds many surf solvent 3 2.0 2.4\ncreate_bonds single/bond 1 1 2\ncreate_bonds single/angle 5 52 98 107 special no\ncreate_bonds single/dihedral 2 4 19 27 101\ncreate_bonds single/improper 3 23 26 31 57",
    "restrictions": "This command cannot be used with molecular systems defined using\nmolecule template files via the molecule and\natom_style template commands."
},
{
    "command": "create_box",
    "html_filename": "create_box.html",
    "short_description": "This command creates a simulation box based on the specified region",
    "description": "This command creates a simulation box based on the specified region.\nThus a region command must first be used to define a\ngeometric domain.  It also partitions the simulation box into a\nregular 3d grid of rectangular bricks, one per processor, based on the\nnumber of processors being used and the settings of the\nprocessors command.  The partitioning can later be\nchanged by the balance or fix balance commands.\nThe argument N is the number of atom types that will be used in the\nsimulation.\nIf the region is not of style prism, then LAMMPS encloses the region\n(block, sphere, etc) with an axis-aligned orthogonal bounding box\nwhich becomes the simulation domain.\nIf the region is of style prism, LAMMPS creates a non-orthogonal\nsimulation domain shaped as a parallelepiped with triclinic symmetry.\nAs defined by the region prism command, the\nparallelepiped has its “origin” at (xlo,ylo,zlo) and is defined by 3\nedge vectors starting from the origin given by A = (xhi-xlo,0,0); B =\n(xy,yhi-ylo,0); C = (xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or\npositive or negative values and are called “tilt factors” because they\nare the amount of displacement applied to faces of an originally\northogonal box to transform it into the parallelepiped.\nBy default, a prism region used with the create_box command must\nhave tilt factors (xy,xz,yz) that do not skew the box more than half\nthe distance of the parallel box length.  For example, if xlo = 2 and\nxhi = 12, then the x box length is 10 and the xy tilt factor must be\nbetween -5 and 5.  Similarly, both xz and yz must be between\n-(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a limitation,\nsince if the maximum tilt factor is 5 (as in this example), then\nconfigurations with tilt = …, -15, -5, 5, 15, 25, … are all\ngeometrically equivalent.  If you wish to define a box with tilt\nfactors that exceed these limits, you can use the box tilt\ncommand, with a setting of large; a setting of small is the\ndefault.\nSee the Howto triclinic doc page for a\ngeometric description of triclinic boxes, as defined by LAMMPS, and\nhow to transform these parameters to and from other commonly used\ntriclinic representations.\nWhen a prism region is used, the simulation domain should normally be\nperiodic in the dimension that the tilt is applied to, which is given\nby the second dimension of the tilt factor (e.g. y for xy tilt).  This\nis so that pairs of atoms interacting across that boundary will have\none of them shifted by the tilt factor.  Periodicity is set by the\nboundary command.  For example, if the xy tilt factor\nis non-zero, then the y dimension should be periodic.  Similarly, the\nz dimension should be periodic if xz or yz is non-zero.  LAMMPS does\nnot require this periodicity, but you may lose atoms if this is not\nthe case.\nAlso note that if your simulation will tilt the box, e.g. via the fix deform command, the simulation box must be setup to\nbe triclinic, even if the tilt factors are initially 0.0.  You can\nalso change an orthogonal box to a triclinic box or vice versa by\nusing the change box command with its ortho and\ntriclinic options.\n\nNote\nIf the system is non-periodic (in a dimension), then you should\nnot make the lo/hi box dimensions (as defined in your\nregion command) radically smaller/larger than the extent\nof the atoms you eventually plan to create, e.g. via the\ncreate_atoms command.  For example, if your atoms\nextend from 0 to 50, you should not specify the box bounds as -10000\nand 10000. This is because as described above, LAMMPS uses the\nspecified box size to layout the 3d grid of processors.  A huge\n(mostly empty) box will be sub-optimal for performance when using\n“fixed” boundary conditions (see the boundary\ncommand).  When using “shrink-wrap” boundary conditions (see the\nboundary command), a huge (mostly empty) box may cause\na parallel simulation to lose atoms the first time that LAMMPS\nshrink-wraps the box around the atoms.\n\n\nThe optional keywords can be used to create a system that allows for\nbond (angle, dihedral, improper) interactions, or for molecules with\nspecial 1-2,1-3,1-4 neighbors to be added later.  These optional\nkeywords serve the same purpose as the analogous keywords that can be\nused in a data file which are recognized by the\nread_data command when it sets up a system.\nNote that if these keywords are not used, then the create_box command\ncreates an atomic (non-molecular) simulation that does not allow bonds\nbetween pairs of atoms to be defined, or a bond potential to be specified, or for molecules with\nspecial neighbors to be added to the system by commands such as\ncreate_atoms mol, fix deposit\nor fix pour.\nAs an example, see the examples/deposit/in.deposit.molecule script,\nwhich deposits molecules onto a substrate.  Initially there are no\nmolecules in the system, but they are added later by the fix deposit command.  The create_box command in the\nscript uses the bond/types and extra/bond/per/atom keywords to allow\nthis.  If the added molecule contained more than 1 special bond\n(allowed by default), an extra/special/per/atom keyword would also\nneed to be specified.",
    "syntax": "create_box N region-ID keyword value ...",
    "parameters": " * N = # of atom types to use in this simulation\n * region-ID = ID of region to use as simulation domain\n * zero or more keyword/value pairs may be appended\n * keyword = bond/types or angle/types or dihedral/types or improper/types or extra/bond/per/atom or extra/angle/per/atom or extra/dihedral/per/atom or extra/improper/per/atom\n * bond/types value = # of bond types\n * angle/types value = # of angle types\n * dihedral/types value = # of dihedral types\n * improper/types value = # of improper types\n * extra/bond/per/atom value = # of bonds per atom\n * extra/angle/per/atom value = # of angles per atom\n * extra/dihedral/per/atom value = # of dihedrals per atom\n * extra/improper/per/atom value = # of impropers per atom\n * extra/special/per/atom value = # of special neighbors per atom",
    "examples": "create_box 2 mybox\ncreate_box 2 mybox bond/types 2 extra/bond/per/atom 1",
    "restrictions": "An atom_style and region must have\nbeen previously defined to use this command."
},
{
    "command": "delete_atoms",
    "html_filename": "delete_atoms.html",
    "short_description": "Delete the specified atoms",
    "description": "Delete the specified atoms.  This command can be used to carve out\nvoids from a block of material or to delete created atoms that are too\nclose to each other (e.g. at a grain boundary).\nFor style group, all atoms belonging to the group are deleted.\nFor style region, all atoms in the region volume are deleted.\nAdditional atoms can be deleted if they are in a molecule for which\none or more atoms were deleted within the region; see the mol\nkeyword discussion below.\nFor style overlap pairs of atoms whose distance of separation is\nwithin the specified cutoff distance are searched for, and one of the\n2 atoms is deleted.  Only pairs where one of the two atoms is in the\nfirst group specified and the other atom is in the second group are\nconsidered.  The atom that is in the first group is the one that is\ndeleted.\nNote that it is OK for the two group IDs to be the same (e.g. group\nall), or for some atoms to be members of both groups.  In these\ncases, either atom in the pair may be deleted.  Also note that if\nthere are atoms which are members of both groups, the only guarantee\nis that at the end of the deletion operation, enough deletions will\nhave occurred that no atom pairs within the cutoff will remain\n(subject to the group restriction).  There is no guarantee that the\nminimum number of atoms will be deleted, or that the same atoms will\nbe deleted when running on different numbers of processors.\nFor style porosity a specified fraction of atoms are deleted\nwithin the specified region.  For example, if fraction is 0.1, then\n10% of the atoms will be deleted.  The atoms to delete are chosen\nrandomly.  There is no guarantee that the exact fraction of atoms will\nbe deleted, or that the same atoms will be deleted when running on\ndifferent numbers of processors.\nIf the compress keyword is set to yes, then after atoms are\ndeleted, then atom IDs are re-assigned so that they run from 1 to the\nnumber of atoms in the system.  Note that this is not done for\nmolecular systems (see the atom_style command),\nregardless of the compress setting, since it would foul up the bond\nconnectivity that has already been assigned.  However, the\nreset_ids command can be used after this command to\naccomplish the same thing.\nNote that the re-assignment of IDs is not really a compression, where\ngaps in atom IDs are removed by decrementing atom IDs that are larger.\nInstead the IDs for all atoms are erased, and new IDs are assigned so\nthat the atoms owned by individual processors have consecutive IDs, as\nthe create_atoms command explains.\nA molecular system with fixed bonds, angles, dihedrals, or improper\ninteractions, is one where the topology of the interactions is\ntypically defined in the data file read by the\nread_data command, and where the interactions\nthemselves are defined with the bond_style,\nangle_style, etc commands.  If you delete atoms\nfrom such a system, you must be careful not to end up with bonded\ninteractions that are stored by remaining atoms but which include\ndeleted atoms.  This will cause LAMMPS to generate a “missing atoms”\nerror when the bonded interaction is computed.  The bond and mol\nkeywords offer two ways to do that.\nIt the bond keyword is set to yes then any bond or angle or\ndihedral or improper interaction that includes a deleted atom is also\nremoved from the lists of such interactions stored by non-deleted\natoms.  Note that simply deleting interactions due to dangling bonds\n(e.g. at a surface) may result in a inaccurate or invalid model for\nthe remaining atoms.\nIt the mol keyword is set to yes, then for every atom that is\ndeleted, all other atoms in the same molecule (with the same molecule\nID) will also be deleted.  This is not done for atoms with molecule ID\n= 0, since such an ID is assumed to flag isolated atoms that are not\npart of molecules.\n\nNote\nThe molecule deletion operation in invoked after all individual\natoms have been deleted using the rules described above for each\nstyle.  This means additional atoms may be deleted that are not in the\ngroup or region, that are not required by the overlap cutoff\ncriterion, or that will create a higher fraction of porosity than was\nrequested.",
    "syntax": "delete_atoms style args keyword value ...",
    "parameters": " * style = group or region or overlap or porosity\n * group args = group-ID\n * region args = region-ID\n * overlap args = cutoff group1-ID group2-ID\n *   cutoff = delete one atom from pairs of atoms within the cutoff (distance units)\n *   group1-ID = one atom in pair must be in this group\n *   group2-ID = other atom in pair must be in this group\n * porosity args = region-ID fraction seed\n *   region-ID = region within which to perform deletions\n *   fraction = delete this fraction of atoms\n *   seed = random number seed (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = compress or bond or mol\n * compress value = no or yes\n * bond value = no or yes\n * mol value = no or yes",
    "examples": "delete_atoms group edge\ndelete_atoms region sphere compress no\ndelete_atoms overlap 0.3 all all\ndelete_atoms overlap 0.5 solvent colloid\ndelete_atoms porosity cube 0.1 482793 bond yes",
    "restrictions": "The overlap styles requires inter-processor communication to acquire\nghost atoms and build a neighbor list.  This means that your system\nmust be ready to perform a simulation before using this command (force\nfields setup, atom masses set, etc).  Since a neighbor list is used to\nfind overlapping atom pairs, it also means that you must define a\npair style with the minimum force cutoff distance\nbetween any pair of atoms types (plus the neighbor\nskin) >= the specified overlap cutoff.\nIf the special_bonds command is used with a\nsetting of 0, then a pair of bonded atoms (1-2, 1-3, or 1-4) will not\nappear in the neighbor list, and thus will not be considered for\ndeletion by the overlap styles.  You probably don’t want to be\ndeleting one atom in a bonded pair anyway.\nThe bond yes option cannot be used with molecular systems defined\nusing molecule template files via the molecule and\natom_style template commands."
},
{
    "command": "delete_bonds",
    "html_filename": "delete_bonds.html",
    "short_description": "Turn off (or on) molecular topology interactions, i",
    "description": "Turn off (or on) molecular topology interactions, i.e. bonds, angles,\ndihedrals, impropers.  This command is useful for deleting\ninteractions that have been previously turned off by bond-breaking\npotentials.  It is also useful for turning off topology interactions\nbetween frozen or rigid atoms.  Pairwise interactions can be turned\noff via the neigh_modify exclude command.  The\nfix shake command also effectively turns off certain\nbond and angle interactions.\nFor all styles, by default, an interaction is only turned off (or on)\nif all the atoms involved are in the specified group.  See the any\nkeyword to change the behavior.\nSeveral of the styles (atom, bond, angle, dihedral,\nimproper) take a type as an argument.  The specified type should\nbe an integer from 0 to N, where N is the number of relevant types\n(atom types, bond types, etc).  A value of 0 is only relevant for\nstyle bond; see details below.  In all cases, a wildcard asterisk\ncan be used in place of or in conjunction with the type argument to\nspecify a range of types.  This takes the form “*” or “*n” or “n*” or\n“m*n”.  If N = the number of types, then an asterisk with no numeric\nvalues means all types from 0 to N.  A leading asterisk means all\ntypes from 0 to n (inclusive).  A trailing asterisk means all types\nfrom n to N (inclusive).  A middle asterisk means all types from m to\nn (inclusive).  Note that it is fine to include a type of 0 for\nnon-bond styles; it will simply be ignored.\nFor style multi all bond, angle, dihedral, and improper interactions\nof any type, involving atoms in the group, are turned off.\nStyle atom is the same as style multi except that in addition, one\nor more of the atoms involved in the bond, angle, dihedral, or\nimproper interaction must also be of the specified atom type.\nFor style bond, only bonds are candidates for turn-off, and the bond\nmust also be of the specified type.  Styles angle, dihedral, and\nimproper are treated similarly.\nFor style bond, you can set the type to 0 to delete bonds that have\nbeen previously broken by a bond-breaking potential (which sets the\nbond type to 0 when a bond is broken); e.g. see the bond_style quartic command.\nFor style stats no interactions are turned off (or on); the status\nof all interactions in the specified group is simply reported.  This\nis useful for diagnostic purposes if bonds have been turned off by a\nbond-breaking potential during a previous run.\nThe default behavior of the delete_bonds command is to turn off\ninteractions by toggling their type to a negative value, but not to\npermanently remove the interaction.  E.g. a bond_type of 2 is set to\n-2.  The neighbor list creation routines will not include such an\ninteraction in their interaction lists.  The default is also to not\nalter the list of 1-2, 1-3, 1-4 neighbors computed by the\nspecial_bonds command and used to weight pairwise\nforce and energy calculations.  This means that pairwise computations\nwill proceed as if the bond (or angle, etc) were still turned on.\nSeveral keywords can be appended to the argument list to alter the\ndefault behaviors.\nThe any keyword changes the requirement that all atoms in the bond\n(angle, etc) must be in the specified group in order to turn-off the\ninteraction.  Instead, if any of the atoms in the interaction are in\nthe specified group, it will be turned off (or on if the undo\nkeyword is used).\nThe undo keyword inverts the delete_bonds command so that the\nspecified bonds, angles, etc are turned on if they are currently\nturned off.  This means a negative value is toggled to positive.  For\nexample, for style angle, if type is specified as 2, then all\nangles with current type = -2, are reset to type = 2.  Note that the\nfix shake command also sets bond and angle types\nnegative, so this option should not be used on those interactions.\nThe remove keyword is invoked at the end of the delete_bonds\noperation.  It causes turned-off bonds (angles, etc) to be removed\nfrom each atom’s data structure and then adjusts the global bond\n(angle, etc) counts accordingly.  Removal is a permanent change;\nremoved bonds cannot be turned back on via the undo keyword.\nRemoval does not alter the pairwise 1-2, 1-3, 1-4 weighting list.\nThe special keyword is invoked at the end of the delete_bonds\noperation, after (optional) removal.  It re-computes the pairwise 1-2,\n1-3, 1-4 weighting list.  The weighting list computation treats\nturned-off bonds the same as turned-on.  Thus, turned-off bonds must\nbe removed if you wish to change the weighting list.\nNote that the choice of remove and special options affects how\n1-2, 1-3, 1-4 pairwise interactions will be computed across bonds that\nhave been modified by the delete_bonds command.",
    "syntax": "delete_bonds group-ID style arg keyword ...",
    "parameters": " * group-ID = group ID\n * style = multi or atom or bond or angle or dihedral or improper or stats\n * multi arg = none\n * atom arg = an atom type or range of types (see below)\n * bond arg = a bond type or range of types (see below)\n * angle arg = an angle type or range of types (see below)\n * dihedral arg = a dihedral type or range of types (see below)\n * improper arg = an improper type or range of types (see below)\n * stats arg = none\n * zero or more keywords may be appended\n * keyword = any or undo or remove or special",
    "examples": "delete_bonds frozen multi remove\ndelete_bonds all atom 4 special\ndelete_bonds all bond 0*3 special\ndelete_bonds all stats",
    "restrictions": "This command requires inter-processor communication to acquire ghost\natoms, to coordinate the deleting of bonds, angles, etc between atoms\nshared by multiple processors.  This means that your system must be\nready to perform a simulation before using this command (force fields\nsetup, atom masses set, etc).  Just as would be needed to run\ndynamics, the force field you define should define a cutoff\n(e.g. through a pair_style command) which is long\nenough for a processor to acquire the ghost atoms its needs to compute\nbond, angle, etc interactions.\nIf deleted bonds (angles, etc) are removed but the 1-2, 1-3, 1-4\nweighting list is not re-computed, this can cause a later fix shake command to fail due to an atom’s bonds being\ninconsistent with the weighting list.  This should only happen if the\ngroup used in the fix command includes both atoms in the bond, in\nwhich case you probably should be recomputing the weighting list."
},
{
    "command": "dielectric",
    "html_filename": "dielectric.html",
    "short_description": "Set the dielectric constant for Coulombic interactions (pairwise and long-range) to this value",
    "description": "Set the dielectric constant for Coulombic interactions (pairwise and\nlong-range) to this value.  The constant is unitless, since it is used\nto reduce the strength of the interactions.  The value is used in the\ndenominator of the formulas for Coulombic interactions - e.g. a value\nof 4.0 reduces the Coulombic interactions to 25% of their default\nstrength.  See the pair_style command for more\ndetails.",
    "syntax": "dielectric value",
    "parameters": " * value = dielectric constant",
    "examples": "dielectric 2.0",
    "restrictions": "\nnone"
},
{
    "command": "dimension",
    "html_filename": "dimension.html",
    "short_description": "Set the dimensionality of the simulation",
    "description": "Set the dimensionality of the simulation.  By default LAMMPS runs 3d\nsimulations.  To run a 2d simulation, this command should be used\nprior to setting up a simulation box via the\ncreate_box or read_data commands.\nRestart files also store this setting.\nSee the discussion on the Howto 2d doc page for\nadditional instructions on how to run 2d simulations.\n\nNote\nSome models in LAMMPS treat particles as finite-size spheres or\nellipsoids, as opposed to point particles.  In 2d, the particles will\nstill be spheres or ellipsoids, not circular disks or ellipses,\nmeaning their moment of inertia will be the same as in 3d.",
    "syntax": "dimension N",
    "parameters": " * N = 2 or 3",
    "examples": "dimension 2",
    "restrictions": "This command must be used before the simulation box is defined by a\nread_data or create_box command."
},
{
    "command": "displace_atoms",
    "html_filename": "displace_atoms.html",
    "short_description": "Displace a group of atoms",
    "description": "Displace a group of atoms.  This can be used to move atoms a large\ndistance before beginning a simulation or to randomize atoms initially\non a lattice.  For example, in a shear simulation, an initial strain\ncan be imposed on the system.  Or two groups of atoms can be brought\ninto closer proximity.\nThe move style displaces the group of atoms by the specified 3d\ndisplacement vector.  Any of the 3 quantities defining the vector\ncomponents can be specified as an equal-style or atom-style\nvariable.  If the value is a variable, it should be\nspecified as v_name, where name is the variable name.  In this case,\nthe variable will be evaluated, and its value(s) used for the\ndisplacement(s).  The scale factor implied by the units keyword will\nalso be applied to the variable result.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Atom-style variables can specify the same formulas as\nequal-style variables but can also include per-atom values, such as\natom coordinates or per-atom values read from a file.  Note that if\nthe variable references other compute or fix\ncommands, those values must be up-to-date for the current timestep.\nSee the “Variable Accuracy” section of the variable\ndoc page for more details.\nThe ramp style displaces atoms a variable amount in one dimension\ndepending on the atom’s coordinate in a (possibly) different\ndimension.  For example, the second example command displaces atoms in\nthe x-direction an amount between 0.0 and 5.0 distance units.  Each\natom’s displacement depends on the fractional distance its y\ncoordinate is between 2.0 and 20.5.  Atoms with y-coordinates outside\nthose bounds will be moved the minimum (0.0) or maximum (5.0) amount.\nThe random style independently moves each atom in the group by a\nrandom displacement, uniformly sampled from a value between -dx and\n+dx in the x dimension, and similarly for y and z.  Random numbers are\nused in such a way that the displacement of a particular atom is the\nsame, regardless of how many processors are being used.\nThe rotate style rotates each atom in the group by the angle theta\naround a rotation axis R = (Rx,Ry,Rz) that goes through a point P =\n(Px,Py,Pz).  The direction of rotation for the atoms around the\nrotation axis is consistent with the right-hand rule: if your\nright-hand thumb points along R, then your fingers wrap around the\naxis in the direction of positive theta.\nIf the defined atom_style assigns an orientation to\neach atom (atom styles ellipsoid, line, tri, body),\nthen that property is also updated appropriately to correspond to the\natom’s rotation.\nDistance units for displacements and the origin point of the rotate\nstyle are determined by the setting of box or lattice for the\nunits keyword.  Box means distance units as defined by the\nunits command - e.g. Angstroms for real units.\nLattice means distance units are in lattice spacings.  The\nlattice command must have been previously used to\ndefine the lattice spacing.\n\n\nNote\nCare should be taken not to move atoms on top of other atoms.\nAfter the move, atoms are remapped into the periodic simulation box if\nneeded, and any shrink-wrap boundary conditions (see the\nboundary command) are enforced which may change the\nbox size.  Other than this effect, this command does not change the\nsize or shape of the simulation box.  See the\nchange_box command if that effect is desired.\n\n\nNote\nAtoms can be moved arbitrarily long distances by this command.\nIf the simulation box is non-periodic and shrink-wrapped (see the\nboundary command), this can change its size or shape.\nThis is not a problem, except that the mapping of processors to the\nsimulation box is not changed by this command from its initial 3d\nconfiguration; see the processors command.  Thus, if\nthe box size/shape changes dramatically, the mapping of processors to\nthe simulation box may not end up as optimal as the initial mapping\nattempted to be.",
    "syntax": "displace_atoms group-ID style args keyword value ...",
    "parameters": " * group-ID = ID of group of atoms to displace\n * style = move or ramp or random or rotate\n * move args = delx dely delz\n *   delx,dely,delz = distance to displace in each dimension (distance units)\n *   any of delx,dely,delz can be a variable (see below)\n * ramp args = ddim dlo dhi dim clo chi\n *   ddim = x or y or z\n *   dlo,dhi = displacement distance between dlo and dhi (distance units)\n *   dim = x or y or z\n *   clo,chi = lower and upper bound of domain to displace (distance units)\n * random args = dx dy dz seed\n *   dx,dy,dz = random displacement magnitude in each dimension (distance units)\n *   seed = random # seed (positive integer)\n * rotate args = Px Py Pz Rx Ry Rz theta\n *   Px,Py,Pz = origin point of axis of rotation (distance units)\n *   Rx,Ry,Rz = axis of rotation vector\n *   theta = angle of rotation (degrees)\n * zero or more keyword/value pairs may be appended\n * keyword = units\n *   value = box or lattice",
    "examples": "displace_atoms top move 0 -5 0 units box\ndisplace_atoms flow ramp x 0.0 5.0 y 2.0 20.5",
    "restrictions": "For a 2d simulation, only rotations around the a vector parallel to\nthe z-axis are allowed."
},
{
    "command": "dump",
    "html_filename": "dump.html",
    "short_description": "Dump a snapshot of atom quantities to one or more files every N timesteps in one of several styles",
    "description": "Dump a snapshot of atom quantities to one or more files every N\ntimesteps in one of several styles.  The image and movie styles are\nthe exception: the image style renders a JPG, PNG, or PPM image file\nof the atom configuration every N timesteps while the movie style\ncombines and compresses them into a movie file; both are discussed in\ndetail on the dump image doc page.  The timesteps on\nwhich dump output is written can also be controlled by a variable.\nSee the dump_modify every command.\nOnly information for atoms in the specified group is dumped.  The\ndump_modify thresh and region and refresh commands\ncan also alter what atoms are included.  Not all styles support\nthese options; see details on the dump_modify doc\npage.\nAs described below, the filename determines the kind of output (text\nor binary or gzipped, one big file or one per timestep, one big file\nor multiple smaller files).\n\nNote\nBecause periodic boundary conditions are enforced only on\ntimesteps when neighbor lists are rebuilt, the coordinates of an atom\nwritten to a dump file may be slightly outside the simulation box.\nRe-neighbor timesteps will not typically coincide with the timesteps\ndump snapshots are written.  See the dump_modify pbc command if you with to force coordinates to be\nstrictly inside the simulation box.\n\n\nNote\nUnless the dump_modify sort option is\ninvoked, the lines of atom information written to dump files\n(typically one line per atom) will be in an indeterminate order for\neach snapshot.  This is even true when running on a single processor,\nif the atom_modify sort option is on, which it is\nby default.  In this case atoms are re-ordered periodically during a\nsimulation, due to spatial sorting.  It is also true when running in\nparallel, because data for a single snapshot is collected from\nmultiple processors, each of which owns a subset of the atoms.\n\nFor the atom, custom, cfg, and local styles, sorting is off by\ndefault.  For the dcd, xtc, xyz, and molfile styles, sorting by\natom ID is on by default. See the dump_modify doc\npage for details.\nThe atom/gz, cfg/gz, custom/gz, and xyz/gz styles are identical\nin command syntax to the corresponding styles without “gz”, however,\nthey generate compressed files using the zlib library. Thus the filename\nsuffix “.gz” is mandatory. This is an alternative approach to writing\ncompressed files via a pipe, as done by the regular dump styles, which\nmay be required on clusters where the interface to the high-speed network\ndisallows using the fork() library call (which is needed for a pipe).\nFor the remainder of this doc page, you should thus consider the atom\nand atom/gz styles (etc) to be inter-changeable, with the exception\nof the required filename suffix.\nAs explained below, the atom/mpiio, cfg/mpiio, custom/mpiio, and\nxyz/mpiio styles are identical in command syntax and in the format\nof the dump files they create, to the corresponding styles without\n“mpiio”, except the single dump file they produce is written in\nparallel via the MPI-IO library.  For the remainder of this doc page,\nyou should thus consider the atom and atom/mpiio styles (etc) to\nbe inter-changeable.  The one exception is how the filename is\nspecified for the MPI-IO styles, as explained below.\nThe precision of values output to text-based dump files can be\ncontrolled by the dump_modify format command and\nits options.\n\nThe style keyword determines what atom quantities are written to the\nfile and in what format.  Settings made via the\ndump_modify command can also alter the format of\nindividual values and the file itself.\nThe atom, local, and custom styles create files in a simple text\nformat that is self-explanatory when viewing a dump file.  Some of the\nLAMMPS post-processing tools described on the Tools doc\npage, including Pizza.py,\nwork with this format, as does the rerun command.\nFor post-processing purposes the atom, local, and custom text\nfiles are self-describing in the following sense.\nThe dimensions of the simulation box are included in each snapshot.\nFor an orthogonal simulation box this information is formatted as:\nITEM: BOX BOUNDS xx yy zz\nxlo xhi\nylo yhi\nzlo zhi\n\n\nwhere xlo,xhi are the maximum extents of the simulation box in the\nx-dimension, and similarly for y and z.  The “xx yy zz” represent 6\ncharacters that encode the style of boundary for each of the 6\nsimulation box boundaries (xlo,xhi and ylo,yhi and zlo,zhi).  Each of\nthe 6 characters is either p = periodic, f = fixed, s = shrink wrap,\nor m = shrink wrapped with a minimum value.  See the\nboundary command for details.\nFor triclinic simulation boxes (non-orthogonal), an orthogonal\nbounding box which encloses the triclinic simulation box is output,\nalong with the 3 tilt factors (xy, xz, yz) of the triclinic box,\nformatted as follows:\nITEM: BOX BOUNDS xy xz yz xx yy zz\nxlo_bound xhi_bound xy\nylo_bound yhi_bound xz\nzlo_bound zhi_bound yz\n\n\nThe presence of the text “xy xz yz” in the ITEM line indicates that\nthe 3 tilt factors will be included on each of the 3 following lines.\nThis bounding box is convenient for many visualization programs.  The\nmeaning of the 6 character flags for “xx yy zz” is the same as above.\nNote that the first two numbers on each line are now xlo_bound instead\nof xlo, etc, since they represent a bounding box.  See the Howto triclinic doc page for a geometric description\nof triclinic boxes, as defined by LAMMPS, simple formulas for how the\n6 bounding box extents (xlo_bound,xhi_bound,etc) are calculated from\nthe triclinic parameters, and how to transform those parameters to and\nfrom other commonly used triclinic representations.\nThe “ITEM: ATOMS” line in each snapshot lists column descriptors for\nthe per-atom lines that follow.  For example, the descriptors would be\n“id type xs ys zs” for the default atom style, and would be the atom\nattributes you specify in the dump command for the custom style.\nFor style atom, atom coordinates are written to the file, along with\nthe atom ID and atom type.  By default, atom coords are written in a\nscaled format (from 0 to 1).  I.e. an x value of 0.25 means the atom\nis at a location 1/4 of the distance from xlo to xhi of the box\nboundaries.  The format can be changed to unscaled coords via the\ndump_modify settings.  Image flags can also be\nadded for each atom via dump_modify.\nStyle custom allows you to specify a list of atom attributes to be\nwritten to the dump file for each atom.  Possible attributes are\nlisted above and will appear in the order specified.  You cannot\nspecify a quantity that is not defined for a particular simulation -\nsuch as q for atom style bond, since that atom style doesn’t\nassign charges.  Dumps occur at the very end of a timestep, so atom\nattributes will include effects due to fixes that are applied during\nthe timestep.  An explanation of the possible dump custom attributes\nis given below.\nFor style local, local output generated by computes\nand fixes is used to generate lines of output that is\nwritten to the dump file.  This local data is typically calculated by\neach processor based on the atoms it owns, but there may be zero or\nmore entities per atom, e.g. a list of bond distances.  An explanation\nof the possible dump local attributes is given below.  Note that by\nusing input from the compute property/local command with dump local,\nit is possible to generate information on bonds, angles, etc that can\nbe cut and pasted directly into a data file read by the\nread_data command.\nStyle cfg has the same command syntax as style custom and writes\nextended CFG format files, as used by the\nAtomEye visualization\npackage.  Since the extended CFG format uses a single snapshot of the\nsystem per file, a wildcard “*” must be included in the filename, as\ndiscussed below.  The list of atom attributes for style cfg must\nbegin with either “mass type xs ys zs” or “mass type xsu ysu zsu”\nsince these quantities are needed to write the CFG files in the\nappropriate format (though the “mass” and “type” fields do not appear\nexplicitly in the file).  Any remaining attributes will be stored as\n“auxiliary properties” in the CFG files.  Note that you will typically\nwant to use the dump_modify element command with\nCFG-formatted files, to associate element names with atom types, so\nthat AtomEye can render atoms appropriately. When unwrapped\ncoordinates xsu, ysu, and zsu are requested, the nominal AtomEye\nperiodic cell dimensions are expanded by a large factor UNWRAPEXPAND =\n10.0, which ensures atoms that are displayed correctly for up to\nUNWRAPEXPAND/2 periodic boundary crossings in any direction.  Beyond\nthis, AtomEye will rewrap the unwrapped coordinates.  The expansion\ncauses the atoms to be drawn farther away from the viewer, but it is\neasy to zoom the atoms closer, and the interatomic distances are\nunaffected.\nThe dcd style writes DCD files, a standard atomic trajectory format\nused by the CHARMM, NAMD, and XPlor molecular dynamics packages.  DCD\nfiles are binary and thus may not be portable to different machines.\nThe number of atoms per snapshot cannot change with the dcd style.\nThe unwrap option of the dump_modify command\nallows DCD coordinates to be written “unwrapped” by the image flags\nfor each atom.  Unwrapped means that if the atom has passed through\na periodic boundary one or more times, the value is printed for what\nthe coordinate would be if it had not been wrapped back into the\nperiodic box.  Note that these coordinates may thus be far outside\nthe box size stored with the snapshot.\nThe xtc style writes XTC files, a compressed trajectory format used\nby the GROMACS molecular dynamics package, and described\nhere.\nThe precision used in XTC files can be adjusted via the\ndump_modify command.  The default value of 1000\nmeans that coordinates are stored to 1/1000 nanometer accuracy.  XTC\nfiles are portable binary files written in the NFS XDR data format,\nso that any machine which supports XDR should be able to read them.\nThe number of atoms per snapshot cannot change with the xtc style.\nThe unwrap option of the dump_modify command allows\nXTC coordinates to be written “unwrapped” by the image flags for each\natom.  Unwrapped means that if the atom has passed through a periodic\nboundary one or more times, the value is printed for what the\ncoordinate would be if it had not been wrapped back into the periodic\nbox.  Note that these coordinates may thus be far outside the box size\nstored with the snapshot.\nThe xyz style writes XYZ files, which is a simple text-based\ncoordinate format that many codes can read. Specifically it has\na line with the number of atoms, then a comment line that is\nusually ignored followed by one line per atom with the atom type\nand the x-, y-, and z-coordinate of that atom. You can use the\ndump_modify element option to change the output\nfrom using the (numerical) atom type to an element name (or some\nother label). This will help many visualization programs to guess\nbonds and colors.\nNote that atom, custom, dcd, xtc, and xyz style dump files\ncan be read directly by VMD, a\npopular molecular viewing program.\n\nDumps are performed on timesteps that are a multiple of N (including\ntimestep 0) and on the last timestep of a minimization if the\nminimization converges.  Note that this means a dump will not be\nperformed on the initial timestep after the dump command is invoked,\nif the current timestep is not a multiple of N.  This behavior can be\nchanged via the dump_modify first command, which\ncan also be useful if the dump command is invoked after a minimization\nended on an arbitrary timestep.  N can be changed between runs by\nusing the dump_modify every command (not allowed\nfor dcd style).  The dump_modify every command\nalso allows a variable to be used to determine the sequence of\ntimesteps on which dump files are written.  In this mode a dump on the\nfirst timestep of a run will also not be written unless the\ndump_modify first command is used.\nThe specified filename determines how the dump file(s) is written.\nThe default is to write one large text file, which is opened when the\ndump command is invoked and closed when an undump\ncommand is used or when LAMMPS exits.  For the dcd and xtc styles,\nthis is a single large binary file.\nDump filenames can contain two wildcard characters.  If a “*”\ncharacter appears in the filename, then one file per snapshot is\nwritten and the “*” character is replaced with the timestep value.\nFor example, tmp.dump.* becomes tmp.dump.0, tmp.dump.10000,\ntmp.dump.20000, etc.  This option is not available for the dcd and\nxtc styles.  Note that the dump_modify pad\ncommand can be used to insure all timestep numbers are the same length\n(e.g. 00010), which can make it easier to read a series of dump files\nin order with some post-processing tools.\nIf a “%” character appears in the filename, then each of P processors\nwrites a portion of the dump file, and the “%” character is replaced\nwith the processor ID from 0 to P-1.  For example, tmp.dump.% becomes\ntmp.dump.0, tmp.dump.1, … tmp.dump.P-1, etc.  This creates smaller\nfiles and can be a fast mode of output on parallel machines that\nsupport parallel I/O for output. This option is not available for the\ndcd, xtc, and xyz styles.\nBy default, P = the number of processors meaning one file per\nprocessor, but P can be set to a smaller value via the nfile or\nfileper keywords of the dump_modify command.\nThese options can be the most efficient way of writing out dump files\nwhen running on large numbers of processors.\nNote that using the “*” and “%” characters together can produce a\nlarge number of small dump files!\nFor the atom/mpiio, cfg/mpiio, custom/mpiio, and xyz/mpiio\nstyles, a single dump file is written in parallel via the MPI-IO\nlibrary, which is part of the MPI standard for versions 2.0 and above.\nUsing MPI-IO requires two steps.  First, build LAMMPS with its MPIIO\npackage installed, e.g.\nmake yes-mpiio    # installs the MPIIO package\nmake mpi          # build LAMMPS for your platform\n\n\nSecond, use a dump filename which contains “.mpiio”.  Note that it\ndoes not have to end in “.mpiio”, just contain those characters.\nUnlike MPI-IO restart files, which must be both written and read using\nMPI-IO, the dump files produced by these MPI-IO styles are identical\nin format to the files produced by their non-MPI-IO style\ncounterparts.  This means you can write a dump file using MPI-IO and\nuse the read_dump command or perform other\npost-processing, just as if the dump file was not written using\nMPI-IO.\nNote that MPI-IO dump files are one large file which all processors\nwrite to.  You thus cannot use the “%” wildcard character described\nabove in the filename since that specifies generation of multiple\nfiles.  You can use the “.bin” suffix described below in an MPI-IO\ndump file; again this file will be written in parallel and have the\nsame binary format as if it were written without MPI-IO.\nIf the filename ends with “.bin”, the dump file (or files, if “*” or\n“%” is also used) is written in binary format.  A binary dump file\nwill be about the same size as a text version, but will typically\nwrite out much faster.  Of course, when post-processing, you will need\nto convert it back to text format (see the binary2txt tool) or write your own code to read the binary\nfile.  The format of the binary file can be understood by looking at\nthe tools/binary2txt.cpp file.  This option is only available for the\natom and custom styles.\nIf the filename ends with “.gz”, the dump file (or files, if “*” or “%”\nis also used) is written in gzipped format.  A gzipped dump file will\nbe about 3x smaller than the text version, but will also take longer\nto write.  This option is not available for the dcd and xtc\nstyles.\n\nNote that in the discussion which follows, for styles which can\nreference values from a compute or fix, like the custom, cfg, or\nlocal styles, the bracketed index I can be specified using a\nwildcard asterisk with the index to effectively specify multiple\nvalues.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nsize of the vector (for mode = scalar) or the number of columns in\nthe array (for mode = vector), then an asterisk with no numeric\nvalues means all indices from 1 to N.  A leading asterisk means all\nindices from 1 to n (inclusive).  A trailing asterisk means all\nindices from n to N (inclusive).  A middle asterisk means all indices\nfrom m to n (inclusive).\nUsing a wildcard is the same as if the individual columns of the array\nhad been listed one by one.  E.g. these 2 dump commands are\nequivalent, since the compute stress/atom\ncommand creates a per-atom array with 6 columns:\ncompute myPress all stress/atom NULL\ndump 2 all custom 100 tmp.dump id myPress[*]\ndump 2 all custom 100 tmp.dump id myPress[1] myPress[2] myPress[3] &\n                                  myPress[4] myPress[5] myPress[6]\n\nThis section explains the local attributes that can be specified as\npart of the local style.\nThe index attribute can be used to generate an index number from 1\nto N for each line written into the dump file, where N is the total\nnumber of local datums from all processors, or lines of output that\nwill appear in the snapshot.  Note that because data from different\nprocessors depend on what atoms they currently own, and atoms migrate\nbetween processor, there is no guarantee that the same index will be\nused for the same info (e.g. a particular bond) in successive\nsnapshots.\nThe c_ID and c_ID[I] attributes allow local vectors or arrays\ncalculated by a compute to be output.  The ID in the\nattribute should be replaced by the actual ID of the compute that has\nbeen defined previously in the input script.  See the\ncompute command for details.  There are computes for\ncalculating local information such as indices, types, and energies for\nbonds and angles.\nNote that computes which calculate global or per-atom quantities, as\nopposed to local quantities, cannot be output in a dump local command.\nInstead, global quantities can be output by the thermo_style custom command, and per-atom quantities can be\noutput by the dump custom command.\nIf c_ID is used as a attribute, then the local vector calculated by\nthe compute is printed.  If c_ID[I] is used, then I must be in the\nrange from 1-M, which will print the Ith column of the local array\nwith M columns calculated by the compute.  See the discussion above\nfor how I can be specified with a wildcard asterisk to effectively\nspecify multiple values.\nThe f_ID and f_ID[I] attributes allow local vectors or arrays\ncalculated by a fix to be output.  The ID in the attribute\nshould be replaced by the actual ID of the fix that has been defined\npreviously in the input script.\nIf f_ID is used as a attribute, then the local vector calculated by\nthe fix is printed.  If f_ID[I] is used, then I must be in the\nrange from 1-M, which will print the Ith column of the local with M\ncolumns calculated by the fix.  See the discussion above for how I can\nbe specified with a wildcard asterisk to effectively specify multiple\nvalues.\nHere is an example of how to dump bond info for a system, including\nthe distance and energy of each bond:\ncompute 1 all property/local batom1 batom2 btype\ncompute 2 all bond/local dist eng\ndump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_2[1] c_2[2]\n\n\n\nThis section explains the atom attributes that can be specified as\npart of the custom and cfg styles.\nThe id, mol, proc, procp1, type, element, mass, vx,\nvy, vz, fx, fy, fz, q attributes are self-explanatory.\nId is the atom ID.  Mol is the molecule ID, included in the data\nfile for molecular systems.  Proc is the ID of the processor (0 to\nNprocs-1) that currently owns the atom.  Procp1 is the proc ID+1,\nwhich can be convenient in place of a type attribute (1 to Ntypes)\nfor coloring atoms in a visualization program.  Type is the atom\ntype (1 to Ntypes).  Element is typically the chemical name of an\nelement, which you must assign to each type via the dump_modify element command.  More generally, it can be any\nstring you wish to associated with an atom type.  Mass is the atom\nmass.  Vx, vy, vz, fx, fy, fz, and q are components of\natom velocity and force and atomic charge.\nThere are several options for outputting atom coordinates.  The x,\ny, z attributes write atom coordinates “unscaled”, in the\nappropriate distance units (Angstroms, sigma, etc).  Use\nxs, ys, zs if you want the coordinates “scaled” to the box size,\nso that each value is 0.0 to 1.0.  If the simulation box is triclinic\n(tilted), then all atom coords will still be between 0.0 and 1.0.\nI.e. actual unscaled (x,y,z) = xs*A + ys*B + zs*C, where (A,B,C) are\nthe non-orthogonal vectors of the simulation box edges, as discussed\non the Howto triclinic doc page.\nUse xu, yu, zu if you want the coordinates “unwrapped” by the\nimage flags for each atom.  Unwrapped means that if the atom has\npassed through a periodic boundary one or more times, the value is\nprinted for what the coordinate would be if it had not been wrapped\nback into the periodic box.  Note that using xu, yu, zu means\nthat the coordinate values may be far outside the box bounds printed\nwith the snapshot.  Using xsu, ysu, zsu is similar to using\nxu, yu, zu, except that the unwrapped coordinates are scaled by\nthe box size. Atoms that have passed through a periodic boundary will\nhave the corresponding coordinate increased or decreased by 1.0.\nThe image flags can be printed directly using the ix, iy, iz\nattributes.  For periodic dimensions, they specify which image of the\nsimulation box the atom is considered to be in.  An image of 0 means\nit is inside the box as defined.  A value of 2 means add 2 box lengths\nto get the true value.  A value of -1 means subtract 1 box length to\nget the true value.  LAMMPS updates these flags as atoms cross\nperiodic boundaries during the simulation.\nThe mux, muy, muz attributes are specific to dipolar systems\ndefined with an atom style of dipole.  They give the orientation of\nthe atom’s point dipole moment.  The mu attribute gives the\nmagnitude of the atom’s dipole moment.\nThe radius and diameter attributes are specific to spherical\nparticles that have a finite size, such as those defined with an atom\nstyle of sphere.\nThe omegax, omegay, and omegaz attributes are specific to\nfinite-size spherical particles that have an angular velocity.  Only\ncertain atom styles, such as sphere define this quantity.\nThe angmomx, angmomy, and angmomz attributes are specific to\nfinite-size aspherical particles that have an angular momentum.  Only\nthe ellipsoid atom style defines this quantity.\nThe tqx, tqy, tqz attributes are for finite-size particles that\ncan sustain a rotational torque due to interactions with other\nparticles.\nThe c_ID and c_ID[I] attributes allow per-atom vectors or arrays\ncalculated by a compute to be output.  The ID in the\nattribute should be replaced by the actual ID of the compute that has\nbeen defined previously in the input script.  See the\ncompute command for details.  There are computes for\ncalculating the per-atom energy, stress, centro-symmetry parameter,\nand coordination number of individual atoms.\nNote that computes which calculate global or local quantities, as\nopposed to per-atom quantities, cannot be output in a dump custom\ncommand.  Instead, global quantities can be output by the\nthermo_style custom command, and local quantities\ncan be output by the dump local command.\nIf c_ID is used as a attribute, then the per-atom vector calculated\nby the compute is printed.  If c_ID[I] is used, then I must be in\nthe range from 1-M, which will print the Ith column of the per-atom\narray with M columns calculated by the compute.  See the discussion\nabove for how I can be specified with a wildcard asterisk to\neffectively specify multiple values.\nThe f_ID and f_ID[I] attributes allow vector or array per-atom\nquantities calculated by a fix to be output.  The ID in the\nattribute should be replaced by the actual ID of the fix that has been\ndefined previously in the input script.  The fix ave/atom command is one that calculates per-atom\nquantities.  Since it can time-average per-atom quantities produced by\nany compute, fix, or atom-style\nvariable, this allows those time-averaged results to\nbe written to a dump file.\nIf f_ID is used as a attribute, then the per-atom vector calculated\nby the fix is printed.  If f_ID[I] is used, then I must be in the\nrange from 1-M, which will print the Ith column of the per-atom array\nwith M columns calculated by the fix.  See the discussion above for\nhow I can be specified with a wildcard asterisk to effectively specify\nmultiple values.\nThe v_name attribute allows per-atom vectors calculated by a\nvariable to be output.  The name in the attribute\nshould be replaced by the actual name of the variable that has been\ndefined previously in the input script.  Only an atom-style variable\ncan be referenced, since it is the only style that generates per-atom\nvalues.  Variables of style atom can reference individual atom\nattributes, per-atom attributes, thermodynamic keywords, or\ninvoke other computes, fixes, or variables when they are evaluated, so\nthis is a very general means of creating quantities to output to a\ndump file.\nThe d_name and i_name attributes allow to output custom per atom\nfloating point or integer properties that are managed by\nfix property/atom.\nSee the Modify doc page for information on how to add\nnew compute and fix styles to LAMMPS to calculate per-atom quantities\nwhich could then be output into dump files.",
    "syntax": "dump ID group-ID style N file args",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be dumped\n * style = atom or atom/gz or atom/mpiio or cfg or cfg/gz or\n * cfg/mpiio or custom or custom/gz or custom/mpiio or dcd or h5md or image or local or local/gz or molfile or movie or netcdf or netcdf/mpiio or vtk or xtc or xyz or xyz/gz or xyz/mpiio\n * N = dump every this many timesteps\n * file = name of file to write dump info to\n * args = list of arguments for a particular style\n * atom args = none\n * atom/gz args = none\n * atom/mpiio args = none\n * atom/adios args = none,  discussed on dump atom/adios doc page\n * cfg args = same as custom args, see below\n * cfg/gz args = same as custom args, see below\n * cfg/mpiio args = same as custom args, see below\n * custom, custom/gz, custom/mpiio args = see below\n * custom/adios args = same as custom args, discussed on dump custom/adios doc page\n * dcd args = none\n * h5md args = discussed on dump h5md doc page\n * image args = discussed on dump image doc page\n * local args = see below\n * molfile args = discussed on dump molfile doc page\n * movie args = discussed on dump image doc page\n * netcdf args = discussed on dump netcdf doc page\n * netcdf/mpiio args = discussed on dump netcdf doc page\n * vtk args = same as custom args, see below, also dump vtk doc page\n * xtc args = none\n * xyz args = none\n * xyz/gz args = none\n * xyz/mpiio args = none\n * custom or custom/gz or custom/mpiio or netcdf or netcdf/mpiio args = list of atom attributes\n * possible attributes = id, mol, proc, procp1, type, element, mass,\n *                       x, y, z, xs, ys, zs, xu, yu, zu,\n *                       xsu, ysu, zsu, ix, iy, iz,\n *                       vx, vy, vz, fx, fy, fz,\n *                       q, mux, muy, muz, mu,\n *                       radius, diameter, omegax, omegay, omegaz,\n *                       angmomx, angmomy, angmomz, tqx, tqy, tqz,\n *                       c_ID, c_ID[N], f_ID, f_ID[N], v_name\n * id = atom ID\n * mol = molecule ID\n * proc = ID of processor that owns atom\n * procp1 = ID+1 of processor that owns atom\n * type = atom type\n * element = name of atom element, as defined by dump_modify command\n * mass = atom mass\n * x,y,z = unscaled atom coordinates\n * xs,ys,zs = scaled atom coordinates\n * xu,yu,zu = unwrapped atom coordinates\n * xsu,ysu,zsu = scaled unwrapped atom coordinates\n * ix,iy,iz = box image that the atom is in\n * vx,vy,vz = atom velocities\n * fx,fy,fz = forces on atoms\n * q = atom charge\n * mux,muy,muz = orientation of dipole moment of atom\n * mu = magnitude of dipole moment of atom\n * radius,diameter = radius,diameter of spherical particle\n * omegax,omegay,omegaz = angular velocity of spherical particle\n * angmomx,angmomy,angmomz = angular momentum of aspherical particle\n * tqx,tqy,tqz = torque on finite-size particles\n * c_ID = per-atom vector calculated by a compute with ID\n * c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n * f_ID = per-atom vector calculated by a fix with ID\n * f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n * v_name = per-atom vector calculated by an atom-style variable with name\n * d_name = per-atom floating point vector with name, managed by fix property/atom\n * i_name = per-atom integer vector with name, managed by fix property/atom\n * local args = list of local attributes\n * possible attributes = index, c_ID, c_ID[I], f_ID, f_ID[I]\n *   index = enumeration of local values\n *   c_ID = local vector calculated by a compute with ID\n *   c_ID[I] = Ith column of local array calculated by a compute with ID, I can include wildcard (see below)\n *   f_ID = local vector calculated by a fix with ID\n *   f_ID[I] = Ith column of local array calculated by a fix with ID, I can include wildcard (see below)",
    "examples": "dump myDump all atom 100 dump.atom\ndump myDump all atom/mpiio 100 dump.atom.mpiio\ndump myDump all atom/gz 100 dump.atom.gz\ndump 2 subgroup atom 50 dump.run.bin\ndump 2 subgroup atom 50 dump.run.mpiio.bin\ndump 4a all custom 100 dump.myforce.* id type x y vx fx\ndump 4b flow custom 100 dump.%.myforce id type c_myF[3] v_ke\ndump 4b flow custom 100 dump.%.myforce id type c_myF[*] v_ke\ndump 2 inner cfg 10 dump.snap.*.cfg mass type xs ys zs vx vy vz\ndump snap all cfg 100 dump.config.*.cfg mass type xs ys zs id type c_Stress[2]\ndump 1 all xtc 1000 file.xtc",
    "restrictions": "To write gzipped dump files, you must either compile LAMMPS with the\n-DLAMMPS_GZIP option or use the styles from the COMPRESS package.\nSee the Build settings doc page for details.\nThe atom/gz, cfg/gz, custom/gz, and xyz/gz styles are part of\nthe COMPRESS package.  They are only enabled if LAMMPS was built with\nthat package.  See the Build package doc page for\nmore info.\nThe atom/mpiio, cfg/mpiio, custom/mpiio, and xyz/mpiio styles\nare part of the MPIIO package.  They are only enabled if LAMMPS was\nbuilt with that package.  See the Build package\ndoc page for more info.\nThe xtc style is part of the MISC package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "dump atom/adios",
    "html_filename": "dump_adios.html",
    "short_description": "Dump a snapshot of atom coordinates every N timesteps in the ADIOS based “BP” file format, or using different I/O solutions in ADIOS, to a stream that can be read on-line by another program",
    "description": "Dump a snapshot of atom coordinates every N timesteps in the\nADIOS based “BP” file format, or using different I/O solutions in ADIOS,\nto a stream that can be read on-line by another program.\nADIOS-BP files are binary, portable and self-describing.\nUse from write_dump:\nIt is possible to use these dump styles with the\nwrite_dump command.  In this case, the sub-intervals\nmust not be set at all.  The write_dump command can be used to\ncreate a new file at each individual dump.\ndump 4     all atom/adios 100 dump.bp\nwrite_dump all atom/adios singledump.bp",
    "syntax": "dump ID group-ID atom/adios N file.bp",
    "parameters": " * dump ID group-ID custom/adios N file.bp args\n * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be imaged\n * adios = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file.bp = name of file/stream to write to\n * args = same options as in *dump custom* command",
    "examples": "dump adios1 all atom/adios   100 atoms.bp\ndump 4a     all custom/adios 100 dump_adios.bp id v_p x y z\ndump 2 subgroup custom/adios 100 dump_adios.bp mass type xs ys zs vx vy vz",
    "restrictions": "The number of atoms per snapshot CAN change with the adios style.\nWhen using the ADIOS tool ‘bpls’ to list the content of a .bp file,\nbpls will print __ for the size of the output table indicating that\nits size is changing every step.\nThe atom/adios and custom/adios dump styles are part of the USER-ADIOS\npackage.  They are only enabled if LAMMPS was built with that package.\nSee the Build package doc page for more info."
},
{
    "command": "dump cfg/uef",
    "html_filename": "dump_cfg_uef.html",
    "short_description": "This command is used to dump atomic coordinates in the reference frame of the applied flow field when fix nvt/uef or fix npt/uef or is used",
    "description": "This command is used to dump atomic coordinates in the\nreference frame of the applied flow field when\nfix nvt/uef or\nfix npt/uef or is used. Only the atomic\ncoordinates and frame-invariant scalar quantities\nwill be in the flow frame. If velocities are selected\nas output, for example, they will not be in the same\nreference frame as the atomic positions.",
    "syntax": "dump ID group-ID cfg/uef N file mass type xs ys zs args",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be dumped\n * N = dump every this many timesteps\n * file = name of file to write dump info to\n * args = same as args for dump custom",
    "examples": "dump 1 all cfg/uef 10 dump.*.cfg mass type xs ys zs\ndump 2 all cfg/uef 100 dump.*.cfg mass type xs ys zs id c_stress",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\nwas built with that package. See the Build package doc page for more info.\nThis command can only be used when fix nvt/uef\nor fix npt/uef is active."
},
{
    "command": "dump h5md",
    "html_filename": "dump_h5md.html",
    "short_description": "Dump a snapshot of atom coordinates every N timesteps in the HDF5 based H5MD file format (de Buyl)",
    "description": "Dump a snapshot of atom coordinates every N timesteps in the\nHDF5 based H5MD file format (de Buyl).\nHDF5 files are binary, portable and self-describing.  This dump style\nwill write only one file, on the root node.\nSeveral dumps may write to the same file, by using file_from and\nreferring to a previously defined dump.  Several groups may also be\nstored within the same file by defining several dumps.  A dump that\nrefers (via file_from) to an already open dump ID and that concerns\nanother particle group must specify create_group yes.\nEach data element is written every N*N_element steps. For image, no\nsub-interval is needed as it must be present at the same interval as\nposition.  image must be given after position in any case.  The\nbox information (edges in each dimension) is stored at the same\ninterval than the position element, if present. Else it is stored\nevery N steps.\n\nNote\nBecause periodic boundary conditions are enforced only on\ntimesteps when neighbor lists are rebuilt, the coordinates of an atom\nwritten to a dump file may be slightly outside the simulation box.\n\nUse from write_dump:\nIt is possible to use this dump style with the\nwrite_dump command.  In this case, the sub-intervals\nmust not be set at all.  The write_dump command can be used either to\ncreate a new file or to add current data to an existing dump file by\nusing the file_from keyword.\nTypically, the species data is fixed. The following two commands\nstore the position data every 100 timesteps, with the image data, and\nstore once the species data in the same file.\ndump h5md1 all h5md 100 dump.h5 position image\nwrite_dump all h5md dump.h5 file_from h5md1 species",
    "syntax": "dump ID group-ID h5md N file.h5 args",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be imaged\n * h5md = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file.h5 = name of file to write to\n * args = list of data elements to dump, with their dump \"sub-intervals\"\n *   position options\n *   image\n *   velocity options\n *   force options\n *   species options\n *   file_from ID: do not open a new file, re-use the already opened file from dump ID\n *   box value = yes or no\n *   create_group value = yes or no\n *   author value = quoted string\n * Note that at least one element must be specified and image may only be\n * present if position is specified first.\n * For the elements position, velocity, force and species, a\n * sub-interval may be specified to write the data only every N_element\n * iterations of the dump (i.e. every N*N_element time steps). This is\n * specified by this option directly following the element declaration:\n * every N_element",
    "examples": "dump h5md1 all h5md 100 dump_h5md.h5 position image\ndump h5md1 all h5md 100 dump_h5md.h5 position velocity every 10\ndump h5md1 all h5md 100 dump_h5md.h5 velocity author \"John Doe\"",
    "restrictions": "The number of atoms per snapshot cannot change with the h5md style.\nThe position data is stored wrapped (box boundaries not enforced, see\nnote above).  Only orthogonal domains are currently supported. This is\na limitation of the present dump h5md command and not of H5MD itself.\nThe h5md dump style is part of the USER-H5MD package. It is only\nenabled if LAMMPS was built with that package. See the Build package doc page for more info. It also requires\n(i) building the ch5md library provided with LAMMPS (See the Build package doc page for more info.) and (ii) having\nthe HDF5 library installed (C bindings are sufficient) on\nyour system.  The library ch5md is compiled with the h5cc wrapper\nprovided by the HDF5 library."
},
{
    "command": "dump image",
    "html_filename": "dump_image.html",
    "short_description": "Dump a high-quality rendered image of the atom configuration every N timesteps and save the images either as a sequence of JPEG or PNG or PPM files, or as a single movie file",
    "description": "Dump a high-quality rendered image of the atom configuration every N\ntimesteps and save the images either as a sequence of JPEG or PNG or\nPPM files, or as a single movie file.  The options for this command as\nwell as the dump_modify command control what is\nincluded in the image or movie and how it appears.  A series of such\nimages can easily be manually converted into an animated movie of your\nsimulation or the process can be automated without writing the\nintermediate files using the dump movie style; see further details\nbelow.  Other dump styles store snapshots of numerical data associated\nwith atoms in various formats, as discussed on the dump\ndoc page.\nNote that a set of images or a movie can be made after a simulation\nhas been run, using the rerun command to read snapshots\nfrom an existing dump file, and using these dump commands in the rerun\nscript to generate the images/movie.\nHere are two sample images, rendered as 1024x1024 JPEG files.  Click\nto see the full-size images:\n\n\nOnly atoms in the specified group are rendered in the image.  The\ndump_modify region and thresh commands can also\nalter what atoms are included in the image.\nThe filename suffix determines whether a JPEG, PNG, or PPM file is\ncreated with the image dump style.  If the suffix is “.jpg” or\n“.jpeg”, then a JPEG format file is created, if the suffix is “.png”,\nthen a PNG format is created, else a PPM (aka NETPBM) format file is\ncreated.  The JPEG and PNG files are binary; PPM has a text mode\nheader followed by binary data. JPEG images have lossy compression;\nPNG has lossless compression; and PPM files are uncompressed but can\nbe compressed with gzip, if LAMMPS has been compiled with\n-DLAMMPS_GZIP and a “.gz” suffix is used.\nSimilarly, the format of the resulting movie is chosen with the\nmovie dump style. This is handled by the underlying FFmpeg converter\nand thus details have to be looked up in the FFmpeg documentation.\nTypical examples are: .avi, .mpg, .m4v, .mp4, .mkv, .flv, .mov, .gif\nAdditional settings of the movie compression like bitrate and\nframerate can be set using the dump_modify command.\nTo write out JPEG and PNG format files, you must build LAMMPS with\nsupport for the corresponding JPEG or PNG library. To convert images\ninto movies, LAMMPS has to be compiled with the -DLAMMPS_FFMPEG\nflag. See the Build settings doc page for\ndetails.\n\nNote\nBecause periodic boundary conditions are enforced only on\ntimesteps when neighbor lists are rebuilt, the coordinates of an atom\nin the image may be slightly outside the simulation box.\n\n\nDumps are performed on timesteps that are a multiple of N (including\ntimestep 0) and on the last timestep of a minimization if the\nminimization converges.  Note that this means a dump will not be\nperformed on the initial timestep after the dump command is invoked,\nif the current timestep is not a multiple of N.  This behavior can be\nchanged via the dump_modify first command, which\ncan be useful if the dump command is invoked after a minimization\nended on an arbitrary timestep.  N can be changed between runs by\nusing the dump_modify every command.\nDump image filenames must contain a wildcard character “*”, so that\none image file per snapshot is written.  The “*” character is replaced\nwith the timestep value.  For example, tmp.dump.*.jpg becomes\ntmp.dump.0.jpg, tmp.dump.10000.jpg, tmp.dump.20000.jpg, etc.  Note\nthat the dump_modify pad command can be used to\ninsure all timestep numbers are the same length (e.g. 00010), which\ncan make it easier to convert a series of images into a movie in the\ncorrect ordering.\nDump movie filenames on the other hand, must not have any wildcard\ncharacter since only one file combining all images into a single\nmovie will be written by the movie encoder.\n\nThe color and diameter settings determine the color and size of\natoms rendered in the image.  They can be any atom attribute defined\nfor the dump custom command, including type and\nelement.  This includes per-atom quantities calculated by a\ncompute, fix, or variable,\nwhich are prefixed by “c_”, “f_”, or “v_” respectively.  Note that the\ndiameter setting can be overridden with a numeric value applied to\nall atoms by the optional adiam keyword.\nIf type is specified for the color setting, then the color of each\natom is determined by its atom type.  By default the mapping of types\nto colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for types > 6.  This mapping can be changed by the\ndump_modify acolor command.\nIf type is specified for the diameter setting then the diameter of\neach atom is determined by its atom type.  By default all types have\ndiameter 1.0.  This mapping can be changed by the dump_modify adiam command.\nIf element is specified for the color and/or diameter setting,\nthen the color and/or diameter of each atom is determined by which\nelement it is, which in turn is specified by the element-to-type\nmapping specified by the “dump_modify element” command.  By default\nevery atom type is C (carbon).  Every element has a color and diameter\nassociated with it, which is the same as the colors and sizes used by\nthe AtomEye visualization package.\nIf other atom attributes are used for the color or diameter\nsettings, they are interpreted in the following way.\nIf “vx”, for example, is used as the color setting, then the color\nof the atom will depend on the x-component of its velocity.  The\nassociation of a per-atom value with a specific color is determined by\na “color map”, which can be specified via the\ndump_modify command.  The basic idea is that the\natom-attribute will be within a range of values, and every value\nwithin the range is mapped to a specific color.  Depending on how the\ncolor map is defined, that mapping can take place via interpolation so\nthat a value of -3.2 is halfway between “red” and “blue”, or\ndiscretely so that the value of -3.2 is “orange”.\nIf “vx”, for example, is used as the diameter setting, then the atom\nwill be rendered using the x-component of its velocity as the\ndiameter.  If the per-atom value <= 0.0, them the atom will not be\ndrawn.  Note that finite-size spherical particles, as defined by\natom_style sphere define a per-particle radius or\ndiameter, which can be used as the diameter setting.\n\nThe various keywords listed above control how the image is rendered.\nAs listed below, all of the keywords have defaults, most of which you\nwill likely not need to change.  The dump modify\nalso has options specific to the dump image style, particularly for\nassigning colors to atoms, bonds, and other image features.\n\nThe atom keyword allow you to turn off the drawing of all atoms, if\nthe specified value is no.  Note that this will not turn off the\ndrawing of particles that are represented as lines, triangles, or\nbodies, as discussed below.  These particles can be drawn separately\nif the line, tri, or body keywords are used.\nThe adiam keyword allows you to override the diameter setting to\nset a single numeric size.  All atoms will be drawn with that\ndiameter, e.g. 1.5, which is in whatever distance units\nthe input script defines, e.g. Angstroms.\n\nThe bond keyword allows to you to alter how bonds are drawn.  A bond\nis only drawn if both atoms in the bond are being drawn due to being\nin the specified group and due to other selection criteria\n(e.g. region, threshold settings of the\ndump_modify command).  By default, bonds are drawn\nif they are defined in the input data file as read by the\nread_data command.  Using none for both the bond\ncolor and width value will turn off the drawing of all bonds.\nIf atom is specified for the bond color value, then each bond is\ndrawn in 2 halves, with the color of each half being the color of the\natom at that end of the bond.\nIf type is specified for the color value, then the color of each\nbond is determined by its bond type.  By default the mapping of bond\ntypes to colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for bond types > 6.  This mapping can be changed by\nthe dump_modify bcolor command.\nThe bond width value can be a numeric value or atom or type (or\nnone as indicated above).\nIf a numeric value is specified, then all bonds will be drawn as\ncylinders with that diameter, e.g. 1.0, which is in whatever distance\nunits the input script defines, e.g. Angstroms.\nIf atom is specified for the width value, then each bond\nwill be drawn with a width corresponding to the minimum diameter\nof the 2 atoms in the bond.\nIf type is specified for the width value then the diameter of each\nbond is determined by its bond type.  By default all types have\ndiameter 0.5.  This mapping can be changed by the dump_modify bdiam command.\n\nThe line keyword can be used when atom_style line\nis used to define particles as line segments, and will draw them as\nlines.  If this keyword is not used, such particles will be drawn as\nspheres, the same as if they were regular atoms.  The only setting\ncurrently allowed for the color value is type, which will color\nthe lines according to the atom type of the particle.  By default the\nmapping of types to colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for types > 6.  There is not yet an option to\nchange this via the dump_modify command.\nThe line width can only be a numeric value, which specifies that all\nlines will be drawn as cylinders with that diameter, e.g. 1.0, which\nis in whatever distance units the input script defines,\ne.g. Angstroms.\n\nThe tri keyword can be used when atom_style tri is\nused to define particles as triangles, and will draw them as triangles\nor edges (3 lines) or both, depending on the setting for tflag.  If\nedges are drawn, the width setting determines the diameters of the\nline segments.  If this keyword is not used, triangle particles will\nbe drawn as spheres, the same as if they were regular atoms.  The only\nsetting currently allowed for the color value is type, which will\ncolor the triangles according to the atom type of the particle.  By\ndefault the mapping of types to colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for types > 6.  There is not yet an option to\nchange this via the dump_modify command.\n\nThe body keyword can be used when atom_style body\nis used to define body particles with internal state\n(e.g. sub-particles), and will drawn them in a manner specific to the\nbody style.  If this keyword is not used, such particles will be drawn\nas spheres, the same as if they were regular atoms.\nThe Howto body doc page describes the body styles\nLAMMPS currently supports, and provides more details as to the kind of\nbody particles they represent and how they are drawn by this dump\nimage command.  For all the body styles, individual atoms can be\neither a body particle or a usual point (non-body) particle.  Non-body\nparticles will be drawn the same way they would be as a regular atom.\nThe bflag1 and bflag2 settings are numerical values which are\npassed to the body style to affect how the drawing of a body particle\nis done.  See the Howto body doc page for a\ndescription of what these parameters mean for each body style.\nThe only setting currently allowed for the color value is type,\nwhich will color the body particles according to the atom type of the\nparticle.  By default the mapping of types to colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for types > 6.  There is not yet an option to\nchange this via the dump_modify command.\n\nThe fix keyword can be used with a fix that produces\nobjects to be drawn.\nThe fflag1 and fflag2 settings are numerical values which are\npassed to the fix to affect how the drawing of its objects is done.\nSee the individual fix doc page for a description of what these\nparameters mean for a particular fix.\nThe only setting currently allowed for the color value is type,\nwhich will color the fix objects according to their type.  By default\nthe mapping of types to colors is as follows:\n\ntype 1 = red\ntype 2 = green\ntype 3 = blue\ntype 4 = yellow\ntype 5 = aqua\ntype 6 = cyan\n\nand repeats itself for types > 6.  There is not yet an option to\nchange this via the dump_modify command.\n\nThe size keyword sets the width and height of the created images,\ni.e. the number of pixels in each direction.\n\nThe view, center, up, zoom, and persp values determine how\n3d simulation space is mapped to the 2d plane of the image.  Basically\nthey control how the simulation box appears in the image.\nAll of the view, center, up, zoom, and persp values can be\nspecified as numeric quantities, whose meaning is explained below.\nAny of them can also be specified as an equal-style variable, by using v_name as the value, where “name” is\nthe variable name.  In this case the variable will be evaluated on the\ntimestep each image is created to create a new value.  If the\nequal-style variable is time-dependent, this is a means of changing\nthe way the simulation box appears from image to image, effectively\ndoing a pan or fly-by view of your simulation.\nThe view keyword determines the viewpoint from which the simulation\nbox is viewed, looking towards the center point.  The theta value\nis the vertical angle from the +z axis, and must be an angle from 0 to\n180 degrees.  The phi value is an azimuthal angle around the z axis\nand can be positive or negative.  A value of 0.0 is a view along the\n+x axis, towards the center point.  If theta or phi are\nspecified via variables, then the variable values should be in\ndegrees.\nThe center keyword determines the point in simulation space that\nwill be at the center of the image.  Cx, Cy, and Cz are\nspecified as fractions of the box dimensions, so that (0.5,0.5,0.5) is\nthe center of the simulation box.  These values do not have to be\nbetween 0.0 and 1.0, if you want the simulation box to be offset from\nthe center of the image.  Note, however, that if you choose strange\nvalues for Cx, Cy, or Cz you may get a blank image.  Internally,\nCx, Cy, and Cz are converted into a point in simulation space.\nIf flag is set to “s” for static, then this conversion is done once,\nat the time the dump command is issued.  If flag is set to “d” for\ndynamic then the conversion is performed every time a new image is\ncreated.  If the box size or shape is changing, this will adjust the\ncenter point in simulation space.\nThe up keyword determines what direction in simulation space will be\n“up” in the image.  Internally it is stored as a vector that is in the\nplane perpendicular to the view vector implied by the theta and\npni values, and which is also in the plane defined by the view\nvector and user-specified up vector.  Thus this internal vector is\ncomputed from the user-specified up vector as\nup_internal = view cross (up cross view)\n\n\nThis means the only restriction on the specified up vector is that\nit cannot be parallel to the view vector, implied by the theta and\nphi values.\nThe zoom keyword scales the size of the simulation box as it appears\nin the image.  The default zfactor value of 1 should display an\nimage mostly filled by the atoms in the simulation box.  A zfactor >\n1 will make the simulation box larger; a zfactor < 1 will make it\nsmaller.  Zfactor must be a value > 0.0.\nThe persp keyword determines how much depth perspective is present\nin the image.  Depth perspective makes lines that are parallel in\nsimulation space appear non-parallel in the image.  A pfactor value\nof 0.0 means that parallel lines will meet at infinity (1.0/pfactor),\nwhich is an orthographic rendering with no perspective.  A pfactor\nvalue between 0.0 and 1.0 will introduce more perspective.  A pfactor\nvalue > 1 will create a highly skewed image with a large amount of\nperspective.\n\nNote\nThe persp keyword is not yet supported as an option.\n\n\nThe box keyword determines if and how the simulation box boundaries\nare rendered as thin cylinders in the image.  If no is set, then the\nbox boundaries are not drawn and the diam setting is ignored.  If\nyes is set, the 12 edges of the box are drawn, with a diameter that\nis a fraction of the shortest box length in x,y,z (for 3d) or x,y (for\n2d).  The color of the box boundaries can be set with the dump_modify boxcolor command.\nThe axes keyword determines if and how the coordinate axes are\nrendered as thin cylinders in the image.  If no is set, then the\naxes are not drawn and the length and diam settings are ignored.\nIf yes is set, 3 thin cylinders are drawn to represent the x,y,z\naxes in colors red,green,blue.  The origin of these cylinders will be\noffset from the lower left corner of the box by 10%.  The length\nsetting determines how long the cylinders will be as a fraction of the\nrespective box lengths.  The diam setting determines their thickness\nas a fraction of the shortest box length in x,y,z (for 3d) or x,y (for\n2d).\nThe subbox keyword determines if and how processor sub-domain\nboundaries are rendered as thin cylinders in the image.  If no is\nset (default), then the sub-domain boundaries are not drawn and the\ndiam setting is ignored.  If yes is set, the 12 edges of each\nprocessor sub-domain are drawn, with a diameter that is a fraction of\nthe shortest box length in x,y,z (for 3d) or x,y (for 2d).  The color\nof the sub-domain boundaries can be set with the dump_modify boxcolor command.\n\nThe shiny keyword determines how shiny the objects rendered in the\nimage will appear.  The sfactor value must be a value 0.0 <=\nsfactor <= 1.0, where sfactor = 1 is a highly reflective surface\nand sfactor = 0 is a rough non-shiny surface.\nThe ssao keyword turns on/off a screen space ambient occlusion\n(SSAO) model for depth shading.  If yes is set, then atoms further\naway from the viewer are darkened via a randomized process, which is\nperceived as depth.  The calculation of this effect can increase the\ncost of computing the image by roughly 2x.  The strength of the effect\ncan be scaled by the dfactor parameter.  If no is set, no depth\nshading is performed.\n\nA series of JPEG, PNG, or PPM images can be converted into a movie\nfile and then played as a movie using commonly available tools. Using\ndump style movie automates this step and avoids the intermediate\nstep of writing (many) image snapshot file. But LAMMPS has to be\ncompiled with -DLAMMPS_FFMPEG and an FFmpeg executable have to be\ninstalled.\nTo manually convert JPEG, PNG or PPM files into an animated GIF or\nMPEG or other movie file you can use:\n\n\nUse the ImageMagick convert program.\n\n% convert *.jpg foo.gif\n% convert -loop 1 *.ppm foo.mpg\n\n\nAnimated GIF files from ImageMagick are not optimized. You can use\na program like gifsicle to optimize and thus massively shrink them.\nMPEG files created by ImageMagick are in MPEG-1 format with a rather\ninefficient compression and low quality compared to more modern\ncompression styles like MPEG-4, H.264, VP8, VP9, H.265 and so on.\n\n\nUse QuickTime.\n\nSelect “Open Image Sequence” under the File menu Load the images into\nQuickTime to animate them Select “Export” under the File menu Save the\nmovie as a QuickTime movie (*.mov) or in another format.  QuickTime\ncan generate very high quality and efficiently compressed movie\nfiles. Some of the supported formats require to buy a license and some\nare not readable on all platforms until specific runtime libraries are\ninstalled.\n\n\nUse FFmpeg\n\nFFmpeg is a command line tool that is available on many platforms and\nallows extremely flexible encoding and decoding of movies.\ncat snap.*.jpg | ffmpeg -y -f image2pipe -c:v mjpeg -i - -b:v 2000k movie.m4v\ncat snap.*.ppm | ffmpeg -y -f image2pipe -c:v ppm -i - -b:v 2400k movie.avi\n\n\nFront ends for FFmpeg exist for multiple platforms. For more\ninformation see the FFmpeg homepage\n\n\n\nPlay the movie:\n\n\nUse your browser to view an animated GIF movie.\n\nSelect “Open File” under the File menu\nLoad the animated GIF file\n\nb) Use the freely available mplayer or ffplay tool to view a\nmovie. Both are available for multiple OSes and support a large\nvariety of file formats and decoders.\n% mplayer foo.mpg\n% ffplay bar.avi\n\n\n\nc) Use the Pizza.py\nanimate tool,\nwhich works directly on a series of image files.\na = animate(\"foo*.jpg\")\n\n\n\nd) QuickTime and other Windows- or MacOS-based media players can\nobviously play movie files directly. Similarly for corresponding tools\nbundled with Linux desktop environments.  However, due to licensing\nissues with some file formats, the formats may require installing\nadditional libraries, purchasing a license, or may not be\nsupported.\n\n\nSee the Modify doc page for information on how to add\nnew compute and fix styles to LAMMPS to calculate per-atom quantities\nwhich could then be output into dump files.",
    "syntax": "dump ID group-ID style N file color diameter keyword value ...",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be imaged\n * style = image or movie = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file = name of file to write image to\n * color = atom attribute that determines color of each atom\n * diameter = atom attribute that determines size of each atom\n * zero or more keyword/value pairs may be appended\n * keyword = atom or adiam or bond or line or tri or body or fix or size or view or center or up or zoom or persp or box or axes or subbox or shiny or ssao\n * atom = yes/no = do or do not draw atoms\n * adiam size = numeric value for atom diameter (distance units)\n * bond values = color width = color and width of bonds\n *   color = atom or type or none\n *   width = number or atom or type or none\n *     number = numeric value for bond width (distance units)\n * line = color width\n *   color = type\n *   width = numeric value for line width (distance units)\n * tri = color tflag width\n *   color = type\n *   tflag = 1 for just triangle, 2 for just tri edges, 3 for both\n *   width = numeric value for tringle edge width (distance units)\n * body = color bflag1 bflag2\n *   color = type\n *   bflag1,bflag2 = 2 numeric flags to affect how bodies are drawn\n * fix = fixID color fflag1 fflag2\n *   fixID = ID of fix that generates objects to dray\n *   color = type\n *   fflag1,fflag2 = 2 numeric flags to affect how fix objects are drawn\n * size values = width height = size of images\n *   width = width of image in # of pixels\n *   height = height of image in # of pixels\n * view values = theta phi = view of simulation box\n *   theta = view angle from +z axis (degrees)\n *   phi = azimuthal view angle (degrees)\n *   theta or phi can be a variable (see below)\n * center values = flag Cx Cy Cz = center point of image\n *   flag = \"s\" for static, \"d\" for dynamic\n *   Cx,Cy,Cz = center point of image as fraction of box dimension (0.5 = center of box)\n *   Cx,Cy,Cz can be variables (see below)\n * up values = Ux Uy Uz = direction that is \"up\" in image\n *   Ux,Uy,Uz = components of up vector\n *   Ux,Uy,Uz can be variables (see below)\n * zoom value = zfactor = size that simulation box appears in image\n *   zfactor = scale image size by factor > 1 to enlarge, factor < 1 to shrink\n *   zfactor can be a variable (see below)\n * persp value = pfactor = amount of \"perspective\" in image\n *   pfactor = amount of perspective (0 = none, < 1 = some, > 1 = highly skewed)\n *   pfactor can be a variable (see below)\n * box values = yes/no diam = draw outline of simulation box\n *   yes/no = do or do not draw simulation box lines\n *   diam = diameter of box lines as fraction of shortest box length\n * axes values = yes/no length diam = draw xyz axes\n *   yes/no = do or do not draw xyz axes lines next to simulation box\n *   length = length of axes lines as fraction of respective box lengths\n *   diam = diameter of axes lines as fraction of shortest box length\n * subbox values = yes/no diam = draw outline of processor sub-domains\n *   yes/no = do or do not draw sub-domain lines\n *   diam = diameter of sub-domain lines as fraction of shortest box length\n * shiny value = sfactor = shinyness of spheres and cylinders\n *   sfactor = shinyness of spheres and cylinders from 0.0 to 1.0\n * ssao value = yes/no seed dfactor = SSAO depth shading\n *   yes/no = turn depth shading on/off\n *   seed = random # seed (positive integer)\n *   dfactor = strength of shading from 0.0 to 1.0",
    "examples": "dump d0 all image 100 dump.\\*.jpg type type\ndump d1 mobile image 500 snap.\\*.png element element ssao yes 4539 0.6\ndump d2 all image 200 img-\\*.ppm type type zoom 2.5 adiam 1.5 size 1280 720\ndump m0 all movie 1000 movie.mpg type type size 640 480\ndump m1 all movie 1000 movie.avi type type size 640 480\ndump m2 all movie 100 movie.m4v type type zoom 1.8 adiam v_value size 1280 720",
    "restrictions": "To write JPEG images, you must use the -DLAMMPS_JPEG switch when\nbuilding LAMMPS and link with a JPEG library. To write PNG images, you\nmust use the -DLAMMPS_PNG switch when building LAMMPS and link with a\nPNG library.\nTo write movie dumps, you must use the -DLAMMPS_FFMPEG switch when\nbuilding LAMMPS and have the FFmpeg executable available on the\nmachine where LAMMPS is being run.  Typically it’s name is lowercase,\ni.e. ffmpeg.\nSee the Build settings doc page for details.\nNote that since FFmpeg is run as an external program via a pipe,\nLAMMPS has limited control over its execution and no knowledge about\nerrors and warnings printed by it. Those warnings and error messages\nwill be printed to the screen only. Due to the way image data is\ncommunicated to FFmpeg, it will often print the message\npipe:: Input/output error\n\n\nwhich can be safely ignored. Other warnings\nand errors have to be addressed according to the FFmpeg documentation.\nOne known issue is that certain movie file formats (e.g. MPEG level 1\nand 2 format streams) have video bandwidth limits that can be crossed\nwhen rendering too large of image sizes. Typical warnings look like\nthis:\n[mpeg @ 0x98b5e0] packet too large, ignoring buffer limits to mux it\n[mpeg @ 0x98b5e0] buffer underflow st=0 bufi=281407 size=285018\n[mpeg @ 0x98b5e0] buffer underflow st=0 bufi=283448 size=285018\n\n\nIn this case it is recommended to either reduce the size of the image\nor encode in a different format that is also supported by your copy of\nFFmpeg, and which does not have this limitation (e.g. .avi, .mkv,\nmp4)."
},
{
    "command": "dump_modify",
    "html_filename": "dump_modify.html",
    "short_description": "Modify the parameters of a previously defined dump command",
    "description": "Modify the parameters of a previously defined dump command.  Not all\nparameters are relevant to all dump styles.\nAs explained on the dump doc page, the atom/mpiio,\ncustom/mpiio, and xyz/mpiio dump styles are identical in command\nsyntax and in the format of the dump files they create, to the\ncorresponding styles without “mpiio”, except the single dump file they\nproduce is written in parallel via the MPI-IO library.  Thus if a\ndump_modify option below is valid for the atom style, it is also\nvalid for the atom/mpiio style, and similarly for the other styles\nwhich allow for use of MPI-IO.\n\nThese keywords apply to various dump styles, including the dump image and dump movie styles.  The\ndescription gives details.\n\nThe append keyword applies to all dump styles except cfg and xtc\nand dcd.  It also applies only to text output files, not to binary\nor gzipped or image/movie files.  If specified as yes, then dump\nsnapshots are appended to the end of an existing dump file.  If\nspecified as no, then a new dump file will be created which will\noverwrite an existing file with the same name.\n\nThe at keyword only applies to the netcdf dump style.  It can only\nbe used if the append yes keyword is also used.  The N argument is\nthe index of which frame to append to.  A negative value can be\nspecified for N, which means a frame counted from the end of the\nfile.  The at keyword can only be used if the dump_modify command is\nbefore the first command that causes dump snapshots to be output,\ne.g. a run or minimize command.  Once the\ndump file has been opened, this keyword has no further effect.\n\nThe buffer keyword applies only to dump styles atom, cfg,\ncustom, local, and xyz.  It also applies only to text output\nfiles, not to binary or gzipped files.  If specified as yes, which\nis the default, then each processor writes its output into an internal\ntext buffer, which is then sent to the processor(s) which perform file\nwrites, and written by those processors(s) as one large chunk of text.\nIf specified as no, each processor sends its per-atom data in binary\nformat to the processor(s) which perform file wirtes, and those\nprocessor(s) format and write it line by line into the output file.\nThe buffering mode is typically faster since each processor does the\nrelatively expensive task of formatting the output for its own atoms.\nHowever it requires about twice the memory (per processor) for the\nextra buffering.\n\nThe delay keyword applies to all dump styles.  No snapshots will be\noutput until the specified Dstep timestep or later.  Specifying\nDstep < 0 is the same as turning off the delay setting.  This is a\nway to turn off unwanted output early in a simulation, for example,\nduring an equilibration phase.\n\nThe element keyword applies only to the dump cfg, xyz, and\nimage styles.  It associates element names (e.g. H, C, Fe) with\nLAMMPS atom types.  See the list of element names at the bottom of\nthis page.\nIn the case of dump cfg, this allows the AtomEye\nvisualization package to read the dump file and render atoms with the\nappropriate size and color.\nIn the case of dump image, the output images will follow the same\nAtomEye convention.  An element name is specified for each\natom type (1 to Ntype) in the simulation.  The same element name can\nbe given to multiple atom types.\nIn the case of xyz format dumps, there are no restrictions to what\nlabel can be used as an element name.  Any white-space separated text\nwill be accepted.\n\nThe every keyword changes the dump frequency originally specified by\nthe dump command to a new value.  The every keyword can be\nspecified in one of two ways.  It can be a numeric value in which case\nit must be > 0.  Or it can be an equal-style variable,\nwhich should be specified as v_name, where name is the variable name.\nIn this case, the variable is evaluated at the beginning of a run to\ndetermine the next timestep at which a dump snapshot will be written\nout.  On that timestep the variable will be evaluated again to\ndetermine the next timestep, etc.  Thus the variable should return\ntimestep values.  See the stagger() and logfreq() and stride() math\nfunctions for equal-style variables, as examples of\nuseful functions to use in this context.  Other similar math functions\ncould easily be added as options for equal-style variables.  Also see the next() function, which allows\nuse of a file-style variable which reads successive values from a\nfile, each time the variable is evaluated.  Used with the every\nkeyword, if the file contains a list of ascending timesteps, you can\noutput snapshots whenever you wish.\nNote that when using the variable option with the every keyword, you\nneed to use the first option if you want an initial snapshot written\nto the dump file.  The every keyword cannot be used with the dump\ndcd style.\nFor example, the following commands will\nwrite snapshots at timesteps 0,10,20,30,100,200,300,1000,2000,etc:\nvariable        s equal logfreq(10,3,10)\ndump            1 all atom 100 tmp.dump\ndump_modify     1 every v_s first yes\n\n\nThe following commands would write snapshots at the timesteps listed\nin file tmp.times:\nvariable        f file tmp.times\nvariable        s equal next(f)\ndump            1 all atom 100 tmp.dump\ndump_modify     1 every v_s\n\n\n\nNote\nWhen using a file-style variable with the every keyword, the\nfile of timesteps must list a first timestep that is beyond the\ncurrent timestep (e.g. it cannot be 0).  And it must list one or more\ntimesteps beyond the length of the run you perform.  This is because\nthe dump command will generate an error if the next timestep it reads\nfrom the file is not a value greater than the current timestep.  Thus\nif you wanted output on steps 0,15,100 of a 100-timestep run, the file\nshould contain the values 15,100,101 and you should also use the\ndump_modify first command.  Any final value > 100 could be used in\nplace of 101.\n\n\nThe first keyword determines whether a dump snapshot is written on\nthe very first timestep after the dump command is invoked.  This will\nalways occur if the current timestep is a multiple of N, the frequency\nspecified in the dump command, including timestep 0.  But\nif this is not the case, a dump snapshot will only be written if the\nsetting of this keyword is yes.  If it is no, which is the\ndefault, then it will not be written.\n\nThe flush keyword determines whether a flush operation is invoked\nafter a dump snapshot is written to the dump file.  A flush insures\nthe output in that file is current (no buffering by the OS), even if\nLAMMPS halts before the simulation completes.  Flushes cannot be\nperformed with dump style xtc.\n\nThe format keyword can be used to change the default numeric format\noutput by the text-based dump styles: atom, custom, cfg, and\nxyz styles, and their MPIIO variants.  Only the line or none\noptions can be used with the atom and xyz styles.\nAll the specified format strings are C-style formats, e.g. as used by\nthe C/C++ printf() command.  The line keyword takes a single\nargument which is the format string for an entire line of output for\neach atom (do not include a trailing “n”), with N fields, which you\nmust enclose in quotes if it is more than one field.  The int and\nfloat keywords take a single format argument and are applied to all\ninteger or floating-point quantities output.  The setting for M\nstring also takes a single format argument which is used for the Mth\nvalue output in each line, e.g. the 5th column is output in high\nprecision for “format 5 %20.15g”.\n\nNote\nWhen using the line keyword for the cfg style, the first two\nfields (atom ID and type) are not actually written into the CFG file,\nhowever you must include formats for them in the format string.\n\nThe format keyword can be used multiple times.  The precedence is\nthat for each value in a line of output, the M format (if specified)\nis used, else the int or float setting (if specified) is used,\nelse the line setting (if specified) for that value is used, else\nthe default setting is used.  A setting of none clears all previous\nsettings, reverting all values to their default format.\n\nNote\nAtom and molecule IDs are stored internally as 4-byte or 8-byte\nsigned integers, depending on how LAMMPS was compiled.  When\nspecifying the format int option you can use a “%d”-style format\nidentifier in the format string and LAMMPS will convert this to the\ncorresponding 8-byte form if it is needed when outputting those\nvalues.  However, when specifying the line option or format M\nstring option for those values, you should specify a format string\nappropriate for an 8-byte signed integer, e.g. one with “%ld”, if\nLAMMPS was compiled with the -DLAMMPS_BIGBIG option for 8-byte IDs.\n\n\nNote\nAny value written to a text-based dump file that is a per-atom\nquantity calculated by a compute or fix is\nstored internally as a floating-point value.  If the value is actually\nan integer and you wish it to appear in the text dump file as a\n(large) integer, then you need to use an appropriate format.  For\nexample, these commands:\n\ncompute     1 all property/local batom1 batom2\ndump        1 all local 100 tmp.bonds index c_1[1] c_1[2]\ndump_modify 1 format \"%d %0.0f %0.0f\"\n\n\nwill output the two atom IDs for atoms in each bond as integers.  If\nthe dump_modify command were omitted, they would appear as\nfloating-point values, assuming they were large integers (more than 6\ndigits).  The “index” keyword should use the “%d” format since it is\nnot generated by a compute or fix, and is stored internally as an\ninteger.\n\nThe fileper keyword is documented below with the nfile keyword.\n\nThe image keyword applies only to the dump atom style.  If the\nimage value is yes, 3 flags are appended to each atom’s coords which\nare the absolute box image of the atom in each dimension.  For\nexample, an x image flag of -2 with a normalized coord of 0.5 means\nthe atom is in the center of the box, but has passed through the box\nboundary 2 times and is really 2 box lengths to the left of its\ncurrent coordinate.  Note that for dump style custom these various\nvalues can be printed in the dump file by using the appropriate atom\nattributes in the dump command itself.\n\nThe label keyword applies only to the dump local style.  When\nit writes local information, such as bond or angle topology\nto a dump file, it will use the specified label to format\nthe header.  By default this includes 2 lines:\nITEM: NUMBER OF ENTRIES\nITEM: ENTRIES ...\n\n\nThe word “ENTRIES” will be replaced with the string specified,\ne.g. BONDS or ANGLES.\n\nThe maxfiles keyword can only be used when a ‘*’ wildcard is\nincluded in the dump file name, i.e. when writing a new file(s) for\neach snapshot.  The specified Fmax is how many snapshots will be\nkept.  Once this number is reached, the file(s) containing the oldest\nsnapshot is deleted before a new dump file is written.  If the\nspecified Fmax <= 0, then all files are retained.\nThis can be useful for debugging, especially if you don’t know on what\ntimestep something bad will happen, e.g. when LAMMPS will exit with an\nerror.  You can dump every timestep, and limit the number of dump\nfiles produced, even if you run for 1000s of steps.\n\nThe nfile or fileper keywords can be used in conjunction with the\n“%” wildcard character in the specified dump file name, for all dump\nstyles except the dcd, image, movie, xtc, and xyz styles\n(for which “%” is not allowed).  As explained on the dump\ncommand doc page, the “%” character causes the dump file to be written\nin pieces, one piece for each of P processors.  By default P = the\nnumber of processors the simulation is running on.  The nfile or\nfileper keyword can be used to set P to a smaller value, which can\nbe more efficient when running on a large number of processors.\nThe nfile keyword sets P to the specified Nf value.  For example, if\nNf = 4, and the simulation is running on 100 processors, 4 files will\nbe written, by processors 0,25,50,75.  Each will collect information\nfrom itself and the next 24 processors and write it to a dump file.\nFor the fileper keyword, the specified value of Np means write one\nfile for every Np processors.  For example, if Np = 4, every 4th\nprocessor (0,4,8,12,etc) will collect information from itself and the\nnext 3 processors and write it to a dump file.\n\nThe pad keyword only applies when the dump filename is specified\nwith a wildcard “*” character which becomes the timestep.  If pad is\n0, which is the default, the timestep is converted into a string of\nunpadded length, e.g. 100 or 12000 or 2000000.  When pad is\nspecified with Nchar > 0, the string is padded with leading zeroes\nso they are all the same length = Nchar.  For example, pad 7 would\nyield 0000100, 0012000, 2000000.  This can be useful so that\npost-processing programs can easily read the files in ascending\ntimestep order.\n\nThe pbc keyword applies to all the dump styles.  As explained on the\ndump doc page, atom coordinates in a dump file may be\nslightly outside the simulation box.  This is because periodic\nboundary conditions are enforced only on timesteps when neighbor lists\nare rebuilt, which will not typically coincide with the timesteps dump\nsnapshots are written.  If the setting of this keyword is set to\nyes, then all atoms will be remapped to the periodic box before the\nsnapshot is written, then restored to their original position.  If it\nis set to no they will not be.  The no setting is the default\nbecause it requires no extra computation.\n\nThe precision keyword only applies to the dump xtc style.  A\nspecified value of N means that coordinates are stored to 1/N\nnanometer accuracy, e.g. for N = 1000, the coordinates are written to\n1/1000 nanometer accuracy.\n\nThe refresh keyword only applies to the dump custom, cfg,\nimage, and movie styles.  It allows an “incremental” dump file to\nbe written, by refreshing a compute that is used as a threshold for\ndetermining which atoms are included in a dump snapshot.  The\nspecified c_ID gives the ID of the compute.  It is prefixed by “c_”\nto indicate a compute, which is the only current option.  At some\npoint, other options may be added, e.g. fixes or variables.\n\nNote\nThis keyword can only be specified once for a dump.  Refreshes\nof multiple computes cannot yet be performed.\n\nThe definition and motivation of an incremental dump file is as\nfollows.  Instead of outputting all atoms at each snapshot (with some\nassociated values), you may only wish to output the subset of atoms\nwith a value that has changed in some way compared to the value the\nlast time that atom was output.  In some scenarios this can result in\na dramatically smaller dump file.  If desired, by post-processing the\nsequence of snapshots, the values for all atoms at all timesteps can\nbe inferred.\nA concrete example is a simulation of atom diffusion in a solid,\nrepresented as atoms on a lattice.  Diffusive hops are rare.  Imagine\nthat when a hop occurs an atom moves more than a distance Dhop.  For\nany snapshot we only want to output atoms that have hopped since the\nlast snapshot.  This can be accomplished with something the following\ncommands:\nvariable        Dhop equal 0.6\nvariable        check atom \"c_dsp[4] > v_Dhop\"\ncompute         dsp all displace/atom refresh check\ndump            1 all custom 20 tmp.dump id type x y z\ndump_modify     1 append yes thresh c_dsp[4] > ${Dhop} refresh c_dsp\n\n\nThe compute displace/atom command\ncalculates the displacement of each atom from its reference position.\nThe “4” index is the scalar displacement; 1,2,3 are the xyz components\nof the displacement.  The dump_modify thresh\ncommand will cause only atoms that have displaced more than 0.6\nAngstroms to be output on a given snapshot (assuming metal units).\nHowever, note that when an atom is output, we also need to update the\nreference position for that atom to its new coordinates.  So that it\nwill not be output in every snapshot thereafter.  That reference\nposition is stored by compute displace/atom.  So the dump_modify\nrefresh option triggers a call to compute displace/atom at the end\nof every dump to perform that update.  The refresh check option\nshown as part of the compute displace/atom command enables the compute\nto respond to the call from the dump command, and update the\nappropriate reference positions.  This is done be defining an\natom-style variable, check in this example, which\ncalculates a Boolean value (0 or 1) for each atom, based on the same\ncriterion used by dump_modify thresh.\nSee the compute displace/atom command for\nmore details, including an example of how to produce output that\nincludes an initial snapshot with the reference position of all atoms.\nNote that only computes with a refresh option will work with\ndump_modify refresh.  See individual compute doc pages for details.\nCurrently, only compute displace/atom supports this option.  Others\nmay be added at some point.  If you use a compute that doesn’t support\nrefresh operations, LAMMPS will not complain; dump_modify refresh will\nsimply do nothing.\n\nThe region keyword only applies to the dump custom, cfg,\nimage, and movie styles.  If specified, only atoms in the region\nwill be written to the dump file or included in the image/movie.  Only\none region can be applied as a filter (the last one specified).  See\nthe region command for more details.  Note that a region\ncan be defined as the “inside” or “outside” of a geometric shape, and\nit can be the “union” or “intersection” of a series of simpler\nregions.\n\nThe scale keyword applies only to the dump atom style.  A scale\nvalue of yes means atom coords are written in normalized units from\n0.0 to 1.0 in each box dimension.  If the simulation box is triclinic\n(tilted), then all atom coords will still be between 0.0 and 1.0.  A\nvalue of no means they are written in absolute distance units\n(e.g. Angstroms or sigma).\n\nThe sfactor and tfactor keywords only apply to the dump xtc\nstyle.  They allow customization of the unit conversion factors used\nwhen writing to XTC files.  By default they are initialized for\nwhatever units style is being used, to write out\ncoordinates in nanometers and time in picoseconds.  I.e. for real\nunits, LAMMPS defines sfactor = 0.1 and tfactor = 0.001, since the\nAngstroms and fmsec used by real units are 0.1 nm and 0.001 psec\nrespectively.  If you are using a units system with distance and time\nunits far from nm and psec, you may wish to write XTC files with\ndifferent units, since the compression algorithm used in XTC files is\nmost effective when the typical magnitude of position data is between\n10.0 and 0.1.\n\nThe sort keyword determines whether lines of per-atom output in a\nsnapshot are sorted or not.  A sort value of off means they will\ntypically be written in indeterminate order, either in serial or\nparallel.  This is the case even in serial if the atom_modify sort option is turned on, which it is by default, to\nimprove performance.  A sort value of id means sort the output by\natom ID.  A sort value of N or -N means sort the output by the value\nin the Nth column of per-atom info in either ascending or descending\norder.\nThe dump local style cannot be sorted by atom ID, since there are\ntypically multiple lines of output per atom.  Some dump styles, such\nas dcd and xtc, require sorting by atom ID to format the output\nfile correctly.  If multiple processors are writing the dump file, via\nthe “%” wildcard in the dump filename, then sorting cannot be\nperformed.\n\nNote\nUnless it is required by the dump style, sorting dump file\noutput requires extra overhead in terms of CPU and communication cost,\nas well as memory, versus unsorted output.\n\n\nThe thermo keyword only applies the dump netcdf style.  It\ntriggers writing of thermo information to the dump file\nalongside per-atom data.  The values included in the dump file are\nidentical to the values specified by thermo_style.\n\nThe thresh keyword only applies to the dump custom, cfg,\nimage, and movie styles.  Multiple thresholds can be specified.\nSpecifying none turns off all threshold criteria.  If thresholds are\nspecified, only atoms whose attributes meet all the threshold criteria\nare written to the dump file or included in the image.  The possible\nattributes that can be tested for are the same as those that can be\nspecified in the dump custom command, with the exception\nof the element attribute, since it is not a numeric value.  Note\nthat a different attributes can be used than those output by the dump custom command.  E.g. you can output the coordinates and\nstress of atoms whose energy is above some threshold.\nIf an atom-style variable is used as the attribute, then it can\nproduce continuous numeric values or effective Boolean 0/1 values\nwhich may be useful for the comparison operator.  Boolean values can\nbe generated by variable formulas that use comparison or Boolean math\noperators or special functions like gmask() and rmask() and grmask().\nSee the variable command doc page for details.\nThe specified value must be a simple numeric value or the word LAST.\nIf LAST is used, it refers to the value of the attribute the last time\nthe dump command was invoked to produce a snapshot.  This is a way to\nonly dump atoms whose attribute has changed (or not changed).\nThree examples follow.\ndump_modify ... thresh ix != LAST\n\n\nThis will dump atoms which have crossed the periodic x boundary of the\nsimulation box since the last dump.  (Note that atoms that crossed\nonce and then crossed back between the two dump timesteps would not be\nincluded.)\nregion foo sphere 10 20 10 15\nvariable inregion atom rmask(foo)\ndump_modify ... thresh v_inregion |^ LAST\n\n\nThis will dump atoms which crossed the boundary of the spherical\nregion since the last dump.\nvariable charge atom \"(q > 0.5) || (q < -0.5)\"\ndump_modify ... thresh v_charge |^ LAST\n\n\nThis will dump atoms whose charge has changed from an absolute value\nless than 1/2 to greater than 1/2 (or vice versa) since the last dump.\nE.g. due to reactions and subsequent charge equilibration in a\nreactive force field.\nThe choice of operators listed above are the usual comparison\noperators.  The XOR operation (exclusive or) is also included as “|^”.\nIn this context, XOR means that if either the attribute or value is\n0.0 and the other is non-zero, then the result is “true” and the\nthreshold criterion is met.  Otherwise it is not met.\n\nThe time keyword only applies to the dump atom, custom, and\nlocal styles (and their COMPRESS package versions atom/gz,\ncustom/gz and local/gz). If set to yes, each frame will will\ncontain two extra lines before the “ITEM: TIMESTEP” entry:\nITEM: TIME\n<elapsed time>\nThis will output the current elapsed simulation time in current\ntime units equivalent to the thermo keyword time.\nThis is to simplify post-processing of trajectories using a variable time\nstep, e.g. when using fix dt/reset.\nThe default setting is no.\n\nThe units keyword only applies to the dump atom, custom, and\nlocal styles (and their COMPRESS package versions atom/gz,\ncustom/gz and local/gz). If set to yes, each individual dump\nfile will contain two extra lines at the very beginning with:\nITEM: UNITS\n<units style>\nThis will output the current selected units style\nto the dump file and thus allows visualization and post-processing\ntools to determine the choice of units of the data in the dump file.\nThe default setting is no.\n\nThe unwrap keyword only applies to the dump dcd and xtc styles.\nIf set to yes, coordinates will be written “unwrapped” by the image\nflags for each atom.  Unwrapped means that if the atom has passed through\na periodic boundary one or more times, the value is printed for what\nthe coordinate would be if it had not been wrapped back into the\nperiodic box.  Note that these coordinates may thus be far outside the\nbox size stored with the snapshot.\n\nThese keywords apply only to the dump image and\ndump movie styles.  Any keyword that affects an\nimage, also affects a movie, since the movie is simply a collection of\nimages.  Some of the keywords only affect the dump movie style.  The descriptions give details.\n\nThe acolor keyword can be used with the dump image\ncommand, when its atom color setting is type, to set the color that\natoms of each type will be drawn in the image.\nThe specified type should be an integer from 1 to Ntypes = the\nnumber of atom types.  A wildcard asterisk can be used in place of or\nin conjunction with the type argument to specify a range of atom\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of atom types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nThe specified color can be a single color which is any of the 140\npre-defined colors (see below) or a color name defined by the\ndump_modify color option.  Or it can be two or more colors separated\nby a “/” character, e.g. red/green/blue.  In the former case, that\ncolor is assigned to all the specified atom types.  In the latter\ncase, the list of colors are assigned in a round-robin fashion to each\nof the specified atom types.\n\nThe adiam keyword can be used with the dump image\ncommand, when its atom diameter setting is type, to set the size\nthat atoms of each type will be drawn in the image.  The specified\ntype should be an integer from 1 to Ntypes.  As with the acolor\nkeyword, a wildcard asterisk can be used as part of the type\nargument to specify a range of atom types.  The specified diam is\nthe size in whatever distance units the input script is\nusing, e.g. Angstroms.\n\nThe amap keyword can be used with the dump image\ncommand, with its atom keyword, when its atom setting is an\natom-attribute, to setup a color map.  The color map is used to assign\na specific RGB (red/green/blue) color value to an individual atom when\nit is drawn, based on the atom’s attribute, which is a numeric value,\ne.g. its x-component of velocity if the atom-attribute “vx” was\nspecified.\nThe basic idea of a color map is that the atom-attribute will be\nwithin a range of values, and that range is associated with a series\nof colors (e.g. red, blue, green).  An atom’s specific value (vx =\n-3.2) can then mapped to the series of colors (e.g. halfway between\nred and blue), and a specific color is determined via an interpolation\nprocedure.\nThere are many possible options for the color map, enabled by the\namap keyword.  Here are the details.\nThe lo and hi settings determine the range of values allowed for\nthe atom attribute.  If numeric values are used for lo and/or hi,\nthen values that are lower/higher than that value are set to the\nvalue.  I.e. the range is static.  If lo is specified as min or\nhi as max then the range is dynamic, and the lower and/or\nupper bound will be calculated each time an image is drawn, based\non the set of atoms being visualized.\nThe style setting is two letters, such as “ca”.  The first letter is\neither “c” for continuous, “d” for discrete, or “s” for sequential.\nThe second letter is either “a” for absolute, or “f” for fractional.\nA continuous color map is one in which the color changes continuously\nfrom value to value within the range.  A discrete color map is one in\nwhich discrete colors are assigned to sub-ranges of values within the\nrange.  A sequential color map is one in which discrete colors are\nassigned to a sequence of sub-ranges of values covering the entire\nrange.\nAn absolute color map is one in which the values to which colors are\nassigned are specified explicitly as values within the range.  A\nfractional color map is one in which the values to which colors are\nassigned are specified as a fractional portion of the range.  For\nexample if the range is from -10.0 to 10.0, and the color red is to be\nassigned to atoms with a value of 5.0, then for an absolute color map\nthe number 5.0 would be used.  But for a fractional map, the number\n0.75 would be used since 5.0 is 3/4 of the way from -10.0 to 10.0.\nThe delta setting must be specified for all styles, but is only used\nfor the sequential style; otherwise the value is ignored.  It\nspecifies the bin size to use within the range for assigning\nconsecutive colors to.  For example, if the range is from -10.0 to\n10.0 and a delta of 1.0 is used, then 20 colors will be assigned to\nthe range.  The first will be from -10.0 <= color1 < -9.0, then 2nd\nfrom -9.0 <= color2 < -8.0, etc.\nThe N setting is how many entries follow.  The format of the entries\ndepends on whether the color map style is continuous, discrete or\nsequential.  In all cases the color setting can be any of the 140\npre-defined colors (see below) or a color name defined by the\ndump_modify color option.\nFor continuous color maps, each entry has a value and a color.\nThe value is either a number within the range of values or min or\nmax.  The value of the first entry must be min and the value\nof the last entry must be max.  Any entries in between must have\nincreasing values.  Note that numeric values can be specified either\nas absolute numbers or as fractions (0.0 to 1.0) of the range,\ndepending on the “a” or “f” in the style setting for the color map.\nHere is how the entries are used to determine the color of an\nindividual atom, given the value X of its atom attribute.  X will fall\nbetween 2 of the entry values.  The color of the atom is linearly\ninterpolated (in each of the RGB values) between the 2 colors\nassociated with those entries.  For example, if X = -5.0 and the 2\nsurrounding entries are “red” at -10.0 and “blue” at 0.0, then the\natom’s color will be halfway between “red” and “blue”, which happens\nto be “purple”.\nFor discrete color maps, each entry has a lo and hi value and a\ncolor.  The lo and hi settings are either numbers within the\nrange of values or lo can be min or hi can be max.  The lo\nand hi settings of the last entry must be min and max.  Other\nentries can have any lo and hi values and the sub-ranges of\ndifferent values can overlap.  Note that numeric lo and hi values\ncan be specified either as absolute numbers or as fractions (0.0 to\n1.0) of the range, depending on the “a” or “f” in the style setting\nfor the color map.\nHere is how the entries are used to determine the color of an\nindividual atom, given the value X of its atom attribute.  The entries\nare scanned from first to last.  The first time that lo <= X <=\nhi, X is assigned the color associated with that entry.  You can\nthink of the last entry as assigning a default color (since it will\nalways be matched by X), and the earlier entries as colors that\noverride the default.  Also note that no interpolation of a color RGB\nis done.  All atoms will be drawn with one of the colors in the list\nof entries.\nFor sequential color maps, each entry has only a color.  Here is how\nthe entries are used to determine the color of an individual atom,\ngiven the value X of its atom attribute.  The range is partitioned\ninto N bins of width binsize.  Thus X will fall in a specific bin\nfrom 1 to N, say the Mth bin.  If it falls on a boundary between 2\nbins, it is considered to be in the higher of the 2 bins.  Each bin is\nassigned a color from the E entries.  If E < N, then the colors are\nrepeated.  For example if 2 entries with colors red and green are\nspecified, then the odd numbered bins will be red and the even bins\ngreen.  The color of the atom is the color of its bin.  Note that the\nsequential color map is really a shorthand way of defining a discrete\ncolor map without having to specify where all the bin boundaries are.\nHere is an example of using a sequential color map to color all the\natoms in individual molecules with a different color.  See the\nexamples/pour/in.pour.2d.molecule input script for an example of how\nthis is used.\nvariable        colors string &\n                \"red green blue yellow white &\n                purple pink orange lime gray\"\nvariable        mol atom mol%10\ndump            1 all image 250 image.*.jpg v_mol type &\n                zoom 1.6 adiam 1.5\ndump_modify     1 pad 5 amap 0 10 sa 1 10 ${colors}\n\n\nIn this case, 10 colors are defined, and molecule IDs are\nmapped to one of the colors, even if there are 1000s of molecules.\n\nThe backcolor sets the background color of the images.  The color\nname can be any of the 140 pre-defined colors (see below) or a color\nname defined by the dump_modify color option.\n\nThe bcolor keyword can be used with the dump image\ncommand, with its bond keyword, when its color setting is type, to\nset the color that bonds of each type will be drawn in the image.\nThe specified type should be an integer from 1 to Nbondtypes = the\nnumber of bond types.  A wildcard asterisk can be used in place of or\nin conjunction with the type argument to specify a range of bond\ntypes.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\nnumber of bond types, then an asterisk with no numeric values means\nall types from 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nThe specified color can be a single color which is any of the 140\npre-defined colors (see below) or a color name defined by the\ndump_modify color option.  Or it can be two or more colors separated\nby a “/” character, e.g. red/green/blue.  In the former case, that\ncolor is assigned to all the specified bond types.  In the latter\ncase, the list of colors are assigned in a round-robin fashion to each\nof the specified bond types.\n\nThe bdiam keyword can be used with the dump image\ncommand, with its bond keyword, when its diam setting is type, to\nset the diameter that bonds of each type will be drawn in the image.\nThe specified type should be an integer from 1 to Nbondtypes.  As\nwith the bcolor keyword, a wildcard asterisk can be used as part of\nthe type argument to specify a range of bond types.  The specified\ndiam is the size in whatever distance units you are\nusing, e.g. Angstroms.\n\nThe bitrate keyword can be used with the dump movie command to define the size of the resulting\nmovie file and its quality via setting how many kbits per second are\nto be used for the movie file. Higher bitrates require less\ncompression and will result in higher quality movies.  The quality is\nalso determined by the compression format and encoder.  The default\nsetting is 2000 kbit/s, which will result in average quality with\nolder compression formats.\n\nNote\nNot all movie file formats supported by dump movie allow the\nbitrate to be set.  If not, the setting is silently ignored.\n\n\nThe boxcolor keyword sets the color of the simulation box drawn\naround the atoms in each image as well as the color of processor\nsub-domain boundaries.  See the “dump image box” command for how to\nspecify that a box be drawn via the box keyword, and the sub-domain\nboundaries via the subbox keyword.  The color name can be any of the\n140 pre-defined colors (see below) or a color name defined by the\ndump_modify color option.\n\nThe color keyword allows definition of a new color name, in addition\nto the 140-predefined colors (see below), and associates 3\nred/green/blue RGB values with that color name.  The color name can\nthen be used with any other dump_modify keyword that takes a color\nname as a value.  The RGB values should each be floating point values\nbetween 0.0 and 1.0 inclusive.\nWhen a color name is converted to RGB values, the user-defined color\nnames are searched first, then the 140 pre-defined color names.  This\nmeans you can also use the color keyword to overwrite one of the\npre-defined color names with new RBG values.\n\nThe framerate keyword can be used with the dump movie command to define the duration of the resulting\nmovie file.  Movie files written by the dump movie command have a\ndefault frame rate of 24 frames per second and the images generated\nwill be converted at that rate.  Thus a sequence of 1000 dump images\nwill result in a movie of about 42 seconds.  To make a movie run\nlonger you can either generate images more frequently or lower the\nframe rate.  To speed a movie up, you can do the inverse.  Using a\nframe rate higher than 24 is not recommended, as it will result in\nsimply dropping the rendered images. It is more efficient to dump\nimages less frequently.",
    "syntax": "dump_modify dump-ID keyword values ...",
    "parameters": " * dump-ID = ID of dump to modify\n * one or more keyword/value pairs may be appended\n * these keywords apply to various dump styles\n * keyword = append or at or buffer or delay or element or every or fileper or first or flush or format or image or label or maxfiles or nfile or pad or pbc or precision or region or refresh or scale or sfactor or sort or tfactor or thermo or thresh or time or units or unwrap\n * append arg = yes or no\n * at arg = N\n *   N = index of frame written upon first dump\n * buffer arg = yes or no\n * delay arg = Dstep\n *   Dstep = delay output until this timestep\n * element args = E1 E2 ... EN, where N = # of atom types\n *   E1,...,EN = element name, e.g. C or Fe or Ga\n * every arg = N\n *   N = dump every this many timesteps\n *   N can be a variable (see below)\n * fileper arg = Np\n *   Np = write one file for every this many processors\n * first arg = yes or no\n * flush arg = yes or no\n * format args = line string, int string, float string, M string, or none\n *   string = C-style format string\n *   M = integer from 1 to N, where N = # of per-atom quantities being output\n * image arg = yes or no\n * label arg = string\n *   string = character string (e.g. BONDS) to use in header of dump local file\n * maxfiles arg = Fmax\n *   Fmax = keep only the most recent Fmax snapshots (one snapshot per file)\n * nfile arg = Nf\n *   Nf = write this many files, one from each of Nf processors\n * pad arg = Nchar = # of characters to convert timestep to\n * pbc arg = yes or no = remap atoms via periodic boundary conditions\n * precision arg = power-of-10 value from 10 to 1000000\n * region arg = region-ID or \"none\"\n * refresh arg = c_ID = compute ID that supports a refresh operation\n * scale arg = yes or no\n * sfactor arg = coordinate scaling factor (> 0.0)\n * sort arg = off or id or N or -N\n *    off = no sorting of per-atom lines within a snapshot\n *    id = sort per-atom lines by atom ID\n *    N = sort per-atom lines in ascending order by the Nth column\n *    -N = sort per-atom lines in descending order by the Nth column\n * tfactor arg = time scaling factor (> 0.0)\n * thermo arg = yes or no\n * time arg = yes or no\n * thresh args = attribute operator value\n *   attribute = same attributes (x,fy,etotal,sxx,etc) used by dump custom style\n *   operator = \"<\" or \"<=\" or \">\" or \">=\" or \"==\" or \"!=\" or \"|^\"\n *   value = numeric value to compare to, or LAST\n *   these 3 args can be replaced by the word \"none\" to turn off thresholding\n * units arg = yes or no\n * unwrap arg = yes or no\n * these keywords apply only to the image and movie styles\n * keyword = acolor or adiam or amap or backcolor or bcolor or bdiam or boxcolor or color or bitrate or framerate\n * acolor args = type color\n *   type = atom type or range of types (see below)\n *   color = name of color or color1/color2/...\n * adiam args = type diam\n *   type = atom type or range of types (see below)\n *   diam = diameter of atoms of that type (distance units)\n * amap args = lo hi style delta N entry1 entry2 ... entryN\n *   lo = number or min = lower bound of range of color map\n *   hi = number or max = upper bound of range of color map\n *   style = 2 letters = \"c\" or \"d\" or \"s\" plus \"a\" or \"f\"\n *     \"c\" for continuous\n *     \"d\" for discrete\n *     \"s\" for sequential\n *     \"a\" for absolute\n *     \"f\" for fractional\n *   delta = binsize (only used for style \"s\", otherwise ignored)\n *     binsize = range is divided into bins of this width\n *   N = # of subsequent entries\n *   entry = value color (for continuous style)\n *     value = number or min or max = single value within range\n *     color = name of color used for that value\n *   entry = lo hi color (for discrete style)\n *     lo/hi = number or min or max = lower/upper bound of subset of range\n *     color = name of color used for that subset of values\n *   entry = color (for sequential style)\n *     color = name of color used for a bin of values\n * backcolor arg = color\n *   color = name of color for background\n * bcolor args = type color\n *   type = bond type or range of types (see below)\n *   color = name of color or color1/color2/...\n * bdiam args = type diam\n *   type = bond type or range of types (see below)\n *   diam = diameter of bonds of that type (distance units)\n * boxcolor arg = color\n *   color = name of color for simulation box lines and processor sub-domain lines\n * color args = name R G B\n *   name = name of color\n *   R,G,B = red/green/blue numeric values from 0.0 to 1.0\n * bitrate arg = rate\n *   rate = target bitrate for movie in kbps\n * framerate arg = fps\n *   fps = frames per second for movie",
    "examples": "dump_modify 1 format line \"%d %d %20.15g %g %g\" scale yes\ndump_modify 1 format float %20.15g scale yes\ndump_modify myDump image yes scale no flush yes\ndump_modify 1 region mySphere thresh x < 0.0 thresh epair >= 3.2\ndump_modify xtcdump precision 10000 sfactor 0.1\ndump_modify 1 every 1000 nfile 20\ndump_modify 1 every v_myVar\ndump_modify 1 amap min max cf 0.0 3 min green 0.5 yellow max blue boxcolor red",
    "restrictions": "\nnone"
},
{
    "command": "dump molfile",
    "html_filename": "dump_molfile.html",
    "short_description": "Dump a snapshot of atom coordinates and selected additional quantities to one or more files every N timesteps in one of several formats",
    "description": "Dump a snapshot of atom coordinates and selected additional quantities\nto one or more files every N timesteps in one of several formats.\nOnly information for atoms in the specified group is dumped.  This\nspecific dump style uses molfile plugins that are bundled with the\nVMD molecular visualization and\nanalysis program.\nUnless the filename contains a * character, the output will be written\nto one single file with the specified format. Otherwise there will be\none file per snapshot and the * will be replaced by the time step number\nwhen the snapshot is written.\n\nNote\nBecause periodic boundary conditions are enforced only on\ntimesteps when neighbor lists are rebuilt, the coordinates of an atom\nwritten to a dump file may be slightly outside the simulation box.\n\nThe molfile plugin API has a few restrictions that have to be honored\nby this dump style: the number of atoms must not change, the atoms\nmust be sorted, outside of the coordinates no change in atom properties\n(like type, mass, charge) will be recorded.\n\nThe format keyword determines what format is used to write out the\ndump. For this to work, LAMMPS must be able to find and load a\ncompatible molfile plugin that supports this format.  Settings made via\nthe dump_modify command can alter per atom properties\nlike element names.\nThe path keyword determines which in directories. This is a “path”\nlike other search paths, i.e. it can contain multiple directories\nseparated by a colon (or semi-colon on windows). This keyword is\noptional and default to “.”, the current directory.\nThe unwrap option of the dump_modify command allows\ncoordinates to be written “unwrapped” by the image flags for each atom.\nUnwrapped means that if the atom has passed through a periodic boundary\none or more times, the value is printed for what the coordinate would be\nif it had not been wrapped back into the periodic box.  Note that these\ncoordinates may thus be far outside the box size stored with the\nsnapshot.\n\nDumps are performed on timesteps that are a multiple of N (including\ntimestep 0) and on the last timestep of a minimization if the\nminimization converges.  Note that this means a dump will not be\nperformed on the initial timestep after the dump command is invoked,\nif the current timestep is not a multiple of N.  This behavior can be\nchanged via the dump_modify first command, which can\nbe useful if the dump command is invoked after a minimization ended on\nan arbitrary timestep.  N can be changed between runs by using the\ndump_modify every command. The dump_modify every command also allows a variable to be used to\ndetermine the sequence of timesteps on which dump files are written.",
    "syntax": "dump ID group-ID molfile N file format path",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be imaged\n * molfile = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file = name of file to write to\n * format = file format to be used\n * path = file path with plugins (optional)",
    "examples": "dump mf1 all molfile 10 melt1.xml hoomd\ndump mf2 all molfile 10 melt2-*.pdb pdb .\ndump mf3 all molfile 50 melt3.xyz xyz .:/home/akohlmey/vmd/plugins/LINUX/molfile",
    "restrictions": "The molfile dump style is part of the USER-MOLFILE package.  It is\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nMolfile plugins provide a consistent programming interface to read and\nwrite file formats commonly used in molecular simulations. The\nUSER-MOLFILE package only provides the interface code, not the plugins.\nThese can be obtained from a VMD installation which has to match the\nplatform that you are using to compile LAMMPS for. By adding plugins\nto VMD, support for new file formats can be added to LAMMPS (or VMD\nor other programs that use them) without having to re-compile the\napplication itself.  The plugins are installed in the directory:\n<VMDHOME>/plugins/<VMDARCH>/molfile\n\nNote\nwhile the programming interface (API) to the plugins is backward\ncompatible, the binary interface (ABI) has been changing over time, so\nit is necessary to compile this package with the plugin header files\nfrom VMD that match the binary plugins.  These header files in the\ndirectory: <VMDHOME>/plugins/include For convenience, the package ships\nwith a set of header files that are compatible with VMD 1.9 and 1.9.1\n(June 2012)"
},
{
    "command": "dump netcdf",
    "html_filename": "dump_netcdf.html",
    "short_description": "Dump a snapshot of atom coordinates every N timesteps in Amber-style NetCDF file format",
    "description": "Dump a snapshot of atom coordinates every N timesteps in Amber-style\nNetCDF file format.  NetCDF files are binary, portable and\nself-describing.  This dump style will write only one file on the root\nnode.  The dump style netcdf uses the standard NetCDF library.  All data is collected on one processor and then\nwritten to the dump file.  Dump style netcdf/mpiio uses the\nparallel NetCDF library and MPI-IO to write to the dump\nfile in parallel; it has better performance on a larger number of\nprocessors.  Note that style netcdf outputs all atoms sorted by atom\ntag while style netcdf/mpiio outputs atoms in order of their MPI\nrank.\nNetCDF files can be directly visualized via the following tools:\nOvito (http://www.ovito.org/). Ovito supports the AMBER convention and\nall extensions of this dump style.\n\nVMD (http://www.ks.uiuc.edu/Research/vmd/).\nAtomEye (http://www.libatoms.org/). The libAtoms version of AtomEye\ncontains a NetCDF reader that is not present in the standard\ndistribution of AtomEye.\n\nIn addition to per-atom data, thermo data can be included in the\ndump file. The data included in the dump file is identical to the data specified\nby thermo_style.",
    "syntax": "dump ID group-ID netcdf N file args",
    "parameters": " * dump ID group-ID netcdf/mpiio N file args\n * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be imaged\n * netcdf or netcdf/mpiio  = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file = name of file to write dump info to\n * args = list of atom attributes, same as for dump_style custom",
    "examples": "dump 1 all netcdf 100 traj.nc type x y z vx vy vz\ndump_modify 1 append yes at -1 thermo yes\ndump 1 all netcdf/mpiio 1000 traj.nc id type x y z\ndump 1 all netcdf 1000 traj.*.nc id type x y z",
    "restrictions": "The netcdf and netcdf/mpiio dump styles are part of the\nUSER-NETCDF package.  They are only enabled if LAMMPS was built with\nthat package. See the Build package doc page for\nmore info."
},
{
    "command": "dump vtk",
    "html_filename": "dump_vtk.html",
    "short_description": "Dump a snapshot of atom quantities to one or more files every N timesteps in a format readable by the VTK visualization toolkit or other visualization tools that use it, e",
    "description": "Dump a snapshot of atom quantities to one or more files every N\ntimesteps in a format readable by the VTK visualization toolkit or other visualization tools that use it,\ne.g. ParaView.  The timesteps on which dump\noutput is written can also be controlled by a variable; see the\ndump_modify every command for details.\nThis dump style is similar to dump_style custom but uses\nthe VTK library to write data to VTK simple legacy or XML format\ndepending on the filename extension specified for the dump file.  This\ncan be either *.vtk for the legacy format or *.vtp and *.vtu,\nrespectively, for XML format; see the VTK homepage for a detailed\ndescription of these formats.  Since this naming convention conflicts\nwith the way binary output is usually specified (see below), the\ndump_modify binary command allows setting of a\nbinary option for this dump style explicitly.\nOnly information for atoms in the specified group is dumped.  The\ndump_modify thresh and region commands can also\nalter what atoms are included; see details below.\nAs described below, special characters (“*”, “%”) in the filename\ndetermine the kind of output.\n\nWarning\nBecause periodic boundary conditions are enforced only\non timesteps when neighbor lists are rebuilt, the coordinates of an\natom written to a dump file may be slightly outside the simulation\nbox.\n\n\nWarning\nUnless the dump_modify sort option\nis invoked, the lines of atom information written to dump files will\nbe in an indeterminate order for each snapshot.  This is even true\nwhen running on a single processor, if the atom_modify sort option is on, which it is by default.  In this\ncase atoms are re-ordered periodically during a simulation, due to\nspatial sorting.  It is also true when running in parallel, because\ndata for a single snapshot is collected from multiple processors, each\nof which owns a subset of the atoms.\n\nFor the vtk style, sorting is off by default. See the\ndump_modify doc page for details.\n\nThe dimensions of the simulation box are written to a separate file\nfor each snapshot (either in legacy VTK or XML format depending on the\nformat of the main dump file) with the suffix _boundingBox appended\nto the given dump filename.\nFor an orthogonal simulation box this information is saved as a\nrectilinear grid (legacy .vtk or .vtr XML format).\nTriclinic simulation boxes (non-orthogonal) are saved as\nhexahedrons in either legacy .vtk or .vtu XML format.\nStyle vtk allows you to specify a list of atom attributes to be\nwritten to the dump file for each atom.  The list of possible attributes\nis the same as for the dump_style custom command; see\nits doc page for a listing and an explanation of each attribute.\n\nNote\nSince position data is required to write VTK files the atom\nattributes “x y z” do not have to be specified explicitly; they will\nbe included in the dump file regardless.  Also, in contrast to the\ncustom style, the specified vtk attributes are rearranged to\nensure correct ordering of vector components (except for computes and\nfixes - these have to be given in the right order) and duplicate\nentries are removed.\n\nThe VTK format uses a single snapshot of the system per file, thus\na wildcard “*” must be included in the filename, as discussed below.\nOtherwise the dump files will get overwritten with the new snapshot\neach time.\n\nDumps are performed on timesteps that are a multiple of N (including\ntimestep 0) and on the last timestep of a minimization if the\nminimization converges.  Note that this means a dump will not be\nperformed on the initial timestep after the dump command is invoked,\nif the current timestep is not a multiple of N.  This behavior can be\nchanged via the dump_modify first command, which\ncan also be useful if the dump command is invoked after a minimization\nended on an arbitrary timestep.  N can be changed between runs by\nusing the dump_modify every command.\nThe dump_modify every command\nalso allows a variable to be used to determine the sequence of\ntimesteps on which dump files are written.  In this mode a dump on the\nfirst timestep of a run will also not be written unless the\ndump_modify first command is used.\nDump filenames can contain two wildcard characters.  If a “*”\ncharacter appears in the filename, then one file per snapshot is\nwritten and the “*” character is replaced with the timestep value.\nFor example, tmp.dump*.vtk becomes tmp.dump0.vtk, tmp.dump10000.vtk,\ntmp.dump20000.vtk, etc.  Note that the dump_modify pad\ncommand can be used to insure all timestep numbers are the same length\n(e.g. 00010), which can make it easier to read a series of dump files\nin order with some post-processing tools.\nIf a “%” character appears in the filename, then each of P processors\nwrites a portion of the dump file, and the “%” character is replaced\nwith the processor ID from 0 to P-1 preceded by an underscore character.\nFor example, tmp.dump%.vtp becomes tmp.dump_0.vtp, tmp.dump_1.vtp, …\ntmp.dump_P-1.vtp, etc.  This creates smaller files and can be a fast\nmode of output on parallel machines that support parallel I/O for output.\nBy default, P = the number of processors meaning one file per\nprocessor, but P can be set to a smaller value via the nfile or\nfileper keywords of the dump_modify command.\nThese options can be the most efficient way of writing out dump files\nwhen running on large numbers of processors.\nFor the legacy VTK format “%” is ignored and P = 1, i.e., only\nprocessor 0 does write files.\nNote that using the “*” and “%” characters together can produce a\nlarge number of small dump files!\nIf dump_modify binary is used, the dump file (or files, if “*” or\n“%” is also used) is written in binary format.  A binary dump file\nwill be about the same size as a text version, but will typically\nwrite out much faster.",
    "syntax": "dump ID group-ID vtk N file args",
    "parameters": " * ID = user-assigned name for the dump\n * group-ID = ID of the group of atoms to be dumped\n * vtk = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n * N = dump every this many timesteps\n * file = name of file to write dump info to\n * args = same as arguments for dump_style custom",
    "examples": "dump dmpvtk all vtk 100 dump*.myforce.vtk id type vx fx\ndump dmpvtp flow vtk 100 dump*.%.displace.vtp id type c_myD[1] c_myD[2] c_myD[3] v_ke",
    "restrictions": "The vtk style does not support writing of gzipped dump files.\nThe vtk dump style is part of the USER-VTK package. It is only\nenabled if LAMMPS was built with that package. See the Build package doc page for more info.\nTo use this dump style, you also must link to the VTK library.  See\nthe info in lib/vtk/README and insure the Makefile.lammps file in that\ndirectory is appropriate for your machine.\nThe vtk dump style supports neither buffering or custom format\nstrings."
},
{
    "command": "dynamical_matrix",
    "html_filename": "dynamical_matrix.html",
    "short_description": "Calculate the dynamical matrix by finite difference of the selected group,  \\[D = \\frac{\\Phi_{ij}^{\\alpha\\beta}}{\\sqrt{M_i M_j}}\\] where D is the dynamical matrix and \\(\\Phi\\) is the force constant matrix defined by  \\[\\Phi_{ij}^{\\alpha\\beta} = \\frac{\\partial^2 U}{\\partial x_{i,\\alpha} \\partial x_{j,\\beta}}\\] The output for the dynamical matrix is printed three elements at a time",
    "description": "Calculate the dynamical matrix by finite difference of the selected group,\n\n\\[D = \\frac{\\Phi_{ij}^{\\alpha\\beta}}{\\sqrt{M_i M_j}}\\]\nwhere D is the dynamical matrix and \\(\\Phi\\) is the force constant\nmatrix defined by\n\n\\[\\Phi_{ij}^{\\alpha\\beta} = \\frac{\\partial^2 U}{\\partial x_{i,\\alpha} \\partial x_{j,\\beta}}\\]\nThe output for the dynamical matrix is printed three elements at a time.\nThe three elements are the three \\(\\beta\\) elements for a respective\ni/\\(\\alpha\\)/j combination.  Each line is printed in order of j\nincreasing first, \\(\\alpha\\) second, and i last.\nIf the style eskm is selected, the dynamical matrix will be in units of\ninverse squared femtoseconds. These units will then conveniently leave\nfrequencies in THz.",
    "syntax": "dynamical_matrix group-ID style gamma args keyword value ...",
    "parameters": " * group-ID = ID of group of atoms to displace\n * style = regular or eskm\n * gamma = finite different displacement length (distance units)\n * one or more keyword/arg pairs may be appended\n * keyword = file or binary\n *   file name = name of output file for the dynamical matrix\n *   binary arg = yes or no or gzip",
    "examples": "dynamical_matrix 1 regular 0.000001\ndynamical_matrix 1 eskm 0.000001\ndynamical_matrix 3 regular 0.00004 file dynmat.dat\ndynamical_matrix 5 eskm 0.00000001 file dynamical.dat binary yes",
    "restrictions": "The command collects an array of nine times the number of atoms in a group\non every single MPI rank, so the memory requirements can be very significant\nfor large systems.\nThis command is part of the USER-PHONON package.  It is only enabled if\nLAMMPS was built with that package.\nSee the Build package doc page for more info."
},
{
    "command": "echo",
    "html_filename": "echo.html",
    "short_description": "This command determines whether LAMMPS echoes each input script command to the screen and/or log file as it is read and processed",
    "description": "This command determines whether LAMMPS echoes each input script\ncommand to the screen and/or log file as it is read and processed.  If\nan input script has errors, it can be useful to look at echoed output\nto see the last command processed.\nThe command-line switch -echo can be used in place\nof this command.",
    "syntax": "echo style",
    "parameters": " * style = none or screen or log or both",
    "examples": "echo both\necho log",
    "restrictions": "\nnone\n\nRelated commands: none"
},
{
    "command": "fix",
    "html_filename": "fix.html",
    "short_description": "Set a fix that will be applied to a group of atoms",
    "description": "Set a fix that will be applied to a group of atoms.  In LAMMPS, a\n“fix” is any operation that is applied to the system during\ntimestepping or minimization.  Examples include updating of atom\npositions and velocities due to time integration, controlling\ntemperature, applying constraint forces to atoms, enforcing boundary\nconditions, computing diagnostics, etc.  There are hundreds of fixes\ndefined in LAMMPS and new ones can be added; see the\nModify doc page for details.\nFixes perform their operations at different stages of the timestep.\nIf 2 or more fixes operate at the same stage of the timestep, they are\ninvoked in the order they were specified in the input script.\nThe ID of a fix can only contain alphanumeric characters and\nunderscores.\nFixes can be deleted with the unfix command.\n\nNote\nThe unfix command is the only way to turn off a\nfix; simply specifying a new fix with a similar style will not turn\noff the first one.  This is especially important to realize for\nintegration fixes.  For example, using a fix nve\ncommand for a second run after using a fix nvt command\nfor the first run, will not cancel out the NVT time integration\ninvoked by the “fix nvt” command.  Thus two time integrators would be\nin place!\n\nIf you specify a new fix with the same ID and style as an existing\nfix, the old fix is deleted and the new one is created (presumably\nwith new settings).  This is the same as if an “unfix” command were\nfirst performed on the old fix, except that the new fix is kept in the\nsame order relative to the existing fixes as the old one originally\nwas.  Note that this operation also wipes out any additional changes\nmade to the old fix via the fix_modify command.\nThe fix modify command allows settings for some\nfixes to be reset.  See the doc page for individual fixes for details.\nSome fixes store an internal “state” which is written to binary\nrestart files via the restart or\nwrite_restart commands.  This allows the fix to\ncontinue on with its calculations in a restarted simulation.  See the\nread_restart command for info on how to re-specify\na fix in an input script that reads a restart file.  See the doc pages\nfor individual fixes for info on which ones can be restarted.\n\nSome fixes calculate one of three styles of quantities: global,\nper-atom, or local, which can be used by other commands or output as\ndescribed below.  A global quantity is one or more system-wide values,\ne.g. the energy of a wall interacting with particles.  A per-atom\nquantity is one or more values per atom, e.g. the displacement vector\nfor each atom since time 0.  Per-atom values are set to 0.0 for atoms\nnot in the specified fix group.  Local quantities are calculated by\neach processor based on the atoms it owns, but there may be zero or\nmore per atoms.\nNote that a single fix can produce either global or per-atom or local\nquantities (or none at all), but not both global and per-atom.  It can\nproduce local quantities in tandem with global or per-atom quantities.\nThe fix doc page will explain.\nGlobal, per-atom, and local quantities each come in three kinds: a\nsingle scalar value, a vector of values, or a 2d array of values.  The\ndoc page for each fix describes the style and kind of values it\nproduces, e.g. a per-atom vector.  Some fixes produce more than one\nkind of a single style, e.g. a global scalar and a global vector.\nWhen a fix quantity is accessed, as in many of the output commands\ndiscussed below, it can be referenced via the following bracket\nnotation, where ID is the ID of the fix:\n\n\n\n\n\n\nf_ID\nentire scalar, vector, or array\n\nf_ID[I]\none element of vector, one column of array\n\nf_ID[I][J]\none element of array\n\n\n\nIn other words, using one bracket reduces the dimension of the\nquantity once (vector -> scalar, array -> vector).  Using two brackets\nreduces the dimension twice (array -> scalar).  Thus a command that\nuses scalar fix values as input can also process elements of a vector\nor array.\nNote that commands and variables which use fix\nquantities typically do not allow for all kinds, e.g. a command may\nrequire a vector of values, not a scalar.  This means there is no\nambiguity about referring to a fix quantity as f_ID even if it\nproduces, for example, both a scalar and vector.  The doc pages for\nvarious commands explain the details.\n\nIn LAMMPS, the values generated by a fix can be used in several ways:\n\nGlobal values can be output via the thermo_style custom or fix ave/time command.\nOr the values can be referenced in a variable equal or\nvariable atom command.\nPer-atom values can be output via the dump custom command.\nOr they can be time-averaged via the fix ave/atom\ncommand or reduced by the compute reduce\ncommand.  Or the per-atom values can be referenced in an atom-style variable.\nLocal values can be reduced by the compute reduce command, or histogrammed by the fix ave/histo command.\n\nSee the Howto output doc page for a summary of\nvarious LAMMPS output options, many of which involve fixes.\nThe results of fixes that calculate global quantities can be either\n“intensive” or “extensive” values.  Intensive means the value is\nindependent of the number of atoms in the simulation,\ne.g. temperature.  Extensive means the value scales with the number of\natoms in the simulation, e.g. total rotational kinetic energy.\nThermodynamic output will normalize extensive\nvalues by the number of atoms in the system, depending on the\n“thermo_modify norm” setting.  It will not normalize intensive values.\nIf a fix value is accessed in another way, e.g. by a\nvariable, you may want to know whether it is an\nintensive or extensive value.  See the doc page for individual fixes\nfor further info.\n\nEach fix style has its own doc page which describes its arguments and\nwhat it does, as listed below.  Here is an alphabetic list of fix\nstyles available in LAMMPS.  They are also listed in more compact form\non the Commands fix doc page.\nThere are also additional accelerated fix styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands fix doc\npage are followed by one or more of (g,i,k,o,t) to indicate which\naccelerated styles exist.\n\nadapt - change a simulation parameter over time\nadapt/fep - enhanced version of fix adapt\naddforce - add a force to each atom\naddtorque - add a torque to a group of atoms\nappend/atoms - append atoms to a running simulation\natc - initiates a coupled MD/FE simulation\natom/swap - Monte Carlo atom type swapping\nave/atom - compute per-atom time-averaged quantities\nave/chunk - compute per-chunk time-averaged quantities\nave/correlate - compute/output time correlations\nave/correlate/long -\nave/histo - compute/output time-averaged histograms\nave/histo/weight - weighted version of fix ave/histo\nave/time - compute/output global time-averaged quantities\naveforce - add an averaged force to each atom\nbalance - perform dynamic load-balancing\nbocs - NPT style time integration with pressure correction\nbond/break - break bonds on the fly\nbond/create - create bonds on the fly\nbond/react - apply topology changes to model reactions\nbond/swap - Monte Carlo bond swapping\nbox/relax - relax box size during energy minimization\nclient/md - MD client for client/server simulations\ncmap - enables CMAP cross-terms of the CHARMM force field\ncolvars - interface to the collective variables “Colvars” library\ncontroller - apply control loop feedback mechanism\ndeform - change the simulation box size/shape\ndeposit - add new atoms above a surface\ndpd/energy - constant energy dissipative particle dynamics\ndrag - drag atoms towards a defined coordinate\ndrude - part of Drude oscillator polarization model\ndrude/transform/direct -  part of Drude oscillator polarization model\ndrude/transform/inverse -  part of Drude oscillator polarization model\ndt/reset - reset the timestep based on velocity, forces\nedpd/source - add heat source to eDPD simulations\nefield - impose electric field on system\nehex - enhanced heat exchange algorithm\nelectron/stopping - electronic stopping power as a friction force\nenforce2d - zero out z-dimension velocity and force\neos/cv -\neos/table -\neos/table/rx -\nevaporate - remove atoms from simulation periodically\nexternal - callback to an external driver program\nffl - apply a Fast-Forward Langevin equation thermostat\nfilter/corotate - implement corotation filter to allow larger timesteps with r-RESPA\nflow/gauss - Gaussian dynamics for constant mass flux\nfreeze - freeze atoms in a granular simulation\ngcmc - grand canonical insertions/deletions\ngld - generalized Langevin dynamics integrator\ngle - generalized Langevin equation thermostat\ngravity - add gravity to atoms in a granular simulation\ngrem - implements the generalized replica exchange method\nhalt - terminate a dynamics run or minimization\nheat - add/subtract momentum-conserving heat\nhyper/global - global hyperdynamics\nhyper/local - local hyperdynamics\nimd - implements the “Interactive MD” (IMD) protocol\nindent - impose force due to an indenter\nipi - enable LAMMPS to run as a client for i-PI path-integral simulations\nlangevin - Langevin temperature control\nlangevin/drude - Langevin temperature control of Drude oscillators\nlangevin/eff - Langevin temperature control for the electron force field model\nlangevin/spin - Langevin temperature control for a spin or spin-lattice system\nlatte - wrapper on LATTE density-functional tight-binding code\nlb/fluid -\nlb/momentum -\nlb/pc -\nlb/rigid/pc/sphere -\nlb/viscous -\nlineforce - constrain atoms to move in a line\nmanifoldforce - restrain atoms to a manifold during minimization\nmeso - time integration for SPH/DPDE particles\nmeso/move - move mesoscopic SPH/SDPD particles in a prescribed fashion\nmeso/stationary -\nmomentum - zero the linear and/or angular momentum of a group of atoms\nmove - move atoms in a prescribed fashion\nmscg - apply MSCG method for force-matching to generate coarse grain models\nmsst - multi-scale shock technique (MSST) integration\nmvv/dpd - DPD using the modified velocity-Verlet integration algorithm\nmvv/edpd - constant energy DPD using the modified velocity-Verlet algorithm\nmvv/tdpd - constant temperature DPD using the modified velocity-Verlet algorithm\nneb - nudged elastic band (NEB) spring forces\nneb/spin - nudged elastic band (NEB) spring forces for spins\nnph - constant NPH time integration via Nose/Hoover\nnph/asphere - NPH for aspherical particles\nnph/body - NPH for body particles\nnph/eff - NPH for  nuclei and electrons in the electron force field model\nnph/sphere - NPH for spherical particles\nnphug - constant-stress Hugoniostat integration\nnpt - constant NPT time integration via Nose/Hoover\nnpt/asphere - NPT for aspherical particles\nnpt/body - NPT for body particles\nnpt/cauchy - NPT with Cauchy stress\nnpt/eff - NPT for  nuclei and electrons in the electron force field model\nnpt/sphere - NPT for spherical particles\nnpt/uef - NPT style time integration with diagonal flow\nnve - constant NVE time integration\nnve/asphere - NVE for aspherical particles\nnve/asphere/noforce - NVE for aspherical particles without forces\nnve/awpmd - NVE for the Antisymmetrized Wave Packet Molecular Dynamics model\nnve/body - NVE for body particles\nnve/dot - rigid body constant energy time integrator for coarse grain models\nnve/dotc/langevin - Langevin style rigid body time integrator for coarse grain models\nnve/eff - NVE for  nuclei and electrons in the electron force field model\nnve/limit - NVE with limited step length\nnve/line - NVE for line segments\nnve/manifold/rattle -\nnve/noforce - NVE without forces (v only)\nnve/sphere - NVE for spherical particles\nnve/spin - NVE for a spin or spin-lattice system\nnve/tri - NVE for triangles\nnvk - constant kinetic energy time integration\nnvt - NVT time integration via Nose/Hoover\nnvt/asphere - NVT for aspherical particles\nnvt/body - NVT for body particles\nnvt/eff - NVE for  nuclei and electrons in the electron force field model\nnvt/manifold/rattle -\nnvt/sllod - NVT for NEMD with SLLOD equations\nnvt/sllod/eff - NVT for NEMD with SLLOD equations for the electron force field model\nnvt/sphere - NVT for spherical particles\nnvt/uef - NVT style time integration with diagonal flow\noneway - constrain particles on move in one direction\norient/bcc - add grain boundary migration force for BCC\norient/fcc - add grain boundary migration force for FCC\nphonon - calculate dynamical matrix from MD simulations\npimd - Feynman path integral molecular dynamics\nplaneforce - constrain atoms to move in a plane\nplumed - wrapper on PLUMED free energy library\npoems - constrain clusters of atoms to move as coupled rigid bodies\npour - pour new atoms/molecules into a granular simulation domain\nprecession/spin -\npress/berendsen - pressure control by Berendsen barostat\nprint - print text and variables during a simulation\npropel/self - model self-propelled particles\nproperty/atom - add customized per-atom values\npython/invoke - call a Python function during a simulation\npython/move -  call a Python function during a simulation run\nqbmsst - quantum bath multi-scale shock technique time integrator\nqeq/comb - charge equilibration for COMB potential\nqeq/dynamic - charge equilibration via dynamic method\nqeq/fire - charge equilibration via FIRE minimizer\nqeq/point - charge equilibration via point method\nqeq/reax - charge equilibration for ReaxFF potential\nqeq/shielded - charge equilibration via shielded method\nqeq/slater - charge equilibration via Slater method\nqmmm - functionality to enable a quantum mechanics/molecular mechanics coupling\nqtb - implement quantum thermal bath scheme\nrattle - RATTLE constraints on bonds and/or angles\nreax/c/bonds - write out ReaxFF bond information\nreax/c/species - write out ReaxFF molecule information\nrecenter - constrain the center-of-mass position of a group of atoms\nrestrain - constrain a bond, angle, dihedral\nrhok - add bias potential for long-range ordered systems\nrigid - constrain one or more clusters of atoms to move as a rigid body with NVE integration\nrigid/meso - constrain clusters of mesoscopic SPH/SDPD particles to move as a rigid body\nrigid/nph - constrain one or more clusters of atoms to move as a rigid body with NPH integration\nrigid/nph/small - constrain many small clusters of atoms to move as a rigid body with NPH integration\nrigid/npt - constrain one or more clusters of atoms to move as a rigid body with NPT integration\nrigid/npt/small - constrain many small clusters of atoms to move as a rigid body with NPT integration\nrigid/nve - constrain one or more clusters of atoms to move as a rigid body with alternate NVE integration\nrigid/nve/small - constrain many small clusters of atoms to move as a rigid body with alternate NVE integration\nrigid/nvt - constrain one or more clusters of atoms to move as a rigid body with NVT integration\nrigid/nvt/small - constrain many small clusters of atoms to move as a rigid body with NVT integration\nrigid/small - constrain many small clusters of atoms to move as a rigid body with NVE integration\nrx -\nsaed/vtk -\nsetforce - set the force on each atom\nsetforce/spin - set magnetic precession vectors on each atom\nshake - SHAKE constraints on bonds and/or angles\nshardlow - integration of DPD equations of motion using the Shardlow splitting\nsmd - applied a steered MD force to a group\nsmd/adjust_dt -\nsmd/integrate_tlsph -\nsmd/integrate_ulsph -\nsmd/move_tri_surf -\nsmd/setvel -\nsmd/wall_surface -\nspring - apply harmonic spring force to group of atoms\nspring/chunk - apply harmonic spring force to each chunk of atoms\nspring/rg - spring on radius of gyration of group of atoms\nspring/self - spring from each atom to its origin\nsrd - stochastic rotation dynamics (SRD)\nstore/force - store force on each atom\nstore/state - store attributes for each atom\ntdpd/source -\ntemp/berendsen - temperature control by Berendsen thermostat\ntemp/csld - canonical sampling thermostat with Langevin dynamics\ntemp/csvr - canonical sampling thermostat with Hamiltonian dynamics\ntemp/rescale - temperature control by velocity rescaling\ntemp/rescale/eff - temperature control by velocity rescaling in the electron force field model\ntfmc - perform force-bias Monte Carlo with time-stamped method\nthermal/conductivity - Muller-Plathe kinetic energy exchange for thermal conductivity calculation\nti/spring -\ntmd - guide a group of atoms to a new configuration\nttm - two-temperature model for electronic/atomic coupling\nttm/mod - enhanced two-temperature model with additional options\ntune/kspace - auto-tune KSpace parameters\nvector - accumulate a global vector every N timesteps\nviscosity - Muller-Plathe momentum exchange for viscosity calculation\nviscous - viscous damping for granular simulations\nwall/body/polygon -\nwall/body/polyhedron -\nwall/colloid - Lennard-Jones wall interacting with finite-size particles\nwall/ees - wall for ellipsoidal particles\nwall/gran - frictional wall(s) for granular simulations\nwall/gran/region -\nwall/harmonic - harmonic spring wall\nwall/lj1043 - Lennard-Jones 10-4-3 wall\nwall/lj126 - Lennard-Jones 12-6 wall\nwall/lj93 - Lennard-Jones 9-3 wall\nwall/morse - Morse potential wall\nwall/piston - moving reflective piston wall\nwall/reflect - reflecting wall(s)\nwall/reflect/stochastic - reflecting wall(s) with finite temperature\nwall/region - use region surface as wall\nwall/region/ees - use region surface as wall for ellipsoidal particles\nwall/srd - slip/no-slip wall for SRD particles",
    "syntax": "fix ID group-ID style args",
    "parameters": " * ID = user-assigned name for the fix\n * group-ID = ID of the group of atoms to apply the fix to\n * style = one of a long list of possible style names (see below)\n * args = arguments used by a particular style",
    "examples": "fix 1 all nve\nfix 3 all nvt temp 300.0 300.0 0.01\nfix mine top setforce 0.0 NULL 0.0",
    "restrictions": "Some fix styles are part of specific packages.  They are only enabled\nif LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual fixes tell if it is part of a package."
},
{
    "command": "group",
    "html_filename": "group.html",
    "short_description": "Identify a collection of atoms as belonging to a group",
    "description": "Identify a collection of atoms as belonging to a group.  The group ID\ncan then be used in other commands such as fix,\ncompute, dump, or velocity\nto act on those atoms together.\nIf the group ID already exists, the group command adds the specified\natoms to the group.\n\nNote\nBy default groups are static, meaning the atoms are permanently\nassigned to the group.  For example, if the region style is used to\nassign atoms to a group, the atoms will remain in the group even if\nthey later move out of the region.  As explained below, the dynamic\nstyle can be used to make a group dynamic so that a periodic\ndetermination is made as to which atoms are in the group.  Since many\nLAMMPS commands operate on groups of atoms, you should think carefully\nabout whether making a group dynamic makes sense for your model.\n\nA group with the ID all is predefined.  All atoms belong to this\ngroup.  This group cannot be deleted, or made dynamic.\nThe delete style removes the named group and un-assigns all atoms\nthat were assigned to that group.  Since there is a restriction (see\nbelow) that no more than 32 groups can be defined at any time, the\ndelete style allows you to remove groups that are no longer needed,\nso that more can be specified.  You cannot delete a group if it has\nbeen used to define a current fix or compute\nor dump.\nThe clear style un-assigns all atoms that were assigned to that\ngroup.  This may be dangerous to do during a simulation run,\ne.g. using the run every command if a fix or compute or\nother operation expects the atoms in the group to remain constant, but\nLAMMPS does not check for this.\nThe empty style creates an empty group, which is useful for commands\nlike fix gcmc or with complex scripts that add atoms\nto a group.\nThe region style puts all atoms in the region volume into the group.\nNote that this is a static one-time assignment.  The atoms remain\nassigned (or not assigned) to the group even in they later move out of\nthe region volume.\nThe type, id, and molecule styles put all atoms with the\nspecified atom types, atom IDs, or molecule IDs into the group.  These\n3 styles can use arguments specified in one of two formats.\nThe first format is a list of values (types or IDs).  For example, the\n2nd command in the examples above puts all atoms of type 3 or 4 into\nthe group named water.  Each entry in the list can be a\ncolon-separated sequence A:B or A:B:C, as in two of the examples\nabove.  A “sequence” generates a sequence of values (types or IDs),\nwith an optional increment.  The first example with 500:1000 has the\ndefault increment of 1 and would add all atom IDs from 500 to 1000\n(inclusive) to the group sub, along with 10,25,50 since they also\nappear in the list of values.  The second example with 100:10000:10\nuses an increment of 10 and would thus would add atoms IDs\n100,110,120, … 9990,10000 to the group sub.\nThe second format is a logical followed by one or two values (type\nor ID).  The 7 valid logicals are listed above.  All the logicals\nexcept <> take a single argument.  The 3rd example above adds all\natoms with IDs from 1 to 150 to the group named sub.  The logical <>\nmeans “between” and takes 2 arguments.  The 4th example above adds all\natoms belonging to molecules with IDs from 50 to 250 (inclusive) to\nthe group named polyA.\nThe variable style evaluates a variable to determine which atoms to\nadd to the group.  It must be an atom-style variable\npreviously defined in the input script.  If the variable evaluates\nto a non-zero value for a particular atom, then that atom is added\nto the specified group.\nAtom-style variables can specify formulas that include thermodynamic\nquantities, per-atom values such as atom coordinates, or per-atom\nquantities calculated by computes, fixes, or other variables.  They\ncan also include Boolean logic where 2 numeric values are compared to\nyield a 1 or 0 (effectively a true or false).  Thus using the\nvariable style, is a general way to flag specific atoms to include\nor exclude from a group.\nFor example, these lines define a variable “eatom” that calculates the\npotential energy of each atom and includes it in the group if its\npotential energy is above the threshold value -3.0.\ncompute         1 all pe/atom\ncompute         2 all reduce sum c_1\nthermo_style    custom step temp pe c_2\nrun             0\n\nvariable        eatom atom \"c_1 > -3.0\"\ngroup           hienergy variable eatom\n\n\nNote that these lines\ncompute         2 all reduce sum c_1\nthermo_style    custom step temp pe c_2\nrun             0\n\n\nare necessary to insure that the “eatom” variable is current when the\ngroup command invokes it.  Because the eatom variable computes the\nper-atom energy via the pe/atom compute, it will only be current if a\nrun has been performed which evaluated pairwise energies, and the\npe/atom compute was actually invoked during the run.  Printing the\nthermodynamic info for compute 2 insures that this is the case, since\nit sums the pe/atom compute values (in the reduce compute) to output\nthem to the screen.  See the “Variable Accuracy” section of the\nvariable doc page for more details on insuring that\nvariables are current when they are evaluated between runs.\nThe include style with its arg molecule adds atoms to a group that\nhave the same molecule ID as atoms already in the group.  The molecule\nID = 0 is ignored in this operation, since it is assumed to flag\nisolated atoms that are not part of molecules.  An example of where\nthis operation is useful is if the region style has been used\npreviously to add atoms to a group that are within a geometric region.\nIf molecules straddle the region boundary, then atoms outside the\nregion that are part of molecules with atoms inside the region will\nnot be in the group.  Using the group command a 2nd time with include\nmolecule will add those atoms that are outside the region to the\ngroup.\n\nNote\nThe include molecule operation is relatively expensive in a\nparallel sense.  This is because it requires communication of relevant\nmolecule IDs between all the processors and each processor to loop\nover its atoms once per processor, to compare its atoms to the list of\nmolecule IDs from every other processor.  Hence it scales as N, rather\nthan N/P as most of the group operations do, where N is the number of\natoms, and P is the number of processors.\n\nThe subtract style takes a list of two or more existing group names\nas arguments.  All atoms that belong to the 1st group, but not to any\nof the other groups are added to the specified group.\nThe union style takes a list of one or more existing group names as\narguments.  All atoms that belong to any of the listed groups are\nadded to the specified group.\nThe intersect style takes a list of two or more existing group names\nas arguments.  Atoms that belong to every one of the listed groups are\nadded to the specified group.\n\nThe dynamic style flags an existing or new group as dynamic.  This\nmeans atoms will be (re)assigned to the group periodically as a\nsimulation runs.  This is in contrast to static groups where atoms are\npermanently assigned to the group.  The way the assignment occurs is\nas follows.  Only atoms in the group specified as the parent group via\nthe parent-ID are assigned to the dynamic group before the following\nconditions are applied.  If the region keyword is used, atoms not in\nthe specified region are removed from the dynamic group.  If the var\nkeyword is used, the variable name must be an atom-style or\natomfile-style variable.  The variable is evaluated and atoms whose\nper-atom values are 0.0, are removed from the dynamic group. If the property\nkeyword is used, the per-atom property name must be a previously defined\nper-atom property.  The per-atom property is evaluated and atoms whose\nvalues are 0.0 are removed from the dynamic group.\nThe assignment of atoms to a dynamic group is done at the beginning of\neach run and on every timestep that is a multiple of N, which is the\nargument for the every keyword (N = 1 is the default).  For an\nenergy minimization, via the minimize command, an\nassignment is made at the beginning of the minimization, but not\nduring the iterations of the minimizer.\nThe point in the timestep at which atoms are assigned to a dynamic\ngroup is after the initial stage of velocity Verlet time integration\nhas been performed, and before neighbor lists or forces are computed.\nThis is the point in the timestep where atom positions have just\nchanged due to the time integration, so the region criterion should be\naccurate, if applied.\n\nNote\nIf the region keyword is used to determine what atoms are in\nthe dynamic group, atoms can move outside of the simulation box\nbetween reneighboring events.  Thus if you want to include all atoms\non the left side of the simulation box, you probably want to set the\nleft boundary of the region to be outside the simulation box by some\nreasonable amount (e.g. up to the cutoff of the potential), else they\nmay be excluded from the dynamic region.\n\nHere is an example of using a dynamic group to shrink the set of atoms\nbeing integrated by using a spherical region with a variable radius\n(shrinking from 18 to 5 over the course of the run).  This could be\nused to model a quench of the system, freezing atoms outside the\nshrinking sphere, then converting the remaining atoms to a static\ngroup and running further.\nvariable        nsteps equal 5000\nvariable        rad equal 18-(step/v_nsteps)*(18-5)\nregion          ss sphere 20 20 0 v_rad\ngroup           mobile dynamic all region ss\nfix             1 mobile nve\nrun             ${nsteps}\ngroup           mobile static\nrun             ${nsteps}\n\nNote\nAll fixes and computes take a group ID as an argument, but they\ndo not all allow for use of a dynamic group.  If you get an error\nmessage that this is not allowed, but feel that it should be for the\nfix or compute in question, then please post your reasoning to the\nLAMMPS mail list and we can change it.\n\nThe static style removes the setting for a dynamic group, converting\nit to a static group (the default).  The atoms in the static group are\nthose currently in the dynamic group.",
    "syntax": "group ID style args",
    "parameters": " * ID = user-defined name of the group\n * style = delete or clear or empty or region or         type or id or molecule or variable or         include or subtract or union or intersect or         dynamic or static\n * delete = no args\n * clear = no args\n * empty = no args\n * region args = region-ID\n * type or id or molecule\n *   args = list of one or more atom types, atom IDs, or molecule IDs\n *     any entry in list can be a sequence formatted as A:B or A:B:C where\n *     A = starting index, B = ending index,\n *     C = increment between indices, 1 if not specified\n *   args = logical value\n *     logical = \"<\" or \"<=\" or \">\" or \">=\" or \"==\" or \"!=\"\n *     value = an atom type or atom ID or molecule ID (depending on style)\n *   args = logical value1 value2\n *     logical = \"<>\"\n *     value1,value2 = atom types or atom IDs or molecule IDs (depending on style)\n * variable args = variable-name\n * include args = molecule\n *   molecule = add atoms to group with same molecule ID as atoms already in group\n * subtract args = two or more group IDs\n * union args = one or more group IDs\n * intersect args = two or more group IDs\n * dynamic args = parent-ID keyword value ...\n *   one or more keyword/value pairs may be appended\n *   keyword = region or var or every\n *     region value = region-ID\n *     var value = name of variable\n *     property value = name of per-atom property\n *     every value = N = update group every this many timesteps\n * static = no args",
    "examples": "group edge region regstrip\ngroup water type 3 4\ngroup sub id 10 25 50\ngroup sub id 10 25 50 500:1000\ngroup sub id 100:10000:10\ngroup sub id <= 150\ngroup polyA molecule <> 50 250\ngroup hienergy variable eng\ngroup hienergy include molecule\ngroup boundary subtract all a2 a3\ngroup boundary union lower upper\ngroup boundary intersect upper flow\ngroup boundary delete\ngroup mine dynamic all region myRegion every 100",
    "restrictions": "There can be no more than 32 groups defined at one time, including\n“all”.\nThe parent group of a dynamic group cannot itself be a dynamic group."
},
{
    "command": "group2ndx",
    "html_filename": "group2ndx.html",
    "short_description": "Write or read a Gromacs style index file in text format that associates atom IDs with the corresponding group definitions",
    "description": "Write or read a Gromacs style index file in text format that associates\natom IDs with the corresponding group definitions. This index file can be\nused with in combination with Gromacs analysis tools or to import group\ndefinitions into the fix colvars input file. It can\nalso be used to save and restore group definitions for static groups.\nThe group2ndx command will write group definitions to an index file.\nWithout specifying any group IDs, all groups will be written to the index\nfile. When specifying group IDs, only those groups will be written to the\nindex file. In order to follow the Gromacs conventions, the group all\nwill be renamed to System in the index file.\nThe ndx2group command will create of update group definitions from those\nstored in an index file. Without specifying any group IDs, all groups except\nSystem will be read from the index file and the corresponding groups\nrecreated. If a group of the same name already exists, it will be completely\nreset. When specifying group IDs, those groups, if present, will be read\nfrom the index file and restored.",
    "syntax": "group2ndx file group-ID ...",
    "parameters": " * ndx2group file group-ID ...\n * file = name of index file to write out or read in\n * zero or more group IDs may be appended",
    "examples": "group2ndx allindex.ndx\ngroup2ndx someindex.ndx upper lower mobile\nndx2group someindex.ndx\nndx2group someindex.ndx mobile",
    "restrictions": "This command requires that atoms have atom IDs, since this is the\ninformation that is written to the index file.\nThese commands are part of the USER-COLVARS package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "hyper",
    "html_filename": "hyper.html",
    "short_description": "Run a bond-boost hyperdynamics (HD) simulation where time is accelerated by application of a bias potential to one or more pairs of nearby atoms in the system",
    "description": "Run a bond-boost hyperdynamics (HD) simulation where time is\naccelerated by application of a bias potential to one or more pairs of\nnearby atoms in the system.  This command can be used to run both\nglobal and local hyperdynamics.  In global HD a single bond within the\nsystem is biased on each timestep.  In local HD multiple bonds\n(separated by a sufficient distance) can be biased simultaneously at\neach timestep.  In the bond-boost hyperdynamics context, a “bond” is\nnot a covalent bond between a pair of atoms in a molecule.  Rather it\nis simply a pair of nearby atoms as discussed below.\nBoth global and local HD are described in (Voter2013) by\nArt Voter and collaborators.  Similar to parallel replica dynamics\n(PRD), global and local HD are methods for performing accelerated\ndynamics that are suitable for infrequent-event systems that obey\nfirst-order kinetics.  A good overview of accelerated dynamics methods\nfor such systems in given in (Voter2002) from the same\ngroup.  To quote from the review paper: “The dynamical evolution is\ncharacterized by vibrational excursions within a potential basin,\npunctuated by occasional transitions between basins.”  The transition\nprobability is characterized by p(t) = k*exp(-kt) where k is the rate\nconstant.  Running multiple replicas gives an effective enhancement in\nthe timescale spanned by the multiple simulations, while waiting for\nan event to occur.\nBoth HD and PRD produce a time-accurate trajectory that effectively\nextends the timescale over which a system can be simulated, but they\ndo it differently.  HD uses a single replica of the system and\naccelerates time by biasing the interaction potential in a manner such\nthat each timestep is effectively longer.  PRD creates Nr replicas of\nthe system and runs dynamics on each independently with a normal\nunbiased potential until an event occurs in one of the replicas.  The\ntime between events is reduced by a factor of Nr replicas.  For both\nmethods, per CPU second, more physical time elapses and more events\noccur.  See the prd doc page for more info about PRD.\nAn HD run has several stages, which are repeated each time an event\noccurs, as explained below.  The logic for an HD run is as follows:\nquench\ncreate initial list of bonds\n\nwhile (time remains):\n  run dynamics for Nevent steps\n  quench\n  check for an event\n  if event occurred: reset list of bonds\n  restore pre-quench state\n\n\nThe list of bonds is the list of atom pairs of atoms that are within a\nshort cutoff distance of each other after the system energy is\nminimized (quenched).  This list is created and reset by a fix hyper/global or fix hyper/local command specified as fix-ID.  At\nevery dynamics timestep, the same fix selects one of more bonds to\napply a bias potential to.\n\nNote\nThe style of fix associated with the specified fix-ID\ndetermines whether you are running the global versus local\nhyperdynamics algorithm.\n\nDynamics (with the bias potential) is run continuously, stopping every\nNevent steps to check if a transition event has occurred.  The\nspecified N for total steps must be a multiple of Nevent.  check\nis performed by quenching the system and comparing the resulting atom\ncoordinates to the coordinates from the previous basin.\nA quench is an energy minimization and is performed by whichever\nalgorithm has been defined by the min_style command.\nMinimization parameters may be set via the\nmin_modify command and by the min keyword of the\nhyper command.  The latter are the settings that would be used with\nthe minimize command.  Note that typically, you do not\nneed to perform a highly-converged minimization to detect a transition\nevent, though you may need to in order to prevent a set of atoms in\nthe system from relaxing to a saddle point.\nThe event check is performed by a compute with the specified\ncompute-ID.  Currently there is only one compute that works with the\nhyper command, which is the compute event/displace command.  Other\nevent-checking computes may be added.  Compute event/displace checks whether any atom in\nthe compute group has moved further than a specified threshold\ndistance.  If so, an event has occurred.\nIf this happens, the list of bonds is reset, since some bond pairs\nare likely now too far apart, and new pairs are likely close enough\nto be considered a bond.  The pre-quenched state of the\nsystem (coordinates and velocities) is restored, and dynamics continue.\nAt the end of the hyper run, a variety of statistics are output to the\nscreen and logfile.  These include info relevant to both global and\nlocal hyperdynamics, such as the number of events and the elapsed\nhyper time (accelerated time), And it includes info specific to one or\nthe other, depending on which style of fix was specified by fix-ID.\n\nThe optional keywords operate as follows.\nAs explained above, the min keyword can be used to specify\nparameters for the quench.  Their meaning is the same\nas for the minimize command\nThe dump keyword can be used to trigger a specific dump command with\nthe specified dump-ID to output a snapshot each time an event is\ndetected.  It can be specified multiple times with different dump-ID\nvalues, as in the example above.  These snapshots will be for the\nquenched state of the system on a timestep that is a multiple of\nNevent, i.e. a timestep after the event has occurred.  Note that any\ndump command in the input script will also output snapshots at\nwhatever timestep interval it defines via its N argument; see the\ndump command for details.  This means if you only want a\nparticular dump to output snapshots when events are detected, you\nshould specify its N as a value larger than the length of the\nhyperdynamics run.\nAs in the code logic above, the bond list is normally only reset when\nan event occurs.  The rebond keyword will force a reset of the bond\nlist every Nrebond steps, even if an event has not occurred.\nNrebond must be a multiple of Nevent.  This can be useful to check\nif more frequent resets alter event statistics, perhaps because the\nparameters chosen for defining what is a bond and what is an event are\nproducing bad dynamics in the presence of the bias potential.",
    "syntax": "hyper N Nevent fix-ID compute-ID keyword values ...",
    "parameters": " * N = # of timesteps to run\n * Nevent = check for events every this many steps\n * fix-ID = ID of a fix that applies a global or local bias potential, can be NULL\n * compute-ID = ID of a compute that identifies when an event has occurred\n * zero or more keyword/value pairs may be appended\n * keyword = min or dump or rebond\n * min values = etol ftol maxiter maxeval\n *   etol = stopping tolerance for energy, used in quenching\n *   ftol = stopping tolerance for force, used in quenching\n *   maxiter = max iterations of minimize, used in quenching\n *   maxeval = max number of force/energy evaluations, used in quenching\n * dump value = dump-ID\n *   dump-ID = ID of dump to trigger whenever an event takes place\n * rebond value = Nrebond\n *   Nrebond = frequency at which to reset bonds, even if no event has occurred",
    "examples": "compute event all event/displace 1.0\nfix HG mobile hyper/global 3.0 0.3 0.4 800.0\nhyper 5000 100 HG event min 1.0e-6 1.0e-6 100 100 dump 1 dump 5",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "if",
    "html_filename": "if.html",
    "short_description": "This command provides an if-then-else capability within an input script",
    "description": "This command provides an if-then-else capability within an input\nscript.  A Boolean expression is evaluated and the result is TRUE or\nFALSE.  Note that as in the examples above, the expression can contain\nvariables, as defined by the variable command, which\nwill be evaluated as part of the expression.  Thus a user-defined\nformula that reflects the current state of the simulation can be used\nto issue one or more new commands.\nIf the result of the Boolean expression is TRUE, then one or more\ncommands (t1, t2, …, tN) are executed.  If it is FALSE, then Boolean\nexpressions associated with successive elif keywords are evaluated\nuntil one is found to be true, in which case its commands (f1, f2,\n…, fN) are executed.  If no Boolean expression is TRUE, then the\ncommands associated with the else keyword, namely (e1, e2, …, eN),\nare executed.  The elif and else keywords and their associated\ncommands are optional.  If they aren’t specified and the initial\nBoolean expression is FALSE, then no commands are executed.\nThe syntax for Boolean expressions is described below.\nEach command (t1, f1, e1, etc) can be any valid LAMMPS input script\ncommand.  If the command is more than one word, it must enclosed in\nquotes, so it will be treated as a single argument, as in the examples\nabove.\n\nNote\nIf a command itself requires a quoted argument (e.g. a\nprint command), then double and single quotes can be used\nand nested in the usual manner, as in the examples above and below.\nThe Commands parse doc page has more details on\nusing quotes in arguments.  Only one of level of nesting is allowed,\nbut that should be sufficient for most use cases.\n\nNote that by using the line continuation character “&”, the if command\ncan be spread across many lines, though it is still a single command:\nif \"$a < $b\" then &\n  \"print 'Minimum value = $a'\" &\n  \"run 1000\" &\nelse &\n  'print \"Minimum value = $b\"' &\n  \"minimize 0.001 0.001 1000 10000\"\n\n\nNote that if one of the commands to execute is quit, as in\nthe first example above, then executing the command will cause LAMMPS\nto halt.\nNote that by jumping to a label in the same input script, the if\ncommand can be used to break out of a loop.  See the variable delete command for info on how to delete the associated\nloop variable, so that it can be re-used later in the input script.\nHere is an example of a loop which checks every 1000 steps if the\nsystem temperature has reached a certain value, and if so, breaks out\nof the loop to finish the run.  Note that any variable could be\nchecked, so long as it is current on the timestep when the run\ncompletes.  As explained on the variable doc page,\nthis can be insured by including the variable in thermodynamic output.\nvariable myTemp equal temp\nlabel loop\nvariable a loop 1000\nrun 1000\nif \"${myTemp} < 300.0\" then \"jump SELF break\"\nnext a\njump SELF loop\nlabel break\nprint \"ALL DONE\"\n\n\nHere is an example of a double loop which uses the if and\njump commands to break out of the inner loop when a\ncondition is met, then continues iterating through the outer loop.\nlabel       loopa\nvariable    a loop 5\n  label     loopb\n  variable  b loop 5\n  print     \"A,B = $a,$b\"\n  run       10000\n  if        \"$b > 2\" then \"jump SELF break\"\n  next      b\n  jump      in.script loopb\nlabel       break\nvariable    b delete\nnext        a\njump        SELF loopa\n\n\n\nThe Boolean expressions for the if and elif keywords have a C-like\nsyntax.  Note that each expression is a single argument within the if\ncommand.  Thus if you want to include spaces in the expression for\nclarity, you must enclose the entire expression in quotes.\nAn expression is built out of numbers (which start with a digit or\nperiod or minus sign) or strings (which start with a letter and can\ncontain alphanumeric characters or underscores):\n0.2, 100, 1.0e20, -15.4, etc\nInP, myString, a123, ab_23_cd, etc\n\n\nand Boolean operators:\nA == B, A != B, A < B, A <= B, A > B, A >= B, A && B, A || B, A |^ B, !A\nEach A and B is a number or string or a variable reference like $a or\n${abc}, or A or B can be another Boolean expression.\nIf a variable is used it can produce a number when evaluated, like an\nequal-style variable.  Or it can produce a string,\nlike an index-style variable.  For an individual\nBoolean operator, A and B must both be numbers or must both be\nstrings.  You cannot compare a number to a string.\nExpressions are evaluated left to right and have the usual C-style\nprecedence: the unary logical NOT operator “!” has the highest\nprecedence, the 4 relational operators “<”, “<=”, “>”, and “>=” are\nnext; the two remaining relational operators “==” and “!=” are next;\nthen the logical AND operator “&&”; and finally the logical OR\noperator “||” and logical XOR (exclusive or) operator “|^” have the\nlowest precedence.  Parenthesis can be used to group one or more\nportions of an expression and/or enforce a different order of\nevaluation than what would occur with the default precedence.\nWhen the 6 relational operators (first 6 in list above) compare 2\nnumbers, they return either a 1.0 or 0.0 depending on whether the\nrelationship between A and B is TRUE or FALSE.  When the 6 relational\noperators compare 2 strings, they also return a 1.0 or 0.0 for TRUE or\nFALSE, but the comparison is done by the C function strcmp().\nWhen the 3 logical operators (last 3 in list above) compare 2 numbers,\nthey also return either a 1.0 or 0.0 depending on whether the\nrelationship between A and B is TRUE or FALSE (or just A).  The\nlogical AND operator will return 1.0 if both its arguments are\nnon-zero, else it returns 0.0.  The logical OR operator will return\n1.0 if either of its arguments is non-zero, else it returns 0.0.  The\nlogical XOR operator will return 1.0 if one of its arguments is zero\nand the other non-zero, else it returns 0.0.  The logical NOT operator\nreturns 1.0 if its argument is 0.0, else it returns 0.0.  The 3\nlogical operators can only be used to operate on numbers, not on\nstrings.\nThe overall Boolean expression produces a TRUE result if the result is\nnon-zero.  If the result is zero, the expression result is FALSE.",
    "syntax": "if boolean then t1 t2 ... elif boolean f1 f2 ... elif boolean f1 f2 ... else e1 e2 ...",
    "parameters": " * boolean = a Boolean expression evaluated as TRUE or FALSE (see below)\n * then = required word\n * t1,t2,…,tN = one or more LAMMPS commands to execute if condition is met, each enclosed in quotes\n * elif = optional word, can appear multiple times\n * f1,f2,…,fN = one or more LAMMPS commands to execute if elif condition is met, each enclosed in quotes (optional arguments)\n * else = optional argument\n * e1,e2,…,eN = one or more LAMMPS commands to execute if no condition is met, each enclosed in quotes (optional arguments)",
    "examples": "if \"${steps} > 1000\" then quit\nif \"${myString} == a10\" then quit\nif \"$x <= $y\" then \"print X is smaller = $x\" else \"print Y is smaller = $y\"\nif \"(${eng} > 0.0) || ($n < 1000)\" then &\n  \"timestep 0.005\" &\nelif $n<10000 &\n  \"timestep 0.01\" &\nelse &\n  \"timestep 0.02\" &\n  \"print 'Max step reached'\"\nif \"${eng} > ${eng_previous}\" then \"jump file1\" else \"jump file2\"",
    "restrictions": "\nnone"
},
{
    "command": "improper_coeff",
    "html_filename": "improper_coeff.html",
    "short_description": "Specify the improper force field coefficients for one or more improper types",
    "description": "Specify the improper force field coefficients for one or more improper\ntypes.  The number and meaning of the coefficients depends on the\nimproper style.  Improper coefficients can also be set in the data\nfile read by the read_data command or in a restart\nfile.\nN can be specified in one of two ways.  An explicit numeric value can\nbe used, as in the 1st example above.  Or a wild-card asterisk can be\nused to set the coefficients for multiple improper types.  This takes\nthe form “*” or “*n” or “n*” or “m*n”.  If N = the number of improper\ntypes, then an asterisk with no numeric values means all types from 1\nto N.  A leading asterisk means all types from 1 to n (inclusive).  A\ntrailing asterisk means all types from n to N (inclusive).  A middle\nasterisk means all types from m to n (inclusive).\nNote that using an improper_coeff command can override a previous\nsetting for the same improper type.  For example, these commands set\nthe coeffs for all improper types, then overwrite the coeffs for just\nimproper type 2:\nimproper_coeff * 300.0 0.0\nimproper_coeff 2 50.0 0.0\n\n\nA line in a data file that specifies improper coefficients uses the\nexact same format as the arguments of the improper_coeff command in an\ninput script, except that wild-card asterisks should not be used since\ncoefficients for all N types must be listed in the file.  For example,\nunder the “Improper Coeffs” section of a data file, the line that\ncorresponds to the 1st example above would be listed as\n1 300.0 0.0\n\n\nThe improper_style class2 is an exception to\nthis rule, in that an additional argument is used in the input script\nto allow specification of the cross-term coefficients.  See its doc\npage for details.\n\nThe list of all improper styles defined in LAMMPS is given on the\nimproper_style doc page.  They are also listed\nin more compact form on the Commands improper doc page.\nOn either of those pages, click on the style to display the formula it\ncomputes and its coefficients as specified by the associated\nimproper_coeff command.",
    "syntax": "improper_coeff N args",
    "parameters": " * N = improper type (see asterisk form below)\n * args = coefficients for one or more improper types",
    "examples": "improper_coeff 1 300.0 0.0\nimproper_coeff * 80.2 -1 2\nimproper_coeff *4 80.2 -1 2",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command.\nAn improper style must be defined before any improper coefficients are\nset, either in the input script or in a data file."
},
{
    "command": "improper_style",
    "html_filename": "improper_style.html",
    "short_description": "Set the formula(s) LAMMPS uses to compute improper interactions between quadruplets of atoms, which remain in force for the duration of the simulation",
    "description": "Set the formula(s) LAMMPS uses to compute improper interactions\nbetween quadruplets of atoms, which remain in force for the duration\nof the simulation.  The list of improper quadruplets is read in by a\nread_data or read_restart command\nfrom a data or restart file.  Note that the ordering of the 4 atoms in\nan improper quadruplet determines the definition of the improper\nangle used in the formula for each style.  See the doc pages of\nindividual styles for details.\nHybrid models where impropers are computed using different improper\npotentials can be setup using the hybrid improper style.\nThe coefficients associated with an improper style can be specified in\na data or restart file or via the improper_coeff\ncommand.\nAll improper potentials store their coefficient data in binary restart\nfiles which means improper_style and\nimproper_coeff commands do not need to be\nre-specified in an input script that restarts a simulation.  See the\nread_restart command for details on how to do\nthis.  The one exception is that improper_style hybrid only stores\nthe list of sub-styles in the restart file; improper coefficients need\nto be re-specified.\n\nNote\nWhen both an improper and pair style is defined, the\nspecial_bonds command often needs to be used to\nturn off (or weight) the pairwise interaction that would otherwise\nexist between a group of 4 bonded atoms.\n\n\nHere is an alphabetic list of improper styles defined in LAMMPS.\nClick on the style to display the formula it computes and coefficients\nspecified by the associated improper_coeff\ncommand.\nClick on the style to display the formula it computes, any additional\narguments specified in the improper_style command, and coefficients\nspecified by the associated improper_coeff\ncommand.\nThere are also additional accelerated pair styles included in the\nLAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\nThe individual style names on the Commands improper doc page are followed by one or\nmore of (g,i,k,o,t) to indicate which accelerated styles exist.\n\nnone - turn off improper interactions\nzero - topology but no interactions\nhybrid - define multiple styles of improper interactions\nclass2 - COMPASS (class 2) improper\ncossq - improper with a cosine squared term\ncvff - CVFF improper\ndistance - improper based on distance between atom planes\ndistharm - improper that is harmonic in the out-of-plane distance\nfourier - improper with multiple cosine terms\nharmonic - harmonic improper\ninversion/harmonic - harmonic improper with Wilson-Decius out-of-plane definition\nring - improper which prevents planar conformations\numbrella - DREIDING improper\n\nsqdistharm - improper that is harmonic in the square of the out-of-plane distance",
    "syntax": "improper_style style",
    "parameters": " * style = none or hybrid or class2 or cvff or harmonic",
    "examples": "improper_style harmonic\nimproper_style cvff\nimproper_style hybrid cvff harmonic",
    "restrictions": "Improper styles can only be set for atom_style choices that allow\nimpropers to be defined.\nMost improper styles are part of the MOLECULE package.  They are only\nenabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\nindividual improper potentials tell if it is part of a package."
},
{
    "command": "include",
    "html_filename": "include.html",
    "short_description": "This command opens a new input script file and begins reading LAMMPS commands from that file",
    "description": "This command opens a new input script file and begins reading LAMMPS\ncommands from that file.  When the new file is finished, the original\nfile is returned to.  Include files can be nested as deeply as\ndesired.  If input script A includes script B, and B includes A, then\nLAMMPS could run for a long time.\nIf the filename is a variable (see the variable\ncommand), different processor partitions can run different input\nscripts.",
    "syntax": "include file",
    "parameters": " * file = filename of new input script to switch to",
    "examples": "include newfile\ninclude in.run2",
    "restrictions": "\nnone"
},
{
    "command": "info",
    "html_filename": "info.html",
    "short_description": "Print out information about the current internal state of the running LAMMPS process",
    "description": "Print out information about the current internal state of the running\nLAMMPS process. This can be helpful when debugging or validating\ncomplex input scripts.  Several output categories are available and\none or more output category may be requested.\nThe out flag controls where the output is sent. It can only be sent\nto one target. By default this is the screen, if it is active. The\nlog argument selects the log file instead. With the append and\noverwrite option, followed by a filename, the output is written\nto that file, which is either appended to or overwritten, respectively.\nThe all flag activates printing all categories listed below.\nThe configuration category prints some information about the\nLAMMPS version as well as architecture and OS it is run on.\nThe memory category prints some information about the current\nmemory allocation of MPI rank 0 (this the amount of dynamically\nallocated memory reported by LAMMPS classes). Where supported,\nalso some OS specific information about the size of the reserved\nmemory pool size (this is where malloc() and the new operator\nrequest memory from) and the maximum resident set size is reported\n(this is the maximum amount of physical memory occupied so far).\nThe system category prints a general system overview listing.  This\nincludes the unit style, atom style, number of atoms, bonds, angles,\ndihedrals, and impropers and the number of the respective types, box\ndimensions and properties, force computing styles and more.\nThe communication category prints a variety of information about\ncommunication and parallelization: the MPI library version level,\nthe number of MPI ranks and OpenMP threads, the communication style\nand layout, the processor grid dimensions, ghost atom communication\nmode, cutoff, and related settings.\nThe computes category prints a list of all currently defined\ncomputes, their IDs and styles and groups they operate on.\nThe dumps category prints a list of all currently active dumps,\ntheir IDs, styles, filenames, groups, and dump frequencies.\nThe fixes category prints a list of all currently defined fixes,\ntheir IDs and styles and groups they operate on.\nThe groups category prints a list of all currently defined groups.\nThe regions category prints a list of all currently defined regions,\ntheir IDs and styles and whether “inside” or “outside” atoms are\nselected.\nThe variables category prints a list of all currently defined\nvariables, their names, styles, definition and last computed value, if\navailable.\nThe coeffs category prints a list for each defined force style\n(pair, bond, angle, dihedral, improper) indicating which of the\ncorresponding coefficients have been set. This can be very helpful\nto debug error messages like “All pair coeffs are not set”.\nThe styles category prints the list of styles available in the\ncurrent LAMMPS binary. It supports one of the following options\nto control which category of styles is printed out:\n\nall\nangle\natom\nbond\ncompute\ncommand\ndump\ndihedral\nfix\nimproper\nintegrate\nkspace\nminimize\npair\nregion\n\nThe time category prints the accumulated CPU and wall time for the\nprocess that writes output (usually MPI rank 0).",
    "syntax": "info args",
    "parameters": " * args = one or more of the following keywords: out, all, system, memory, communication, computes, dumps, fixes, groups, regions, variables, coeffs, styles, time, or configuration\n * out values = screen, log, append filename, overwrite filename\n * styles values = all, angle, atom, bond, compute, command, dump, dihedral, fix, improper, integrate, kspace, minimize, pair, region",
    "examples": "info system\ninfo groups computes variables\ninfo all out log\ninfo all out append info.txt\ninfo styles all\ninfo styles atom",
    "restrictions": "\nnone"
},
{
    "command": "jump",
    "html_filename": "jump.html",
    "short_description": "This command closes the current input script file, opens the file with the specified name, and begins reading LAMMPS commands from that file",
    "description": "This command closes the current input script file, opens the file with\nthe specified name, and begins reading LAMMPS commands from that file.\nUnlike the include command, the original file is not\nreturned to, although by using multiple jump commands it is possible\nto chain from file to file or back to the original file.\nIf the word “SELF” is used for the filename, then the current input\nscript is re-opened and read again.\n\nNote\nThe SELF option is not guaranteed to work when the current input\nscript is being read through stdin (standard input), e.g.\n\nlmp_g++ < in.script\n\n\nsince the SELF option invokes the C-library rewind() call, which may\nnot be supported for stdin on some systems or by some MPI\nimplementations.  This can be worked around by using the -in command-line switch, e.g.\nlmp_g++ -in in.script\n\n\nor by using the -var command-line switch to pass\nthe script name as a variable to the input script.  In the latter\ncase, a variable called “fname” could be used in place\nof SELF, e.g.\nlmp_g++ -var fname in.script < in.script\n\n\nThe 2nd argument to the jump command is optional.  If specified, it is\ntreated as a label and the new file is scanned (without executing\ncommands) until the label is found, and commands are executed from\nthat point forward.  This can be used to loop over a portion of the\ninput script, as in this example.  These commands perform 10 runs,\neach of 10000 steps, and create 10 dump files named file.1, file.2,\netc.  The next command is used to exit the loop after 10\niterations.  When the “a” variable has been incremented for the tenth\ntime, it will cause the next jump command to be skipped.\nvariable a loop 10\nlabel loop\ndump 1 all atom 100 file.$a\nrun 10000\nundump 1\nnext a\njump in.lj loop\n\n\nIf the jump file argument is a variable, the jump command can be\nused to cause different processor partitions to run different input\nscripts.  In this example, LAMMPS is run on 40 processors, with 4\npartitions of 10 procs each.  An in.file containing the example\nvariable and jump command will cause each partition to run a different\nsimulation.\nmpirun -np 40 lmp_ibm -partition 4x10 -in in.file\n\nvariable f world script.1 script.2 script.3 script.4\njump $f\n\n\nHere is an example of a loop which checks every 1000 steps if the\nsystem temperature has reached a certain value, and if so, breaks out\nof the loop to finish the run.  Note that any variable could be\nchecked, so long as it is current on the timestep when the run\ncompletes.  As explained on the variable doc page,\nthis can be insured by including the variable in thermodynamic output.\nvariable myTemp equal temp\nlabel loop\nvariable a loop 1000\nrun 1000\nif \"${myTemp} < 300.0\" then \"jump SELF break\"\nnext a\njump SELF loop\nlabel break\nprint \"ALL DONE\"\n\n\nHere is an example of a double loop which uses the if and\njump commands to break out of the inner loop when a\ncondition is met, then continues iterating through the outer loop.\nlabel       loopa\nvariable    a loop 5\n  label     loopb\n  variable  b loop 5\n  print     \"A,B = $a,$b\"\n  run       10000\n  if        \"$b > 2\" then \"jump SELF break\"\n  next      b\n  jump      in.script loopb\nlabel       break\nvariable    b delete\nnext        a\njump        SELF loopa",
    "syntax": "jump file label",
    "parameters": " * file = filename of new input script to switch to\n * label = optional label within file to jump to",
    "examples": "jump newfile\njump in.run2 runloop\njump SELF runloop",
    "restrictions": "If you jump to a file and it does not contain the specified label,\nLAMMPS will come to the end of the file and exit."
},
{
    "command": "kim_init",
    "html_filename": "kim_commands.html",
    "short_description": "The set of kim_commands provide a high-level wrapper around the Open Knowledgebase of Interatomic Models (OpenKIM) repository of interatomic models (IMs) (potentials and force fields), so that they can be used by LAMMPS scripts",
    "description": "The set of kim_commands provide a high-level wrapper around the\nOpen Knowledgebase of Interatomic Models (OpenKIM)\nrepository of interatomic models (IMs) (potentials and force fields),\nso that they can be used by LAMMPS scripts.  These commands do not implement\nany computations directly, but rather generate LAMMPS input commands based\non the information retrieved from the OpenKIM repository to initialize and\nactivate OpenKIM IMs and query their predictions for use in the LAMMPS script.\nAll LAMMPS input commands generated and executed by kim_commands are\nechoed to the LAMMPS log file.\n\nBenefits of Using OpenKIM IMs\nEmploying OpenKIM IMs provides LAMMPS users with multiple benefits:\n\nReliability\n\nAll content archived in OpenKIM is reviewed by the KIM Editor for quality.\nIMs in OpenKIM are archived with full provenance control. Each is associated with a maintainer responsible for the integrity of the content. All changes are tracked and recorded.\nIMs in OpenKIM are exhaustively tested using KIM Tests that compute a host of material properties, and KIM Verification Checks that provide the user with information on various aspects of the IM behavior and coding correctness. This information is displayed on the IM’s page accessible through the  OpenKIM browse interface.\n\n\n\nReproducibility\n\nEach IM in OpenKIM is issued a unique identifier (KIM ID), which includes a version number (last three digits).  Any changes that can result in different numerical values lead to a version increment in the KIM ID. This makes it possible to reproduce simulations since the specific version of a specific IM used can be retrieved using its KIM ID.\nOpenKIM is a member organization of DataCite and issues digital object identifiers (DOIs) to all IMs archived in OpenKIM. This makes it possible to cite the IM code used in a simulation in a publications to give credit to the developers and further facilitate reproducibility.\n\n\n\nConvenience\n\nIMs in OpenKIM are distributed in binary form along with LAMMPS and can be used in a LAMMPS input script simply by providing their KIM ID in the kim_init command documented on this page.\nThe kim_query web query tool provides the ability to use the predictions of IMs for supported material properties (computed via KIM Tests) as part of a LAMMPS input script setup and analysis.\nSupport is provided for unit conversion between the unit style used in the LAMMPS input script and the units required by the OpenKIM IM. This makes it possible to use a single input script with IMs using different units without change and minimizes the likelihood of errors due to incompatible units.\n\n\n\n\nTypes of IMs in OpenKIM\nThere are two types of IMs archived in OpenKIM:\n\nThe first type is called a KIM Portable Model (PM). A KIM PM is an independent computer implementation of an IM written in one of the languages supported by KIM (C, C++, Fortran) that conforms to the KIM Application Programming Interface (KIM API) Portable Model Interface (PMI) standard. A KIM PM will work seamlessly with any simulation code that supports the KIM API/PMI standard (including LAMMPS; see complete list of supported codes).\nThe second type is called a KIM Simulator Model (SM). A KIM SM is an IM that is implemented natively within a simulation code (simulator) that supports the KIM API Simulator Model Interface (SMI); in this case LAMMPS. A separate SM package is archived in OpenKIM for each parameterization of the IM, which includes all of the necessary parameter files, LAMMPS commands, and metadata (supported species, units, etc.) needed to run the IM in LAMMPS.\n\nWith these two IM types, OpenKIM can archive and test almost all IMs that\ncan be used by LAMMPS. (It is easy to contribute new IMs to OpenKIM, see\nthe upload instructions.)\nOpenKIM IMs are uniquely identified by a\nKIM ID.\nThe extended KIM ID consists of\na human-readable prefix identifying the type of IM, authors, publication year,\nand supported species, separated by two underscores from the KIM ID itself,\nwhich begins with an IM code\n(MO for a KIM Portable Model, and SM for a KIM Simulator Model)\nfollowed by a unique 12-digit code and a 3-digit version identifier.\nBy convention SM prefixes begin with Sim_ to readily identify them.\nSW_StillingerWeber_1985_Si__MO_405512056662_005\nSim_LAMMPS_ReaxFF_StrachanVanDuinChakraborty_2003_CHNO__SM_107643900657_000\n\n\nEach OpenKIM IM has a dedicated “Model Page” on OpenKIM\nproviding all the information on the IM including a title, description,\nauthorship and citation information, test and verification check results,\nvisualizations of results, a wiki with documentation and user comments, and\naccess to raw files, and other information.\nThe URL for the Model Page is constructed from the\nextended KIM ID of the IM:\nhttps://openkim.org/id/extended_KIM_ID\n\n\nFor example, for the Stillinger–Weber potential\nlisted above the Model Page is located at:\nhttps://openkim.org/id/SW_StillingerWeber_1985_Si__MO_405512056662_005\nSee the current list of KIM PMs and SMs archived in OpenKIM.\nThis list is sorted by species and can be filtered to display only\nIMs for certain species combinations.\nSee Obtaining KIM Models to\nlearn how to install a pre-build binary of the OpenKIM Repository of Models.\n\nNote\nIt is also possible to locally install IMs not archived in OpenKIM,\nin which case their names do not have to conform to the KIM ID format.\n\n\n\nUsing OpenKIM IMs with LAMMPS\nTwo commands are employed when using OpenKIM IMs, one to select the\nIM and perform necessary initialization (kim_init), and the second\nto set up the IM for use by executing any necessary LAMMPS commands\n(kim_interactions). Both are required.\nSee the examples/kim directory for example input scripts that use KIM PMs\nand KIM SMs.\n\nOpenKIM IM Initialization (kim_init)\nThe kim_init mode command must be issued before\nthe simulation box is created (normally at the top of the file).\nThis command sets the OpenKIM IM that will be used and may issue\nadditional commands changing LAMMPS default settings that are required\nfor using the selected IM (such as units or\natom_style). If needed, those settings can be overridden,\nhowever, typically a script containing a kim_init command\nwould not include units and atom_style commands.\nThe required arguments of kim_init are the model name of the\nIM to be used in the simulation (for an IM archived in OpenKIM this is\nits extended KIM ID, and\nthe user_units, which are the LAMMPS units style used\nin the input script.  (Any dimensioned numerical values in the input\nscript and values read in from files are expected to be in the\nuser_units system.)\nThe selected IM can be either a KIM PM or a KIM SM.\nFor a KIM SM, the kim_init command verifies that the SM is designed\nto work with LAMMPS (and not another simulation code).\nIn addition, the LAMMPS version used for defining\nthe SM and the LAMMPS version being currently run are\nprinted to help diagnose any incompatible changes to input script or\ncommand syntax between the two LAMMPS versions.\nBased on the selected model kim_init may modify the\natom_style.\nSome SMs have requirements for this setting. If this is the case, then\natom_style will be set to the required style. Otherwise, the value is left\nunchanged (which in the absence of an atom_style command in the input script\nis the default atom_style value).\nRegarding units, the kim_init command behaves in different ways depending\non whether or not unit conversion mode is activated as indicated by the\noptional unitarg argument.\nIf unit conversion mode is not active, then user_units must\neither match the required units of the IM or the IM must be able\nto adjust its units to match. (The latter is only possible with some KIM PMs;\nSMs can never adjust their units.) If a match is possible, the LAMMPS\nunits command is called to set the units to\nuser_units. If the match fails, the simulation is terminated with\nan error.\nHere is an example of a LAMMPS script to compute the cohesive energy\nof a face-centered cubic (fcc) lattice for the Ercolessi and Adams (1994)\npotential for Al:\nkim_init         EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal\nboundary         p p p\nlattice          fcc 4.032\nregion           simbox block 0 1 0 1 0 1 units lattice\ncreate_box       1 simbox\ncreate_atoms     1 box\nmass             1 26.981539\nkim_interactions Al\nrun              0\nvariable         Ec equal (pe/count(all))/${_u_energy}\nprint            \"Cohesive Energy = ${EcJ} eV\"\n\n\nThe above script will end with an error in the kim_init line if the\nIM is changed to another potential for Al that does not work with metal\nunits. To address this kim_init offers the unit_conversion_mode\nas shown below.\nIf unit conversion mode is active, then kim_init calls the LAMMPS\nunits command to set the units to the IM’s required or\npreferred units. Conversion factors between the IM’s units and the user_units\nare defined for all physical quantities (mass, distance, etc.).\n(Note that converting to or from the “lj” unit style is not supported.)\nThese factors are stored as internal style variables with\nthe following standard names:\n_u_mass\n_u_distance\n_u_time\n_u_energy\n_u_velocity\n_u_force\n_u_torque\n_u_temperature\n_u_pressure\n_u_viscosity\n_u_charge\n_u_dipole\n_u_efield\n_u_density\n\n\nIf desired, the input script can be designed to work with these conversion\nfactors so that the script will work without change with any OpenKIM IM.\n(This approach is used in the\nOpenKIM Testing Framework.)\nFor example, the script given above for the cohesive energy of fcc Al\ncan be rewritten to work with any IM regardless of units. The following\nscript constructs an fcc lattice with a lattice parameter defined in\nmeters, computes the total energy, and prints the cohesive energy in\nJoules regardless of the units of the IM.\nkim_init         EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 si unit_conversion_mode\nboundary         p p p\nlattice          fcc 4.032e-10*${_u_distance}\nregion           simbox block 0 1 0 1 0 1 units lattice\ncreate_box       1 simbox\ncreate_atoms     1 box\nmass             1 4.480134e-26*${_u_mass}\nkim_interactions Al\nrun              0\nvariable         Ec_in_J equal (pe/count(all))/${_u_energy}\nprint            \"Cohesive Energy = ${Ec_in_J} J\"\n\n\nNote the multiplication by ${_u_distance} and ${_u_mass} to convert\nfrom SI units (specified in the kim_init command) to whatever units the\nIM uses (metal in this case), and the division by ${_u_energy}\nto convert from the IM’s energy units to SI units (Joule). This script\nwill work correctly for any IM for Al (KIM PM or SM) selected by the\nkim_init command.\nCare must be taken to apply unit conversion to dimensional variables read in\nfrom a file. For example, if a configuration of atoms is read in from a\ndump file using the read_dump command, the following can\nbe done to convert the box and all atomic positions to the correct units:\nvariable xyfinal equal xy*${_u_distance}\nvariable xzfinal equal xz*${_u_distance}\nvariable yzfinal equal yz*${_u_distance}\nchange_box all x scale ${_u_distance} &\n                       y scale ${_u_distance} &\n                       z scale ${_u_distance} &\n                       xy final ${xyfinal} &\n                       xz final ${xzfinal} &\n                       yz final ${yzfinal} &\n                       remap\n\n\n\nNote\nUnit conversion will only work if the conversion factors are placed in\nall appropriate places in the input script. It is up to the user to do this\ncorrectly.\n\n\n\nOpenKIM IM Execution (kim_interactions)\nThe second and final step in using an OpenKIM IM is to execute the\nkim_interactions command. This command must be preceded by a kim_init\ncommand and a command that defines the number of atom types N (such as\ncreate_box).\nThe kim_interactions command has one argument typeargs. This argument\ncontains either a list of N chemical species, which defines a mapping between\natom types in LAMMPS to the available species in the OpenKIM IM, or the\nkeyword fixed_types for models that have a preset fixed mapping (i.e.\nthe mapping between LAMMPS atom types and chemical species is defined by\nthe model and cannot be changed). In the latter case, the user must consult\nthe model documentation to see how many atom types there are and how they\nmap to the chemical species.\nFor example, consider an OpenKIM IM that supports Si and C species.\nIf the LAMMPS simulation has four atom types, where the first three are Si,\nand the fourth is C, the following kim_interactions command would be used:\nkim_interactions Si Si Si C\n\n\nAlternatively, for a model with a fixed mapping the command would be:\nkim_interactions fixed_types\n\n\nThe kim_interactions command performs all the necessary steps to set up\nthe OpenKIM IM selected in the kim_init command. The specific actions depend\non whether the IM is a KIM PM or a KIM SM.  For a KIM PM,\na pair_style kim command is executed followed by\nthe appropriate pair_coeff command. For example, for the\nErcolessi and Adams (1994) KIM PM for Al set by the following commands:\nkim_init EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal\n...\n...  box specification lines skipped\n...\nkim_interactions Al\n\n\nthe kim_interactions command executes the following LAMMPS input commands:\npair_style kim EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005\npair_coeff * * Al\n\n\nFor a KIM SM, the generated input commands may be more complex\nand require that LAMMPS is built with the required packages included\nfor the type of potential being used. The set of commands to be executed\nis defined in the SM specification file, which is part of the SM package.\nFor example, for the Strachan et al. (2003) ReaxFF SM\nset by the following commands:\nkim_init Sim_LAMMPS_ReaxFF_StrachanVanDuinChakraborty_2003_CHNO__SM_107643900657_000 real\n...\n...  box specification lines skipped\n...\nkim_interactions C H N O\n\n\nthe kim_interactions command executes the following LAMMPS input commands:\npair_style reax/c lmp_control safezone 2.0 mincap 100\npair_coeff * * ffield.reax.rdx C H N O\nfix reaxqeq all qeq/reax 1 0.0 10.0 1.0e-6 param.qeq\n\n\nNote that the files lmp_control, ffield.reax.rdx and param.qeq\nare specific to the Strachan et al. (2003) ReaxFF parameterization\nand are archived as part of the SM package in OpenKIM.\nNote also that parameters like cutoff radii and charge tolerances,\nwhich have an effect on IM predictions, are also included in the\nSM definition ensuring reproducibility.\n\nNote\nWhen using kim_init and kim_interactions to select\nand set up an OpenKIM IM, other LAMMPS commands\nfor the same functions (such as pair_style, pair_coeff, bond_style,\nbond_coeff, fixes related to charge equilibration, etc.) should normally\nnot appear in the input script.\n\n\n\nUsing OpenKIM Web Queries in LAMMPS (kim_query)\nThe kim_query command performs a web query to retrieve the predictions\nof an IM set by kim_init for material properties archived in\nOpenKIM.\n\nNote\nThe kim_query command must be preceded by a kim_init command.\n\nThe syntax for the kim_query command is as follows:\nkim_query variable formatarg query_function queryargs\n\n\nThe result of the query is stored in one or more\nstring style variables as determined by the\noptional formatarg argument documented above.\nFor the “list” setting of formatarg (or if formatarg is not\nspecified), the result is returned as a space-separated list of\nvalues in variable.\nThe formatarg keyword “split” separates the result values into\nindividual variables of the form prefix_I, where prefix is set to the\nkim_query variable argument and I ranges from 1 to the number of\nreturned values. The number and order of the returned values is determined\nby the type of query performed.  (Note that the “explicit” setting of\nformatarg is not supported by kim_query.)\n\nNote\nkim_query only supports queries that return a single result or\nan array of values. More complex queries that return a JSON structure\nare not currently supported. An attempt to use kim_query in such\ncases will generate an error.\n\nThe second required argument query_function is the name of the\nquery function to be called (e.g. get_lattice_constant_cubic).\nAll following arguments are parameters handed over to\nthe web query in the format keyword=value, where value is always\nan array of one or more comma-separated items in brackets.\nThe list of supported keywords and the type and format of their values\ndepend on the query function used. The current list of query functions\nis available on the OpenKIM webpage at\nhttps://openkim.org/doc/usage/kim-query.\n\nNote\nAll query functions require the model keyword, which identifies\nthe IM whose predictions are being queried. This keyword is automatically\ngenerated by kim_query based on the IM set in kim_init and must not\nbe specified as an argument to kim_query.\n\n\nNote\nEach query_function is associated with a default method (implemented\nas a KIM Test)\nused to compute this property. In cases where there are multiple\nmethods in OpenKIM for computing a property, a method keyword can\nbe provided to select the method of choice.  See the\nquery documentation\nto see which methods are available for a given query function.\n\n\n\nkim_query Usage Examples and Further Clarifications\nThe data obtained by kim_query commands can be used as part of the setup\nor analysis phases of LAMMPS simulations. Some examples are given below.\nDefine an equilibrium fcc crystal\nkim_init         EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal\nboundary         p p p\nkim_query        a0 get_lattice_constant_cubic crystal=[\"fcc\"] species=[\"Al\"] units=[\"angstrom\"]\nlattice          fcc ${a0}\n...\n\n\nThe kim_query command retrieves from OpenKIM\nthe equilibrium lattice constant predicted by the Ercolessi and Adams (1994)\npotential for the fcc structure and places it in\nvariable a0. This variable is then used on the next line to set up the\ncrystal. By using kim_query, the user is saved the trouble and possible\nerror of tracking this value down, or of having to perform an energy\nminimization to find the equilibrium lattice constant.\nNote that in unit_conversion_mode the results obtained from a\nkim_query would need to be converted to the appropriate units system.\nFor example, in the above script, the lattice command would need to be\nchanged to: “lattice fcc ${a0}*${_u_distance}”.\nDefine an equilibrium hcp crystal\nkim_init         EAM_Dynamo_Mendelev_2007_Zr__MO_848899341753_000 metal\nboundary         p p p\nkim_query        latconst split get_lattice_constant_hexagonal crystal=[\"hcp\"] species=[\"Zr\"] units=[\"angstrom\"]\nvariable         a0 equal latconst_1\nvariable         c0 equal latconst_2\nvariable         c_to_a equal ${c0}/${a0}\nlattice          custom ${a0} a1 0.5 -0.866025 0 a2 0.5 0.866025 0 a3 0 0 ${c_to_a} &\n                 basis 0.333333 0.666666 0.25 basis 0.666666 0.333333 0.75\n...\n\n\nIn this case the kim_query returns two arguments (since the hexagonal\nclose packed (hcp) structure has two independent lattice constants).\nThe formatarg keyword “split” places the two values into\nthe variables latconst_1 and latconst_2. (These variables are\ncreated if they do not already exist.) For convenience the variables\na0 and c0 are created in order to make the remainder of the\ninput script more readable.\nDefine a crystal at finite temperature accounting for thermal expansion\nkim_init         EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal\nboundary         p p p\nkim_query        a0 get_lattice_constant_cubic crystal=[\"fcc\"] species=[\"Al\"] units=[\"angstrom\"]\nkim_query        alpha get_linear_thermal_expansion_coefficient_cubic  crystal=[\"fcc\"] species=[\"Al\"] units=[\"1/K\"] temperature=[293.15] temperature_units=[\"K\"]\nvariable         DeltaT equal 300\nlattice          fcc ${a0}*${alpha}*${DeltaT}\n...\n\n\nAs in the previous example, the equilibrium lattice constant is obtained\nfor the Ercolessi and Adams (1994) potential. However, in this case the\ncrystal is scaled to the appropriate lattice constant at room temperature\n(293.15 K) by using the linear thermal expansion constant predicted by the\npotential.\n\nNote\nWhen passing numerical values as arguments (as in the case\nof the temperature in the above example) it is also possible to pass a\ntolerance indicating how close to the value is considered a match.\nIf no tolerance is passed a default value is used. If multiple results\nare returned (indicating that the tolerance is too large), kim_query\nwill return an error. See the\nquery documentation\nto see which numerical arguments and tolerances are available for a\ngiven query function.\n\nCompute defect formation energy\nkim_init         EAM_Dynamo_ErcolessiAdams_1994_Al__MO_123629422045_005 metal\n...\n... Build fcc crystal containing some defect and compute the total energy\n... which is stored in the variable *Etot*\n...\nkim_query        Ec get_cohesive_energy_cubic crystal=[\"fcc\"] species=[\"Al\"] units=[\"eV\"]\nvariable         Eform equal ${Etot} - count(all)*${Ec}\n...\n\n\nThe defect formation energy Eform is computed by subtracting from Etot the\nideal fcc cohesive energy of the atoms in the system obtained from\nOpenKIM for the Ercolessi and Adams (1994) potential.\n\nNote\nkim_query commands return results archived in\nOpenKIM. These results are obtained\nusing programs for computing material properties\n(KIM Tests and KIM Test Drivers) that were contributed to OpenKIM.\nIn order to give credit to Test developers, the number of times results\nfrom these programs are queried is tracked. No other information about\nthe nature of the query or its source is recorded.\n\n\n\nAccessing KIM Model Parameters from LAMMPS (kim_param)\nAll IMs are functional forms containing a set of\nparameters.  The values of these parameters are typically\nselected to best reproduce a training set of quantum mechanical\ncalculations or available experimental data.  For example, a\nLennard-Jones potential intended to model argon might have the values of\nits two parameters, epsilon and sigma, fit to the\ndimer dissociation energy or thermodynamic properties at a critical point\nof the phase diagram.\nNormally a user employing an IM should not modify its parameters since,\nas noted above, these are selected to reproduce material properties.\nHowever, there are cases where accessing and modifying IM parameters\nis desired, such as for assessing uncertainty, fitting an IM,\nor working with an ensemble of IMs. As explained above,\nIMs archived in OpenKIM are either Portable Models (PMs) or\nSimulator Models (SMs). KIM PMs are complete independent implementations\nof an IM, whereas KIM SMs are wrappers to an IM implemented within LAMMPS.\nTwo different mechanisms are provided for accessing IM parameters in these\ntwo cases:\n\nFor a KIM PM, the kim_param command can be used to get and set the values of the PM’s parameters as explained below.\nFor a KIM SM, the user should consult the documentation page for the specific IM and follow instructions there for how to modify its parameters (if possible).\n\nThe kim_param get and kim_param set commands provide an interface\nto access and change the parameters of a KIM PM that “publishes” its\nparameters and makes them publicly available (see the\nKIM API documentation\nfor details).\n\nNote\nThe kim_param get/set commands must be preceded by kim_init.\nThe kim_param set command must additionally be preceded by a\nkim_interactions command (or alternatively by a pair_style kim\nand pair_coeff commands).  The kim_param set command may be used wherever a pair_coeff command may occur.\n\nThe syntax for the kim_param command is as follows:\nkim_param get param_name index_range variable formatarg\nkim_param set param_name index_range values\n\n\nHere, param_name is the name of a KIM PM parameter (which is published\nby the PM and available for access). The specific string used to identify\na parameter is defined by the PM. For example, for the\nStillinger–Weber (SW) potential in OpenKIM,\nthe parameter names are A, B, p, q, sigma, gamma, cutoff, lambda, costheta0.\n\nNote\nThe list of all the parameters that a PM exposes for access/mutation are\nautomatically written to the lammps log file when kim_init is called.\n\nEach published parameter of a KIM PM takes the form of an array of\nnumerical values. The array can contain one element for a single-valued\nparameter, or a set of values. For example, the\nmultispecies SW potential for the Zn-Cd-Hg-S-Se-Te system\nhas the same parameter names as the\nsingle-species SW potential,\nbut each parameter array contains 21 entries that correspond to the parameter\nvalues used for each pairwise combination of the model’s six supported species\n(this model does not have parameters specific to individual ternary\ncombinations of its supported species).\nThe index_range argument may either be an integer referring to\na specific element within the array associated with the parameter\nspecified by param_name, or a pair of integers separated by a colon\nthat refer to a slice of this array.  In both cases, one-based indexing is\nused to refer to the entries of the array.\nThe result of a get operation for a specific index_range is stored in\none or more LAMMPS string style variables as determined\nby the optional formatarg argument documented above.\nIf not specified, the default for formatarg is “explicit” for the\nkim_param command.\nFor the case where the result is an array with multiple values\n(i.e. index_range contains a range), the optional “split” or “explicit”\nformatarg keywords can be used to separate the results into multiple\nvariables; see the examples below.\nMultiple parameters can be retrieved with a single call to kim_param get\nby repeating the argument list following get.\nFor a set operation, the values argument contains the new value(s)\nfor the element(s) of the parameter specified by index_range. For the case\nwhere multiple values are being set, values contains a set of values\nseparated by spaces. Multiple parameters can be set with a single call to\nkim_param set by repeating the argument list following set.\n\n\nkim_param Usage Examples and Further Clarifications\nExamples of getting and setting KIM PM parameters with further\nclarifications are provided below.\nGetting a scalar parameter\nkim_init         SW_StillingerWeber_1985_Si__MO_405512056662_005 metal\n...\nkim_param        get A 1 VARA\n\n\nIn this case, the value of the SW A parameter is retrieved and placed\nin the LAMMPS variable VARA. The variable VARA can be used\nin the remainder of the input script in the same manner as any other\nLAMMPS variable.\nGetting multiple scalar parameters with a single call\nkim_init         SW_StillingerWeber_1985_Si__MO_405512056662_005 metal\n...\nkim_param        get A 1 VARA B 1 VARB\n\n\nThis retrieves the A and B parameters of the SW potential and stores\nthem in the LAMMPS variables VARA and VARB.\nGetting a range of values from a parameter\nThere are several options when getting a range of values from a parameter\ndetermined by the formatarg argument.\nkim_init         SW_ZhouWardMartin_2013_CdTeZnSeHgS__MO_503261197030_002 metal\n...\nkim_param        get lambda 7:9 LAM_TeTe LAM_TeZn LAM_TeSe\n\n\nIn this case, formatarg is not specified and therefore the default\n“explicit” mode is used. (The behavior would be the same if the word\nexplicit were added after LAM_TeSe.) Elements 7, 8 and 9 of parameter\nlambda retrieved by the get operation are placed in the LAMMPS variables\nLAM_TeTe, LAM_TeZn and LAM_TeSe, respectively.\n\nNote\nIn the above example, elements 7–9 of the lambda parameter correspond\nto Te-Te, Te-Zm and Te-Se interactions. This can be determined by visiting\nthe model page for the specified potential\nand looking at its parameter file linked to at the bottom of the page\n(file with .param ending) and consulting the README documentation\nprovided with the driver for the PM being used. A link to the driver\nis provided at the top of the model page.\n\nkim_init         SW_ZhouWardMartin_2013_CdTeZnSeHgS__MO_503261197030_002 metal\n...\nkim_param        get lambda 15:17 LAMS list\nvariable         LAM_VALUE index ${LAMS}\nlabel            loop_on_lambda\n...\n... do something with current value of lambda\n...\nnext             LAM_VALUE\njump             SELF loop_on_lambda\n\n\nIn this case, the “list” mode of formatarg is used.\nThe result of the get operation is stored in the LAMMPS variable\nLAMS as a string containing the three retrieved values separated\nby spaces, e.g “1.0 2.0 3.0”. This can be used in LAMMPS with an\nindex variable to access the values one at a time within a loop\nas shown in the example. At each iteration of the loop LAM_VALUE\ncontains the current value of lambda.\nkim_init         SW_ZhouWardMartin_2013_CdTeZnSeHgS__MO_503261197030_002 metal\n...\nkim_param        get lambda 15:17 LAM split\n\n\nIn this case, the “split” mode of formatarg is used.\nThe three values retrieved by the get operation are stored in\nthe three LAMMPS variables LAM_15, LAM_16 and LAM_17.\nThe provided name “LAM” is used as prefix and the location in\nthe lambda array is appended to create the variable names.\nSetting a scalar parameter\nkim_init         SW_StillingerWeber_1985_Si__MO_405512056662_005 metal\n...\nkim_interactions Si\nkim_param        set gamma 1 2.6\n\n\nHere, the SW potential’s gamma parameter is set to 2.6.  Note that the get\nand set commands work together, so that a get following a set\noperation will return the new value that was set. For example:\n...\nkim_interactions Si\nkim_param        get gamma 1 ORIG_GAMMA\nkim_param        set gamma 1 2.6\nkim_param        get gamma 1 NEW_GAMMA\n...\nprint            \"original gamma = ${ORIG_GAMMA}, new gamma = ${NEW_GAMMA}\"\n\n\nHere, ORIG_GAMMA will contain the original gamma value for the SW\npotential, while NEW_GAMMA will contain the value 2.6.\nSetting multiple scalar parameters with a single call\nkim_init         SW_ZhouWardMartin_2013_CdTeZnSeHgS__MO_503261197030_002 metal\n...\nkim_interactions Cd Te\nvariable        VARG equal 2.6\nvariable        VARS equal 2.0951\nkim_param       set gamma 1 ${VARG} sigma 3 ${VARS}\n\n\nIn this case, the first element of the gamma parameter and\nthird element of the sigma parameter are set to 2.6 and 2.0951,\nrespectively. This example also shows how LAMMPS variables can\nbe used when setting parameters.\nSetting a range of values of a parameter\nkim_init         SW_ZhouWardMartin_2013_CdTeZnSeHgS__MO_503261197030_002 metal\n...\nkim_interactions Cd Te Zn Se Hg S\nkim_param        set sigma 2:6 2.35214 2.23869 2.04516 2.43269 1.80415\n\n\nIn this case, elements 2 through 6 of the parameter sigma\nare set to the values 2.35214, 2.23869, 2.04516, 2.43269 and 1.80415 in\norder.\n\n\n\nCitation of OpenKIM IMs\nWhen publishing results obtained using OpenKIM IMs researchers are requested\nto cite the OpenKIM project (Tadmor), KIM API\n(Elliott), and the specific IM codes used in the simulations,\nin addition to the relevant scientific references for the IM.\nThe citation format for an IM is displayed on its page on\nOpenKIM along with the corresponding BibTex file,\nand is automatically added to the LAMMPS log.cite file.\nCiting the IM software (KIM infrastructure and specific PM or SM codes)\nused in the simulation gives credit to the researchers who developed them\nand enables open source efforts like OpenKIM to function.",
    "syntax": "kim_init model user_units unitarg",
    "parameters": " * kim_interactions typeargs\n * kim_query variable formatarg query_function queryargs\n * kim_param get param_name index_range variables formatarg\n * kim_param set param_name index_range values\n * model = name of the KIM interatomic model (the KIM ID for models archived in OpenKIM)\n * user_units = the LAMMPS units style assumed in the LAMMPS input script\n * unitarg = unit_conversion_mode (optional)\n * typeargs = atom type to species mapping (one entry per atom type) or fixed_types for models with a preset fixed mapping\n * variable(s) = single name or list of names of (string style) LAMMPS variable(s) where a query result or parameter get result is stored. Variables that do not exist will be created by the command.\n * formatarg = list, split, or explicit (optional):\n * list = returns a single string with a list of space separated values\n *        (e.g. \"1.0 2.0 3.0\"), which is placed in a LAMMPS variable as\n *        defined by the variable argument. [default for kim_query]\n * split = returns the values separately in new variables with names based\n *        on the prefix specified in variable and a number appended to\n *        indicate which element in the list of values is in the variable.\n * explicit = returns the values separately in one more more variable names\n *        provided as arguments that preceed formatarg. [default for kim_param]\n * query_function = name of the OpenKIM web API query function to be used\n * queryargs = a series of keyword=value pairs that represent the web query; supported keywords depend on the query function\n * param_name = name of a KIM portable model parameter\n * index_range = KIM portable model parameter index range (an integer for a single element, or pair of integers separated by a colon for a range of elements)\n * values = new value(s) to replace the current value(s) of a KIM portable model parameter",
    "examples": "kim_init SW_StillingerWeber_1985_Si__MO_405512056662_005 metal\nkim_interactions Si\nkim_init Sim_LAMMPS_ReaxFF_StrachanVanDuinChakraborty_2003_CHNO__SM_107643900657_000 real\nkim_init Sim_LAMMPS_ReaxFF_StrachanVanDuinChakraborty_2003_CHNO__SM_107643900657_000 metal unit_conversion_mode\nkim_interactions C H O\nkim_init Sim_LAMMPS_IFF_PCFF_HeinzMishraLinEmami_2015Ver1v5_FccmetalsMineralsSolventsPolymers__SM_039297821658_000 real\nkim_interactions fixed_types\nkim_query a0 get_lattice_constant_cubic crystal=[\"fcc\"] species=[\"Al\"] units=[\"angstrom\"]\nkim_param get gamma 1 varGamma\nkim_param set gamma 1 3.0",
    "restrictions": "The set of kim_commands is part of the KIM package.  It is only enabled if\nLAMMPS is built with that package. A requirement for the KIM package,\nis the KIM API library that must be downloaded from the\nOpenKIM website and installed before\nLAMMPS is compiled. When installing LAMMPS from binary, the kim-api package\nis a dependency that is automatically downloaded and installed. See the KIM\nsection of the Packages details for details.\nFurthermore, when using kim_commands to run KIM SMs, any packages required\nby the native potential being used or other commands or fixes that it invokes\nmust be installed."
},
{
    "command": "kspace_modify",
    "html_filename": "kspace_modify.html",
    "short_description": "Set parameters used by the kspace solvers defined by the kspace_style command",
    "description": "Set parameters used by the kspace solvers defined by the\nkspace_style command.  Not all parameters are\nrelevant to all kspace styles.\n\nThe collective keyword applies only to PPPM.  It is set to no by\ndefault, except on IBM BlueGene machines.  If this option is set to\nyes, LAMMPS will use MPI collective operations to remap data for\n3d-FFT operations instead of the default point-to-point communication.\nThis is faster on IBM BlueGene machines, and may also be faster on\nother machines if they have an efficient implementation of MPI\ncollective operations and adequate hardware.\n\nThe compute keyword allows Kspace computations to be turned off,\neven though a kspace_style is defined.  This is\nnot useful for running a real simulation, but can be useful for\ndebugging purposes or for computing only partial forces that do not\ninclude the Kspace contribution.  You can also do this by simply not\ndefining a kspace_style, but a Kspace-compatible\npair_style requires a kspace style to be defined.\nThis keyword gives you that option.\n\nThe cutoff/adjust keyword applies only to MSM. If this option is\nturned on, the Coulombic cutoff will be automatically adjusted at the\nbeginning of the run to give the desired estimated error. Other\ncutoffs such as LJ will not be affected. If the grid is not set using\nthe mesh command, this command will also attempt to use the optimal\ngrid that minimizes cost using an estimate given by\n(Hardy). Note that this cost estimate is not exact, somewhat\nexperimental, and still may not yield the optimal parameters.\n\nThe diff keyword specifies the differentiation scheme used by the\nPPPM method to compute forces on particles given electrostatic\npotentials on the PPPM mesh.  The ik approach is the default for\nPPPM and is the original formulation used in (Hockney).  It\nperforms differentiation in Kspace, and uses 3 FFTs to transfer each\ncomponent of the computed fields back to real space for total of 4\nFFTs per timestep.\nThe analytic differentiation ad approach uses only 1 FFT to transfer\ninformation back to real space for a total of 2 FFTs per timestep.  It\nthen performs analytic differentiation on the single quantity to\ngenerate the 3 components of the electric field at each grid point.\nThis is sometimes referred to as “smoothed” PPPM.  This approach\nrequires a somewhat larger PPPM mesh to achieve the same accuracy as\nthe ik method. Currently, only the ik method (default) can be\nused for a triclinic simulation cell with PPPM. The ad method is\nalways used for MSM.\n\nNote\nCurrently, not all PPPM styles support the ad option.  Support\nfor those PPPM variants will be added later.\n\n\nThe disp/auto option controls whether the pppm/disp is allowed to\ngenerate PPPM parameters automatically. If set to no, parameters have\nto be specified using the gewald/disp, mesh/disp,\nforce/disp/real or force/disp/kspace keywords, or\nthe code will stop with an error message. When this option is set to\nyes, the error message will not appear and the simulation will start.\nFor a typical application, using the automatic parameter generation\nwill provide simulations that are either inaccurate or slow. Using this\noption is thus not recommended. For guidelines on how to obtain good\nparameters, see the How-To discussion.\n\nThe fftbench keyword applies only to PPPM. It is off by default. If\nthis option is turned on, LAMMPS will perform a short FFT benchmark\ncomputation and report its timings, and will thus finish a some seconds\nlater than it would if this option were off.\n\nThe force/disp/real and force/disp/kspace keywords set the force\naccuracy for the real and space computations for the dispersion part\nof pppm/disp. As shown in (Isele-Holder), optimal\nperformance and accuracy in the results is obtained when these values\nare different.\n\nThe force keyword overrides the relative accuracy parameter set by\nthe kspace_style command with an absolute\naccuracy.  The accuracy determines the RMS error in per-atom forces\ncalculated by the long-range solver and is thus specified in force\nunits.  A negative value for the accuracy setting means to use the\nrelative accuracy parameter.  The accuracy setting is used in\nconjunction with the pairwise cutoff to determine the number of\nK-space vectors for style ewald, the FFT grid size for style\npppm, or the real space grid size for style msm.\n\nThe gewald keyword sets the value of the Ewald or PPPM G-ewald\nparameter for charge as rinv in reciprocal distance units.  Without\nthis setting, LAMMPS chooses the parameter automatically as a function\nof cutoff, precision, grid spacing, etc.  This means it can vary from\none simulation to the next which may not be desirable for matching a\nKSpace solver to a pre-tabulated pairwise potential.  This setting can\nalso be useful if Ewald or PPPM fails to choose a good grid spacing\nand G-ewald parameter automatically.  If the value is set to 0.0,\nLAMMPS will choose the G-ewald parameter automatically.  MSM does not\nuse the gewald parameter.\n\nThe gewald/disp keyword sets the value of the Ewald or PPPM G-ewald\nparameter for dispersion as rinv in reciprocal distance units.  It\nhas the same meaning as the gewald setting for Coulombics.\n\nThe kmax/ewald keyword sets the number of kspace vectors in each\ndimension for kspace style ewald.  The three values must be positive\nintegers, or else (0,0,0), which unsets the option.  When this option\nis not set, the Ewald sum scheme chooses its own kspace vectors,\nconsistent with the user-specified accuracy and pairwise cutoff. In\nany case, if kspace style ewald is invoked, the values used are\nprinted to the screen and the log file at the start of the run.\n\nThe mesh keyword sets the grid size for kspace style pppm or\nmsm.  In the case of PPPM, this is the FFT mesh, and each dimension\nmust be factorizable into powers of 2, 3, and 5.  In the case of MSM,\nthis is the finest scale real-space mesh, and each dimension must be\nfactorizable into powers of 2.  When this option is not set, the PPPM\nor MSM solver chooses its own grid size, consistent with the\nuser-specified accuracy and pairwise cutoff.  Values for x,y,z of\n0,0,0 unset the option.\n\nThe mesh/disp keyword sets the grid size for kspace style\npppm/disp.  This is the FFT mesh for long-range dispersion and ach\ndimension must be factorizable into powers of 2, 3, and 5.  When this\noption is not set, the PPPM solver chooses its own grid size,\nconsistent with the user-specified accuracy and pairwise cutoff.\nValues for x,y,z of 0,0,0 unset the option.\n\nThe minorder keyword allows LAMMPS to reduce the order setting if\nnecessary to keep the communication of ghost grid point limited to\nexchanges between nearest-neighbor processors.  See the discussion of\nthe overlap keyword for details.  If the overlap keyword is set to\nyes, which is the default, this is never needed.  If it set to no\nand overlap occurs, then LAMMPS will reduce the order setting, one\nstep at a time, until the ghost grid overlap only extends to nearest\nneighbor processors.  The minorder keyword limits how small the\norder setting can become.  The minimum allowed value for PPPM is 2,\nwhich is the default.  If minorder is set to the same value as\norder then no reduction is allowed, and LAMMPS will generate an\nerror if the grid communication is non-nearest-neighbor and overlap\nis set to no. The minorder keyword is not currently supported in\nMSM.\n\nThe mix/disp keyword selects the mixing rule for the dispersion\ncoefficients.  With pair, the dispersion coefficients of unlike\ntypes are computed as indicated with pair_modify.\nWith geom, geometric mixing is enforced on the dispersion\ncoefficients in the kspace coefficients. When using the arithmetic\nmixing rule, this will speed-up the simulations but introduces some\nerror in the force computations, as shown in (Wennberg).\nWith none, it is assumed that no mixing rule is\napplicable. Splitting of the dispersion coefficients will be performed\nas described in (Isele-Holder).\nThis splitting can be influenced with the splittol keywords.  Only\nthe eigenvalues that are larger than tol compared to the largest\neigenvalues are included. Using this keywords the original matrix of\ndispersion coefficients is approximated. This leads to faster\ncomputations, but the accuracy in the reciprocal space computations of\nthe dispersion part is decreased.\n\nThe order keyword determines how many grid spacings an atom’s charge\nextends when it is mapped to the grid in kspace style pppm or msm.\nThe default for this parameter is 5 for PPPM and 8 for MSM, which\nmeans each charge spans 5 or 8 grid cells in each dimension,\nrespectively.  For the LAMMPS implementation of MSM, the order can\nrange from 4 to 10 and must be even. For PPPM, the minimum allowed\nsetting is 2 and the maximum allowed setting is 7.  The larger the\nvalue of this parameter, the smaller that LAMMPS will set the grid\nsize, to achieve the requested accuracy.  Conversely, the smaller the\norder value, the larger the grid size will be.  Note that there is an\ninherent trade-off involved: a small grid will lower the cost of FFTs\nor MSM direct sum, but a larger order parameter will increase the cost\nof interpolating charge/fields to/from the grid.\nThe PPPM order parameter may be reset by LAMMPS when it sets up the\nFFT grid if the implied grid stencil extends beyond the grid cells\nowned by neighboring processors.  Typically this will only occur when\nsmall problems are run on large numbers of processors.  A warning will\nbe generated indicating the order parameter is being reduced to allow\nLAMMPS to run the problem. Automatic adjustment of the order parameter\nis not supported in MSM.\n\nThe order/disp keyword determines how many grid spacings an atom’s\ndispersion term extends when it is mapped to the grid in kspace style\npppm/disp.  It has the same meaning as the order setting for\nCoulombics.\n\nThe overlap keyword can be used in conjunction with the minorder\nkeyword with the PPPM styles to adjust the amount of communication\nthat occurs when values on the FFT grid are exchanged between\nprocessors.  This communication is distinct from the communication\ninherent in the parallel FFTs themselves, and is required because\nprocessors interpolate charge and field values using grid point values\nowned by neighboring processors (i.e. ghost point communication).  If\nthe overlap keyword is set to yes then this communication is\nallowed to extend beyond nearest-neighbor processors, e.g. when using\nlots of processors on a small problem.  If it is set to no then the\ncommunication will be limited to nearest-neighbor processors and the\norder setting will be reduced if necessary, as explained by the\nminorder keyword discussion. The overlap keyword is always set to\nyes in MSM.\n\nThe pressure/scalar keyword applies only to MSM. If this option is\nturned on, only the scalar pressure (i.e. (Pxx + Pyy + Pzz)/3.0) will\nbe computed, which can be used, for example, to run an isotropic barostat.\nComputing the full pressure tensor with MSM is expensive, and this option\nprovides a faster alternative. The scalar pressure is computed using a\nrelationship between the Coulombic energy and pressure (Hummer)\ninstead of using the virial equation. This option cannot be used to access\nindividual components of the pressure tensor, to compute per-atom virial,\nor with suffix kspace/pair styles of MSM, like OMP or GPU.\n\nThe scafacos keyword is used for settings that are passed to the\nScaFaCoS library when using kspace_style scafacos.\nThe tolerance option affects how the accuracy specified with the\nkspace_style command is interpreted by ScaFaCoS.\nThe following values may be used:\n\nenergy = absolute accuracy in total Coulombic energy\nenergy_rel = relative accuracy in total Coulombic energy\npotential = absolute accuracy in total Coulombic potential\npotential_rel = relative accuracy in total Coulombic potential\nfield = absolute accuracy in electric field\nfield_rel = relative accuracy in electric field\n\nThe values with suffix _rel indicate the tolerance is a relative\ntolerance; the other values impose an absolute tolerance on the given\nquantity. Absolute tolerance in this case means, that for a given\nquantity q and a given absolute tolerance of t_a the result should\nbe between q-t_a and q+t_a. For a relative tolerance t_r the relative\nerror should not be greater than t_r, i.e. abs(1 - (result/q)) < t_r.\nAs a consequence of this, the tolerance type should be checked, when\nperforming computations with a high absolute field / energy. E.g.\nif the total energy in the system is 1000000.0 an absolute tolerance\nof 1e-3 would mean that the result has to be between 999999.999 and\n1000000.001, which would be equivalent to a relative tolerance of\n1e-9.\nThe energy and energy_rel values, set a tolerance based on the total\nCoulombic energy of the system.  The potential and potential_rel set a\ntolerance based on the per-atom Coulombic energy.  The field and\nfield_rel tolerance types set a tolerance based on the electric field\nvalues computed by ScaFaCoS.  Since per-atom forces are derived from\nthe per-atom electric field, this effectively sets a tolerance on the\nforces, similar to other LAMMPS KSpace styles, as explained on the\nkspace_style doc page.\nNote that not all ScaFaCoS solvers support all tolerance types.\nThese are the allowed values for each method:\n\nfmm = energy and energy_rel\np2nfft = field (1d-,2d-,3d-periodic systems) or potential (0d-periodic)\np3m = field\newald = field\ndirect = has no tolerance tuning\n\nIf the tolerance type is not changed, the default values for the\ntolerance type are the first values in the above list, e.g. energy\nis the default tolerance type for the fmm solver.\nThe fmm_tuning option is only relevant when using the FMM method.\nIt activates (value=1) or deactivates (value=0) an internal tuning\nmechanism for the FMM solver.  The tuning operation runs sequentially\nand can be very time-consuming.  Usually it is not needed for systems\nwith a homogeneous charge distribution. The default for this option is\ntherefore 0. The FMM internal tuning is performed once, when the\nsolver is set up.\n\nThe slab keyword allows an Ewald or PPPM solver to be used for a\nsystems that are periodic in x,y but non-periodic in z - a\nboundary setting of “boundary p p f”.  This is done by\ntreating the system as if it were periodic in z, but inserting empty\nvolume between atom slabs and removing dipole inter-slab interactions\nso that slab-slab interactions are effectively turned off.  The\nvolfactor value sets the ratio of the extended dimension in z divided\nby the actual dimension in z.  The recommended value is 3.0.  A larger\nvalue is inefficient; a smaller value introduces unwanted slab-slab\ninteractions.  The use of fixed boundaries in z means that the user\nmust prevent particle migration beyond the initial z-bounds, typically\nby providing a wall-style fix.  The methodology behind the slab\noption is explained in the paper by (Yeh).  The slab option\nis also extended to non-neutral systems (Ballenegger).\nAn alternative slab option can be invoked with the nozforce keyword\nin lieu of the volfactor.  This turns off all kspace forces in the z\ndirection.  The nozforce option is not supported by MSM. For MSM,\nany combination of periodic, non-periodic, or shrink-wrapped\nboundaries can be set using boundary (the slab\napproximation in not needed).  The slab keyword is not currently\nsupported by Ewald or PPPM when using a triclinic simulation cell. The\nslab correction has also been extended to point dipole interactions\n(Klapp) in kspace_style ewald/disp,\newald/dipole, and pppm/dipole.\n\nNote\nIf you wish to apply an electric field in the Z-direction, in\nconjunction with the slab keyword, you should do it by adding\nexplicit charged particles to the +/- Z surfaces.  If you do it via\nthe fix efield command, it will not give the correct\ndielectric constant due to the Yeh/Berkowitz (Yeh) correction\nnot being compatible with how fix efield works.\n\n\nThe force/disp/real and force/disp/kspace keywords set the force\naccuracy for the real and space computations for the dispersion part\nof pppm/disp. As shown in (Isele-Holder), optimal\nperformance and accuracy in the results is obtained when these values\nare different.\nThe disp/auto option controls whether the pppm/disp is allowed to\ngenerate PPPM parameters automatically. If set to no, parameters\nhave to be specified using the gewald/disp, mesh/disp,\nforce/disp/real or force/disp/kspace keywords, or the code will\nstop with an error message. When this option is set to yes, the\nerror message will not appear and the simulation will start.  For a\ntypical application, using the automatic parameter generation will\nprovide simulations that are either inaccurate or slow. Using this\noption is thus not recommended.  For guidelines on how to obtain good\nparameters, see the Howto dispersion doc page.",
    "syntax": "kspace_modify keyword value ...",
    "parameters": " * one or more keyword/value pairs may be listed\n * keyword = collective or compute or cutoff/adjust or diff or disp/auto or fftbench or force/disp/kspace or force/disp/real or force or gewald/disp or gewald or kmax/ewald or mesh or minorder or mix/disp or order/disp or order or overlap or scafacos or slab or splittol\n * collective value = yes or no\n * compute value = yes or no\n * cutoff/adjust value = yes or no\n * diff value = ad or ik = 2 or 4 FFTs for PPPM in smoothed or non-smoothed mode\n * disp/auto value = yes or no\n * fftbench value = yes or no\n * force/disp/real value = accuracy (force units)\n * force/disp/kspace value = accuracy (force units)\n * force value = accuracy (force units)\n * gewald value = rinv (1/distance units)\n *   rinv = G-ewald parameter for Coulombics\n * gewald/disp value = rinv (1/distance units)\n *   rinv = G-ewald parameter for dispersion\n * kmax/ewald value = kx ky kz\n *   kx,ky,kz = number of Ewald sum kspace vectors in each dimension\n * mesh value = x y z\n *   x,y,z = grid size in each dimension for long-range Coulombics\n * mesh/disp value = x y z\n *   x,y,z = grid size in each dimension for 1/r^6 dispersion\n * minorder value = M\n *   M = min allowed extent of Gaussian when auto-adjusting to minimize grid communication\n * mix/disp value = pair or geom or none\n * order value = N\n *   N = extent of Gaussian for PPPM or MSM mapping of charge to grid\n * order/disp value = N\n *   N = extent of Gaussian for PPPM mapping of dispersion term to grid\n * overlap = yes or no = whether the grid stencil for PPPM is allowed to overlap into more than the nearest-neighbor processor\n * pressure/scalar value = yes or no\n * scafacos values = option value1 value2 ...\n *   option = tolerance\n *     value = energy or energy_rel or field or field_rel or potential or potential_rel\n *   option = fmm_tuning\n *     value = 0 or 1\n * slab value = volfactor or nozforce\n *   volfactor = ratio of the total extended volume used in the\n *     2d approximation compared with the volume of the simulation domain\n *   nozforce turns off kspace forces in the z direction\n * splittol value = tol\n *   tol = relative size of two eigenvalues (see discussion below)",
    "examples": "kspace_modify mesh 24 24 30 order 6\nkspace_modify slab 3.0\nkspace_modify scafacos tolerance energy",
    "restrictions": "none"
},
{
    "command": "kspace_style",
    "html_filename": "kspace_style.html",
    "short_description": "Define a long-range solver for LAMMPS to use each timestep to compute long-range Coulombic interactions or long-range \\(1/r^6\\) interactions",
    "description": "Define a long-range solver for LAMMPS to use each timestep to compute\nlong-range Coulombic interactions or long-range \\(1/r^6\\) interactions.\nMost of the long-range solvers perform their computation in K-space,\nhence the name of this command.\nWhen such a solver is used in conjunction with an appropriate pair\nstyle, the cutoff for Coulombic or \\(1/r^N\\) interactions is effectively\ninfinite.  If the Coulombic case, this means each charge in the system\ninteracts with charges in an infinite array of periodic images of the\nsimulation domain.\nNote that using a long-range solver requires use of a matching pair style to perform consistent short-range pairwise\ncalculations.  This means that the name of the pair style contains a\nmatching keyword to the name of the KSpace style, as in this table:\n\n\n\n\n\n\nPair style\nKSpace style\n\ncoul/long\newald or pppm\n\ncoul/msm\nmsm\n\nlj/long or buck/long\ndisp (for dispersion)\n\ntip4p/long\ntip4p\n\n\n\n\nThe ewald style performs a standard Ewald summation as described in\nany solid-state physics text.\nThe ewald/disp style adds a long-range dispersion sum option for\n\\(1/r^6\\) potentials and is useful for simulation of interfaces\n(Veld).  It also performs standard Coulombic Ewald summations,\nbut in a more efficient manner than the ewald style.  The \\(1/r^6\\)\ncapability means that Lennard-Jones or Buckingham potentials can be\nused without a cutoff, i.e. they become full long-range potentials.\nThe ewald/disp style can also be used with point-dipoles, see\n(Toukmaji).\nThe ewald/dipole style adds long-range standard Ewald summations\nfor dipole-dipole interactions, see (Toukmaji).\nThe ewald/dipole/spin style adds long-range standard Ewald\nsummations for magnetic dipole-dipole interactions between\nmagnetic spins.\n\nThe pppm style invokes a particle-particle particle-mesh solver\n(Hockney) which maps atom charge to a 3d mesh, uses 3d FFTs\nto solve Poisson’s equation on the mesh, then interpolates electric\nfields on the mesh points back to the atoms.  It is closely related to\nthe particle-mesh Ewald technique (PME) (Darden) used in\nAMBER and CHARMM.  The cost of traditional Ewald summation scales as\n\\(N^{\\frac{3}{2}}\\) where \\(N\\) is the number of atoms in the system.  The PPPM solver\nscales as \\(N \\log{N}\\) due to the FFTs, so it is almost always a faster\nchoice (Pollock).\nThe pppm/cg style is identical to the pppm style except that it\nhas an optimization for systems where most particles are uncharged.\nSimilarly the msm/cg style implements the same optimization for msm.\nThe optional smallq argument defines the cutoff for the absolute\ncharge value which determines whether a particle is considered charged\nor not.  Its default value is 1.0e-5.\nThe pppm/dipole style invokes a particle-particle particle-mesh solver\nfor dipole-dipole interactions, following the method of (Cerda).\nThe pppm/dipole/spin style invokes a particle-particle particle-mesh solver\nfor magnetic dipole-dipole interactions between magnetic spins.\nThe pppm/tip4p style is identical to the pppm style except that it\nadds a charge at the massless 4th site in each TIP4P water molecule.\nIt should be used with pair styles with a\ntip4p/long in their style name.\nThe pppm/stagger style performs calculations using two different\nmeshes, one shifted slightly with respect to the other.  This can\nreduce force aliasing errors and increase the accuracy of the method\nfor a given mesh size.  Or a coarser mesh can be used for the same\ntarget accuracy, which saves CPU time.  However, there is a trade-off\nsince FFTs on two meshes are now performed which increases the\ncomputation required.  See (Cerutti), (Neelov),\nand (Hockney) for details of the method.\nFor high relative accuracy, using staggered PPPM allows the mesh size\nto be reduced by a factor of 2 in each dimension as compared to\nregular PPPM (for the same target accuracy).  This can give up to a 4x\nspeedup in the KSpace time (8x less mesh points, 2x more expensive).\nHowever, for low relative accuracy, the staggered PPPM mesh size may\nbe essentially the same as for regular PPPM, which means the method\nwill be up to 2x slower in the KSpace time (simply 2x more expensive).\nFor more details and timings, see the Speed tips doc\npage.\n\nNote\nUsing pppm/stagger may not give the same increase in the\naccuracy of energy and pressure as it does in forces, so some caution\nmust be used if energy and/or pressure are quantities of interest,\nsuch as when using a barostat.\n\n\nThe pppm/disp and pppm/disp/tip4p styles add a mesh-based long-range\ndispersion sum option for 1/r^6 potentials (Isele-Holder),\nsimilar to the ewald/disp style. The 1/r^6 capability means\nthat Lennard-Jones or Buckingham potentials can be used without a cutoff,\ni.e. they become full long-range potentials.\nFor these styles, you will possibly want to adjust the default choice\nof parameters by using the kspace_modify command.\nThis can be done by either choosing the Ewald and grid parameters, or\nby specifying separate accuracies for the real and kspace\ncalculations. When not making any settings, the simulation will stop\nwith an error message. Further information on the influence of the\nparameters and how to choose them is described in\n(Isele-Holder),\n(Isele-Holder2) and the Howto dispersion doc page.\n\n\nNote\nAll of the PPPM styles can be used with single-precision FFTs by\nusing the compiler switch -DFFT_SINGLE for the FFT_INC setting in your\nlow-level Makefile.  This setting also changes some of the PPPM\noperations (e.g. mapping charge to mesh and interpolating electric\nfields to particles) to be performed in single precision.  This option\ncan speed-up long-range calculations, particularly in parallel or on\nGPUs.  The use of the -DFFT_SINGLE flag is discussed on the Build settings doc page. MSM does not currently support\nthe -DFFT_SINGLE compiler switch.\n\n\nThe msm style invokes a multi-level summation method MSM solver,\n(Hardy) or (Hardy2), which maps atom charge\nto a 3d mesh, and uses a multi-level hierarchy of coarser and coarser\nmeshes on which direct Coulomb solvers are done.  This method does not\nuse FFTs and scales as \\(N\\). It may therefore be faster than the other\nK-space solvers for relatively large problems when running on large\ncore counts. MSM can also be used for non-periodic boundary conditions\nand for mixed periodic and non-periodic boundaries.\nMSM is most competitive versus Ewald and PPPM when only relatively\nlow accuracy forces, about 1e-4 relative error or less accurate,\nare needed. Note that use of a larger Coulombic cutoff (i.e. 15\nangstroms instead of 10 angstroms) provides better MSM accuracy for\nboth the real space and grid computed forces.\nCurrently calculation of the full pressure tensor in MSM is expensive.\nUsing the kspace_modify pressure/scalar yes\ncommand provides a less expensive way to compute the scalar pressure\n(Pxx + Pyy + Pzz)/3.0. The scalar pressure can be used, for example,\nto run an isotropic barostat. If the full pressure tensor is needed,\nthen calculating the pressure at every timestep or using a fixed\npressure simulation with MSM will cause the code to run slower.\n\nThe scafacos style is a wrapper on the ScaFaCoS Coulomb solver library which provides a variety of solver\nmethods which can be used with LAMMPS.  The paper by (Who)\ngives an overview of ScaFaCoS.\nScaFaCoS was developed by a consortium of German research facilities\nwith a BMBF (German Ministry of Science and Education) funded project\nin 2009-2012. Participants of the consortium were the Universities of\nBonn, Chemnitz, Stuttgart, and Wuppertal as well as the\nForschungszentrum Juelich.\nThe library is available for download at “http://scafacos.de” or can\nbe cloned from the git-repository\n“git://github.com/scafacos/scafacos.git”.\nIn order to use this KSpace style, you must download and build the\nScaFaCoS library, then build LAMMPS with the USER-SCAFACOS package\ninstalled package which links LAMMPS to the ScaFaCoS library.\nSee details on this page.\n\nNote\nUnlike other KSpace solvers in LAMMPS, ScaFaCoS computes all\nCoulombic interactions, both short- and long-range.  Thus you should\nNOT use a Coulombic pair style when using kspace_style scafacos.  This\nalso means the total Coulombic energy (short- and long-range) will be\ntallied for thermodynamic output command as part\nof the elong keyword; the ecoul keyword will be zero.\n\n\nNote\nSee the current restriction below about use of ScaFaCoS in\nLAMMPS with molecular charged systems or the TIP4P water model.\n\nThe specified method determines which ScaFaCoS algorithm is used.\nThese are the ScaFaCoS methods currently available from LAMMPS:\n\nfmm = Fast Multi-Pole method\np2nfft = FFT-based Coulomb solver\newald = Ewald summation\ndirect = direct O(N^2) summation\np3m = PPPM\n\nWe plan to support additional ScaFaCoS solvers from LAMMPS in the\nfuture.  For an overview of the included solvers, refer to\n(Sutmann)\nThe specified accuracy is similar to the accuracy setting for other\nLAMMPS KSpace styles, but is passed to ScaFaCoS, which can interpret\nit in different ways for different methods it supports.  Within the\nScaFaCoS library the accuracy is treated as a tolerance level\n(either absolute or relative) for the chosen quantity, where the\nquantity can be either the Columic field values, the per-atom Columic\nenergy or the total Columic energy.  To select from these options, see\nthe kspace_modify scafacos accuracy doc page.\nThe kspace_modify scafacos command also explains\nother ScaFaCoS options currently exposed to LAMMPS.\n\nThe specified accuracy determines the relative RMS error in per-atom\nforces calculated by the long-range solver.  It is set as a\ndimensionless number, relative to the force that two unit point\ncharges (e.g. 2 monovalent ions) exert on each other at a distance of\n1 Angstrom.  This reference value was chosen as representative of the\nmagnitude of electrostatic forces in atomic systems.  Thus an accuracy\nvalue of 1.0e-4 means that the RMS error will be a factor of 10000\nsmaller than the reference force.\nThe accuracy setting is used in conjunction with the pairwise cutoff\nto determine the number of K-space vectors for style ewald or the\ngrid size for style pppm or msm.\nNote that style pppm only computes the grid size at the beginning of\na simulation, so if the length or triclinic tilt of the simulation\ncell increases dramatically during the course of the simulation, the\naccuracy of the simulation may degrade.  Likewise, if the\nkspace_modify slab option is used with\nshrink-wrap boundaries in the z-dimension, and the box size changes\ndramatically in z.  For example, for a triclinic system with all three\ntilt factors set to the maximum limit, the PPPM grid should be\nincreased roughly by a factor of 1.5 in the y direction and 2.0 in the\nz direction as compared to the same system using a cubic orthogonal\nsimulation cell.  One way to handle this issue if you have a long\nsimulation where the box size changes dramatically, is to break it\ninto shorter simulations (multiple run commands).  This\nworks because the grid size is re-computed at the beginning of each\nrun.  Another way to ensure the described accuracy requirement is met\nis to run a short simulation at the maximum expected tilt or length,\nnote the required grid size, and then use the\nkspace_modify mesh command to manually set the\nPPPM grid size to this value for the long run.  The simulation then\nwill be “too accurate” for some portion of the run.\nRMS force errors in real space for ewald and pppm are estimated\nusing equation 18 of (Kolafa), which is also referenced as\nequation 9 of (Petersen). RMS force errors in K-space for\newald are estimated using equation 11 of (Petersen),\nwhich is similar to equation 32 of (Kolafa). RMS force\nerrors in K-space for pppm are estimated using equation 38 of\n(Deserno). RMS force errors for msm are estimated\nusing ideas from chapter 3 of (Hardy), with equation 3.197\nof particular note. When using msm with non-periodic boundary\nconditions, it is expected that the error estimation will be too\npessimistic. RMS force errors for dipoles when using ewald/disp\nor ewald/dipole are estimated using equations 33 and 46 of\n(Wang). The RMS force errors for pppm/dipole are estimated\nusing the equations in (Cerda).\nSee the kspace_modify command for additional\noptions of the K-space solvers that can be set, including a force\noption for setting an absolute RMS error in forces, as opposed to a\nrelative RMS error.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nMore specifically, the pppm/gpu style performs charge assignment and\nforce interpolation calculations on the GPU.  These processes are\nperformed either in single or double precision, depending on whether\nthe -DFFT_SINGLE setting was specified in your low-level Makefile, as\ndiscussed above.  The FFTs themselves are still calculated on the CPU.\nIf pppm/gpu is used with a GPU-enabled pair style, part of the PPPM\ncalculation can be performed concurrently on the GPU while other\ncalculations for non-bonded and bonded force calculation are performed\non the CPU.\nThe pppm/kk style performs charge assignment and force interpolation\ncalculations, along with the FFTs themselves, on the GPU or (optionally) threaded\non the CPU when using OpenMP and FFTW3.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP, and OPT packages respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "kspace_style style value",
    "parameters": " * style = none or ewald or ewald/dipole or ewald/dipole/spin or ewald/disp or ewald/omp or pppm or pppm/cg or pppm/disp or pppm/tip4p or pppm/stagger or pppm/disp/tip4p or pppm/gpu or pppm/intel or pppm/disp/intel or pppm/kk or pppm/omp or pppm/cg/omp or pppm/disp/tip4p/omp or pppm/tip4p/omp or msm or msm/cg or msm/omp or msm/cg/omp or scafacos\n * none value = none\n * ewald value = accuracy\n *   accuracy = desired relative error in forces\n * ewald/dipole value = accuracy\n *   accuracy = desired relative error in forces\n * ewald/dipole/spin value = accuracy\n *   accuracy = desired relative error in forces\n * ewald/disp value = accuracy\n *   accuracy = desired relative error in forces\n * ewald/omp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/cg values = accuracy (smallq)\n *   accuracy = desired relative error in forces\n *   smallq = cutoff for charges to be considered (optional) (charge units)\n * pppm/dipole value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/dipole/spin value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/disp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/tip4p value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/disp/tip4p value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/gpu value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/intel value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/disp/intel value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/kk value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/omp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/cg/omp values = accuracy (smallq)\n *   accuracy = desired relative error in forces\n *   smallq = cutoff for charges to be considered (optional) (charge units)\n * pppm/disp/omp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/tip4p/omp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/disp/tip4p/omp value = accuracy\n *   accuracy = desired relative error in forces\n * pppm/stagger value = accuracy\n *   accuracy = desired relative error in forces\n * msm value = accuracy\n *   accuracy = desired relative error in forces\n * msm/cg value = accuracy (smallq)\n *   accuracy = desired relative error in forces\n *   smallq = cutoff for charges to be considered (optional) (charge units)\n * msm/omp value = accuracy\n *   accuracy = desired relative error in forces\n * msm/cg/omp value = accuracy (smallq)\n *   accuracy = desired relative error in forces\n *   smallq = cutoff for charges to be considered (optional) (charge units)\n * scafacos values = method accuracy\n *   method = fmm or p2nfft or p3m or ewald or direct\n *   accuracy = desired relative error in forces",
    "examples": "kspace_style pppm 1.0e-4\nkspace_style pppm/cg 1.0e-5 1.0e-6\nkspace style msm 1.0e-4\nkspace style scafacos fmm 1.0e-4\nkspace_style none",
    "restrictions": "Note that the long-range electrostatic solvers in LAMMPS assume conducting\nmetal (tinfoil) boundary conditions for both charge and dipole\ninteractions. Vacuum boundary conditions are not currently supported.\nThe ewald/disp, ewald, pppm, and msm styles support\nnon-orthogonal (triclinic symmetry) simulation boxes. However,\ntriclinic simulation cells may not yet be supported by suffix versions\nof these styles.\nAll of the kspace styles are part of the KSPACE package.  They are\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nFor MSM, a simulation must be 3d and one can use any combination of\nperiodic, non-periodic, or shrink-wrapped boundaries (specified using\nthe boundary command).\nFor Ewald and PPPM, a simulation must be 3d and periodic in all\ndimensions.  The only exception is if the slab option is set with\nkspace_modify, in which case the xy dimensions\nmust be periodic and the z dimension must be non-periodic.\nThe scafacos KSpace style will only be enabled if LAMMPS is built with\nthe USER-SCAFACOS package.  See the Build package\ndoc page for more info.\nThe use of ScaFaCos in LAMMPS does not yet support molecular charged\nsystems where the short-range Coulombic interactions between atoms in\nthe same bond/angle/dihedral are weighted by the\nspecial_bonds command.  Likewise it does not\nsupport the “TIP4P water style” where a fictitious charge site is\nintroduced in each water molecule.\nFinally, the methods p3m and ewald do not support computing the\nvirial, so this contribution is not included."
},
{
    "command": "label",
    "html_filename": "label.html",
    "short_description": "Label this line of the input script with the chosen ID",
    "description": "Label this line of the input script with the chosen ID.  Unless a jump\ncommand was used previously, this does nothing.  But if a\njump command was used with a label argument to begin\ninvoking this script file, then all command lines in the script prior\nto this line will be ignored.  I.e. execution of the script will begin\nat this line.  This is useful for looping over a section of the input\nscript as discussed in the jump command.",
    "syntax": "label ID",
    "parameters": " * ID = string used as label name",
    "examples": "label xyz\nlabel loop",
    "restrictions": "\nnone\n\nRelated commands: none\nDefault: none"
},
{
    "command": "lattice",
    "html_filename": "lattice.html",
    "short_description": "Define a lattice for use by other commands",
    "description": "Define a lattice for use by other commands.  In LAMMPS, a lattice is\nsimply a set of points in space, determined by a unit cell with basis\natoms, that is replicated infinitely in all dimensions.  The arguments\nof the lattice command can be used to define a wide variety of\ncrystallographic lattices.\nA lattice is used by LAMMPS in two ways.  First, the\ncreate_atoms command creates atoms on the lattice\npoints inside the simulation box.  Note that the\ncreate_atoms command allows different atom types\nto be assigned to different basis atoms of the lattice.  Second, the\nlattice spacing in the x,y,z dimensions implied by the lattice, can be\nused by other commands as distance units\n(e.g. create_box, region and\nvelocity), which are often convenient to use when the\nunderlying problem geometry is atoms on a lattice.\nThe lattice style must be consistent with the dimension of the\nsimulation - see the dimension command.  Styles sc\nor bcc or fcc or hcp or diamond are for 3d problems.  Styles\nsq or sq2 or hex are for 2d problems.  Style custom can be\nused for either 2d or 3d problems.\nA lattice consists of a unit cell, a set of basis atoms within that\ncell, and a set of transformation parameters (scale, origin, orient)\nthat map the unit cell into the simulation box.  The vectors a1,a2,a3\nare the edge vectors of the unit cell.  This is the nomenclature for\n“primitive” vectors in solid-state crystallography, but in LAMMPS the\nunit cell they determine does not have to be a “primitive cell” of\nminimum volume.\nNote that the lattice command can be used multiple times in an input\nscript.  Each time it is invoked, the lattice attributes are\nre-defined and are used for all subsequent commands (that use lattice\nattributes).  For example, a sequence of lattice,\nregion, and create_atoms commands\ncan be repeated multiple times to build a poly-crystalline model with\ndifferent geometric regions populated with atoms in different lattice\norientations.\n\nA lattice of style none does not define a unit cell and basis set,\nso it cannot be used with the create_atoms\ncommand.  However it does define a lattice spacing via the specified\nscale parameter.  As explained above the lattice spacings in x,y,z can\nbe used by other commands as distance units.  No additional\nkeyword/value pairs can be specified for the none style.  By\ndefault, a “lattice none 1.0” is defined, which means the lattice\nspacing is the same as one distance unit, as defined by the\nunits command.\nLattices of style sc, fcc, bcc, and diamond are 3d lattices\nthat define a cubic unit cell with edge length = 1.0.  This means a1 =\n1 0 0, a2 = 0 1 0, and a3 = 0 0 1.  Style hcp has a1 = 1 0 0, a2 = 0\nsqrt(3) 0, and a3 = 0 0 sqrt(8/3).  The placement of the basis atoms\nwithin the unit cell are described in any solid-state physics text.  A\nsc lattice has 1 basis atom at the lower-left-bottom corner of the\ncube.  A bcc lattice has 2 basis atoms, one at the corner and one at\nthe center of the cube.  A fcc lattice has 4 basis atoms, one at the\ncorner and 3 at the cube face centers.  A hcp lattice has 4 basis\natoms, two in the z = 0 plane and 2 in the z = 0.5 plane.  A diamond\nlattice has 8 basis atoms.\nLattices of style sq and sq2 are 2d lattices that define a square\nunit cell with edge length = 1.0.  This means a1 = 1 0 0 and a2 = 0 1\n0.  A sq lattice has 1 basis atom at the lower-left corner of the\nsquare.  A sq2 lattice has 2 basis atoms, one at the corner and one\nat the center of the square.  A hex style is also a 2d lattice, but\nthe unit cell is rectangular, with a1 = 1 0 0 and a2 = 0 sqrt(3) 0.\nIt has 2 basis atoms, one at the corner and one at the center of the\nrectangle.\nA lattice of style custom allows you to specify a1, a2, a3, and a\nlist of basis atoms to put in the unit cell.  By default, a1 and a2\nand a3 are 3 orthogonal unit vectors (edges of a unit cube).  But you\ncan specify them to be of any length and non-orthogonal to each other,\nso that they describe a tilted parallelepiped.  Via the basis\nkeyword you add atoms, one at a time, to the unit cell.  Its arguments\nare fractional coordinates (0.0 <= x,y,z < 1.0).  The position vector\nx of a basis atom within the unit cell is thus a linear combination of\nthe unit cell’s 3 edge vectors, i.e. x = bx a1 + by a2 + bz a3,\nwhere bx,by,bz are the 3 values specified for the basis keyword.\n\nThis sub-section discusses the arguments that determine how the\nidealized unit cell is transformed into a lattice of points within the\nsimulation box.\nThe scale argument determines how the size of the unit cell will be\nscaled when mapping it into the simulation box.  I.e. it determines a\nmultiplicative factor to apply to the unit cell, to convert it to a\nlattice of the desired size and distance units in the simulation box.\nThe meaning of the scale argument depends on the units\nbeing used in your simulation.\nFor all unit styles except lj, the scale argument is specified in\nthe distance units defined by the unit style.  For example, in real\nor metal units, if the unit cell is a unit cube with edge length\n1.0, specifying scale = 3.52 would create a cubic lattice with a\nspacing of 3.52 Angstroms.  In cgs units, the spacing would be 3.52\ncm.\nFor unit style lj, the scale argument is the Lennard-Jones reduced\ndensity, typically written as rho*.  LAMMPS converts this value into\nthe multiplicative factor via the formula “factor^dim = rho/rho*”,\nwhere rho = N/V with V = the volume of the lattice unit cell and N =\nthe number of basis atoms in the unit cell (described below), and dim\n= 2 or 3 for the dimensionality of the simulation.  Effectively, this\nmeans that if LJ particles of size sigma = 1.0 are used in the\nsimulation, the lattice of particles will be at the desired reduced\ndensity.\nThe origin option specifies how the unit cell will be shifted or\ntranslated when mapping it into the simulation box.  The x,y,z values\nare fractional values (0.0 <= x,y,z < 1.0) meaning shift the lattice\nby a fraction of the lattice spacing in each dimension.  The meaning\nof “lattice spacing” is discussed below.\nThe orient option specifies how the unit cell will be rotated when\nmapping it into the simulation box.  The dim argument is one of the\n3 coordinate axes in the simulation box.  The other 3 arguments are\nthe crystallographic direction in the lattice that you want to orient\nalong that axis, specified as integers.  E.g. “orient x 2 1 0” means\nthe x-axis in the simulation box will be the [210] lattice\ndirection, and similarly for y and z.  The 3 lattice directions you\nspecify do not have to be unit vectors, but they must be mutually\northogonal and obey the right-hand rule, i.e. (X cross Y) points in\nthe Z direction.\n\nNote\nThe preceding paragraph describing lattice directions is only\nvalid for orthogonal cubic unit cells (or square in 2d).  If you are\nusing a hcp or hex lattice or the more general lattice style\ncustom with non-orthogonal a1,a2,a3 vectors, then you should think\nof the 3 orient vectors as creating a 3x3 rotation matrix which is\napplied to a1,a2,a3 to rotate the original unit cell to a new\norientation in the simulation box.\n\n\nSeveral LAMMPS commands have the option to use distance units that are\ninferred from “lattice spacings” in the x,y,z box directions.\nE.g. the region command can create a block of size\n10x20x20, where 10 means 10 lattice spacings in the x direction.\n\nNote\nThough they are called lattice spacings, all the commands that\nhave a “units lattice” option, simply use the 3 values as scale\nfactors on the distance units defined by the units\ncommand.  Thus if you do not like the lattice spacings computed by\nLAMMPS (e.g. for a non-orthogonal or rotated unit cell), you can\ndefine the 3 values to be whatever you wish, via the spacing option.\n\nIf the spacing option is not specified, the lattice spacings are\ncomputed by LAMMPS in the following way.  A unit cell of the lattice\nis mapped into the simulation box (scaled and rotated), so that it now\nhas (perhaps) a modified size and orientation.  The lattice spacing in\nX is defined as the difference between the min/max extent of the x\ncoordinates of the 8 corner points of the modified unit cell (4 in\n2d).  Similarly, the Y and Z lattice spacings are defined as the\ndifference in the min/max of the y and z coordinates.\nNote that if the unit cell is orthogonal with axis-aligned edges (no\nrotation via the orient keyword), then the lattice spacings in each\ndimension are simply the scale factor (described above) multiplied by\nthe length of a1,a2,a3.  Thus a hex style lattice with a scale\nfactor of 3.0 Angstroms, would have a lattice spacing of 3.0 in x and\n3*sqrt(3.0) in y.\n\nNote\nFor non-orthogonal unit cells and/or when a rotation is applied\nvia the orient keyword, then the lattice spacings computed by LAMMPS\nare typically less intuitive.  In particular, in these cases, there is\nno guarantee that a particular lattice spacing is an integer multiple\nof the periodicity of the lattice in that direction.  Thus, if you\ncreate an orthogonal periodic simulation box whose size in a dimension\nis a multiple of the lattice spacing, and then fill it with atoms via\nthe create_atoms command, you will NOT necessarily\ncreate a periodic system.  I.e. atoms may overlap incorrectly at the\nfaces of the simulation box.\n\nThe spacing option sets the 3 lattice spacings directly.  All must\nbe non-zero (use 1.0 for dz in a 2d simulation).  The specified values\nare multiplied by the multiplicative factor described above that is\nassociated with the scale factor.  Thus a spacing of 1.0 means one\nunit cell edge length independent of the scale factor.  As mentioned\nabove, this option can be useful if the spacings LAMMPS computes are\ninconvenient to use in subsequent commands, which can be the case for\nnon-orthogonal or rotated lattices.\nNote that whenever the lattice command is used, the values of the\nlattice spacings LAMMPS calculates are printed out.  Thus their effect\nin commands that use the spacings should be decipherable.\n\nExample commands for generating a Wurtzite crystal (courtesy\nof Aidan Thompson), with its 8 atom unit cell.\nvariable a equal  4.340330\nvariable b equal  $a*sqrt(3.0)\nvariable c equal  $a*sqrt(8.0/3.0)\n\nvariable 1_3 equal 1.0/3.0\nvariable 2_3 equal 2.0/3.0\nvariable 1_6 equal 1.0/6.0\nvariable 5_6 equal 5.0/6.0\nvariable 1_12 equal 1.0/12.0\nvariable 5_12 equal 5.0/12.0\n\nlattice custom    1.0     &\n        a1      $a      0.0     0.0     &\n        a2      0.0     $b      0.0     &\n        a3      0.0     0.0     $c      &\n        basis   0.0     0.0     0.0     &\n        basis   0.5     0.5     0.0     &\n        basis   ${1_3}  0.0     0.5     &\n        basis   ${5_6}  0.5     0.5     &\n        basis   0.0     0.0     0.625   &\n        basis   0.5     0.5     0.625   &\n        basis   ${1_3}  0.0     0.125   &\n        basis   ${5_6}  0.5     0.125\n\nregion myreg block 0 1 0 1 0 1\ncreate_box      2 myreg\ncreate_atoms    1 box      &\n        basis   5       2       &\n        basis   6       2       &\n        basis   7       2       &\n        basis   8       2",
    "syntax": "lattice style scale keyword values ...",
    "parameters": " * style = none or sc or bcc or fcc or hcp or diamond or         sq or sq2 or hex or custom\n * scale = scale factor between lattice and simulation box\n * scale = reduced density rho* (for LJ units)\n * scale = lattice constant in distance units (for all other units)\n * zero or more keyword/value pairs may be appended\n * keyword = origin or orient or spacing or a1 or a2 or a3 or basis\n * origin values = x y z\n *   x,y,z = fractions of a unit cell (0 <= x,y,z < 1)\n * orient values = dim i j k\n *   dim = x or y or z\n *   i,j,k = integer lattice directions\n * spacing values = dx dy dz\n *   dx,dy,dz = lattice spacings in the x,y,z box directions\n * a1,a2,a3 values = x y z\n *   x,y,z = primitive vector components that define unit cell\n * basis values = x y z\n *   x,y,z = fractional coords of a basis atom (0 <= x,y,z < 1)",
    "examples": "lattice fcc 3.52\nlattice hex 0.85\nlattice sq 0.8 origin 0.0 0.5 0.0 orient x 1 1 0 orient y -1 1 0\nlattice custom 3.52 a1 1.0 0.0 0.0 a2 0.5 1.0 0.0 a3 0.0 0.0 0.5 &\n                    basis 0.0 0.0 0.0 basis 0.5 0.5 0.5\nlattice none 2.0",
    "restrictions": "The a1,a2,a3,basis keywords can only be used with style custom."
},
{
    "command": "log",
    "html_filename": "log.html",
    "short_description": "This command closes the current LAMMPS log file, opens a new file with the specified name, and begins logging information to it",
    "description": "This command closes the current LAMMPS log file, opens a new file with\nthe specified name, and begins logging information to it.  If the\nspecified file name is none, then no new log file is opened.  If the\noptional keyword append is specified, then output will be appended\nto an existing log file, instead of overwriting it.\nIf multiple processor partitions are being used, the file name should\nbe a variable, so that different processors do not attempt to write to\nthe same log file.\nThe file “log.lammps” is the default log file for a LAMMPS run.  The\nname of the initial log file can also be set by the -log command-line switch.",
    "syntax": "log file keyword",
    "parameters": " * file = name of new logfile\n * keyword = append if output should be appended to logfile (optional)",
    "examples": "log log.equil\nlog log.equil append",
    "restrictions": "\nnone\n\nRelated commands: none"
},
{
    "command": "mass",
    "html_filename": "mass.html",
    "short_description": "Set the mass for all atoms of one or more atom types",
    "description": "Set the mass for all atoms of one or more atom types.  Per-type mass\nvalues can also be set in the read_data data file\nusing the “Masses” keyword.  See the units command for\nwhat mass units to use.\nThe I index can be specified in one of two ways.  An explicit numeric\nvalue can be used, as in the 1st example above.  Or a wild-card\nasterisk can be used to set the mass for multiple atom types.  This\ntakes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\natom types, then an asterisk with no numeric values means all types\nfrom 1 to N.  A leading asterisk means all types from 1 to n\n(inclusive).  A trailing asterisk means all types from n to N\n(inclusive).  A middle asterisk means all types from m to n\n(inclusive).\nA line in a data file that follows the “Masses”\nkeyword specifies mass using the same format as the arguments of the\nmass command in an input script, except that no wild-card asterisk can\nbe used.  For example, under the “Masses” section of a data file, the\nline that corresponds to the 1st example above would be listed as\n1 1.0\n\n\nNote that the mass command can only be used if the atom style requires per-type atom mass to be set.\nCurrently, all but the sphere and ellipsoid and peri styles do.\nThey require mass to be set for individual particles, not types.\nPer-atom masses are defined in the data file read by the\nread_data command, or set to default values by the\ncreate_atoms command.  Per-atom masses can also be\nset to new values by the set mass or set density\ncommands.\nAlso note that pair_style eam and pair_style bop commands define the masses of atom types in their\nrespective potential files, in which case the mass command is normally\nnot used.\nIf you define a hybrid atom style which includes one\n(or more) sub-styles which require per-type mass and one (or more)\nsub-styles which require per-atom mass, then you must define both.\nHowever, in this case the per-type mass will be ignored; only the\nper-atom mass will be used by LAMMPS.",
    "syntax": "mass I value",
    "parameters": " * I = atom type (see asterisk form below)\n * value = mass",
    "examples": "mass 1 1.0\nmass * 62.5\nmass 2* 62.5",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command.\nAll masses must be defined before a simulation is run.  They must also\nall be defined before a velocity or fix shake command is used.\nThe mass assigned to any type or atom must be > 0.0.\nRelated commands: none\nDefault: none"
},
{
    "command": "message",
    "html_filename": "message.html",
    "short_description": "Establish a messaging protocol between LAMMPS and another code for the purpose of client/server coupling",
    "description": "Establish a messaging protocol between LAMMPS and another code for the\npurpose of client/server coupling.\nThe Howto client/server doc page gives an\noverview of client/server coupling of LAMMPS with another code where\none code is the “client” and sends request messages to a “server”\ncode.  The server responds to each request with a reply message.  This\nenables the two codes to work in tandem to perform a simulation.\n\nThe which argument defines LAMMPS to be the client or the server.\nAs explained below the quit option should be used when LAMMPS is\nfinished as a client.  It sends a message to the server to tell it to\nshut down.\n\nThe protocol argument defines the format and content of messages\nthat will be exchanged between the two codes.  The current options\nare:\n\nmd = run dynamics with another code\nmc = perform Monte Carlo moves with another code\n\nFor protocol md, LAMMPS can be either a client or server.  See the\nserver md doc page for details on the protocol.\nFor protocol mc, LAMMPS can be the server.  See the server mc doc page for details on the protocol.\n\nThe mode argument specifies how messages are exchanged between the\nclient and server codes.  Both codes must use the same mode and use\nconsistent parameters.\nFor mode file, the 2 codes communicate via binary files.  They must\nuse the same filename, which is actually a file prefix.  Several files\nwith that prefix will be created and deleted as a simulation runs.\nThe filename can include a path.  Both codes must be able to access\nthe path/file in a common filesystem.\nFor mode zmq, the 2 codes communicate via a socket on the server\ncode’s machine.  Support for socket messaging is provided by the\nopen-source ZeroMQ library, which must be\ninstalled on your system.  The client specifies an IP address (IPv4\nformat) or the DNS name of the machine the server code is running on,\nfollowed by a 4-digit port ID for the socket, separated by a colon.\nE.g.\nlocalhost:5555        # client and server running on same machine\n192.168.1.1:5555      # server is 192.168.1.1\ndeptbox.uni.edu:5555  # server is deptbox.uni.edu\n\n\nThe server specifies “*:5555” where “*” represents all available\ninterfaces on the server’s machine, and the port ID must match\nwhat the client specifies.\n\nNote\nWhat are allowed port IDs?\n\n\nNote\nAdditional explanation is needed here about how to use the zmq\nmode on a parallel machine, e.g. a cluster with many nodes.\n\nFor mode mpi/one, the 2 codes communicate via MPI and are launched\nby the same mpirun command, e.g. with this syntax for OpenMPI:\nmpirun -np 2 lmp_mpi -mpicolor 0 -in in.client -log log.client : -np 4 othercode args  # LAMMPS is client\nmpirun -np 2 othercode args : -np 4 lmp_mpi -mpicolor 1 -in in.server  # LAMMPS is server\n\n\nNote the use of the “-mpicolor color” command-line argument with\nLAMMPS.  See the command-line args doc page for\nfurther explanation.\nFor mode mpi/two, the 2 codes communicate via MPI, but are launched\nbe 2 separate mpirun commands.  The specified filename argument is a\nfile the 2 MPI processes will use to exchange info so that an MPI\ninter-communicator can be established to enable the 2 codes to send\nMPI messages to each other.  Both codes must be able to access the\npath/file in a common filesystem.\n\nNormally, the message client or message server command should be used\nat the top of a LAMMPS input script.  It performs an initial handshake\nwith the other code to setup messaging and to verify that both codes\nare using the same message protocol and mode.  Assuming both codes are\nlaunched at (nearly) the same time, the other code should perform the\nsame kind of initialization.\nIf LAMMPS is the client code, it will begin sending messages when a\nLAMMPS client command begins its operation.  E.g. for the fix client/md command, it is when a run\ncommand is executed.\nIf LAMMPS is the server code, it will begin receiving messages when\nthe server command is invoked.\nIf LAMMPS is being used as a client, the message quit command will\nterminate its messaging with the server.  If you do not use this\ncommand and just allow LAMMPS to exit, then the server will continue\nto wait for further messages.  This may not be a problem, but if both\nthe client and server programs were launched in the same batch script,\nthen if the server runs indefinitely, it may consume the full allocation\nof computer time, even if the calculation finishes sooner.\nNote that if LAMMPS is the client or server, it will continue\nprocessing the rest of its input script after client/server\ncommunication terminates.\nIf both codes cooperate in this manner, a new round of client/server\nmessaging can be initiated after termination by re-using a 2nd message\ncommand in your LAMMPS input script, followed by a new fix client or\nserver command, followed by another message quit command (if LAMMPS is\nthe client).  As an example, this can be performed in a loop to use a\nquantum code as a server to compute quantum forces for multiple LAMMPS\ndata files or periodic snapshots while running dynamics.",
    "syntax": "message which protocol mode arg",
    "parameters": " * which = client or server or quit\n * protocol = md or mc\n * mode = file or zmq or mpi/one or mpi/two\n * file arg = filename\n *   filename = file used for message exchanges\n * zmq arg = socket-ID\n *   socket-ID for client = localhost:5555, see description below\n *   socket-ID for server = *:5555, see description below\n * mpi/one arg = none\n * mpi/two arg = filename\n *   filename = file used to establish communication between 2 MPI jobs",
    "examples": "message client md file tmp.couple\nmessage server md file tmp.couple\n\nmessage client md zmq localhost:5555\nmessage server md zmq *:5555\n\nmessage client md mpi/one\nmessage server md mpi/one\n\nmessage client md mpi/two tmp.couple\nmessage server md mpi/two tmp.couple\n\nmessage quit",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "min_modify",
    "html_filename": "min_modify.html",
    "short_description": "This command sets parameters that affect the energy minimization algorithms selected by the min_style command",
    "description": "This command sets parameters that affect the energy minimization\nalgorithms selected by the min_style command.  The\nvarious settings may affect the convergence rate and overall number of\nforce evaluations required by a minimization, so users can experiment\nwith these parameters to tune their minimizations.\nThe cg and sd minimization styles have an outer iteration and an\ninner iteration which is steps along a one-dimensional line search in\na particular search direction.  The dmax parameter is how far any\natom can move in a single line search in any dimension (x, y, or z).\nFor the quickmin and fire minimization styles, the dmax setting\nis how far any atom can move in a single iteration (timestep).  Thus a\nvalue of 0.1 in real units means no atom will move\nfurther than 0.1 Angstroms in a single outer iteration.  This prevents\nhighly overlapped atoms from being moved long distances (e.g. through\nanother atom) due to large forces.\nThe choice of line search algorithm for the cg and sd minimization\nstyles can be selected via the line keyword.  The default\nquadratic line search algorithm starts out using the robust\nbacktracking method described below. However, once the system gets\nclose to a local minimum and the linesearch steps get small, so that\nthe energy is approximately quadratic in the step length, it uses the\nestimated location of zero gradient as the linesearch step, provided\nthe energy change is downhill.  This becomes more efficient than\nbacktracking for highly-converged relaxations. The forcezero line\nsearch algorithm is similar to quadratic.  It may be more\nefficient than quadratic on some systems.\nThe backtracking search is robust and should always find a local\nenergy minimum.  However, it will “converge” when it can no longer\nreduce the energy of the system.  Individual atom forces may still be\nlarger than desired at this point, because the energy change is\nmeasured as the difference of two large values (energy before and\nenergy after) and that difference may be smaller than machine epsilon\neven if atoms could move in the gradient direction to reduce forces\nfurther.\nThe choice of a norm can be modified for the min styles cg, sd, quickmin, fire, fire/old, spin, spin/cg and\nspin/lbfgs using the norm keyword.  The default two norm computes\nthe 2-norm (Euclidean length) of the global force vector:\n\n\\[|| \\vec{F} ||_{2} = \\sqrt{\\vec{F}_1+ \\cdots + \\vec{F}_N}\\]\nThe max norm computes the length of the 3-vector force\nfor each atom  (2-norm), and takes the maximum value of those across\nall atoms\n\n\\[|| \\vec{F} ||_{max} = {\\rm max}\\left(||\\vec{F}_1||, \\cdots, ||\\vec{F}_N||\\right)\\]\nThe inf norm takes the maximum component across the forces of\nall atoms in the system:\n\n\\[|| \\vec{F} ||_{inf} = {\\rm max}\\left(|F_1^1|, |F_1^2|, |F_1^3| \\cdots, |F_N^1|, |F_N^2|, |F_N^3|\\right)\\]\nFor the min styles spin, spin/cg and spin/lbfgs, the force\nnorm is replaced by the spin-torque norm.\nKeywords alpha_damp and discrete_factor only make sense when\na min_spin command is declared.\nKeyword alpha_damp defines an analog of a magnetic Gilbert\ndamping. It defines a relaxation rate toward an equilibrium for\na given magnetic system.\nKeyword discrete_factor defines a discretization factor for the\nadaptive timestep used in the spin minimization.\nSee min_spin for more information about those\nquantities.\nThe choice of a line search algorithm for the spin/cg and\nspin/lbfgs styles can be specified via the line keyword.  The\nspin_cubic and spin_none keywords only make sense when one of those two\nminimization styles is declared.  The spin_cubic performs the line\nsearch based on a cubic interpolation of the energy along the search\ndirection. The spin_none keyword deactivates the line search\nprocedure.  The spin_none is a default value for line keyword for\nboth spin/lbfgs and spin/cg. Convergence of spin/lbfgs can be\nmore robust if spin_cubic line search is used.\nThe Newton integrator used for fire minimization can be selected\nto be either the symplectic Euler (eulerimplicit) or velocity\nVerlet (verlet).  tmax defines the maximum value for the\nadaptive timestep during a fire minimization. It is a multiplication\nfactor applied to the current timestep (not in time\nunit). For example, tmax = 4.0 with a timestep of\n2fs, means that the maximum value the timestep can reach during a fire\nminimization is 4fs.\nNote that parameter defaults has been chosen to be reliable in most cases,\nbut one should consider adjusting timestep and tmax to\noptimize the minimization for large or complex systems.  Other\nparameters of the fire minimization can be tuned (tmin,\ndelaystep, dtgrow, dtshrink, alpha0, and\nalphashrink). Please refer to the references describing the\nmin_style fire.\nAn additional stopping criteria vdfmax is used by fire in order to avoid\nunnecessary looping when it is reasonable to think the system will not\nbe relaxed further.  Note that in this case the system will NOT have\nreached your minimization criteria. This could happen when the system\ncomes to be stuck in a local basin of the phase space.  vdfmax is\nthe maximum number of consecutive iterations with P(t) < 0.\nThe min_style fire is an optimized implementation of\nmin_style fire/old. It can however behave similarly\nto the fire/old style by using the following set of parameters:\nmin_modify integrator eulerexplicit tmax 10.0 tmin 0.0 delaystep 5 &\n          dtgrow 1.1 dtshrink 0.5 alpha0 0.1 alphashrink 0.99 &\n          vdfmax 100000 halfstepback no initialdelay no",
    "syntax": "min_modify keyword values ...",
    "parameters": " * one or more keyword/value pairs may be listed\n * keyword = dmax or line or norm or alpha_damp or discrete_factor or integrator or tmax\n *   dmax value = max\n *     max = maximum distance for line search to move (distance units)\n *   line value = backtrack or quadratic or forcezero or spin_cubic or spin_none\n *     backtrack,quadratic,forcezero,spin_cubic,spin_none = style of linesearch to use\n *   norm value = two or max\n *     two = Euclidean two-norm (length of 3N vector)\n *     inf = max force component across all 3-vectors\n *     max = max force norm across all 3-vectors\n *   alpha_damp value = damping\n *     damping = fictitious Gilbert damping for spin minimization (adim)\n *   discrete_factor value = factor\n *     factor = discretization factor for adaptive spin timestep (adim)\n *   integrator value = eulerimplicit or verlet\n *     time integration scheme for fire minimization\n *   tmax value = factor\n *     factor = maximum adaptive timestep for fire minimization (adim)",
    "examples": "min_modify dmax 0.2\nmin_modify integrator verlet tmax 4",
    "restrictions": "For magnetic GNEB calculations, only spin_none value for line\nkeyword can be used when minimization styles spin/cg and spin/lbfgs are\nemployed.  See neb/spin for more explanation."
},
{
    "command": "min_style spin",
    "html_filename": "min_spin.html",
    "short_description": "Apply a minimization algorithm to use when a minimize command is performed",
    "description": "Apply a minimization algorithm to use when a minimize\ncommand is performed.\nStyle spin defines a damped spin dynamics with an adaptive\ntimestep, according to:\n\n\\[\\frac{d \\vec{s}_{i}}{dt} = \\lambda\\, \\vec{s}_{i} \\times\\left( \\vec{\\omega}_{i} \\times\\vec{s}_{i} \\right)\\]\nwith \\(\\lambda\\) a damping coefficient (similar to a Gilbert\ndamping). \\(\\lambda\\) can be defined by setting the\nalpha_damp keyword with the min_modify command.\nThe minimization procedure solves this equation using an\nadaptive timestep. The value of this timestep is defined\nby the largest precession frequency that has to be solved in the\nsystem:\n\n\\[{\\Delta t}_{\\rm max} = \\frac{2\\pi}{\\kappa \\left|\\vec{\\omega}_{\\rm max} \\right|}\\]\nwith \\(\\left|\\vec{\\omega}_{\\rm max}\\right|\\) the norm of the largest precession\nfrequency in the system (across all processes, and across all replicas if a\nspin/neb calculation is performed).\n\\(\\kappa\\) defines a discretization factor discrete_factor for\nthe definition of this timestep.  discrete_factor can be defined with\nthe min_modify command.\nStyle spin/cg defines an orthogonal spin optimization\n(OSO) combined to a conjugate gradient (CG) algorithm.\nThe min_modify command can be used to\ncouple the spin/cg to a line search procedure, and to modify the\ndiscretization factor discrete_factor.\nBy default, style spin/cg does not employ the line search procedure\nand uses the adaptive time-step technique in the same way as style spin.\nStyle spin/lbfgs defines an orthogonal spin optimization (OSO)\ncombined to a limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS)\nalgorithm.  By default, style spin/lbfgs does not employ line search\nprocedure.  If the line search procedure is not used then the discrete\nfactor defines the maximum root mean squared rotation angle of spins by\nequation pi/(5*Kappa).  The default value for Kappa is 10.  The\nspin_cubic line search option can improve the convergence of the\nspin/lbfgs algorithm.\nThe min_modify command can be used to\nactivate the line search procedure, and to modify the\ndiscretization factor discrete_factor.\nFor more information about styles spin/cg and spin/lbfgs,\nsee their implementation reported in (Ivanov).\n\nNote\nAll the spin styles replace the force tolerance by a torque\ntolerance. See minimize for more explanation.\n\n\nNote\nThe spin/cg and spin/lbfgs styles can be used\nfor magnetic NEB calculations only if the line search procedure\nis deactivated. See neb/spin for more explanation.",
    "syntax": "min_style spin",
    "parameters": " * min_style spin/cg\n * min_style spin/lbfgs",
    "examples": "min_style  spin/lbfgs\nmin_modify line spin_cubic discrete_factor 10.0",
    "restrictions": "This minimization procedure is only applied to spin degrees of\nfreedom for a frozen lattice configuration."
},
{
    "command": "min_style",
    "html_filename": "min_style.html",
    "short_description": "Choose a minimization algorithm to use when a minimize command is performed",
    "description": "Choose a minimization algorithm to use when a minimize command is performed.\nStyle cg is the Polak-Ribiere version of the conjugate gradient (CG)\nalgorithm.  At each iteration the force gradient is combined with the\nprevious iteration information to compute a new search direction\nperpendicular (conjugate) to the previous search direction.  The PR\nvariant affects how the direction is chosen and how the CG method is\nrestarted when it ceases to make progress.  The PR variant is thought\nto be the most effective CG choice for most problems.\nStyle hftn is a Hessian-free truncated Newton algorithm.  At each\niteration a quadratic model of the energy potential is solved by a\nconjugate gradient inner iteration.  The Hessian (second derivatives)\nof the energy is not formed directly, but approximated in each\nconjugate search direction by a finite difference directional\nderivative.  When close to an energy minimum, the algorithm behaves\nlike a Newton method and exhibits a quadratic convergence rate to high\naccuracy.  In most cases the behavior of hftn is similar to cg,\nbut it offers an alternative if cg seems to perform poorly.  This\nstyle is not affected by the min_modify command.\nStyle sd is a steepest descent algorithm.  At each iteration, the\nsearch direction is set to the downhill direction corresponding to the\nforce vector (negative gradient of energy).  Typically, steepest\ndescent will not converge as quickly as CG, but may be more robust in\nsome situations.\nStyle quickmin is a damped dynamics method described in\n(Sheppard), where the damping parameter is related\nto the projection of the velocity vector along the current force\nvector for each atom.  The velocity of each atom is initialized to 0.0\nby this style, at the beginning of a minimization.\nStyle fire is a damped dynamics method described in (Bitzek), which is similar to quickmin but adds a variable timestep\nand alters the projection operation to maintain components of the\nvelocity non-parallel to the current force vector.  The velocity of\neach atom is initialized to 0.0 by this style, at the beginning of a\nminimization. This style correspond to an optimized version described\nin (Guenole) that include different time integration\nschemes and defaults parameters. The default parameters can be\nmodified with the command min_modify.\nStyle fire/old is the original implementation of fire in Lammps,\nconserved for backward compatibility. The main differences regarding\nthe current version fire are: time integration by Explicit Euler\nonly, different sequence in maintaining velocity components non-parallel\nto the current force vector and hard-coded minimization parameters.\nA complete description of the differences between fire/old and fire\ncan be found in (Guenole) (where the current fire\nin LAMMPS is called fire2.0). By using an appropriate set of\nparameters, fire can behave similar to fire/old, as described\nin the min_modify command.\nStyle spin is a damped spin dynamics with an adaptive timestep.\nStyle spin/cg uses an orthogonal spin optimization (OSO) combined to\na conjugate gradient (CG) approach to minimize spin configurations.\nStyle spin/lbfgs uses an orthogonal spin optimization (OSO) combined\nto a limited-memory Broyden-Fletcher-Goldfarb-Shanno (LBFGS) approach\nto minimize spin configurations.\nSee the min/spin doc page for more information about\nthe spin, spin/cg and spin/lbfgs styles.\nEither the quickmin, fire and fire/old styles are useful in the\ncontext of nudged elastic band (NEB) calculations via the neb command.\nEither the spin, spin/cg and spin/lbfgs styles are useful in\nthe context of magnetic geodesic nudged elastic band (GNEB)\ncalculations via the neb/spin command.\n\nNote\nThe damped dynamic minimizers use whatever timestep you have\ndefined via the timestep command.  Often they\nwill converge more quickly if you use a timestep about 10x larger\nthan you would normally use for dynamics simulations.\nFor fire, the default timestep is recommended to be equal to\nthe one you would normally use for dynamics simulations.\n\n\nNote\nThe quickmin, fire, fire/old, hftn, and cg/kk styles do not yet\nsupport the use of the fix box/relax command\nor minimizations involving the electron radius in eFF models.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages\ndoc page.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix\ncommand-line switch when you invoke LAMMPS, or you can\nuse the suffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "min_style style",
    "parameters": " * style = cg or hftn or sd or quickmin or fire or fire/old or spin or spin/cg or spin/lbfgs",
    "examples": "min_style cg\nmin_style spin\nmin_style fire",
    "restrictions": "none"
},
{
    "command": "minimize",
    "html_filename": "minimize.html",
    "short_description": "Perform an energy minimization of the system, by iteratively adjusting atom coordinates",
    "description": "Perform an energy minimization of the system, by iteratively adjusting\natom coordinates.  Iterations are terminated when one of the stopping\ncriteria is satisfied.  At that point the configuration will hopefully\nbe in local potential energy minimum.  More precisely, the\nconfiguration should approximate a critical point for the objective\nfunction (see below), which may or may not be a local minimum.\nThe minimization algorithm used is set by the\nmin_style command.  Other options are set by the\nmin_modify command.  Minimize commands can be\ninterspersed with run commands to alternate between\nrelaxation and dynamics.  The minimizers bound the distance atoms move\nin one iteration, so that you can relax systems with highly overlapped\natoms (large energies and forces) by pushing the atoms off of each\nother.\nAlternate means of relaxing a system are to run dynamics with a small\nor limited timestep.  Or dynamics can be run\nusing fix viscous to impose a damping force that\nslowly drains all kinetic energy from the system.  The pair_style soft potential can be used to un-overlap atoms while\nrunning dynamics.\nun-overlap atoms while running dynamics.\nNote that you can minimize some atoms in the system while holding the\ncoordinates of other atoms fixed by applying fix setforce to the other atoms.  See a fuller discussion of using\nfixes while minimizing below.\nThe minimization styles cg, sd, and hftn\ninvolves an outer iteration loop which sets the search direction along\nwhich atom coordinates are changed.  An inner iteration is then\nperformed using a line search algorithm.  The line search typically\nevaluates forces and energies several times to set new coordinates.\nCurrently, a backtracking algorithm is used which may not be optimal\nin terms of the number of force evaluations performed, but appears to\nbe more robust than previous line searches we’ve tried.  The\nbacktracking method is described in Nocedal and Wright’s Numerical\nOptimization (Procedure 3.1 on p 41).\nThe minimization styles quickmin, fire and\nfire/old perform damped dynamics using an Euler integration step.  Thus\nthey require a timestep be defined.\n\nNote\nThe damped dynamic minimizers use whatever timestep you have\ndefined via the timestep command.  Often they\nwill converge more quickly if you use a timestep about 10x larger\nthan you would normally use for dynamics simulations.\n\n\nIn all cases, the objective function being minimized is the total\npotential energy of the system as a function of the N atom\ncoordinates:\n\n\\[\\begin{split}E(r_1,r_2, \\ldots ,r_N)  = & \\sum_{i,j} E_{\\it pair}(r_i,r_j) +\n                             \\sum_{ij} E_{\\it bond}(r_i,r_j) +\n                             \\sum_{ijk} E_{\\it angle}(r_i,r_j,r_k) + \\\\\n                           & \\sum_{ijkl} E_{\\it dihedral}(r_i,r_j,r_k,r_l) +\n                             \\sum_{ijkl} E_{\\it improper}(r_i,r_j,r_k,r_l) +\n                             \\sum_i E_{\\it fix}(r_i)\\end{split}\\]\nwhere the first term is the sum of all non-bonded pairwise\ninteractions including long-range Coulombic\ninteractions, the 2nd through 5th terms are bond, angle, dihedral, and improper interactions\nrespectively, and the last term is energy due to fixes\nwhich can act as constraints or apply force to atoms, such as through\ninteraction with a wall.  See the discussion below about how fix\ncommands affect minimization.\nThe starting point for the minimization is the current configuration\nof the atoms.\n\nThe minimization procedure stops if any of several criteria are met:\n\nthe change in energy between outer iterations is less than etol\nthe 2-norm (length) of the global force vector is less than the ftol\nthe line search fails because the step distance backtracks to 0.0\nthe number of outer iterations or timesteps exceeds maxiter\nthe number of total force evaluations exceeds maxeval\n\n\nNote\nthe minimization style spin,\nspin/cg, and spin/lbfgs replace\nthe force tolerance ftol by a torque tolerance.\nThe minimization procedure stops if the 2-norm (length) of the torque vector on atom\n(defined as the cross product between the\natomic spin and its precession vectors omega) is less than ftol,\nor if any of the other criteria are met. Torque have the same units as the energy.\n\n\nNote\nYou can also use the fix halt command to specify\na general criterion for exiting a minimization, that is a\ncalculation performed on the state of the current system, as\ndefined by an equal-style variable.\n\nFor the first criterion, the specified energy tolerance etol is\nunitless; it is met when the energy change between successive\niterations divided by the energy magnitude is less than or equal to\nthe tolerance.  For example, a setting of 1.0e-4 for etol means an\nenergy tolerance of one part in 10^4.  For the damped dynamics\nminimizers this check is not performed for a few steps after\nvelocities are reset to 0, otherwise the minimizer would prematurely\nconverge.\nFor the second criterion, the specified force tolerance ftol is in\nforce units, since it is the length of the global force vector for all\natoms, e.g. a vector of size 3N for N atoms.  Since many of the\ncomponents will be near zero after minimization, you can think of\nftol as an upper bound on the final force on any component of any\natom.  For example, a setting of 1.0e-4 for ftol means no x, y, or z\ncomponent of force on any atom will be larger than 1.0e-4 (in force\nunits) after minimization.\nEither or both of the etol and ftol values can be set to 0.0, in\nwhich case some other criterion will terminate the minimization.\nDuring a minimization, the outer iteration count is treated as a\ntimestep.  Output is triggered by this timestep, e.g. thermodynamic\noutput or dump and restart files.\nUsing the thermo_style custom command with the\nfmax or fnorm keywords can be useful for monitoring the progress\nof the minimization.  Note that these outputs will be calculated only\nfrom forces on the atoms, and will not include any extra degrees of\nfreedom, such as from the fix box/relax command.\nFollowing minimization, a statistical summary is printed that lists\nwhich convergence criterion caused the minimizer to stop, as well as\ninformation about the energy, force, final line search, and iteration\ncounts.  An example is as follows:\nMinimization stats:\n  Stopping criterion = max iterations\n  Energy initial, next-to-last, final =\n       -0.626828169302     -2.82642039062     -2.82643549739\n  Force two-norm initial, final = 2052.1 91.9642\n  Force max component initial, final = 346.048 9.78056\n  Final line search alpha, max atom move = 2.23899e-06 2.18986e-05\n  Iterations, force evaluations = 2000 12724\n\n\nThe 3 energy values are for before and after the minimization and on\nthe next-to-last iteration.  This is what the etol parameter checks.\nThe two-norm force values are the length of the global force vector\nbefore and after minimization.  This is what the ftol parameter\nchecks.\nThe max-component force values are the absolute value of the largest\ncomponent (x,y,z) in the global force vector, i.e. the infinity-norm\nof the force vector.\nThe alpha parameter for the line-search, when multiplied by the max\nforce component (on the last iteration), gives the max distance any\natom moved during the last iteration.  Alpha will be 0.0 if the line\nsearch could not reduce the energy.  Even if alpha is non-zero, if the\n“max atom move” distance is tiny compared to typical atom coordinates,\nthen it is possible the last iteration effectively caused no atom\nmovement and thus the evaluated energy did not change and the\nminimizer terminated.  Said another way, even with non-zero forces,\nit’s possible the effect of those forces is to move atoms a distance\nless than machine precision, so that the energy cannot be further\nreduced.\nThe iterations and force evaluation values are what is checked by the\nmaxiter and maxeval parameters.\n\n\nNote\nThere are several force fields in LAMMPS which have\ndiscontinuities or other approximations which may prevent you from\nperforming an energy minimization to high tolerances.  For example,\nyou should use a pair style that goes to 0.0 at the\ncutoff distance when performing minimization (even if you later change\nit when running dynamics).  If you do not do this, the total energy of\nthe system will have discontinuities when the relative distance\nbetween any pair of atoms changes from cutoff+epsilon to\ncutoff-epsilon and the minimizer may behave poorly.  Some of the\nmany-body potentials use splines and other internal cutoffs that\ninherently have this problem.  The long-range Coulombic styles (PPPM, Ewald) are approximate to within the\nuser-specified tolerance, which means their energy and forces may not\nagree to a higher precision than the Kspace-specified tolerance.  In\nall these cases, the minimizer may give up and stop before finding a\nminimum to the specified energy or force tolerance.\n\nNote that a cutoff Lennard-Jones potential (and others) can be shifted\nso that its energy is 0.0 at the cutoff via the\npair_modify command.  See the doc pages for\nindividual pair styles for details.  Note that\nCoulombic potentials always have a cutoff, unless versions with a\nlong-range component are used (e.g. pair_style lj/cut/coul/long).  The CHARMM potentials go to 0.0 at\nthe cutoff (e.g. pair_style lj/charmm/coul/charmm),\nas do the GROMACS potentials (e.g. pair_style lj/gromacs).\nIf a soft potential (pair_style soft) is used the\nAstop value is used for the prefactor (no time dependence).\nThe fix box/relax command can be used to apply an\nexternal pressure to the simulation box and allow it to shrink/expand\nduring the minimization.\nOnly a few other fixes (typically those that add forces) are invoked\nduring minimization.  See the doc pages for individual fix\ncommands to see which ones are relevant.  Current examples of fixes\nthat can be used include:\n\nfix addforce\nfix addtorque\nfix efield\nfix enforce2d\nfix indent\nfix lineforce\nfix planeforce\nfix setforce\nfix spring\nfix spring/self\nfix viscous\nfix wall\nfix wall/region\n\n\nNote\nSome fixes which are invoked during minimization have an\nassociated potential energy.  For that energy to be included in the\ntotal potential energy of the system (the quantity being minimized),\nyou MUST enable the fix_modify energy option for\nthat fix.  The doc pages for individual fix commands\nspecify if this should be done.\n\n\nNote\nThe minimizers in LAMMPS do not allow for bonds (or angles, etc)\nto be held fixed while atom coordinates are being relaxed, e.g. via\nfix shake or fix rigid.  See more\ninfo in the Restrictions section below.\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "minimize etol ftol maxiter maxeval",
    "parameters": " * etol = stopping tolerance for energy (unitless)\n * ftol = stopping tolerance for force (force units)\n * maxiter = max iterations of minimizer\n * maxeval = max number of force/energy evaluations",
    "examples": "minimize 1.0e-4 1.0e-6 100 1000\nminimize 0.0 1.0e-8 1000 100000",
    "restrictions": "Features that are not yet implemented are listed here, in case someone\nknows how they could be coded:\nIt is an error to use fix shake with minimization\nbecause it turns off bonds that should be included in the potential\nenergy of the system.  The effect of a fix shake can be approximated\nduring a minimization by using stiff spring constants for the bonds\nand/or angles that would normally be constrained by the SHAKE\nalgorithm.\nFix rigid is also not supported by minimization.  It\nis not an error to have it defined, but the energy minimization will\nnot keep the defined body(s) rigid during the minimization.  Note that\nif bonds, angles, etc internal to a rigid body have been turned off\n(e.g. via neigh_modify exclude), they will not\ncontribute to the potential energy which is probably not what is\ndesired.\nPair potentials that produce torque on a particle (e.g. granular potentials or the GayBerne potential for ellipsoidal particles) are not\nrelaxed by a minimization.  More specifically, radial relaxations are\ninduced, but no rotations are induced by a minimization, so such a\nsystem will not fully relax."
},
{
    "command": "molecule",
    "html_filename": "molecule.html",
    "short_description": "Define a molecule template that can be used as part of other LAMMPS commands, typically to define a collection of particles as a bonded molecule or a rigid body",
    "description": "Define a molecule template that can be used as part of other LAMMPS\ncommands, typically to define a collection of particles as a bonded\nmolecule or a rigid body.  Commands that currently use molecule\ntemplates include:\n\nfix deposit\nfix pour\nfix rigid/small\nfix shake\nfix gcmc\ncreate_atoms\natom_style template\n\nThe ID of a molecule template can only contain alphanumeric characters\nand underscores.\nA single template can contain multiple molecules, listed one per file.\nSome of the commands listed above currently use only the first\nmolecule in the template, and will issue a warning if the template\ncontains multiple molecules.  The atom_style template command allows multiple-molecule templates\nto define a system with more than one templated molecule.\nEach filename can be followed by optional keywords which are applied\nonly to the molecule in the file as used in this template.  This is to\nmake it easy to use the same molecule file in different molecule\ntemplates or in different simulations.  You can specify the same file\nmultiple times with different optional keywords.\nThe offset, toff, aoff, doff, ioff keywords add the\nspecified offset values to the atom types, bond types, angle types,\ndihedral types, and/or improper types as they are read from the\nmolecule file.  E.g. if toff = 2, and the file uses atom types\n1,2,3, then each created molecule will have atom types 3,4,5.  For the\noffset keyword, all five offset values must be specified, but\nindividual values will be ignored if the molecule template does not\nuse that attribute (e.g. no bonds).\nThe scale keyword scales the size of the molecule.  This can be\nuseful for modeling polydisperse granular rigid bodies.  The scale\nfactor is applied to each of these properties in the molecule file, if\nthey are defined: the individual particle coordinates (Coords\nsection), the individual mass of each particle (Masses section), the\nindividual diameters of each particle (Diameters section), the total\nmass of the molecule (header keyword = mass), the center-of-mass of\nthe molecule (header keyword = com), and the moments of inertia of the\nmolecule (header keyword = inertia).\n\nNote\nThe molecule command can be used to define molecules with bonds,\nangles, dihedrals, impropers, or special bond lists of neighbors\nwithin a molecular topology, so that you can later add the molecules\nto your simulation, via one or more of the commands listed above.\nSince this topology-related information requires that suitable storage\nis reserved when LAMMPS creates the simulation box (e.g. when using\nthe create_box command or the\nread_data command) suitable space has to be reserved\nso you do not overflow those pre-allocated data structures when adding\nmolecules later.  Both the create_box command and\nthe read_data command have “extra” options which\ninsure space is allocated for storing topology info for molecules that\nare added later.\n\nThe format of an individual molecule file is similar but\n(not identical) to the data file read by the read_data\ncommands, and is as follows.\nA molecule file has a header and a body.  The header appears first.\nThe first line of the header is always skipped; it typically contains\na description of the file.  Then lines are read one at a time.  Lines\ncan have a trailing comment starting with ‘#’ that is ignored.  If the\nline is blank (only white-space after comment is deleted), it is\nskipped.  If the line contains a header keyword, the corresponding\nvalue(s) is read from the line.  If it doesn’t contain a header\nkeyword, the line begins the body of the file.\nThe body of the file contains zero or more sections.  The first line\nof a section has only a keyword.  The next line is skipped.  The\nremaining lines of the section contain values.  The number of lines\ndepends on the section keyword as described below.  Zero or more blank\nlines can be used between sections.  Sections can appear in any order,\nwith a few exceptions as noted below.\nThese are the recognized header keywords.  Header lines can come in\nany order.  The numeric value(s) are read from the beginning of the\nline.  The keyword should appear at the end of the line.  All these\nsettings have default values, as explained below.  A line need only\nappear if the value(s) are different than the default.\n\nN atoms = # of atoms N in molecule, default = 0\nNb bonds = # of bonds Nb in molecule, default = 0\nNa angles = # of angles Na in molecule, default = 0\nNd dihedrals = # of dihedrals Nd in molecule, default = 0\nNi impropers = # of impropers Ni in molecule, default = 0\nMtotal mass = total mass of molecule\nXc Yc Zc com = coordinates of center-of-mass of molecule\nIxx Iyy Izz Ixy Ixz Iyz inertia = 6 components of inertia tensor of molecule\n\nFor mass, com, and inertia, the default is for LAMMPS to\ncalculate this quantity itself if needed, assuming the molecules\nconsists of a set of point particles or finite-size particles (with a\nnon-zero diameter) that do not overlap.  If finite-size particles in\nthe molecule do overlap, LAMMPS will not account for the overlap\neffects when calculating any of these 3 quantities, so you should\npre-compute them yourself and list the values in the file.\nThe mass and center-of-mass coordinates (Xc,Yc,Zc) are\nself-explanatory.  The 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz)\nshould be the values consistent with the current orientation of the\nrigid body around its center of mass.  The values are with respect to\nthe simulation box XYZ axes, not with respect to the principal axes of\nthe rigid body itself.  LAMMPS performs the latter calculation\ninternally.\nThese are the allowed section keywords for the body of the file.\n\nCoords, Types, Charges, Diameters, Masses = atom-property sections\nBonds, Angles, Dihedrals, Impropers = molecular topology sections\nSpecial Bond Counts, Special Bonds = special neighbor info\nShake Flags, Shake Atoms, Shake Bond Types = SHAKE info\n\nIf a Bonds section is specified then the Special Bond Counts and\nSpecial Bonds sections can also be used, if desired, to explicitly\nlist the 1-2, 1-3, 1-4 neighbors within the molecule topology (see\ndetails below).  This is optional since if these sections are not\nincluded, LAMMPS will auto-generate this information.  Note that\nLAMMPS uses this info to properly exclude or weight bonded pairwise\ninteractions between bonded atoms.  See the\nspecial_bonds command for more details.  One\nreason to list the special bond info explicitly is for the\nthermalized Drude oscillator model which treats the\nbonds between nuclear cores and Drude electrons in a different manner.\n\nNote\nWhether a section is required depends on how the molecule\ntemplate is used by other LAMMPS commands.  For example, to add a\nmolecule via the fix deposit command, the Coords\nand Types sections are required.  To add a rigid body via the fix pour command, the Bonds (Angles, etc) sections are not\nrequired, since the molecule will be treated as a rigid body.  Some\nsections are optional.  For example, the fix pour\ncommand can be used to add “molecules” which are clusters of\nfinite-size granular particles.  If the Diameters section is not\nspecified, each particle in the molecule will have a default diameter\nof 1.0.  See the doc pages for LAMMPS commands that use molecule\ntemplates for more details.\n\nEach section is listed below in alphabetic order.  The format of each\nsection is described including the number of lines it must contain and\nrules (if any) for whether it can appear in the data file.  In each\ncase the ID is ignored; it is simply included for readability, and\nshould be a number from 1 to Nlines for the section, indicating which\natom (or bond, etc) the entry applies to.  The lines are assumed to be\nlisted in order from 1 to Nlines, but LAMMPS does not check for this.\n\nCoords section:\n\none line per atom\nline syntax: ID x y z\nx,y,z = coordinate of atom\n\n\nTypes section:\n\none line per atom\nline syntax: ID type\ntype = atom type of atom\n\n\nCharges section:\n\none line per atom\nline syntax: ID q\nq = charge on atom\n\nThis section is only allowed for atom styles that\nsupport charge.  If this section is not included, the default charge\non each atom in the molecule is 0.0.\n\nDiameters section:\n\none line per atom\nline syntax: ID diam\ndiam = diameter of atom\n\nThis section is only allowed for atom styles that\nsupport finite-size spherical particles, e.g. atom_style sphere.  If\nnot listed, the default diameter of each atom in the molecule is 1.0.\n\nMasses section:\n\none line per atom\nline syntax: ID mass\nmass = mass of atom\n\nThis section is only allowed for atom styles that\nsupport per-atom mass, as opposed to per-type mass.  See the\nmass command for details.  If this section is not\nincluded, the default mass for each atom is derived from its volume\n(see Diameters section) and a default density of 1.0, in\nunits of mass/volume.\n\nBonds section:\n\none line per bond\nline syntax: ID type atom1 atom2\ntype = bond type (1-Nbondtype)\natom1,atom2 = IDs of atoms in bond\n\nThe IDs for the two atoms in each bond should be values\nfrom 1 to Natoms, where Natoms = # of atoms in the molecule.\n\nAngles section:\n\none line per angle\nline syntax: ID type atom1 atom2 atom3\ntype = angle type (1-Nangletype)\natom1,atom2,atom3 = IDs of atoms in angle\n\nThe IDs for the three atoms in each angle should be values from 1 to\nNatoms, where Natoms = # of atoms in the molecule.  The 3 atoms are\nordered linearly within the angle.  Thus the central atom (around\nwhich the angle is computed) is the atom2 in the list.\n\nDihedrals section:\n\none line per dihedral\nline syntax: ID type atom1 atom2 atom3 atom4\ntype = dihedral type (1-Ndihedraltype)\natom1,atom2,atom3,atom4 = IDs of atoms in dihedral\n\nThe IDs for the four atoms in each dihedral should be values from 1 to\nNatoms, where Natoms = # of atoms in the molecule.  The 4 atoms are\nordered linearly within the dihedral.\n\nImpropers section:\n\none line per improper\nline syntax: ID type atom1 atom2 atom3 atom4\ntype = improper type (1-Nimpropertype)\natom1,atom2,atom3,atom4 = IDs of atoms in improper\n\nThe IDs for the four atoms in each improper should be values from 1 to\nNatoms, where Natoms = # of atoms in the molecule.  The ordering of\nthe 4 atoms determines the definition of the improper angle used in\nthe formula for the defined improper style.  See\nthe doc pages for individual styles for details.\n\nSpecial Bond Counts section:\n\none line per atom\nline syntax: ID N1 N2 N3\nN1 = # of 1-2 bonds\nN2 = # of 1-3 bonds\nN3 = # of 1-4 bonds\n\nN1, N2, N3 are the number of 1-2, 1-3, 1-4 neighbors respectively of\nthis atom within the topology of the molecule.  See the\nspecial_bonds doc page for more discussion of\n1-2, 1-3, 1-4 neighbors.  If this section appears, the Special Bonds\nsection must also appear.\nAs explained above, LAMMPS will auto-generate this information if this\nsection is not specified.  If specified, this section will\noverride what would be auto-generated.\n\nSpecial Bonds section:\n\none line per atom\nline syntax: ID a b c d …\na,b,c,d,… = IDs of atoms in N1+N2+N3 special bonds\n\nA, b, c, d, etc are the IDs of the n1+n2+n3 atoms that are 1-2, 1-3,\n1-4 neighbors of this atom.  The IDs should be values from 1 to\nNatoms, where Natoms = # of atoms in the molecule.  The first N1\nvalues should be the 1-2 neighbors, the next N2 should be the 1-3\nneighbors, the last N3 should be the 1-4 neighbors.  No atom ID should\nappear more than once.  See the special_bonds doc\npage for more discussion of 1-2, 1-3, 1-4 neighbors.  If this section\nappears, the Special Bond Counts section must also appear.\nAs explained above, LAMMPS will auto-generate this information if this\nsection is not specified.  If specified, this section will override\nwhat would be auto-generated.\n\nShake Flags section:\n\none line per atom\nline syntax: ID flag\nflag = 0,1,2,3,4\n\nThis section is only needed when molecules created using the template\nwill be constrained by SHAKE via the “fix shake” command.  The other\ntwo Shake sections must also appear in the file, following this one.\nThe meaning of the flag for each atom is as follows.  See the fix shake doc page for a further description of SHAKE\nclusters.\n\n0 = not part of a SHAKE cluster\n1 = part of a SHAKE angle cluster (two bonds and the angle they form)\n2 = part of a 2-atom SHAKE cluster with a single bond\n3 = part of a 3-atom SHAKE cluster with two bonds\n4 = part of a 4-atom SHAKE cluster with three bonds\n\n\nShake Atoms section:\n\none line per atom\nline syntax: ID a b c d\na,b,c,d = IDs of atoms in cluster\n\nThis section is only needed when molecules created using the template\nwill be constrained by SHAKE via the “fix shake” command.  The other\ntwo Shake sections must also appear in the file.\nThe a,b,c,d values are atom IDs (from 1 to Natoms) for all the atoms\nin the SHAKE cluster that this atom belongs to.  The number of values\nthat must appear is determined by the shake flag for the atom (see the\nShake Flags section above).  All atoms in a particular cluster should\nlist their a,b,c,d values identically.\nIf flag = 0, no a,b,c,d values are listed on the line, just the\n(ignored) ID.\nIf flag = 1, a,b,c are listed, where a = ID of central atom in the\nangle, and b,c the other two atoms in the angle.\nIf flag = 2, a,b are listed, where a = ID of atom in bond with the\nlowest ID, and b = ID of atom in bond with the highest ID.\nIf flag = 3, a,b,c are listed, where a = ID of central atom,\nand b,c = IDs of other two atoms bonded to the central atom.\nIf flag = 4, a,b,c,d are listed, where a = ID of central atom,\nand b,c,d = IDs of other three atoms bonded to the central atom.\nSee the fix shake doc page for a further description\nof SHAKE clusters.\n\nShake Bond Types section:\n\none line per atom\nline syntax: ID a b c\na,b,c = bond types (or angle type) of bonds (or angle) in cluster\n\nThis section is only needed when molecules created using the template\nwill be constrained by SHAKE via the “fix shake” command.  The other\ntwo Shake sections must also appear in the file.\nThe a,b,c values are bond types (from 1 to Nbondtypes) for all bonds\nin the SHAKE cluster that this atom belongs to.  The number of values\nthat must appear is determined by the shake flag for the atom (see the\nShake Flags section above).  All atoms in a particular cluster should\nlist their a,b,c values identically.\nIf flag = 0, no a,b,c values are listed on the line, just the\n(ignored) ID.\nIf flag = 1, a,b,c are listed, where a = bondtype of the bond between\nthe central atom and the first non-central atom (value b in the Shake\nAtoms section), b = bondtype of the bond between the central atom and\nthe 2nd non-central atom (value c in the Shake Atoms section), and c =\nthe angle type (1 to Nangletypes) of the angle between the 3 atoms.\nIf flag = 2, only a is listed, where a = bondtype of the bond between\nthe 2 atoms in the cluster.\nIf flag = 3, a,b are listed, where a = bondtype of the bond between\nthe central atom and the first non-central atom (value b in the Shake\nAtoms section), and b = bondtype of the bond between the central atom\nand the 2nd non-central atom (value c in the Shake Atoms section).\nIf flag = 4, a,b,c are listed, where a = bondtype of the bond between\nthe central atom and the first non-central atom (value b in the Shake\nAtoms section), b = bondtype of the bond between the central atom and\nthe 2nd non-central atom (value c in the Shake Atoms section), and c =\nbondtype of the bond between the central atom and the 3rd non-central\natom (value d in the Shake Atoms section).\nSee the fix shake doc page for a further description\nof SHAKE clusters.",
    "syntax": "molecule ID file1 keyword values ... file2 keyword values ... fileN ...",
    "parameters": " * ID = user-assigned name for the molecule template\n * file1,file2,… = names of files containing molecule descriptions\n * zero or more keyword/value pairs may be appended after each file\n * keyword = offset or toff or boff or aoff or doff or ioff or scale\n * offset values = Toff Boff Aoff Doff Ioff\n *   Toff = offset to add to atom types\n *   Boff = offset to add to bond types\n *   Aoff = offset to add to angle types\n *   Doff = offset to add to dihedral types\n *   Ioff = offset to add to improper types\n * toff value = Toff\n *   Toff = offset to add to atom types\n * boff value = Boff\n *   Boff = offset to add to bond types\n * aoff value = Aoff\n *   Aoff = offset to add to angle types\n * doff value = Doff\n *   Doff = offset to add to dihedral types\n * ioff value = Ioff\n *   Ioff = offset to add to improper types\n * scale value = sfactor\n *   sfactor = scale factor to apply to the size and mass of the molecule",
    "examples": "molecule 1 mymol.txt\nmolecule 1 co2.txt h2o.txt\nmolecule CO2 co2.txt boff 3 aoff 2\nmolecule 1 mymol.txt offset 6 9 18 23 14\nmolecule objects file.1 scale 1.5 file.1 scale 2.0 file.2 scale 1.3",
    "restrictions": "This command must come after the simulation box is define by a\nread_data, read_restart, or\ncreate_box command."
},
{
    "command": "neb",
    "html_filename": "neb.html",
    "short_description": "Perform a nudged elastic band (NEB) calculation using multiple replicas of a system",
    "description": "Perform a nudged elastic band (NEB) calculation using multiple\nreplicas of a system.  Two or more replicas must be used; the first\nand last are the end points of the transition path.\nNEB is a method for finding both the atomic configurations and height\nof the energy barrier associated with a transition state, e.g. for an\natom to perform a diffusive hop from one energy basin to another in a\ncoordinated fashion with its neighbors.  The implementation in LAMMPS\nfollows the discussion in these 4 papers: (HenkelmanA),\n(HenkelmanB), (Nakano) and (Maras).\nEach replica runs on a partition of one or more processors.  Processor\npartitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\ncan run a multi-replica simulation with more replicas (partitions)\nthan you have physical processors, e.g you can run a 10-replica\nsimulation on just one or two processors.  You will simply not get the\nperformance speed-up you would see with one or more physical\nprocessors per replica.  See the Howto replica\ndoc page for further discussion.\n\nNote\nAs explained below, a NEB calculation performs a damped dynamics\nminimization across all the replicas.  The minimizer uses whatever\ntimestep you have defined in your input script, via the\ntimestep command.  Often NEB will converge more\nquickly if you use a timestep about 10x larger than you would normally\nuse for dynamics simulations.\n\nWhen a NEB calculation is performed, it is assumed that each replica\nis running the same system, though LAMMPS does not check for this.\nI.e. the simulation domain, the number of atoms, the interaction\npotentials, and the starting configuration when the neb command is\nissued should be the same for every replica.\nIn a NEB calculation each replica is connected to other replicas by\ninter-replica nudging forces.  These forces are imposed by the fix neb command, which must be used in conjunction with the\nneb command.  The group used to define the fix neb command defines the\nNEB atoms which are the only ones that inter-replica springs are\napplied to.  If the group does not include all atoms, then non-NEB\natoms have no inter-replica springs and the forces they feel and their\nmotion is computed in the usual way due only to other atoms within\ntheir replica.  Conceptually, the non-NEB atoms provide a background\nforce field for the NEB atoms.  They can be allowed to move during the\nNEB minimization procedure (which will typically induce different\ncoordinates for non-NEB atoms in different replicas), or held fixed\nusing other LAMMPS commands such as fix setforce.\nNote that the partition command can be used to invoke\na command on a subset of the replicas, e.g. if you wish to hold NEB or\nnon-NEB atoms fixed in only the end-point replicas.\nThe initial atomic configuration for each of the replicas can be\nspecified in different manners via the file-style setting, as\ndiscussed below.  Only atoms whose initial coordinates should differ\nfrom the current configuration need be specified.\nConceptually, the initial and final configurations for the first\nreplica should be states on either side of an energy barrier.\nAs explained below, the initial configurations of intermediate\nreplicas can be atomic coordinates interpolated in a linear fashion\nbetween the first and last replicas.  This is often adequate for\nsimple transitions.  For more complex transitions, it may lead to slow\nconvergence or even bad results if the minimum energy path (MEP, see\nbelow) of states over the barrier cannot be correctly converged to\nfrom such an initial path.  In this case, you will want to generate\ninitial states for the intermediate replicas that are geometrically\ncloser to the MEP and read them in.\n\nFor a file-style setting of final, a filename is specified which\ncontains atomic coordinates for zero or more atoms, in the format\ndescribed below.  For each atom that appears in the file, the new\ncoordinates are assigned to that atom in the final replica.  Each\nintermediate replica also assigns a new position to that atom in an\ninterpolated manner.  This is done by using the current position of\nthe atom as the starting point and the read-in position as the final\npoint.  The distance between them is calculated, and the new position\nis assigned to be a fraction of the distance.  E.g. if there are 10\nreplicas, the 2nd replica will assign a position that is 10% of the\ndistance along a line between the starting and final point, and the\n9th replica will assign a position that is 90% of the distance along\nthe line.  Note that for this procedure to produce consistent\ncoordinates across all the replicas, the current coordinates need to\nbe the same in all replicas.  LAMMPS does not check for this, but\ninvalid initial configurations will likely result if it is not the\ncase.\n\nNote\nThe “distance” between the starting and final point is\ncalculated in a minimum-image sense for a periodic simulation box.\nThis means that if the two positions are on opposite sides of a box\n(periodic in that dimension), the distance between them will be small,\nbecause the periodic image of one of the atoms is close to the other.\nSimilarly, even if the assigned position resulting from the\ninterpolation is outside the periodic box, the atom will be wrapped\nback into the box when the NEB calculation begins.\n\nFor a file-style setting of each, a filename is specified which is\nassumed to be unique to each replica.  This can be done by using a\nvariable in the filename, e.g.\nvariable i equal part\nneb 0.0 0.001 1000 500 50 each coords.initial.$i\n\n\nwhich in this case will substitute the partition ID (0 to N-1) for the\nvariable I, which is also effectively the replica ID.  See the\nvariable command for other options, such as using\nworld-, universe-, or uloop-style variables.\nEach replica (except the first replica) will read its file, formatted\nas described below, and for any atom that appears in the file, assign\nthe specified coordinates to its atom.  The various files do not need\nto contain the same set of atoms.\nFor a file-style setting of none, no filename is specified.  Each\nreplica is assumed to already be in its initial configuration at the\ntime the neb command is issued.  This allows each replica to define\nits own configuration by reading a replica-specific data or restart or\ndump file, via the read_data,\nread_restart, or read_dump\ncommands.  The replica-specific names of these files can be specified\nas in the discussion above for the each file-style.  Also see the\nsection below for how a NEB calculation can produce restart files, so\nthat a long calculation can be restarted if needed.\n\nNote\nNone of the file-style settings change the initial\nconfiguration of any atom in the first replica.  The first replica\nmust thus be in the correct initial configuration at the time the neb\ncommand is issued.\n\n\nA NEB calculation proceeds in two stages, each of which is a\nminimization procedure, performed via damped dynamics.  To enable\nthis, you must first define a damped dynamics\nmin_style, such as quickmin or fire.  The cg,\nsd, and hftn styles cannot be used, since they perform iterative\nline searches in their inner loop, which cannot be easily synchronized\nacross multiple replicas.\nThe minimizer tolerances for energy and force are set by etol and\nftol, the same as for the minimize command.\nA non-zero etol means that the NEB calculation will terminate if the\nenergy criterion is met by every replica.  The energies being compared\nto etol do not include any contribution from the inter-replica\nnudging forces, since these are non-conservative.  A non-zero ftol\nmeans that the NEB calculation will terminate if the force criterion\nis met by every replica.  The forces being compared to ftol include\nthe inter-replica nudging forces.\nThe maximum number of iterations in each stage is set by N1 and\nN2.  These are effectively timestep counts since each iteration of\ndamped dynamics is like a single timestep in a dynamics\nrun.  During both stages, the potential energy of each\nreplica and its normalized distance along the reaction path (reaction\ncoordinate RD) will be printed to the screen and log file every\nNevery timesteps.  The RD is 0 and 1 for the first and last replica.\nFor intermediate replicas, it is the cumulative distance (normalized\nby the total cumulative distance) between adjacent replicas, where\n“distance” is defined as the length of the 3N-vector of differences in\natomic coordinates, where N is the number of NEB atoms involved in the\ntransition.  These outputs allow you to monitor NEB’s progress in\nfinding a good energy barrier.  N1 and N2 must both be multiples\nof Nevery.\nIn the first stage of NEB, the set of replicas should converge toward\na minimum energy path (MEP) of conformational states that transition\nover a barrier.  The MEP for a transition is defined as a sequence of\n3N-dimensional states, each of which has a potential energy gradient\nparallel to the MEP itself.  The configuration of highest energy along\na MEP corresponds to a saddle point.  The replica states will also be\nroughly equally spaced along the MEP due to the inter-replica nudging\nforce added by the fix neb command.\nIn the second stage of NEB, the replica with the highest energy is\nselected and the inter-replica forces on it are converted to a force\nthat drives its atom coordinates to the top or saddle point of the\nbarrier, via the barrier-climbing calculation described in\n(HenkelmanB).  As before, the other replicas rearrange\nthemselves along the MEP so as to be roughly equally spaced.\nWhen both stages are complete, if the NEB calculation was successful,\nthe configurations of the replicas should be along (close to) the MEP\nand the replica with the highest energy should be an atomic\nconfiguration at (close to) the saddle point of the transition. The\npotential energies for the set of replicas represents the energy\nprofile of the transition along the MEP.\n\nA few other settings in your input script are required or advised to\nperform a NEB calculation.  See the NOTE about the choice of timestep\nat the beginning of this doc page.\nAn atom map must be defined which it is not by default for atom_style atomic problems.  The atom_modify map command can be used to do this.\nThe minimizers in LAMMPS operate on all atoms in your system, even\nnon-NEB atoms, as defined above.  To prevent non-NEB atoms from moving\nduring the minimization, you should use the fix setforce command to set the force on each of those\natoms to 0.0.  This is not required, and may not even be desired in\nsome cases, but if those atoms move too far (e.g. because the initial\nstate of your system was not well-minimized), it can cause problems\nfor the NEB procedure.\nThe damped dynamics minimizers, such as quickmin\nand fire), adjust the position and velocity of the atoms via an\nEuler integration step.  Thus you must define an appropriate\ntimestep to use with NEB.  As mentioned above, NEB\nwill often converge more quickly if you use a timestep about 10x\nlarger than you would normally use for dynamics simulations.\n\nEach file read by the neb command containing atomic coordinates used\nto initialize one or more replicas must be formatted as follows.\nThe file can be ASCII text or a gzipped text file (detected by a .gz\nsuffix).  The file can contain initial blank lines or comment lines\nstarting with “#” which are ignored.  The first non-blank, non-comment\nline should list N = the number of lines to follow.  The N successive\nlines contain the following information:\nID1 x1 y1 z1\nID2 x2 y2 z2\n...\nIDN xN yN zN\n\n\nThe fields are the atom ID, followed by the x,y,z coordinates.  The\nlines can be listed in any order.  Additional trailing information on\nthe line is OK, such as a comment.\nNote that for a typical NEB calculation you do not need to specify\ninitial coordinates for very many atoms to produce differing starting\nand final replicas whose intermediate replicas will converge to the\nenergy barrier.  Typically only new coordinates for atoms\ngeometrically near the barrier need be specified.\nAlso note there is no requirement that the atoms in the file\ncorrespond to the NEB atoms in the group defined by the fix neb command.  Not every NEB atom need be in the file,\nand non-NEB atoms can be listed in the file.\n\nFour kinds of output can be generated during a NEB calculation: energy\nbarrier statistics, thermodynamic output by each replica, dump files,\nand restart files.\nWhen running with multiple partitions (each of which is a replica in\nthis case), the print-out to the screen and master log.lammps file\ncontains a line of output, printed once every Nevery timesteps.  It\ncontains the timestep, the maximum force per replica, the maximum\nforce per atom (in any replica), potential gradients in the initial,\nfinal, and climbing replicas, the forward and backward energy\nbarriers, the total reaction coordinate (RDT), and the normalized\nreaction coordinate and potential energy of each replica.\nThe “maximum force per replica” is the two-norm of the 3N-length force\nvector for the atoms in each replica, maximized across replicas, which\nis what the ftol setting is checking against.  In this case, N is\nall the atoms in each replica.  The “maximum force per atom” is the\nmaximum force component of any atom in any replica.  The potential\ngradients are the two-norm of the 3N-length force vector solely due to\nthe interaction potential i.e.  without adding in inter-replica\nforces.\nThe “reaction coordinate” (RD) for each replica is the two-norm of the\n3N-length vector of distances between its atoms and the preceding\nreplica’s atoms, added to the RD of the preceding replica. The RD of\nthe first replica RD1 = 0.0; the RD of the final replica RDN = RDT,\nthe total reaction coordinate.  The normalized RDs are divided by RDT,\nso that they form a monotonically increasing sequence from zero to\none. When computing RD, N only includes the atoms being operated on by\nthe fix neb command.\nThe forward (reverse) energy barrier is the potential energy of the\nhighest replica minus the energy of the first (last) replica.\nSupplementary information for all replicas can be printed out to the\nscreen and master log.lammps file by adding the verbose keyword. This\ninformation include the following.  The “path angle” (pathangle) for\nthe replica i which is the angle between the 3N-length vectors (Ri-1 -\nRi) and (Ri+1 - Ri) (where Ri is the atomic coordinates of replica\ni). A “path angle” of 180 indicates that replicas i-1, i and i+1 are\naligned.  “angletangrad” is the angle between the 3N-length tangent\nvector and the 3N-length force vector at image i. The tangent vector\nis calculated as in (HenkelmanA) for all intermediate\nreplicas and at R2 - R1 and RM - RM-1 for the first and last replica,\nrespectively.  “anglegrad” is the angle between the 3N-length energy\ngradient vector of replica i and that of replica i+1. It is not\ndefined for the final replica and reads nan.  gradV is the norm of the\nenergy gradient of image i.  ReplicaForce is the two-norm of the\n3N-length force vector (including nudging forces) for replica i.\nMaxAtomForce is the maximum force component of any atom in replica i.\nWhen a NEB calculation does not converge properly, the supplementary\ninformation can help understanding what is going wrong. For instance\nwhen the path angle becomes acute, the definition of tangent used in\nthe NEB calculation is questionable and the NEB cannot may diverge\n(Maras).\nWhen running on multiple partitions, LAMMPS produces additional log\nfiles for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For a\nNEB calculation, these contain the thermodynamic output for each\nreplica.\nIf dump commands in the input script define a filename\nthat includes a universe or uloop style variable,\nthen one dump file (per dump command) will be created for each\nreplica.  At the end of the NEB calculation, the final snapshot in\neach file will contain the sequence of snapshots that transition the\nsystem over the energy barrier.  Earlier snapshots will show the\nconvergence of the replicas to the MEP.\nLikewise, restart filenames can be specified with a\nuniverse or uloop style variable, to generate\nrestart files for each replica.  These may be useful if the NEB\ncalculation fails to converge properly to the MEP, and you wish to\nrestart the calculation from an intermediate point with altered\nparameters.\nThere are 2 Python scripts provided in the tools/python directory,\nneb_combine.py and neb_final.py, which are useful in analyzing output\nfrom a NEB calculation.  Assume a NEB simulation with M replicas, and\nthe NEB atoms labeled with a specific atom type.\nThe neb_combine.py script extracts atom coords for the NEB atoms from\nall M dump files and creates a single dump file where each snapshot\ncontains the NEB atoms from all the replicas and one copy of non-NEB\natoms from the first replica (presumed to be identical in other\nreplicas).  This can be visualized/animated to see how the NEB atoms\nrelax as the NEB calculation proceeds.\nThe neb_final.py script extracts the final snapshot from each of the M\ndump files to create a single dump file with M snapshots.  This can be\nvisualized to watch the system make its transition over the energy\nbarrier.\nTo illustrate, here are images from the final snapshot produced by the\nneb_combine.py script run on the dump files produced by the two\nexample input scripts in examples/neb.  Click on them to see a larger\nimage.",
    "syntax": "neb etol ftol N1 N2 Nevery file-style arg keyword",
    "parameters": " * etol = stopping tolerance for energy (energy units)\n * ftol = stopping tolerance for force (force units)\n * N1 = max # of iterations (timesteps) to run initial NEB\n * N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n * Nevery = print replica energies and reaction coordinates every this many timesteps\n * file-style = final or each or none\n * final arg = filename\n *   filename = file with initial coords for final replica\n *     coords for intermediate replicas are linearly interpolated\n *     between first and last replica\n * each arg = filename\n *   filename = unique filename for each replica (except first)\n *     with its initial coords\n * none arg = no argument all replicas assumed to already have\n *     their initial coords\n * keyword = verbose",
    "examples": "neb 0.1 0.0 1000 500 50 final coords.final\nneb 0.0 0.001 1000 500 50 each coords.initial.$i\nneb 0.0 0.001 1000 500 50 none verbose",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "neb/spin",
    "html_filename": "neb_spin.html",
    "short_description": "Perform a geodesic nudged elastic band (GNEB) calculation using multiple replicas of a system",
    "description": "Perform a geodesic nudged elastic band (GNEB) calculation using multiple\nreplicas of a system.  Two or more replicas must be used; the first\nand last are the end points of the transition path.\nGNEB is a method for finding both the spin configurations and height\nof the energy barrier associated with a transition state, e.g.\nspins to perform a collective rotation from one energy basin to\nanother.\nThe implementation in LAMMPS follows the discussion in the\nfollowing paper: (BessarabA).\nEach replica runs on a partition of one or more processors.  Processor\npartitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\ncan run a multi-replica simulation with more replicas (partitions)\nthan you have physical processors, e.g you can run a 10-replica\nsimulation on just one or two processors.  You will simply not get the\nperformance speed-up you would see with one or more physical\nprocessors per replica.  See the Howto replica\ndoc page for further discussion.\n\nNote\nAs explained below, a GNEB calculation performs a\nminimization across all the replicas. One of the spin\nstyle minimizers has to be defined in your input script.\n\nWhen a GNEB calculation is performed, it is assumed that each replica\nis running the same system, though LAMMPS does not check for this.\nI.e. the simulation domain, the number of magnetic atoms, the\ninteraction potentials, and the starting configuration when the neb\ncommand is issued should be the same for every replica.\nIn a GNEB calculation each replica is connected to other replicas by\ninter-replica nudging forces.  These forces are imposed by the fix neb/spin command, which must be used in conjunction\nwith the neb command.\nThe group used to define the fix neb/spin command defines the\nGNEB magnetic atoms which are the only ones that inter-replica springs\nare applied to.\nIf the group does not include all magnetic atoms, then non-GNEB\nmagnetic atoms have no inter-replica springs and the torques they feel\nand their precession motion is computed in the usual way due only\nto other magnetic atoms within their replica.\nConceptually, the non-GNEB atoms provide a background force field for\nthe GNEB atoms.\nTheir magnetic spins can be allowed to evolve during the GNEB\nminimization procedure.\nThe initial spin configuration for each of the replicas can be\nspecified in different manners via the file-style setting, as\ndiscussed below.  Only atomic spins whose initial coordinates should\ndiffer from the current configuration need to be specified.\nConceptually, the initial and final configurations for the first\nreplica should be states on either side of an energy barrier.\nAs explained below, the initial configurations of intermediate\nreplicas can be spin coordinates interpolated in a linear fashion\nbetween the first and last replicas.  This is often adequate for\nsimple transitions.  For more complex transitions, it may lead to slow\nconvergence or even bad results if the minimum energy path (MEP, see\nbelow) of states over the barrier cannot be correctly converged to\nfrom such an initial path.  In this case, you will want to generate\ninitial states for the intermediate replicas that are geometrically\ncloser to the MEP and read them in.\n\nFor a file-style setting of final, a filename is specified which\ncontains atomic and spin coordinates for zero or more atoms, in the\nformat described below.\nFor each atom that appears in the file, the new coordinates are\nassigned to that atom in the final replica.  Each intermediate replica\nalso assigns a new spin to that atom in an interpolated manner.\nThis is done by using the current direction of the spin at the starting\npoint and the read-in direction as the final point.\nThe “angular distance” between them is calculated, and the new direction\nis assigned to be a fraction of the angular distance.\n\nNote\nThe “angular distance” between the starting and final point is\nevaluated in the geodesic sense, as described in\n(BessarabA).\n\n\nNote\nThe angular interpolation between the starting and final point\nis achieved using Rodrigues formula:\n\n\n\\[\\vec{m}_i^{\\nu} = \\vec{m}_i^{I} \\cos(\\omega_i^{\\nu})\n+ (\\vec{k}_i \\times \\vec{m}_i^{I}) \\sin(\\omega_i^{\\nu})\n+ (1.0-\\cos(\\omega_i^{\\nu})) \\vec{k}_i (\\vec{k}_i\\cdot\n\\vec{m}_i^{I})\\]\nwhere \\(\\vec{m}_i^I\\) is the initial spin configuration for\nspin i, \\(\\omega_i^{\\nu}\\) is a rotation angle defined as:\n\n\\[\\omega_i^{\\nu} = (\\nu - 1) \\Delta \\omega_i {\\rm ~~and~~} \\Delta \\omega_i = \\frac{\\omega_i}{Q-1}\\]\nwith \\(\\nu\\) the image number, Q the total number of images, and\n\\(\\omega_i\\) the total rotation between the initial and final spins.\n\\(\\vec{k}_i\\) defines a rotation axis such as:\n\n\\[\\vec{k}_i =  \\frac{\\vec{m}_i^I \\times \\vec{m}_i^F}{\\left|\\vec{m}_i^I \\times \\vec{m}_i^F\\right|}\\]\nif the initial and final spins are not aligned.\nIf the initial and final spins are aligned, then their cross\nproduct is null, and the expression above does not apply.\nIf they point toward the same direction, the intermediate images\nconserve the same orientation.\nIf the initial and final spins are aligned, but point toward\nopposite directions, an arbitrary rotation vector belonging to\nthe plane perpendicular to initial and final spins is chosen.\nIn this case, a warning message is displayed.\nFor a file-style setting of each, a filename is specified which is\nassumed to be unique to each replica.\nSee the neb documentation page for more information about this\noption.\nFor a file-style setting of none, no filename is specified.  Each\nreplica is assumed to already be in its initial configuration at the\ntime the neb command is issued.  This allows each replica to define\nits own configuration by reading a replica-specific data or restart or\ndump file, via the read_data,\nread_restart, or read_dump\ncommands.  The replica-specific names of these files can be specified\nas in the discussion above for the each file-style.  Also see the\nsection below for how a NEB calculation can produce restart files, so\nthat a long calculation can be restarted if needed.\n\nNote\nNone of the file-style settings change the initial\nconfiguration of any atom in the first replica.  The first replica\nmust thus be in the correct initial configuration at the time the neb\ncommand is issued.\n\n\nA NEB calculation proceeds in two stages, each of which is a\nminimization procedure.  To enable\nthis, you must first define a\nmin_style, using either the spin,\nspin/cg, or spin/lbfgs style (see\nmin_spin for more information).\nThe other styles cannot be used, since they relax the lattice\ndegrees of freedom instead of the spins.\nThe minimizer tolerances for energy and force are set by etol and\nttol, the same as for the minimize command.\nA non-zero etol means that the GNEB calculation will terminate if the\nenergy criterion is met by every replica.  The energies being compared\nto etol do not include any contribution from the inter-replica\nnudging forces, since these are non-conservative.  A non-zero ttol\nmeans that the GNEB calculation will terminate if the torque criterion\nis met by every replica.  The torques being compared to ttol include\nthe inter-replica nudging forces.\nThe maximum number of iterations in each stage is set by N1 and\nN2.  These are effectively timestep counts since each iteration of\ndamped dynamics is like a single timestep in a dynamics\nrun.  During both stages, the potential energy of each\nreplica and its normalized distance along the reaction path (reaction\ncoordinate RD) will be printed to the screen and log file every\nNevery timesteps.  The RD is 0 and 1 for the first and last replica.\nFor intermediate replicas, it is the cumulative angular distance\n(normalized by the total cumulative angular distance) between adjacent\nreplicas, where “distance” is defined as the length of the 3N-vector of\nthe geodesic distances in spin coordinates, with N the number of\nGNEB spins involved (see equation (13) in (BessarabA)).\nThese outputs allow you to monitor NEB’s progress in\nfinding a good energy barrier.  N1 and N2 must both be multiples\nof Nevery.\nIn the first stage of GNEB, the set of replicas should converge toward\na minimum energy path (MEP) of conformational states that transition\nover a barrier.  The MEP for a transition is defined as a sequence of\n3N-dimensional spin states, each of which has a potential energy\ngradient parallel to the MEP itself.\nThe configuration of highest energy along a MEP corresponds to a saddle\npoint.  The replica states will also be roughly equally spaced along\nthe MEP due to the inter-replica nudging force added by the\nfix neb command.\nIn the second stage of GNEB, the replica with the highest energy is\nselected and the inter-replica forces on it are converted to a force\nthat drives its spin coordinates to the top or saddle point of the\nbarrier, via the barrier-climbing calculation described in\n(BessarabA).  As before, the other replicas rearrange\nthemselves along the MEP so as to be roughly equally spaced.\nWhen both stages are complete, if the GNEB calculation was successful,\nthe configurations of the replicas should be along (close to) the MEP\nand the replica with the highest energy should be a spin\nconfiguration at (close to) the saddle point of the transition. The\npotential energies for the set of replicas represents the energy\nprofile of the transition along the MEP.\n\nAn atom map must be defined which it is not by default for atom_style atomic problems.  The atom_modify map command can be used to do this.\nAn initial value can be defined for the timestep. Although, the spin\nminimization algorithm is an adaptive timestep methodology, so that\nthis timestep is likely to evolve during the calculation.\nThe minimizers in LAMMPS operate on all spins in your system, even\nnon-GNEB atoms, as defined above.\n\nEach file read by the neb/spin command containing spin coordinates used\nto initialize one or more replicas must be formatted as follows.\nThe file can be ASCII text or a gzipped text file (detected by a .gz\nsuffix).  The file can contain initial blank lines or comment lines\nstarting with “#” which are ignored.  The first non-blank, non-comment\nline should list N = the number of lines to follow.  The N successive\nlines contain the following information:\nID1 g1 x1 y1 z1 sx1 sy1 sz1\nID2 g2 x2 y2 z2 sx2 sy2 sz2\n...\nIDN gN yN zN sxN syN szN\n\n\nThe fields are the atom ID, the norm of the associated magnetic spin,\nfollowed by the x,y,z coordinates and the sx,sy,sz spin coordinates.\nThe lines can be listed in any order.  Additional trailing information on\nthe line is OK, such as a comment.\nNote that for a typical GNEB calculation you do not need to specify\ninitial spin coordinates for very many atoms to produce differing starting\nand final replicas whose intermediate replicas will converge to the\nenergy barrier.  Typically only new spin coordinates for atoms\ngeometrically near the barrier need be specified.\nAlso note there is no requirement that the atoms in the file\ncorrespond to the GNEB atoms in the group defined by the fix neb command.  Not every GNEB atom need be in the file,\nand non-GNEB atoms can be listed in the file.\n\nFour kinds of output can be generated during a GNEB calculation: energy\nbarrier statistics, thermodynamic output by each replica, dump files,\nand restart files.\nWhen running with multiple partitions (each of which is a replica in\nthis case), the print-out to the screen and master log.lammps file\ncontains a line of output, printed once every Nevery timesteps.  It\ncontains the timestep, the maximum torque per replica, the maximum\ntorque per atom (in any replica), potential gradients in the initial,\nfinal, and climbing replicas, the forward and backward energy\nbarriers, the total reaction coordinate (RDT), and the normalized\nreaction coordinate and potential energy of each replica.\nThe “maximum torque per replica” is the two-norm of the\n3N-length vector given by the cross product of a spin by its\nprecession vector omega, in each replica, maximized across replicas,\nwhich is what the ttol setting is checking against.  In this case, N is\nall the atoms in each replica.  The “maximum torque per atom” is the\nmaximum torque component of any atom in any replica.  The potential\ngradients are the two-norm of the 3N-length magnetic precession vector\nsolely due to the interaction potential i.e. without adding in\ninter-replica forces, and projected along the path tangent (as detailed\nin Appendix D of (BessarabA)).\nThe “reaction coordinate” (RD) for each replica is the two-norm of the\n3N-length vector of geodesic distances between its spins and the preceding\nreplica’s spins (see equation (13) of (BessarabA)), added to\nthe RD of the preceding replica. The RD of the first replica RD1 = 0.0;\nthe RD of the final replica RDN = RDT, the total reaction coordinate.\nThe normalized RDs are divided by RDT, so that they form a monotonically\nincreasing sequence from zero to one. When computing RD, N only includes\nthe spins being operated on by the fix neb/spin command.\nThe forward (reverse) energy barrier is the potential energy of the\nhighest replica minus the energy of the first (last) replica.\nSupplementary information for all replicas can be printed out to the\nscreen and master log.lammps file by adding the verbose keyword. This\ninformation include the following.\nThe “GradVidottan” are the projections of the potential gradient for\nthe replica i on its tangent vector (as detailed in Appendix D of\n(BessarabA)).\nThe “DNi” are the non normalized geodesic distances (see equation (13)\nof (BessarabA)), between a replica i and the next replica\ni+1. For the last replica, this distance is not defined and a “NAN”\nvalue is the corresponding output.\nWhen a NEB calculation does not converge properly, the supplementary\ninformation can help understanding what is going wrong.\nWhen running on multiple partitions, LAMMPS produces additional log\nfiles for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For a\nGNEB calculation, these contain the thermodynamic output for each\nreplica.\nIf dump commands in the input script define a filename\nthat includes a universe or uloop style variable,\nthen one dump file (per dump command) will be created for each\nreplica.  At the end of the GNEB calculation, the final snapshot in\neach file will contain the sequence of snapshots that transition the\nsystem over the energy barrier.  Earlier snapshots will show the\nconvergence of the replicas to the MEP.\nLikewise, restart filenames can be specified with a\nuniverse or uloop style variable, to generate\nrestart files for each replica.  These may be useful if the GNEB\ncalculation fails to converge properly to the MEP, and you wish to\nrestart the calculation from an intermediate point with altered\nparameters.\nA c file script in provided in the tool/spin/interpolate_gneb\ndirectory, that interpolates the MEP given the information provided\nby the verbose output option (as detailed in Appendix D of\n(BessarabA)).",
    "syntax": "neb/spin etol ttol N1 N2 Nevery file-style arg keyword",
    "parameters": " * etol = stopping tolerance for energy (energy units)\n * ttol = stopping tolerance for torque ( units)\n * N1 = max # of iterations (timesteps) to run initial NEB\n * N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n * Nevery = print replica energies and reaction coordinates every this many timesteps\n * file-style = final or each or none\n * final arg = filename\n *   filename = file with initial coords for final replica\n *     coords for intermediate replicas are linearly interpolated\n *     between first and last replica\n * each arg = filename\n *   filename = unique filename for each replica (except first)\n *     with its initial coords\n * none arg = no argument all replicas assumed to already have\n *     their initial coords\n * keyword = verbose\n * verbose = print supplemental information",
    "examples": "neb/spin 0.1 0.0 1000 500 50 final coords.final\nneb/spin 0.0 0.001 1000 500 50 each coords.initial.$i\nneb/spin 0.0 0.001 1000 500 50 none verbose",
    "restrictions": "This command can only be used if LAMMPS was built with the SPIN\npackage.  See the Build package doc\npage for more info.\nFor magnetic GNEB calculations, only the spin_none value for the\nline keyword can be used when minimization styles spin/cg and\nspin/lbfgs are employed."
},
{
    "command": "neigh_modify",
    "html_filename": "neigh_modify.html",
    "short_description": "This command sets parameters that affect the building and use of pairwise neighbor lists",
    "description": "This command sets parameters that affect the building and use of\npairwise neighbor lists.  Depending on what pair interactions and\nother commands are defined, a simulation may require one or more\nneighbor lists.\nThe every, delay, check, and once options affect how often\nlists are built as a simulation runs.  The delay setting means never\nbuild new lists until at least N steps after the previous build.  The\nevery setting means build lists every M steps (after the delay has\npassed).  If the check setting is no, the lists are built on the\nfirst step that satisfies the delay and every settings.  If the\ncheck setting is yes, then the every and delay settings\ndetermine when a build may possibly be performed, but an actual build\nonly occurs if some atom has moved more than half the skin distance\n(specified in the neighbor command) since the last\nbuild.\nIf the once setting is yes, then the neighbor list is only built\nonce at the beginning of each run, and never rebuilt, except on steps\nwhen a restart file is written, or steps when a fix forces a rebuild\nto occur (e.g. fixes that create or delete atoms, such as fix deposit or fix evaporate).\nThis setting should only be made if you are certain atoms will not\nmove far enough that the neighbor list should be rebuilt, e.g. running\na simulation of a cold crystal.  Note that it is not that expensive to\ncheck if neighbor lists should be rebuilt.\nWhen the rRESPA integrator is used (see the run_style\ncommand), the every and delay parameters refer to the longest\n(outermost) timestep.\nThe cluster option does a sanity test every time neighbor lists are\nbuilt for bond, angle, dihedral, and improper interactions, to check\nthat each set of 2, 3, or 4 atoms is a cluster of nearby atoms.  It\ndoes this by computing the distance between pairs of atoms in the\ninteraction and insuring they are not further apart than half the\nperiodic box length.  If they are, an error is generated, since the\ninteraction would be computed between far-away atoms instead of their\nnearby periodic images.  The only way this should happen is if the\npairwise cutoff is so short that atoms that are part of the same\ninteraction are not communicated as ghost atoms.  This is an unusual\nmodel (e.g. no pair interactions at all) and the problem can be fixed\nby use of the comm_modify cutoff command.  Note\nthat to save time, the default cluster setting is no, so that this\ncheck is not performed.\nThe include option limits the building of pairwise neighbor lists to\natoms in the specified group.  This can be useful for models where a\nlarge portion of the simulation is particles that do not interact with\nother particles or with each other via pairwise interactions.  The\ngroup specified with this option must also be specified via the\natom_modify first command.  Note that specifying\n“all” as the group-ID effectively turns off the include option.\nThe exclude option turns off pairwise interactions between certain\npairs of atoms, by not including them in the neighbor list.  These are\nsample scenarios where this is useful:\n\nIn crack simulations, pairwise interactions can be shut off between 2\nslabs of atoms to effectively create a crack.\nWhen a large collection of atoms is treated as frozen, interactions\nbetween those atoms can be turned off to save needless\ncomputation. E.g. Using the fix setforce command\nto freeze a wall or portion of a bio-molecule.\nWhen one or more rigid bodies are specified, interactions within each\nbody can be turned off to save needless computation.  See the fix rigid command for more details.\n\nThe exclude type option turns off the pairwise interaction if one\natom is of type M and the other of type N.  M can equal N.  The\nexclude group option turns off the interaction if one atom is in the\nfirst group and the other is the second.  Group1-ID can equal\ngroup2-ID.  The exclude molecule/intra option turns off the\ninteraction if both atoms are in the specified group and in the same\nmolecule, as determined by their molecule ID.  The exclude\nmolecule/inter turns off the interaction between pairs of atoms that\nhave different molecule IDs and are both in the specified group.\nEach of the exclude options can be specified multiple times.  The\nexclude type option is the most efficient option to use; it requires\nonly a single check, no matter how many times it has been specified.\nThe other exclude options are more expensive if specified multiple\ntimes; they require one check for each time they have been specified.\nNote that the exclude options only affect pairwise interactions; see\nthe delete_bonds command for information on\nturning off bond interactions.\n\nNote\nExcluding pairwise interactions will not work correctly when\nalso using a long-range solver via the\nkspace_style command.  LAMMPS will give a warning\nto this effect.  This is because the short-range pairwise interaction\nneeds to subtract off a term from the total energy for pairs whose\nshort-range interaction is excluded, to compensate for how the\nlong-range solver treats the interaction.  This is done correctly for\npairwise interactions that are excluded (or weighted) via the\nspecial_bonds command.  But it is not done for\ninteractions that are excluded via these neigh_modify exclude options.\n\nThe page and one options affect how memory is allocated for the\nneighbor lists.  For most simulations the default settings for these\noptions are fine, but if a very large problem is being run or a very\nlong cutoff is being used, these parameters can be tuned.  The indices\nof neighboring atoms are stored in “pages”, which are allocated one\nafter another as they fill up.  The size of each page is set by the\npage value.  A new page is allocated when the next atom’s neighbors\ncould potentially overflow the list.  This threshold is set by the\none value which tells LAMMPS the maximum number of neighbor’s one\natom can have.\n\nNote\nLAMMPS can crash without an error message if the number of\nneighbors for a single particle is larger than the page setting,\nwhich means it is much, much larger than the one setting.  This is\nbecause LAMMPS doesn’t error check these limits for every pairwise\ninteraction (too costly), but only after all the particle’s neighbors\nhave been found.  This problem usually means something is very wrong\nwith the way you have setup your problem (particle spacing, cutoff\nlength, neighbor skin distance, etc).  If you really expect that many\nneighbors per particle, then boost the one and page settings\naccordingly.\n\nThe binsize option allows you to specify what size of bins will be\nused in neighbor list construction to sort and find neighboring atoms.\nBy default, for neighbor style bin, LAMMPS uses bins\nthat are 1/2 the size of the maximum pair cutoff.  For neighbor style multi, the bins are 1/2 the size of the minimum pair\ncutoff.  Typically these are good values for minimizing the time for\nneighbor list construction.  This setting overrides the default.\nIf you make it too big, there is little overhead due to\nlooping over bins, but more atoms are checked.  If you make it too\nsmall, the optimal number of atoms is checked, but bin overhead goes\nup.  If you set the binsize to 0.0, LAMMPS will use the default\nbinsize of 1/2 the cutoff.",
    "syntax": "neigh_modify keyword values ...",
    "parameters": " * one or more keyword/value pairs may be listed\n * keyword = delay or every or check or once or cluster or include or exclude or page or one or binsize\n *   delay value = N\n *     N = delay building until this many steps since last build\n *   every value = M\n *     M = build neighbor list every this many steps\n *   check value = yes or no\n *     yes = only build if some atom has moved half the skin distance or more\n *     no = always build on 1st step that every and delay are satisfied\n *   once\n *     yes = only build neighbor list once at start of run and never rebuild\n *     no = rebuild neighbor list according to other settings\n *   cluster\n *     yes = check bond,angle,etc neighbor list for nearby clusters\n *     no = do not check bond,angle,etc neighbor list for nearby clusters\n *   include value = group-ID\n *     group-ID = only build pair neighbor lists for atoms in this group\n *   exclude values:\n *     type M N\n *       M,N = exclude if one atom in pair is type M, other is type N\n *     group group1-ID group2-ID\n *       group1-ID,group2-ID = exclude if one atom is in 1st group, other in 2nd\n *     molecule/intra group-ID\n *       group-ID = exclude if both atoms are in the same molecule and in group\n *     molecule/inter group-ID\n *       group-ID = exclude if both atoms are in different molecules and in group\n *     none\n *       delete all exclude settings\n *   page value = N\n *     N = number of pairs stored in a single neighbor page\n *   one value = N\n *     N = max number of neighbors of one atom\n *   binsize value = size\n *     size = bin size for neighbor list construction (distance units)",
    "examples": "neigh_modify every 2 delay 10 check yes page 100000\nneigh_modify exclude type 2 3\nneigh_modify exclude group frozen frozen check no\nneigh_modify exclude group residue1 chain3\nneigh_modify exclude molecule/intra rigid",
    "restrictions": "If the “delay” setting is non-zero, then it must be a multiple of the\n“every” setting.\nThe molecule/intra and molecule/inter exclude options can only be used\nwith atom styles that define molecule IDs.\nThe value of the page setting must be at least 10x larger than the\none setting.  This insures neighbor pages are not mostly empty\nspace."
},
{
    "command": "neighbor",
    "html_filename": "neighbor.html",
    "short_description": "This command sets parameters that affect the building of pairwise neighbor lists",
    "description": "This command sets parameters that affect the building of pairwise\nneighbor lists.  All atom pairs within a neighbor cutoff distance\nequal to the their force cutoff plus the skin distance are stored in\nthe list.  Typically, the larger the skin distance, the less often\nneighbor lists need to be built, but more pairs must be checked for\npossible force interactions every timestep.  The default value for\nskin depends on the choice of units for the simulation; see the\ndefault values below.\nThe skin distance is also used to determine how often atoms migrate\nto new processors if the check option of the\nneigh_modify command is set to yes.  Atoms are\nmigrated (communicated) to new processors on the same timestep that\nneighbor lists are re-built.\nThe style value selects what algorithm is used to build the list.\nThe bin style creates the list by binning which is an operation that\nscales linearly with N/P, the number of atoms per processor where N =\ntotal number of atoms and P = number of processors.  It is almost\nalways faster than the nsq style which scales as (N/P)^2.  For\nunsolvated small molecules in a non-periodic box, the nsq choice can\nsometimes be faster.  Either style should give the same answers.\nThe multi style is a modified binning algorithm that is useful for\nsystems with a wide range of cutoff distances, e.g. due to different\nsize particles.  For the bin style, the bin size is set to 1/2 of\nthe largest cutoff distance between any pair of atom types and a\nsingle set of bins is defined to search over for all atom types.  This\ncan be inefficient if one pair of types has a very long cutoff, but\nother type pairs have a much shorter cutoff.  For style multi the\nbin size is set to 1/2 of the shortest cutoff distance and multiple\nsets of bins are defined to search over for different atom types.\nThis imposes some extra setup overhead, but the searches themselves\nmay be much faster for the short-cutoff cases.  See the comm_modify mode multi command for a communication option\nthat may also be beneficial for simulations of this kind.\nThe neigh_modify command has additional options\nthat control how often neighbor lists are built and which pairs are\nstored in the list.\nWhen a run is finished, counts of the number of neighbors stored in\nthe pairwise list and the number of times neighbor lists were built\nare printed to the screen and log file.  See the Run output doc page for details.",
    "syntax": "neighbor skin style",
    "parameters": " * skin = extra distance beyond force cutoff (distance units)\n * style = bin or nsq or multi",
    "examples": "neighbor 0.3 bin\nneighbor 2.0 nsq",
    "restrictions": "\nnone"
},
{
    "command": "newton",
    "html_filename": "newton.html",
    "short_description": "This command turns Newton’s 3rd law on or off for pairwise and bonded interactions",
    "description": "This command turns Newton’s 3rd law on or off for pairwise and\nbonded interactions.  For most problems, setting Newton’s 3rd law to\non means a modest savings in computation at the cost of two times\nmore communication.  Whether this is faster depends on problem size,\nforce cutoff lengths, a machine’s compute/communication ratio, and how\nmany processors are being used.\nSetting the pairwise newton flag to off means that if two\ninteracting atoms are on different processors, both processors compute\ntheir interaction and the resulting force information is not\ncommunicated.  Similarly, for bonded interactions, newton off means\nthat if a bond, angle, dihedral, or improper interaction contains\natoms on 2 or more processors, the interaction is computed by each\nprocessor.\nLAMMPS should produce the same answers for any newton flag settings,\nexcept for round-off issues.\nWith run_style respa and only bonded interactions\n(bond, angle, etc) computed in the innermost timestep, it may be\nfaster to turn newton off for bonded interactions, to avoid extra\ncommunication in the innermost loop.",
    "syntax": "newton flag",
    "parameters": " * newton flag1 flag2\n * flag = on or off for both pairwise and bonded interactions\n * flag1 = on or off for pairwise interactions\n * flag2 = on or off for bonded interactions",
    "examples": "newton off\nnewton on off",
    "restrictions": "The newton bond setting cannot be changed after the simulation box is\ndefined by a read_data or\ncreate_box command."
},
{
    "command": "next",
    "html_filename": "next.html",
    "short_description": "This command is used with variables defined by the variable command",
    "description": "This command is used with variables defined by the\nvariable command.  It assigns the next value to the\nvariable from the list of values defined for that variable by the\nvariable command.  Thus when that variable is\nsubsequently substituted for in an input script command, the new value\nis used.\nSee the variable command for info on how to define and\nuse different kinds of variables in LAMMPS input scripts.  If a\nvariable name is a single lower-case character from “a” to “z”, it can\nbe used in an input script command as $a or $z.  If it is multiple\nletters, it can be used as ${myTemp}.\nIf multiple variables are used as arguments to the next command,\nthen all must be of the same variable style: index, loop, file,\nuniverse, or uloop.  An exception is that universe- and\nuloop-style variables can be mixed in the same next command.\nAll the variables specified with the next command are incremented by\none value from their respective list of values.  A file-style\nvariable reads the next line from its associated file.  An\natomfile-style variable reads the next set of lines (one per atom)\nfrom its associated file.  String- or atom- or equal- or\nworld-style variables cannot be used with the next command,\nsince they only store a single value.\nWhen any of the variables in the next command has no more values, a\nflag is set that causes the input script to skip the next\njump command encountered.  This enables a loop containing\na next command to exit.  As explained in the variable\ncommand, the variable that has exhausted its values is also deleted.\nThis allows it to be used and re-defined later in the input script.\nFile-style and atomfile-style variables are exhausted when the\nend-of-file is reached.\nWhen the next command is used with index- or loop-style variables,\nthe next value is assigned to the variable for all processors.  When\nthe next command is used with file-style variables, the next line is\nread from its file and the string assigned to the variable.  When the\nnext command is used with atomfile-style variables, the next set of\nper-atom values is read from its file and assigned to the variable.\nWhen the next command is used with universe- or uloop-style\nvariables, all universe- or uloop-style variables must be listed\nin the next command.  This is because of the manner in which the\nincrementing is done, using a single lock file for all variables.  The\nnext value (for each variable) is assigned to whichever processor\npartition executes the command first.  All processors in the partition\nare assigned the same value(s).  Running LAMMPS on multiple partitions\nof processors via the -partition command-line switch.  Universe- and uloop-style variables are\nincremented using the files “tmp.lammps.variable” and\n“tmp.lammps.variable.lock” which you will see in your directory during\nand after such a LAMMPS run.\nHere is an example of running a series of simulations using the next\ncommand with an index-style variable.  If this input script is named\nin.polymer, 8 simulations would be run using data files from\ndirectories run1 through run8.\nvariable d index run1 run2 run3 run4 run5 run6 run7 run8\nshell cd $d\nread_data data.polymer\nrun 10000\nshell cd ..\nclear\nnext d\njump in.polymer\n\n\nIf the variable “d” were of style universe, and the same in.polymer\ninput script were run on 3 partitions of processors, then the first 3\nsimulations would begin, one on each set of processors.  Whichever\npartition finished first, it would assign variable “d” the 4th value\nand run another simulation, and so forth until all 8 simulations were\nfinished.\nJump and next commands can also be nested to enable multi-level loops.\nFor example, this script will run 15 simulations in a double loop.\nvariable i loop 3\n  variable j loop 5\n  clear\n  ...\n  read_data data.polymer.$i$j\n  print Running simulation $i.$j\n  run 10000\n  next j\n  jump in.script\nnext i\njump in.script\n\n\nHere is an example of a double loop which uses the if and\njump commands to break out of the inner loop when a\ncondition is met, then continues iterating through the outer loop.\nlabel       loopa\nvariable    a loop 5\n  label     loopb\n  variable  b loop 5\n  print     \"A,B = $a,$b\"\n  run       10000\n  if        $b > 2 then \"jump in.script break\"\n  next      b\n  jump      in.script loopb\nlabel       break\nvariable    b delete\n\nnext        a\njump        in.script loopa",
    "syntax": "next variables",
    "parameters": " * variables = one or more variable names",
    "examples": "next x\nnext a t x myTemp",
    "restrictions": "As described above."
},
{
    "command": "package",
    "html_filename": "package.html",
    "short_description": "This command invokes package-specific settings for the various accelerator packages available in LAMMPS",
    "description": "This command invokes package-specific settings for the various\naccelerator packages available in LAMMPS.  Currently the following\npackages use settings from this command: GPU, USER-INTEL, KOKKOS, and\nUSER-OMP.\nIf this command is specified in an input script, it must be near the\ntop of the script, before the simulation box has been defined.  This\nis because it specifies settings that the accelerator packages use in\ntheir initialization, before a simulation is defined.\nThis command can also be specified from the command-line when\nlaunching LAMMPS, using the “-pk” command-line switch.  The syntax is exactly the same as when used\nin an input script.\nNote that all of the accelerator packages require the package command\nto be specified (except the OPT package), if the package is to be used\nin a simulation (LAMMPS can be built with an accelerator package\nwithout using it in a particular simulation).  However, in all cases,\na default version of the command is typically invoked by other\naccelerator settings.\nThe KOKKOS package requires a “-k on” command-line switch respectively, which invokes a “package\nkokkos” command with default settings.\nFor the GPU, USER-INTEL, and USER-OMP packages, if a “-sf gpu” or “-sf\nintel” or “-sf omp” command-line switch is used to\nauto-append accelerator suffixes to various styles in the input\nscript, then those switches also invoke a “package gpu”, “package\nintel”, or “package omp” command with default settings.\n\nNote\nA package command for a particular style can be invoked multiple\ntimes when a simulation is setup, e.g. by the -c on, -k on, -sf, and -pk command-line switches, and by using this command\nin an input script.  Each time it is used all of the style options are\nset, either to default values or to specified settings.  I.e. settings\nfrom previous invocations do not persist across multiple invocations.\n\nSee the Speed packages doc page for more details\nabout using the various accelerator packages for speeding up LAMMPS\nsimulations.\n\nThe gpu style invokes settings associated with the use of the GPU\npackage.\nThe Ngpu argument sets the number of GPUs per node.  There must be\nat least as many MPI tasks per node as GPUs, as set by the mpirun or\nmpiexec command.  If there are more MPI tasks (per node)\nthan GPUs, multiple MPI tasks will share each GPU.\nOptional keyword/value pairs can also be specified.  Each has a\ndefault value as listed below.\nThe neigh keyword specifies where neighbor lists for pair style\ncomputation will be built.  If neigh is yes, which is the default,\nneighbor list building is performed on the GPU.  If neigh is no,\nneighbor list building is performed on the CPU.  GPU neighbor list\nbuilding currently cannot be used with a triclinic box.  GPU neighbor\nlists are not compatible with commands that are not GPU-enabled.  When\na non-GPU enabled command requires a neighbor list, it will also be\nbuilt on the CPU.  In these cases, it will typically be more efficient\nto only use CPU neighbor list builds.\nThe newton keyword sets the Newton flags for pairwise (not bonded)\ninteractions to off or on, the same as the newton\ncommand allows.  Currently, only an off value is allowed, since all\nthe GPU package pair styles require this setting.  This means more\ncomputation is done, but less communication.  In the future a value of\non may be allowed, so the newton keyword is included as an option\nfor compatibility with the package command for other accelerator\nstyles.  Note that the newton setting for bonded interactions is not\naffected by this keyword.\nThe binsize keyword sets the size of bins used to bin atoms in\nneighbor list builds performed on the GPU, if neigh = yes is set.\nIf binsize is set to 0.0 (the default), then bins = the size of the\npairwise cutoff + neighbor skin distance.  This is 2x larger than the\nLAMMPS default used for neighbor list building on the CPU.  This will\nbe close to optimal for the GPU, so you do not normally need to use\nthis keyword.  Note that if you use a longer-than-usual pairwise\ncutoff, e.g. to allow for a smaller fraction of KSpace work with a\nlong-range Coulombic solver because the GPU is\nfaster at performing pairwise interactions, then it may be optimal to\nmake the binsize smaller than the default.  For example, with a\ncutoff of 20*sigma in LJ units and a neighbor skin\ndistance of sigma, a binsize = 5.25*sigma can be more efficient than\nthe default.\nThe split keyword can be used for load balancing force calculations\nbetween CPU and GPU cores in GPU-enabled pair styles. If 0 < split <\n1.0, a fixed fraction of particles is offloaded to the GPU while force\ncalculation for the other particles occurs simultaneously on the CPU.\nIf split < 0.0, the optimal fraction (based on CPU and GPU timings)\nis calculated every 25 timesteps, i.e. dynamic load-balancing across\nthe CPU and GPU is performed.  If split = 1.0, all force\ncalculations for GPU accelerated pair styles are performed on the GPU.\nIn this case, other hybrid pair interactions,\nbond, angle,\ndihedral, improper, and\nlong-range calculations can be performed on the\nCPU while the GPU is performing force calculations for the GPU-enabled\npair style.  If all CPU force computations complete before the GPU\ncompletes, LAMMPS will block until the GPU has finished before\ncontinuing the timestep.\nAs an example, if you have two GPUs per node and 8 CPU cores per node,\nand would like to run on 4 nodes (32 cores) with dynamic balancing of\nforce calculation across CPU and GPU cores, you could specify\nmpirun -np 32 -sf gpu -in in.script    # launch command\npackage gpu 2 split -1                 # input script command\n\n\nIn this case, all CPU cores and GPU devices on the nodes would be\nutilized.  Each GPU device would be shared by 4 CPU cores. The CPU\ncores would perform force calculations for some fraction of the\nparticles at the same time the GPUs performed force calculation for\nthe other particles.\nThe gpuID keyword allows selection of which GPUs on each node will\nbe used for a simulation.  The first and last values specify the\nGPU IDs to use (from 0 to Ngpu-1).  By default, first = 0 and last =\nNgpu-1, so that all GPUs are used, assuming Ngpu is set to the number\nof physical GPUs.  If you only wish to use a subset, set Ngpu to a\nsmaller number and first/last to a sub-range of the available GPUs.\nThe tpa keyword sets the number of GPU thread per atom used to\nperform force calculations.  With a default value of 1, the number of\nthreads will be chosen based on the pair style, however, the value can\nbe set explicitly with this keyword to fine-tune performance.  For\nlarge cutoffs or with a small number of particles per GPU, increasing\nthe value can improve performance. The number of threads per atom must\nbe a power of 2 and currently cannot be greater than 32.\nThe device keyword can be used to tune parameters optimized for a\nspecific accelerator and platform when using OpenCL. OpenCL supports\nthe concept of a platform, which represents one or more devices that\nshare the same driver (e.g. there would be a different platform for\nGPUs from different vendors or for CPU based accelerator support).\nIn LAMMPS only one platform can be active at a time and by default\nthe first platform with an accelerator is selected. This is equivalent\nto using a platform ID of -1. The platform ID is a number corresponding\nto the output of the ocl_get_devices tool. The platform ID is passed\nto the GPU library, by prefixing the device keyword with that number\nseparated by a colon. For CUDA, the device keyword is ignored.\nCurrently, the device tuning support is limited to NVIDIA Kepler, NVIDIA\nFermi, AMD Cypress, Intel x86_64 CPU, Intel Xeon Phi, or a generic device.\nMore devices may be added later.  The default device type can be\nspecified when building LAMMPS with the GPU library, via setting a\nvariable in the lib/gpu/Makefile that is used.\nIn addition, a device type custom is available, which is followed by\n13 comma separated numbers, which allows to set those tweakable parameters\nfrom the package command. It can be combined with the (colon separated)\nplatform id. The individual settings are:\n\nMEM_THREADS\nTHREADS_PER_ATOM\nTHREADS_PER_CHARGE\nBLOCK_PAIR\nMAX_SHARED_TYPES\nBLOCK_NBOR_BUILD\nBLOCK_BIO_PAIR\nBLOCK_ELLIPSE\nWARP_SIZE\nPPPM_BLOCK_1D\nBLOCK_CELL_2D\nBLOCK_CELL_ID\nMAX_BIO_SHARED_TYPES\n\nThe blocksize keyword allows you to tweak the number of threads used\nper thread block. This number should be a multiple of 32 (for GPUs)\nand its maximum depends on the specific GPU hardware. Typical choices\nare 64, 128, or 256. A larger block size increases occupancy of\nindividual GPU cores, but reduces the total number of thread blocks,\nthus may lead to load imbalance.\n\nThe intel style invokes settings associated with the use of the\nUSER-INTEL package.  All of its settings, except the omp and mode\nkeywords, are ignored if LAMMPS was not built with Xeon Phi\nco-processor support.  All of its settings, including the omp and\nmode keyword are applicable if LAMMPS was built with co-processor\nsupport.\nThe Nphi argument sets the number of co-processors per node.\nThis can be set to any value, including 0, if LAMMPS was not\nbuilt with co-processor support.\nOptional keyword/value pairs can also be specified.  Each has a\ndefault value as listed below.\nThe omp keyword determines the number of OpenMP threads allocated\nfor each MPI task when any portion of the interactions computed by a\nUSER-INTEL pair style are run on the CPU.  This can be the case even\nif LAMMPS was built with co-processor support; see the balance\nkeyword discussion below.  If you are running with less MPI tasks/node\nthan there are CPUs, it can be advantageous to use OpenMP threading on\nthe CPUs.\n\nNote\nThe omp keyword has nothing to do with co-processor threads on\nthe Xeon Phi; see the tpc and tptask keywords below for a\ndiscussion of co-processor threads.\n\nThe Nthread value for the omp keyword sets the number of OpenMP\nthreads allocated for each MPI task.  Setting Nthread = 0 (the\ndefault) instructs LAMMPS to use whatever value is the default for the\ngiven OpenMP environment. This is usually determined via the\nOMP_NUM_THREADS environment variable or the compiler runtime, which\nis usually a value of 1.\nFor more details, including examples of how to set the OMP_NUM_THREADS\nenvironment variable, see the discussion of the Nthreads setting on\nthis doc page for the “package omp” command.  Nthreads is a required\nargument for the USER-OMP package.  Its meaning is exactly the same\nfor the USER-INTEL package.\n\nNote\nIf you build LAMMPS with both the USER-INTEL and USER-OMP\npackages, be aware that both packages allow setting of the Nthreads\nvalue via their package commands, but there is only a single global\nNthreads value used by OpenMP.  Thus if both package commands are\ninvoked, you should insure the two values are consistent.  If they are\nnot, the last one invoked will take precedence, for both packages.\nAlso note that if the -sf hybrid intel omp command-line switch is used, it invokes a “package intel”\ncommand, followed by a “package omp” command, both with a setting of\nNthreads = 0.\n\nThe mode keyword determines the precision mode to use for\ncomputing pair style forces, either on the CPU or on the co-processor,\nwhen using a USER-INTEL supported pair style.  It\ncan take a value of single, mixed which is the default, or\ndouble.  Single means single precision is used for the entire\nforce calculation.  Mixed means forces between a pair of atoms are\ncomputed in single precision, but accumulated and stored in double\nprecision, including storage of forces, torques, energies, and virial\nquantities.  Double means double precision is used for the entire\nforce calculation.\nThe lrt keyword can be used to enable “Long Range Thread (LRT)”\nmode. It can take a value of yes to enable and no to disable.\nLRT mode generates an extra thread (in addition to any OpenMP threads\nspecified with the OMP_NUM_THREADS environment variable or the omp\nkeyword). The extra thread is dedicated for performing part of the\nPPPM solver computations and communications. This\ncan improve parallel performance on processors supporting\nSimultaneous Multithreading (SMT) such as Hyper-Threading (HT) on Intel\nprocessors. In this mode, one additional thread is generated per MPI\nprocess. LAMMPS will generate a warning in the case that more threads\nare used than available in SMT hardware on a node. If the PPPM solver\nfrom the USER-INTEL package is not used, then the LRT setting is\nignored and no extra threads are generated. Enabling LRT will replace\nthe run_style with the verlet/lrt/intel style that\nis identical to the default verlet style aside from supporting the\nLRT feature. This feature requires setting the pre-processor flag\n-DLMP_INTEL_USELRT in the makefile when compiling LAMMPS.\nThe balance keyword sets the fraction of pair style work offloaded to the co-processor for split\nvalues between 0.0 and 1.0 inclusive.  While this fraction of work is\nrunning on the co-processor, other calculations will run on the host,\nincluding neighbor and pair calculations that are not offloaded, as\nwell as angle, bond, dihedral, kspace, and some MPI communications.\nIf split is set to -1, the fraction of work is dynamically adjusted\nautomatically throughout the run.  This typically give performance\nwithin 5 to 10 percent of the optimal fixed fraction.\nThe ghost keyword determines whether or not ghost atoms, i.e. atoms\nat the boundaries of processor sub-domains, are offloaded for neighbor\nand force calculations.  When the value = “no”, ghost atoms are not\noffloaded.  This option can reduce the amount of data transfer with\nthe co-processor and can also overlap MPI communication of forces with\ncomputation on the co-processor when the newton pair\nsetting is “on”.  When the value = “yes”, ghost atoms are offloaded.\nIn some cases this can provide better performance, especially if the\nbalance fraction is high.\nThe tpc keyword sets the max # of co-processor threads Ntpc that\nwill run on each core of the co-processor.  The default value = 4,\nwhich is the number of hardware threads per core supported by the\ncurrent generation Xeon Phi chips.\nThe tptask keyword sets the max # of co-processor threads (Ntptask*\nassigned to each MPI task.  The default value = 240, which is the\ntotal # of threads an entire current generation Xeon Phi chip can run\n(240 = 60 cores * 4 threads/core).  This means each MPI task assigned\nto the Phi will enough threads for the chip to run the max allowed,\neven if only 1 MPI task is assigned.  If 8 MPI tasks are assigned to\nthe Phi, each will run with 30 threads.  If you wish to limit the\nnumber of threads per MPI task, set tptask to a smaller value.\nE.g. for tptask = 16, if 8 MPI tasks are assigned, each will run\nwith 16 threads, for a total of 128.\nNote that the default settings for tpc and tptask are fine for\nmost problems, regardless of how many MPI tasks you assign to a Phi.\nThe no_affinity keyword will turn off automatic setting of core\naffinity for MPI tasks and OpenMP threads on the host when using\noffload to a co-processor. Affinity settings are used when possible\nto prevent MPI tasks and OpenMP threads from being on separate NUMA\ndomains and to prevent offload threads from interfering with other\nprocesses/threads used for LAMMPS.\n\nThe kokkos style invokes settings associated with the use of the\nKOKKOS package.\nAll of the settings are optional keyword/value pairs. Each has a default\nvalue as listed below.\nThe neigh keyword determines how neighbor lists are built. A value of\nhalf uses a thread-safe variant of half-neighbor lists, the same as\nused by most pair styles in LAMMPS, which is the default when running on\nCPUs (i.e. the Kokkos CUDA back end is not enabled).\nA value of full uses a full neighbor lists and is the default when\nrunning on GPUs. This performs twice as much computation as the half\noption, however that is often a win because it is thread-safe and\ndoesn’t require atomic operations in the calculation of pair forces. For\nthat reason, full is the default setting for GPUs. However, when\nrunning on CPUs, a half neighbor list is the default because it are\noften faster, just as it is for non-accelerated pair styles. Similarly,\nthe neigh/qeq keyword determines how neighbor lists are built for fix qeq/reax/kk. If not explicitly set, the value of\nneigh/qeq will match neigh.\nIf the neigh/thread keyword is set to off, then the KOKKOS package\nthreads only over atoms. However, for small systems, this may not expose\nenough parallelism to keep a GPU busy. When this keyword is set to on,\nthe KOKKOS package threads over both atoms and neighbors of atoms. When\nusing neigh/thread on, a full neighbor list must also be used. Using\nneigh/thread on may be slower for large systems, so this this option\nis turned on by default only when there are 16K atoms or less owned by\nan MPI rank and when using a full neighbor list. Not all KOKKOS-enabled\npotentials support this keyword yet, and only thread over atoms. Many\nsimple pair-wise potentials such as Lennard-Jones do support threading\nover both atoms and neighbors.\nThe newton keyword sets the Newton flags for pairwise and bonded\ninteractions to off or on, the same as the newton\ncommand allows. The default for GPUs is off because this will almost\nalways give better performance for the KOKKOS package. This means more\ncomputation is done, but less communication. However, when running on\nCPUs a value of on is the default since it can often be faster, just\nas it is for non-accelerated pair styles\nThe binsize keyword sets the size of bins used to bin atoms in\nneighbor list builds. The same value can be set by the neigh_modify binsize command. Making it an option in the package\nkokkos command allows it to be set from the command line. The default\nvalue for CPUs is 0.0, which means the LAMMPS default will be used,\nwhich is bins = 1/2 the size of the pairwise cutoff + neighbor skin\ndistance. This is fine when neighbor lists are built on the CPU. For GPU\nbuilds, a 2x larger binsize equal to the pairwise cutoff + neighbor skin\nis often faster, which is the default. Note that if you use a\nlonger-than-usual pairwise cutoff, e.g. to allow for a smaller fraction\nof KSpace work with a long-range Coulombic solver\nbecause the GPU is faster at performing pairwise interactions, then this\nrule of thumb may give too large a binsize and the default should be\noverridden with a smaller value.\nThe comm and comm/exchange and comm/forward and comm/reverse\nkeywords determine whether the host or device performs the packing and\nunpacking of data when communicating per-atom data between processors.\n“Exchange” communication happens only on timesteps that neighbor lists\nare rebuilt. The data is only for atoms that migrate to new processors.\n“Forward” communication happens every timestep. “Reverse” communication\nhappens every timestep if the newton option is on. The data is for\natom coordinates and any other atom properties that needs to be updated\nfor ghost atoms owned by each processor.\nThe comm keyword is simply a short-cut to set the same value for both\nthe comm/exchange and comm/forward and comm/reverse keywords.\nThe value options for all 3 keywords are no or host or device. A\nvalue of no means to use the standard non-KOKKOS method of\npacking/unpacking data for the communication. A value of host means to\nuse the host, typically a multi-core CPU, and perform the\npacking/unpacking in parallel with threads. A value of device means to\nuse the device, typically a GPU, to perform the packing/unpacking\noperation.\nThe optimal choice for these keywords depends on the input script and\nthe hardware used. The no value is useful for verifying that the\nKokkos-based host and device values are working correctly. It is the\ndefault when running on CPUs since it is usually the fastest.\nWhen running on CPUs or Xeon Phi, the host and device values work\nidentically. When using GPUs, the device value is the default since it\nwill typically be optimal if all of your styles used in your input\nscript are supported by the KOKKOS package. In this case data can stay\non the GPU for many timesteps without being moved between the host and\nGPU, if you use the device value. If your script uses styles (e.g.\nfixes) which are not yet supported by the KOKKOS package, then data has\nto be move between the host and device anyway, so it is typically faster\nto let the host handle communication, by using the host value. Using\nhost instead of no will enable use of multiple threads to\npack/unpack communicated data. When running small systems on a GPU,\nperforming the exchange pack/unpack on the host CPU can give speedup\nsince it reduces the number of CUDA kernel launches.\nThe cuda/aware keyword chooses whether CUDA-aware MPI will be used. When\nthis keyword is set to on, buffers in GPU memory are passed directly\nthrough MPI send/receive calls. This reduces overhead of first copying\nthe data to the host CPU. However CUDA-aware MPI is not supported on all\nsystems, which can lead to segmentation faults and would require using a\nvalue of off. If LAMMPS can safely detect that CUDA-aware MPI is not\navailable (currently only possible with OpenMPI v2.0.0 or later), then\nthe cuda/aware keyword is automatically set to off by default. When\nthe cuda/aware keyword is set to off while any of the comm\nkeywords are set to device, the value for these comm keywords will\nbe automatically changed to host. This setting has no effect if not\nrunning on GPUs or if using only one MPI rank. CUDA-aware MPI is available\nfor OpenMPI 1.8 (or later versions), Mvapich2 1.9 (or later) when the\n“MV2_USE_CUDA” environment variable is set to “1”, CrayMPI, and IBM\nSpectrum MPI when the “-gpu” flag is used.\n\nThe omp style invokes settings associated with the use of the\nUSER-OMP package.\nThe Nthread argument sets the number of OpenMP threads allocated for\neach MPI task.  For example, if your system has nodes with dual\nquad-core processors, it has a total of 8 cores per node.  You could\nuse two MPI tasks per node (e.g. using the -ppn option of the mpirun\ncommand in MPICH or -npernode in OpenMPI), and set Nthreads = 4.\nThis would use all 8 cores on each node.  Note that the product of MPI\ntasks * threads/task should not exceed the physical number of cores\n(on a node), otherwise performance will suffer.\nSetting Nthread = 0 instructs LAMMPS to use whatever value is the\ndefault for the given OpenMP environment. This is usually determined\nvia the OMP_NUM_THREADS environment variable or the compiler\nruntime.  Note that in most cases the default for OpenMP capable\ncompilers is to use one thread for each available CPU core when\nOMP_NUM_THREADS is not explicitly set, which can lead to poor\nperformance.\nHere are examples of how to set the environment variable when\nlaunching LAMMPS:\nenv OMP_NUM_THREADS=4 lmp_machine -sf omp -in in.script\nenv OMP_NUM_THREADS=2 mpirun -np 2 lmp_machine -sf omp -in in.script\nmpirun -x OMP_NUM_THREADS=2 -np 2 lmp_machine -sf omp -in in.script\n\n\nor you can set it permanently in your shell’s start-up script.\nAll three of these examples use a total of 4 CPU cores.\nNote that different MPI implementations have different ways of passing\nthe OMP_NUM_THREADS environment variable to all MPI processes.  The\n2nd example line above is for MPICH; the 3rd example line with -x is\nfor OpenMPI.  Check your MPI documentation for additional details.\nWhat combination of threads and MPI tasks gives the best performance\nis difficult to predict and can depend on many components of your\ninput.  Not all features of LAMMPS support OpenMP threading via the\nUSER-OMP package and the parallel efficiency can be very different,\ntoo.\nOptional keyword/value pairs can also be specified.  Each has a\ndefault value as listed below.\nThe neigh keyword specifies whether neighbor list building will be\nmulti-threaded in addition to force calculations.  If neigh is set\nto no then neighbor list calculation is performed only by MPI tasks\nwith no OpenMP threading.  If mode is yes (the default), a\nmulti-threaded neighbor list build is used.  Using neigh = yes is\nalmost always faster and should produce identical neighbor lists at the\nexpense of using more memory.  Specifically, neighbor list pages are\nallocated for all threads at the same time and each thread works\nwithin its own pages.",
    "syntax": "package style args",
    "parameters": " * style = gpu or intel or kokkos or omp\n * args = arguments specific to the style\n * gpu args = Ngpu keyword value ...\n *   Ngpu = # of GPUs per node\n *   zero or more keyword/value pairs may be appended\n *   keywords = neigh or newton or binsize or split or gpuID or tpa or device or blocksize\n *     neigh value = yes or no\n *       yes = neighbor list build on GPU (default)\n *       no = neighbor list build on CPU\n *     newton = off or on\n *       off = set Newton pairwise flag off (default and required)\n *       on = set Newton pairwise flag on (currently not allowed)\n *     binsize value = size\n *       size = bin size for neighbor list construction (distance units)\n *     split = fraction\n *       fraction = fraction of atoms assigned to GPU (default = 1.0)\n *     gpuID values = first last\n *       first = ID of first GPU to be used on each node\n *       last = ID of last GPU to be used on each node\n *     tpa value = Nthreads\n *       Nthreads = # of GPU threads used per atom\n *     device value = device_type or platform_id:device_type or platform_id:custom,val1,val2,val3,..,val13\n *       platform_id = numerical OpenCL platform id (default: -1)\n *       device_type = kepler or fermi or cypress or intel or phi or generic or custom\n *       val1,val2,... = custom OpenCL tune parameters (see below for details)\n *     blocksize value = size\n *       size = thread block size for pair force computation\n * intel args = NPhi keyword value ...\n *   Nphi = # of co-processors per node\n *   zero or more keyword/value pairs may be appended\n *   keywords = mode or omp or lrt or balance or ghost or tpc or tptask or no_affinity\n *     mode value = single or mixed or double\n *       single = perform force calculations in single precision\n *       mixed = perform force calculations in mixed precision\n *       double = perform force calculations in double precision\n *     omp value = Nthreads\n *       Nthreads = number of OpenMP threads to use on CPU (default = 0)\n *     lrt value = yes or no\n *       yes = use additional thread dedicated for some PPPM calculations\n *       no = do not dedicate an extra thread for some PPPM calculations\n *     balance value = split\n *       split = fraction of work to offload to co-processor, -1 for dynamic\n *     ghost value = yes or no\n *       yes = include ghost atoms for offload\n *       no = do not include ghost atoms for offload\n *     tpc value = Ntpc\n *       Ntpc = max number of co-processor threads per co-processor core (default = 4)\n *     tptask value = Ntptask\n *       Ntptask = max number of co-processor threads per MPI task (default = 240)\n *     no_affinity values = none\n * kokkos args = keyword value ...\n *   zero or more keyword/value pairs may be appended\n *   keywords = neigh or neigh/qeq or neigh/thread or newton or binsize or comm or comm/exchange or comm/forward or comm/reverse or cuda/aware\n *     neigh value = full or half\n *       full = full neighbor list\n *       half = half neighbor list built in thread-safe manner\n *     neigh/qeq value = full or half\n *       full = full neighbor list\n *       half = half neighbor list built in thread-safe manner\n *     neigh/thread value = off or on\n *       off = thread only over atoms\n *       on = thread over both atoms and neighbors\n *     newton = off or on\n *       off = set Newton pairwise and bonded flags off\n *       on = set Newton pairwise and bonded flags on\n *     binsize value = size\n *       size = bin size for neighbor list construction (distance units)\n *     comm value = no or host or device\n *       use value for comm/exchange and comm/forward and comm/reverse\n *     comm/exchange value = no or host or device\n *     comm/forward value = no or host or device\n *     comm/reverse value = no or host or device\n *       no = perform communication pack/unpack in non-KOKKOS mode\n *       host = perform pack/unpack on host (e.g. with OpenMP threading)\n *       device = perform pack/unpack on device (e.g. on GPU)\n *     cuda/aware = off or on\n *       off = do not use CUDA-aware MPI\n *       on = use CUDA-aware MPI (default)\n * omp args = Nthreads keyword value ...\n *   Nthread = # of OpenMP threads to associate with each MPI process\n *   zero or more keyword/value pairs may be appended\n *   keywords = neigh\n *     neigh value = yes or no\n *       yes = threaded neighbor list build (default)\n *       no = non-threaded neighbor list build",
    "examples": "package gpu 1\npackage gpu 1 split 0.75\npackage gpu 2 split -1.0\npackage gpu 1 device kepler\npackage gpu 1 device 2:generic\npackage gpu 1 device custom,32,4,8,256,11,128,256,128,32,64,8,128,128\npackage kokkos neigh half comm device\npackage omp 0 neigh no\npackage omp 4\npackage intel 1\npackage intel 2 omp 4 mode mixed balance 0.5",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command.\nThe gpu style of this command can only be invoked if LAMMPS was built\nwith the GPU package.  See the Build package doc\npage for more info.\nThe intel style of this command can only be invoked if LAMMPS was\nbuilt with the USER-INTEL package.  See the Build package doc page for more info.\nThe kk style of this command can only be invoked if LAMMPS was built\nwith the KOKKOS package.  See the Build package\ndoc page for more info.\nThe omp style of this command can only be invoked if LAMMPS was built\nwith the USER-OMP package.  See the Build package\ndoc page for more info."
},
{
    "command": "partition",
    "html_filename": "partition.html",
    "short_description": "This command invokes the specified command on a subset of the partitions of processors you have defined via the -partition command-line switch",
    "description": "This command invokes the specified command on a subset of the\npartitions of processors you have defined via the -partition command-line switch.\nNormally, every input script command in your script is invoked by\nevery partition.  This behavior can be modified by defining world- or\nuniverse-style variables that have different values\nfor each partition.  This mechanism can be used to cause your script\nto jump to different input script files on different partitions, if\nsuch a variable is used in a jump command.\nThe “partition” command is another mechanism for having as input\nscript operate differently on different partitions.  It is basically a\nprefix on any LAMMPS command.  The command will only be invoked on\nthe partition(s) specified by the style and N arguments.\nIf the style is yes, the command will be invoked on any partition\nwhich matches the N argument.  If the style is no the command\nwill be invoked on all the partitions which do not match the Np\nargument.\nPartitions are numbered from 1 to Np, where Np is the number of\npartitions specified by the -partition command-line switch.\nN can be specified in one of two ways.  An explicit numeric value\ncan be used, as in the 1st example above.  Or a wild-card asterisk can\nbe used to span a range of partition numbers.  This takes the form “*”\nor “*n” or “n*” or “m*n”.  An asterisk with no numeric values means\nall partitions from 1 to Np.  A leading asterisk means all partitions\nfrom 1 to n (inclusive).  A trailing asterisk means all partitions\nfrom n to Np (inclusive).  A middle asterisk means all partitions from\nm to n (inclusive).\nThis command can be useful for the “run_style verlet/split” command\nwhich imposed requirements on how the processors\ncommand lays out a 3d grid of processors in each of 2 partitions.",
    "syntax": "partition style N command ...",
    "parameters": " * style = yes or no\n * N = partition number (see asterisk form below)\n * command = any LAMMPS command",
    "examples": "partition yes 1 processors 4 10 6\npartition no 5 print \"Active partition\"\npartition yes *5 fix all nve\npartition yes 6* fix all nvt temp 1.0 1.0 0.1",
    "restrictions": "\nnone"
},
{
    "command": "prd",
    "html_filename": "prd.html",
    "short_description": "Run a parallel replica dynamics (PRD) simulation using multiple replicas of a system",
    "description": "Run a parallel replica dynamics (PRD) simulation using multiple\nreplicas of a system.  One or more replicas can be used.  The total\nnumber of steps N to run can be interpreted in one of two ways; see\ndiscussion of the time keyword below.\nPRD is described in (Voter1998) by Art Voter.  Similar to\nglobal or local hyperdynamics (HD), PRD is a method for performing\naccelerated dynamics that is suitable for infrequent-event systems\nthat obey first-order kinetics.  A good overview of accelerated\ndynamics methods for such systems in given in this review paper\n(Voter2002) from Art’s group.  To quote from the\npaper: “The dynamical evolution is characterized by vibrational\nexcursions within a potential basin, punctuated by occasional\ntransitions between basins.”  The transition probability is\ncharacterized by p(t) = k*exp(-kt) where k is the rate constant.\nRunning multiple replicas gives an effective enhancement in the\ntimescale spanned by the multiple simulations, while waiting for an\nevent to occur.\nBoth PRD and HD produce a time-accurate trajectory that effectively\nextends the timescale over which a system can be simulated, but they\ndo it differently.  PRD creates Nr replicas of the system and runs\ndynamics on each independently with a normal unbiased potential until\nan event occurs in one of the replicas.  The time between events is\nreduced by a factor of Nr replicas.  HD uses a single replica of the\nsystem and accelerates time by biasing the interaction potential in a\nmanner such that each timestep is effectively longer.  For both\nmethods, per CPU second, more physical time elapses and more events\noccur.  See the hyper doc page for more info about HD.\nIn PRD, each replica runs on a partition of one or more processors.\nProcessor partitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI\ninstalled, you can run a multi-replica simulation with more replicas\n(partitions) than you have physical processors, e.g you can run a\n10-replica simulation on one or two processors.  However for PRD, this\nmakes little sense, since running a replica on virtual instead of\nphysical processors,offers no effective parallel speed-up in searching\nfor infrequent events.  See the Howto replica doc\npage for further discussion.\nWhen a PRD simulation is performed, it is assumed that each replica is\nrunning the same model, though LAMMPS does not check for this.\nI.e. the simulation domain, the number of atoms, the interaction\npotentials, etc should be the same for every replica.\nA PRD run has several stages, which are repeated each time an “event”\noccurs in one of the replicas, as explained below.  The logic for a\nPRD run is as follows:\nwhile (time remains):\n  dephase for n_dephase*t_dephase steps\n  until (event occurs on some replica):\n    run dynamics for t_event steps\n    quench\n    check for uncorrelated event on any replica\n  until (no correlated event occurs):\n    run dynamics for t_correlate steps\n    quench\n    check for correlated event on this replica\n  event replica shares state with all replicas\nBefore this loop begins, the state of the system on replica 0 is\nshared with all replicas, so that all replicas begin from the same\ninitial state. The first potential energy basin is identified by\nquenching (an energy minimization, see below) the initial state and\nstoring the resulting coordinates for reference.\nIn the first stage, dephasing is performed by each replica\nindependently to eliminate correlations between replicas.  This is\ndone by choosing a random set of velocities, based on the\nrandom_seed that is specified, and running t_dephase timesteps of\ndynamics.  This is repeated n_dephase times.  At each of the\nn_dephase stages, if an event occurs during the t_dephase steps of\ndynamics for a particular replica, the replica repeats the stage until\nno event occurs.\nIf the temp keyword is not specified, the target temperature for\nvelocity randomization for each replica is the current temperature of\nthat replica.  Otherwise, it is the specified Tdephase temperature.\nThe style of velocity randomization is controlled using the keyword\nvel with arguments that have the same meaning as their counterparts\nin the velocity command.\nIn the second stage, each replica runs dynamics continuously, stopping\nevery t_event steps to check if a transition event has occurred.\nThis check is performed by quenching the system and comparing the\nresulting atom coordinates to the coordinates from the previous basin.\nThe first time through the PRD loop, the “previous basin” is the set\nof quenched coordinates from the initial state of the system.\nA quench is an energy minimization and is performed by whichever\nalgorithm has been defined by the min_style command.\nMinimization parameters may be set via the\nmin_modify command and by the min keyword of the\nPRD command.  The latter are the settings that would be used with the\nminimize command.  Note that typically, you do not\nneed to perform a highly-converged minimization to detect a transition\nevent, though you may need to in order to prevent a set of atoms in\nthe system from relaxing to a saddle point.\nThe event check is performed by a compute with the specified\ncompute-ID.  Currently there is only one compute that works with the\nPRD command, which is the compute event/displace command.  Other\nevent-checking computes may be added.  Compute event/displace checks whether any atom in\nthe compute group has moved further than a specified threshold\ndistance.  If so, an “event” has occurred.\nIn the third stage, the replica on which the event occurred (event\nreplica) continues to run dynamics to search for correlated events.\nThis is done by running dynamics for t_correlate steps, quenching\nevery t_event steps, and checking if another event has occurred.\nThe first time no correlated event occurs, the final state of the\nevent replica is shared with all replicas, the new basin reference\ncoordinates are updated with the quenched state, and the outer loop\nbegins again. While the replica event is searching for correlated\nevents, all the other replicas also run dynamics and event checking\nwith the same schedule, but the final states are always overwritten by\nthe state of the event replica.\nThe outer loop of the pseudo-code above continues until N steps of\ndynamics have been performed.  Note that N only includes the\ndynamics of stages 2 and 3, not the steps taken during dephasing or\nthe minimization iterations of quenching.  The specified N is\ninterpreted in one of two ways, depending on the time keyword.  If\nthe time value is steps, which is the default, then each replica\nruns for N timesteps.  If the time value is clock, then the\nsimulation runs until N aggregate timesteps across all replicas have\nelapsed.  This aggregate time is the “clock” time defined below, which\ntypically advances nearly M times faster than the timestepping on a\nsingle replica, where M is the number of replicas.\n\nFour kinds of output can be generated during a PRD run: event\nstatistics, thermodynamic output by each replica, dump files, and\nrestart files.\nWhen running with multiple partitions (each of which is a replica in\nthis case), the print-out to the screen and master log.lammps file is\nlimited to event statistics.  Note that if a PRD run is performed on\nonly a single replica then the event statistics will be intermixed\nwith the usual thermodynamic output discussed below.\nThe quantities printed each time an event occurs are the timestep, CPU\ntime, clock, event number, a correlation flag, the number of\ncoincident events, and the replica number of the chosen event.\nThe timestep is the usual LAMMPS timestep, except that time does not\nadvance during dephasing or quenches, but only during dynamics.  Note\nthat are two kinds of dynamics in the PRD loop listed above that\ncontribute to this timestepping.  The first is when all replicas are\nperforming independent dynamics, waiting for an event to occur.  The\nsecond is when correlated events are being searched for, but only one\nreplica is running dynamics.\nThe CPU time is the total elapsed time on each processor, since the\nstart of the PRD run.\nThe clock is the same as the timestep except that it advances by M\nsteps per timestep during the first kind of dynamics when the M\nreplicas are running independently.  The clock advances by only 1 step\nper timestep during the second kind of dynamics, when only a single\nreplica is checking for a correlated event.  Thus “clock” time\nrepresents the aggregate time (in steps) that has effectively elapsed\nduring a PRD simulation on M replicas.  If most of the PRD run is\nspent in the second stage of the loop above, searching for infrequent\nevents, then the clock will advance nearly M times faster than it\nwould if a single replica was running.  Note the clock time between\nsuccessive events should be drawn from p(t).\nThe event number is a counter that increments with each event, whether\nit is uncorrelated or correlated.\nThe correlation flag will be 0 when an uncorrelated event occurs\nduring the second stage of the loop listed above, i.e. when all\nreplicas are running independently.  The correlation flag will be 1\nwhen a correlated event occurs during the third stage of the loop\nlisted above, i.e. when only one replica is running dynamics.\nWhen more than one replica detects an event at the end of the same\nevent check (every t_event steps) during the second stage, then\none of them is chosen at random.  The number of coincident events is\nthe number of replicas that detected an event.  Normally, this value\nshould be 1.  If it is often greater than 1, then either the number of\nreplicas is too large, or t_event is too large.\nThe replica number is the ID of the replica (from 0 to M-1) in which\nthe event occurred.\n\nWhen running on multiple partitions, LAMMPS produces additional log\nfiles for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For\nthe PRD command, these contain the thermodynamic output for each\nreplica.  You will see short runs and minimizations corresponding to\nthe dynamics and quench operations of the loop listed above.  The\ntimestep will be reset appropriately depending on whether the\noperation advances time or not.\nAfter the PRD command completes, timing statistics for the PRD run are\nprinted in each replica’s log file, giving a breakdown of how much CPU\ntime was spent in each stage (dephasing, dynamics, quenching, etc).\n\nAny dump files defined in the input script, will be\nwritten to during a PRD run at timesteps corresponding to both\nuncorrelated and correlated events.  This means the requested dump\nfrequency in the dump command is ignored.  There will be\none dump file (per dump command) created for all partitions.\nThe atom coordinates of the dump snapshot are those of the minimum\nenergy configuration resulting from quenching following a transition\nevent.  The timesteps written into the dump files correspond to the\ntimestep at which the event occurred and NOT the clock.  A dump\nsnapshot corresponding to the initial minimum state used for event\ndetection is written to the dump file at the beginning of each PRD\nrun.\n\nIf the restart command is used, a single restart file\nfor all the partitions is generated, which allows a PRD run to be\ncontinued by a new input script in the usual manner.\nThe restart file is generated at the end of the loop listed above.  If\nno correlated events are found, this means it contains a snapshot of\nthe system at time T + t_correlate, where T is the time at which the\nuncorrelated event occurred.  If correlated events were found, then it\ncontains a snapshot of the system at time T + t_correlate, where T\nis the time of the last correlated event.\nThe restart frequency specified in the restart command\nis interpreted differently when performing a PRD run.  It does not\nmean the timestep interval between restart files.  Instead it means an\nevent interval for uncorrelated events.  Thus a frequency of 1 means\nwrite a restart file every time an uncorrelated event occurs.  A\nfrequency of 10 means write a restart file every 10th uncorrelated\nevent.\nWhen an input script reads a restart file from a previous PRD run, the\nnew script can be run on a different number of replicas or processors.\nHowever, it is assumed that t_correlate in the new PRD command is\nthe same as it was previously.  If not, the calculation of the “clock”\nvalue for the first event in the new run will be slightly off.",
    "syntax": "prd N t_event n_dephase t_dephase t_correlate compute-ID seed keyword value ...",
    "parameters": " * N = # of timesteps to run (not including dephasing/quenching)\n * t_event = timestep interval between event checks\n * n_dephase = number of velocity randomizations to perform in each dephase run\n * t_dephase = number of timesteps to run dynamics after each velocity randomization during dephase\n * t_correlate = number of timesteps within which 2 consecutive events are considered to be correlated\n * compute-ID = ID of the compute used for event detection\n * random_seed = random # seed (positive integer)\n * zero or more keyword/value pairs may be appended\n * keyword = min or temp or vel\n * min values = etol ftol maxiter maxeval\n *   etol = stopping tolerance for energy, used in quenching\n *   ftol = stopping tolerance for force, used in quenching\n *   maxiter = max iterations of minimize, used in quenching\n *   maxeval = max number of force/energy evaluations, used in quenching\n * temp value = Tdephase\n *   Tdephase = target temperature for velocity randomization, used in dephasing\n * vel values = loop dist\n *   loop = all or local or geom, used in dephasing\n *   dist = uniform or gaussian, used in dephasing\n * time value = steps or clock\n *   steps = simulation runs for N timesteps on each replica (default)\n *   clock = simulation runs for N timesteps across all replicas",
    "examples": "prd 5000 100 10 10 100 1 54982\nprd 5000 100 10 10 100 1 54982 min 0.1 0.1 100 200",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info.\nThe N and t_correlate settings must be integer multiples of\nt_event.\nRuns restarted from restart file written during a PRD run will not\nproduce identical results due to changes in the random numbers used\nfor dephasing.\nThis command cannot be used when any fixes are defined that keep track\nof elapsed time to perform time-dependent operations.  Examples\ninclude the “ave” fixes such as fix ave/chunk.\nAlso fix dt/reset and fix deposit."
},
{
    "command": "print",
    "html_filename": "print.html",
    "short_description": "Print a text string to the screen and logfile",
    "description": "Print a text string to the screen and logfile.  The text string must\nbe a single argument, so if it is one line but more than one word, it\nshould be enclosed in single or double quotes.  To generate multiple\nlines of output, the string can be enclosed in triple quotes, as in\nthe last example above.  If the text string contains variables, they\nwill be evaluated and their current values printed.\nIf the file or append keyword is used, a filename is specified to\nwhich the output will be written.  If file is used, then the\nfilename is overwritten if it already exists.  If append is used,\nthen the filename is appended to if it already exists, or created if\nit does not exist.\nIf the screen keyword is used, output to the screen and logfile can\nbe turned on or off as desired.\nIf the universe keyword is used, output to the global screen and\nlogfile can be turned on or off as desired. In multi-partition\ncalculations, the screen option and the corresponding output only\napply to the screen and logfile of the individual partition.\nIf you want the print command to be executed multiple times (with\nchanging variable values), there are 3 options.  First, consider using\nthe fix print command, which will print a string\nperiodically during a simulation.  Second, the print command can be\nused as an argument to the every option of the run\ncommand.  Third, the print command could appear in a section of the\ninput script that is looped over (see the jump and\nnext commands).\nSee the variable command for a description of equal\nstyle variables which are typically the most useful ones to use with\nthe print command.  Equal-style variables can calculate formulas\ninvolving mathematical operations, atom properties, group properties,\nthermodynamic properties, global values calculated by a\ncompute or fix, or references to other\nvariables.",
    "syntax": "print string keyword value",
    "parameters": " * string = text string to print, which may contain variables\n * zero or more keyword/value pairs may be appended\n * keyword = file or append or screen or universe\n * file value = filename\n * append value = filename\n * screen value = yes or no\n * universe value = yes or no",
    "examples": "print \"Done with equilibration\" file info.dat\nprint Vol=$v append info.dat screen no\nprint \"The system volume is now $v\"\nprint 'The system volume is now $v'\nprint \"NEB calculation 1 complete\" screen no universe yes\nprint \"\"\"\nSystem volume = $v\nSystem temperature = $t\n\"\"\"",
    "restrictions": "\nnone"
},
{
    "command": "processors",
    "html_filename": "processors.html",
    "short_description": "Specify how processors are mapped as a regular 3d grid to the global simulation box",
    "description": "Specify how processors are mapped as a regular 3d grid to the global\nsimulation box.  The mapping involves 2 steps.  First if there are P\nprocessors it means choosing a factorization P = Px by Py by Pz so\nthat there are Px processors in the x dimension, and similarly for the\ny and z dimensions.  Second, the P processors are mapped to the\nregular 3d grid.  The arguments to this command control each of these\n2 steps.\nThe Px, Py, Pz parameters affect the factorization.  Any of the 3\nparameters can be specified with an asterisk “*”, which means LAMMPS\nwill choose the number of processors in that dimension of the grid.\nIt will do this based on the size and shape of the global simulation\nbox so as to minimize the surface-to-volume ratio of each processor’s\nsub-domain.\nChoosing explicit values for Px or Py or Pz can be used to override\nthe default manner in which LAMMPS will create the regular 3d grid of\nprocessors, if it is known to be sub-optimal for a particular problem.\nE.g. a problem where the extent of atoms will change dramatically in a\nparticular dimension over the course of the simulation.\nThe product of Px, Py, Pz must equal P, the total # of processors\nLAMMPS is running on.  For a 2d simulation, Pz must\nequal 1.\nNote that if you run on a prime number of processors P, then a grid\nsuch as 1 x P x 1 will be required, which may incur extra\ncommunication costs due to the high surface area of each processor’s\nsub-domain.\nAlso note that if multiple partitions are being used then P is the\nnumber of processors in this partition; see the -partition command-line switch doc page for details.  Also note\nthat you can prefix the processors command with the\npartition command to easily specify different\nPx,Py,Pz values for different partitions.\nYou can use the partition command to specify\ndifferent processor grids for different partitions, e.g.\npartition yes 1 processors 4 4 4\npartition yes 2 processors 2 3 2\n\n\n\nNote\nThis command only affects the initial regular 3d grid created\nwhen the simulation box is first specified via a\ncreate_box or read_data or\nread_restart command.  Or if the simulation box is\nre-created via the replicate command.  The same\nregular grid is initially created, regardless of which\ncomm_style command is in effect.\n\nIf load-balancing is never invoked via the balance or\nfix balance commands, then the initial regular grid\nwill persist for all simulations.  If balancing is performed, some of\nthe methods invoked by those commands retain the logical topology of\nthe initial 3d grid, and the mapping of processors to the grid\nspecified by the processors command.  However the grid spacings in\ndifferent dimensions may change, so that processors own sub-domains of\ndifferent sizes.  If the comm_style tiled command is\nused, methods invoked by the balancing commands may discard the 3d\ngrid of processors and tile the simulation domain with sub-domains of\ndifferent sizes and shapes which no longer have a logical 3d\nconnectivity.  If that occurs, all the information specified by the\nprocessors command is ignored.\n\nThe grid keyword affects the factorization of P into Px,Py,Pz and it\ncan also affect how the P processor IDs are mapped to the 3d grid of\nprocessors.\nThe onelevel style creates a 3d grid that is compatible with the\nPx,Py,Pz settings, and which minimizes the surface-to-volume ratio of\neach processor’s sub-domain, as described above.  The mapping of\nprocessors to the grid is determined by the map keyword setting.\nThe twolevel style can be used on machines with multicore nodes to\nminimize off-node communication.  It insures that contiguous\nsub-sections of the 3d grid are assigned to all the cores of a node.\nFor example if Nc is 4, then 2x2x1 or 2x1x2 or 1x2x2 sub-sections of\nthe 3d grid will correspond to the cores of each node.  This affects\nboth the factorization and mapping steps.\nThe Cx, Cy, Cz settings are similar to the Px, Py, Pz\nsettings, only their product should equal Nc.  Any of the 3\nparameters can be specified with an asterisk “*”, which means LAMMPS\nwill choose the number of cores in that dimension of the node’s\nsub-grid.  As with Px,Py,Pz, it will do this based on the size and\nshape of the global simulation box so as to minimize the\nsurface-to-volume ratio of each processor’s sub-domain.\n\nNote\nFor the twolevel style to work correctly, it assumes the MPI\nranks of processors LAMMPS is running on are ordered by core and then\nby node.  E.g. if you are running on 2 quad-core nodes, for a total of\n8 processors, then it assumes processors 0,1,2,3 are on node 1, and\nprocessors 4,5,6,7 are on node 2.  This is the default rank ordering\nfor most MPI implementations, but some MPIs provide options for this\nordering, e.g. via environment variable settings.\n\nThe numa style operates similar to the twolevel keyword except\nthat it auto-detects which cores are running on which nodes.\nCurrently, it does this in only 2 levels, but it may be extended in\nthe future to account for socket topology and other non-uniform memory\naccess (NUMA) costs.  It also uses a different algorithm than the\ntwolevel keyword for doing the two-level factorization of the\nsimulation box into a 3d processor grid to minimize off-node\ncommunication, and it does its own MPI-based mapping of nodes and\ncores to the regular 3d grid.  Thus it may produce a different layout\nof the processors than the twolevel options.\nThe numa style will give an error if the number of MPI processes is\nnot divisible by the number of cores used per node, or any of the Px\nor Py of Pz values is greater than 1.\n\nNote\nUnlike the twolevel style, the numa style does not require\nany particular ordering of MPI ranks i norder to work correctly.  This\nis because it auto-detects which processes are running on which nodes.\n\nThe custom style uses the file infile to define both the 3d\nfactorization and the mapping of processors to the grid.\nThe file should have the following format.  Any number of initial\nblank or comment lines (starting with a “#” character) can be present.\nThe first non-blank, non-comment line should have\n3 values:\nPx Py Py\n\n\nThese must be compatible with the total number of processors\nand the Px, Py, Pz settings of the processors command.\nThis line should be immediately followed by\nP = Px*Py*Pz lines of the form:\nID I J K\n\n\nwhere ID is a processor ID (from 0 to P-1) and I,J,K are the\nprocessors location in the 3d grid.  I must be a number from 1 to Px\n(inclusive) and similarly for J and K.  The P lines can be listed in\nany order, but no processor ID should appear more than once.\n\nThe map keyword affects how the P processor IDs (from 0 to P-1) are\nmapped to the 3d grid of processors.  It is only used by the\nonelevel and twolevel grid settings.\nThe cart style uses the family of MPI Cartesian functions to perform\nthe mapping, namely MPI_Cart_create(), MPI_Cart_get(),\nMPI_Cart_shift(), and MPI_Cart_rank().  It invokes the\nMPI_Cart_create() function with its reorder flag = 0, so that MPI is\nnot free to reorder the processors.\nThe cart/reorder style does the same thing as the cart style\nexcept it sets the reorder flag to 1, so that MPI can reorder\nprocessors if it desires.\nThe xyz, xzy, yxz, yzx, zxy, and zyx styles are all\nsimilar.  If the style is IJK, then it maps the P processors to the\ngrid so that the processor ID in the I direction varies fastest, the\nprocessor ID in the J direction varies next fastest, and the processor\nID in the K direction varies slowest.  For example, if you select\nstyle xyz and you have a 2x2x2 grid of 8 processors, the assignments\nof the 8 octants of the simulation domain will be:\nproc 0 = lo x, lo y, lo z octant\nproc 1 = hi x, lo y, lo z octant\nproc 2 = lo x, hi y, lo z octant\nproc 3 = hi x, hi y, lo z octant\nproc 4 = lo x, lo y, hi z octant\nproc 5 = hi x, lo y, hi z octant\nproc 6 = lo x, hi y, hi z octant\nproc 7 = hi x, hi y, hi z octant\n\n\nNote that, in principle, an MPI implementation on a particular machine\nshould be aware of both the machine’s network topology and the\nspecific subset of processors and nodes that were assigned to your\nsimulation.  Thus its MPI_Cart calls can optimize the assignment of\nMPI processes to the 3d grid to minimize communication costs.  In\npractice, however, few if any MPI implementations actually do this.\nSo it is likely that the cart and cart/reorder styles simply give\nthe same result as one of the IJK styles.\nAlso note, that for the twolevel grid style, the map setting is\nused to first map the nodes to the 3d grid, then again to the cores\nwithin each node.  For the latter step, the cart and cart/reorder\nstyles are not supported, so an xyz style is used in their place.\n\nThe part keyword affects the factorization of P into Px,Py,Pz.\nIt can be useful when running in multi-partition mode, e.g. with the\nrun_style verlet/split command.  It specifies a\ndependency between a sending partition Psend and a receiving\npartition Precv which is enforced when each is setting up their own\nmapping of their processors to the simulation box.  Each of Psend\nand Precv must be integers from 1 to Np, where Np is the number of\npartitions you have defined via the -partition command-line switch.\nA “dependency” means that the sending partition will create its\nregular 3d grid as Px by Py by Pz and after it has done this, it will\nsend the Px,Py,Pz values to the receiving partition.  The receiving\npartition will wait to receive these values before creating its own\nregular 3d grid and will use the sender’s Px,Py,Pz values as a\nconstraint.  The nature of the constraint is determined by the\ncstyle argument.\nFor a cstyle of multiple, each dimension of the sender’s processor\ngrid is required to be an integer multiple of the corresponding\ndimension in the receiver’s processor grid.  This is a requirement of\nthe run_style verlet/split command.\nFor example, assume the sending partition creates a 4x6x10 grid = 240\nprocessor grid.  If the receiving partition is running on 80\nprocessors, it could create a 4x2x10 grid, but it will not create a\n2x4x10 grid, since in the y-dimension, 6 is not an integer multiple of\n4.\n\nNote\nIf you use the partition command to invoke\ndifferent “processors” commands on different partitions, and you also\nuse the part keyword, then you must insure that both the sending and\nreceiving partitions invoke the “processors” command that connects the\n2 partitions via the part keyword.  LAMMPS cannot easily check for\nthis, but your simulation will likely hang in its setup phase if this\nerror has been made.\n\n\nThe file keyword writes the mapping of the factorization of P\nprocessors and their mapping to the 3d grid to the specified file\noutfile.  This is useful to check that you assigned physical\nprocessors in the manner you desired, which can be tricky to figure\nout, especially when running on multiple partitions or on, a multicore\nmachine or when the processor ranks were reordered by use of the\n-reorder command-line switch or due to use of\nMPI-specific launch options such as a config file.\nIf you have multiple partitions you should insure that each one writes\nto a different file, e.g. using a world-style variable\nfor the filename.  The file has a self-explanatory header, followed by\none-line per processor in this format:\nworld-ID universe-ID original-ID: I J K: name\nThe IDs are the processor’s rank in this simulation (the world), the\nuniverse (of multiple simulations), and the original MPI communicator\nused to instantiate LAMMPS, respectively.  The world and universe IDs\nwill only be different if you are running on more than one partition;\nsee the -partition command-line switch.  The\nuniverse and original IDs will only be different if you used the\n-reorder command-line switch to reorder the\nprocessors differently than their rank in the original communicator\nLAMMPS was instantiated with.\nI,J,K are the indices of the processor in the regular 3d grid, each\nfrom 1 to Nd, where Nd is the number of processors in that dimension\nof the grid.\nThe name is what is returned by a call to MPI_Get_processor_name()\nand should represent an identifier relevant to the physical processors\nin your machine.  Note that depending on the MPI implementation,\nmultiple cores can have the same name.",
    "syntax": "processors Px Py Pz keyword args ...",
    "parameters": " * Px,Py,Pz = # of processors in each dimension of 3d grid overlaying the simulation domain\n * zero or more keyword/arg pairs may be appended\n * keyword = grid or map or part or file\n * grid arg = gstyle params ...\n *   gstyle = onelevel or twolevel or numa or custom\n *     onelevel params = none\n *     twolevel params = Nc Cx Cy Cz\n *       Nc = number of cores per node\n *       Cx,Cy,Cz = # of cores in each dimension of 3d sub-grid assigned to each node\n *     numa params = none\n *     custom params = infile\n *       infile = file containing grid layout\n * map arg = cart or cart/reorder or xyz or xzy or yxz or yzx or zxy or zyx\n *    cart = use MPI_Cart() methods to map processors to 3d grid with reorder = 0\n *    cart/reorder = use MPI_Cart() methods to map processors to 3d grid with reorder = 1\n *    xyz,xzy,yxz,yzx,zxy,zyx = map processors to 3d grid in IJK ordering\n * numa arg = none\n * part args = Psend Precv cstyle\n *   Psend = partition # (1 to Np) which will send its processor layout\n *   Precv = partition # (1 to Np) which will recv the processor layout\n *   cstyle = multiple\n *     multiple = Psend grid will be multiple of Precv grid in each dimension\n * file arg = outfile\n *   outfile = name of file to write 3d grid of processors to",
    "examples": "processors * * 5\nprocessors 2 4 4\nprocessors * * 8 map xyz\nprocessors * * * grid numa\nprocessors * * * grid twolevel 4 * * 1\nprocessors 4 8 16 grid custom myfile\nprocessors * * * part 1 2 multiple",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command.\nIt can be used before a restart file is read to change the 3d\nprocessor grid from what is specified in the restart file.\nThe grid numa keyword only currently works with the map cart\noption.\nThe part keyword (for the receiving partition) only works with the\ngrid onelevel or grid twolevel options."
},
{
    "command": "python",
    "html_filename": "python.html",
    "short_description": "Define a Python function or execute a previously defined function or execute some arbitrary python code",
    "description": "Define a Python function or execute a previously defined function or\nexecute some arbitrary python code.\nArguments, including LAMMPS variables, can be passed to the function\nfrom the LAMMPS input script and a value returned by the Python\nfunction to a LAMMPS variable.  The Python code for the function can\nbe included directly in the input script or in a separate Python file.\nThe function can be standard Python code or it can make “callbacks” to\nLAMMPS through its library interface to query or set internal values\nwithin LAMMPS.  This is a powerful mechanism for performing complex\noperations in a LAMMPS input script that are not possible with the\nsimple input script and variable syntax which LAMMPS defines.  Thus\nyour input script can operate more like a true programming language.\nUse of this command requires building LAMMPS with the PYTHON package\nwhich links to the Python library so that the Python interpreter is\nembedded in LAMMPS.  More details about this process are given below.\nThere are two ways to invoke a Python function once it has been\ndefined.  One is using the invoke keyword.  The other is to assign\nthe function to a python-style variable defined in\nyour input script.  Whenever the variable is evaluated, it will\nexecute the Python function to assign a value to the variable.  Note\nthat variables can be evaluated in many different ways within LAMMPS.\nThey can be substituted for directly in an input script.  Or they can\nbe passed to various commands as arguments, so that the variable is\nevaluated during a simulation run.\nA broader overview of how Python can be used with LAMMPS is given on\nthe Python doc page.  There is an examples/python\ndirectory which illustrates use of the python command.\n\nThe func setting specifies the name of the Python function.  The\ncode for the function is defined using the file or here keywords\nas explained below. In case of the source keyword, the name of\nthe function is ignored.\nIf the invoke keyword is used, no other keywords can be used, and a\nprevious python command must have defined the Python function\nreferenced by this command.  This invokes the Python function with the\npreviously defined arguments and return value processed as explained\nbelow.  You can invoke the function as many times as you wish in your\ninput script.\nIf the source keyword is used, no other keywords can be used.\nThe argument can be a filename or a string with python commands,\neither on a single line enclosed in quotes, or as multiple lines\nenclosed in triple quotes. These python commands will be passed\nto the python interpreter and executed immediately without registering\na python function for future execution.\nThe input keyword defines how many arguments N the Python function\nexpects.  If it takes no arguments, then the input keyword should\nnot be used.  Each argument can be specified directly as a value,\ne.g. 6 or 3.14159 or abc (a string of characters).  The type of each\nargument is specified by the format keyword as explained below, so\nthat Python will know how to interpret the value.  If the word SELF is\nused for an argument it has a special meaning.  A pointer is passed to\nthe Python function which it converts into a reference to LAMMPS\nitself.  This enables the function to call back to LAMMPS through its\nlibrary interface as explained below.  This allows the Python function\nto query or set values internal to LAMMPS which can affect the\nsubsequent execution of the input script.  A LAMMPS variable can also\nbe used as an argument, specified as v_name, where “name” is the name\nof the variable.  Any style of LAMMPS variable can be used, as defined\nby the variable command.  Each time the Python\nfunction is invoked, the LAMMPS variable is evaluated and its value is\npassed to the Python function.\nThe return keyword is only needed if the Python function returns a\nvalue.  The specified varReturn must be of the form v_name, where\n“name” is the name of a python-style LAMMPS variable, defined by the\nvariable command.  The Python function can return a\nnumeric or string value, as specified by the format keyword.\nAs explained on the variable doc page, the definition\nof a python-style variable associates a Python function name with the\nvariable.  This must match the func setting for this command.  For\nexample these two commands would be self-consistent:\nvariable foo python myMultiply\npython myMultiply return v_foo format f file funcs.py\n\n\nThe two commands can appear in either order in the input script so\nlong as both are specified before the Python function is invoked for\nthe first time.\nThe format keyword must be used if the input or return keyword\nis used.  It defines an fstring with M characters, where M = sum of\nnumber of inputs and outputs.  The order of characters corresponds to\nthe N inputs, followed by the return value (if it exists).  Each\ncharacter must be one of the following: “i” for integer, “f” for\nfloating point, “s” for string, or “p” for SELF.  Each character\ndefines the type of the corresponding input or output value of the\nPython function and affects the type conversion that is performed\ninternally as data is passed back and forth between LAMMPS and Python.\nNote that it is permissible to use a python-style variable in a LAMMPS command that allows for an\nequal-style variable as an argument, but only if the output of the\nPython function is flagged as a numeric value (“i” or “f”) via the\nformat keyword.\nIf the return keyword is used and the format keyword specifies the\noutput as a string, then the default maximum length of that string is\n63 characters (64-1 for the string terminator).  If you want to return\na longer string, the length keyword can be specified with its Nlen\nvalue set to a larger number (the code allocates space for Nlen+1 to\ninclude the string terminator).  If the Python function generates a\nstring longer than the default 63 or the specified Nlen, it will be\ntruncated.\n\nEither the file, here, or exists keyword must be used, but only\none of them.  These keywords specify what Python code to load into the\nPython interpreter.  The file keyword gives the name of a file,\nwhich should end with a “.py” suffix, which contains Python code.  The\ncode will be immediately loaded into and run in the “main” module of\nthe Python interpreter.  Note that Python code which contains a\nfunction definition does not “execute” the function when it is run; it\nsimply defines the function so that it can be invoked later.\nThe here keyword does the same thing, except that the Python code\nfollows as a single argument to the here keyword.  This can be done\nusing triple quotes as delimiters, as in the examples above.  This\nallows Python code to be listed verbatim in your input script, with\nproper indentation, blank lines, and comments, as desired.  See the\nCommands parse doc page, for an explanation of\nhow triple quotes can be used as part of input script syntax.\nThe exists keyword takes no argument.  It means that Python code\ncontaining the required Python function defined by the func setting,\nis assumed to have been previously loaded by another python command.\nNote that the Python code that is loaded and run must contain a\nfunction with the specified func name.  To operate properly when\nlater invoked, the function code must match the input and\nreturn and format keywords specified by the python command.\nOtherwise Python will generate an error.\n\nThis section describes how Python code can be written to work with\nLAMMPS.\nWhether you load Python code from a file or directly from your input\nscript, via the file and here keywords, the code can be identical.\nIt must be indented properly as Python requires.  It can contain\ncomments or blank lines.  If the code is in your input script, it\ncannot however contain triple-quoted Python strings, since that will\nconflict with the triple-quote parsing that the LAMMPS input script\nperforms.\nAll the Python code you specify via one or more python commands is\nloaded into the Python “main” module, i.e. __main__.  The code can\ndefine global variables or statements that are outside of function\ndefinitions.  It can contain multiple functions, only one of which\nmatches the func setting in the python command.  This means you can\nuse the file keyword once to load several functions, and the\nexists keyword thereafter in subsequent python commands to access\nthe other functions previously loaded.\nA Python function you define (or more generally, the code you load)\ncan import other Python modules or classes, it can make calls to other\nsystem functions or functions you define, and it can access or modify\nglobal variables (in the “main” module) which will persist between\nsuccessive function calls.  The latter can be useful, for example, to\nprevent a function from being invoke multiple times per timestep by\ndifferent commands in a LAMMPS input script that access the returned\npython-style variable associated with the function.  For example,\nconsider this function loaded with two global variables defined\noutside the function:\nnsteplast = -1\nnvaluelast = 0\n\ndef expensive(nstep):\n  global nsteplast,nvaluelast\n  if nstep == nsteplast: return nvaluelast\n  nsteplast = nstep\n  # perform complicated calculation\n  nvalue = ...\n  nvaluelast = nvalue\n  return nvalue\n\n\nNsteplast stores the previous timestep the function was invoked\n(passed as an argument to the function).  Nvaluelast stores the return\nvalue computed on the last function invocation.  If the function is\ninvoked again on the same timestep, the previous value is simply\nreturned, without re-computing it.  The “global” statement inside the\nPython function allows it to overwrite the global variables.\nNote that if you load Python code multiple times (via multiple python\ncommands), you can overwrite previously loaded variables and functions\nif you are not careful.  E.g. if the code above were loaded twice, the\nglobal variables would be re-initialized, which might not be what you\nwant.  Likewise, if a function with the same name exists in two chunks\nof Python code you load, the function loaded second will override the\nfunction loaded first.\nIt’s important to realize that if you are running LAMMPS in parallel,\neach MPI task will load the Python interpreter and execute a local\ncopy of the Python function(s) you define.  There is no connection\nbetween the Python interpreters running on different processors.\nThis implies three important things.\nFirst, if you put a print statement in your Python function, you will\nsee P copies of the output, when running on P processors.  If the\nprints occur at (nearly) the same time, the P copies of the output may\nbe mixed together.  Welcome to the world of parallel programming and\ndebugging.\nSecond, if your Python code loads modules that are not pre-loaded by\nthe Python library, then it will load the module from disk.  This may\nbe a bottleneck if 1000s of processors try to load a module at the\nsame time.  On some large supercomputers, loading of modules from disk\nby Python may be disabled.  In this case you would need to pre-build a\nPython library that has the required modules pre-loaded and link\nLAMMPS with that library.\nThird, if your Python code calls back to LAMMPS (discussed in the\nnext section) and causes LAMMPS to perform an MPI operation requires\nglobal communication (e.g. via MPI_Allreduce), such as computing the\nglobal temperature of the system, then you must insure all your Python\nfunctions (running independently on different processors) call back to\nLAMMPS.  Otherwise the code may hang.\n\nYour Python function can “call back” to LAMMPS through its\nlibrary interface, if you use the SELF input to pass Python\na pointer to LAMMPS.  The mechanism for doing this in your\nPython function is as follows:\ndef foo(lmpptr,...):\n  from lammps import lammps\n  lmp = lammps(ptr=lmpptr)\n  lmp.command('print \"Hello from inside Python\"')\n  ...\n\n\nThe function definition must include a variable (lmpptr in this case)\nwhich corresponds to SELF in the python command.  The first line of the\nfunction imports the Python module lammps.py in the python directory of\nthe distribution.  The second line creates a Python object “lmp” which\nwraps the instance of LAMMPS that called the function.  The “ptr=lmpptr”\nargument is what makes that happen.  The third line invokes the\ncommand() function in the LAMMPS library interface.  It takes a single\nstring argument which is a LAMMPS input script command for LAMMPS to\nexecute, the same as if it appeared in your input script.  In this case,\nLAMMPS should output\nHello from inside Python\n\n\nto the screen and log file.  Note that since the LAMMPS print command\nitself takes a string in quotes as its argument, the Python string\nmust be delimited with a different style of quotes.\nThe Python library doc page describes the syntax\nfor how Python wraps the various functions included in the LAMMPS\nlibrary interface.\nA more interesting example is in the examples/python/in.python script\nwhich loads and runs the following function from examples/python/funcs.py:\ndef loop(N,cut0,thresh,lmpptr):\n  print \"LOOP ARGS\",N,cut0,thresh,lmpptr\n  from lammps import lammps\n  lmp = lammps(ptr=lmpptr)\n  natoms = lmp.get_natoms()\n\n  for i in range(N):\n    cut = cut0 + i*0.1\n\n    lmp.set_variable(\"cut\",cut)                 # set a variable in LAMMPS\n    lmp.command(\"pair_style lj/cut ${cut}\")     # LAMMPS command\n    #lmp.command(\"pair_style lj/cut %d\" % cut)  # LAMMPS command option\n\n    lmp.command(\"pair_coeff * * 1.0 1.0\")       # ditto\n    lmp.command(\"run 10\")                       # ditto\n    pe = lmp.extract_compute(\"thermo_pe\",0,0)   # extract total PE from LAMMPS\n    print \"PE\",pe/natoms,thresh\n    if pe/natoms < thresh: return\n\n\nwith these input script commands:\npython          loop input 4 10 1.0 -4.0 SELF format iffp file funcs.py\npython          loop invoke\n\n\nThis has the effect of looping over a series of 10 short runs (10\ntimesteps each) where the pair style cutoff is increased from a value\nof 1.0 in distance units, in increments of 0.1.  The looping stops\nwhen the per-atom potential energy falls below a threshold of -4.0 in\nenergy units.  More generally, Python can be used to implement a loop\nwith complex logic, much more so than can be created using the LAMMPS\njump and if commands.\nSeveral LAMMPS library functions are called from the loop function.\nGet_natoms() returns the number of atoms in the simulation, so that it\ncan be used to normalize the potential energy that is returned by\nextract_compute() for the “thermo_pe” compute that is defined by\ndefault for LAMMPS thermodynamic output.  Set_variable() sets the\nvalue of a string variable defined in LAMMPS.  This library function\nis a useful way for a Python function to return multiple values to\nLAMMPS, more than the single value that can be passed back via a\nreturn statement.  This cutoff value in the “cut” variable is then\nsubstituted (by LAMMPS) in the pair_style command that is executed\nnext.  Alternatively, the “LAMMPS command option” line could be used\nin place of the 2 preceding lines, to have Python insert the value\ninto the LAMMPS command string.\n\nNote\nWhen using the callback mechanism just described, recognize that\nthere are some operations you should not attempt because LAMMPS cannot\nexecute them correctly.  If the Python function is invoked between\nruns in the LAMMPS input script, then it should be OK to invoke any\nLAMMPS input script command via the library interface command() or\nfile() functions, so long as the command would work if it were\nexecuted in the LAMMPS input script directly at the same point.\n\nHowever, a Python function can also be invoked during a run, whenever\nan associated LAMMPS variable it is assigned to is evaluated.  If the\nvariable is an input argument to another LAMMPS command (e.g. fix setforce), then the Python function will be invoked\ninside the class for that command, in one of its methods that is\ninvoked in the middle of a timestep.  You cannot execute arbitrary\ninput script commands from the Python function (again, via the\ncommand() or file() functions) at that point in the run and expect it\nto work.  Other library functions such as those that invoke computes\nor other variables may have hidden side effects as well.  In these\ncases, LAMMPS has no simple way to check that something illogical is\nbeing attempted.\nThe same applies to Python functions called during a simulation run at\neach time step using fix python/invoke.\n\nIf you run Python code directly on your workstation, either\ninteractively or by using Python to launch a Python script stored in a\nfile, and your code has an error, you will typically see informative\nerror messages.  That is not the case when you run Python code from\nLAMMPS using an embedded Python interpreter.  The code will typically\nfail silently.  LAMMPS will catch some errors but cannot tell you\nwhere in the Python code the problem occurred.  For example, if the\nPython code cannot be loaded and run because it has syntax or other\nlogic errors, you may get an error from Python pointing to the\noffending line, or you may get one of these generic errors from\nLAMMPS:\nCould not process Python file\nCould not process Python string\n\n\nWhen the Python function is invoked, if it does not return properly,\nyou will typically get this generic error from LAMMPS:\nPython function evaluation failed\n\n\nHere are three suggestions for debugging your Python code while\nrunning it under LAMMPS.\nFirst, don’t run it under LAMMPS, at least to start with!  Debug it\nusing plain Python.  Load and invoke your function, pass it arguments,\ncheck return values, etc.\nSecond, add Python print statements to the function to check how far\nit gets and intermediate values it calculates.  See the discussion\nabove about printing from Python when running in parallel.\nThird, use Python exception handling.  For example, say this statement\nin your Python function is failing, because you have not initialized the\nvariable foo:\nfoo += 1\n\n\nIf you put one (or more) statements inside a “try” statement,\nlike this:\nimport exceptions\nprint \"Inside simple function\"\ntry:\n  foo += 1      # one or more statements here\nexcept Exception, e:\n  print \"FOO error:\",e\n\n\nthen you will get this message printed to the screen:\nFOO error: local variable 'foo' referenced before assignment\n\n\nIf there is no error in the try statements, then nothing is printed.\nEither way the function continues on (unless you put a return or\nsys.exit() in the except clause).",
    "syntax": "python func keyword args ...",
    "parameters": " * func = name of Python function\n * one or more keyword/args pairs must be appended\n * keyword = invoke or input or return or format or length or file or here or exists or source\n *   invoke arg = none = invoke the previously defined Python function\n *   input args = N i1 i2 ... iN\n *     N = # of inputs to function\n *     i1,...,iN = value, SELF, or LAMMPS variable name\n *       value = integer number, floating point number, or string\n *       SELF = reference to LAMMPS itself which can be accessed by Python function\n *       variable = v_name, where name = name of LAMMPS variable, e.g. v_abc\n *   return arg = varReturn\n *     varReturn = v_name  = LAMMPS variable name which return value of function will be assigned to\n *   format arg = fstring with M characters\n *     M = N if no return value, where N = # of inputs\n *     M = N+1 if there is a return value\n *     fstring = each character (i,f,s,p) corresponds in order to an input or return value\n *     'i' = integer, 'f' = floating point, 's' = string, 'p' = SELF\n *   length arg = Nlen\n *     Nlen = max length of string returned from Python function\n *   file arg = filename\n *     filename = file of Python code, which defines func\n *   here arg = inline\n *     inline = one or more lines of Python code which defines func\n *              must be a single argument, typically enclosed between triple quotes\n *   exists arg = none = Python code has been loaded by previous python command\n *   source arg = filename or inline\n *     filename = file of Python code which will be executed immediately\n *     inline = one or more lines of Python code which will be executed immediately\n *              must be a single argument, typically enclosed between triple quotes",
    "examples": "python pForce input 2 v_x 20.0 return v_f format fff file force.py\npython pForce invoke\n\npython factorial input 1 myN return v_fac format ii here \"\"\"\ndef factorial(n):\n  if n == 1: return n\n  return n * factorial(n-1)\n \"\"\"\n\npython loop input 1 SELF return v_value format pf here \"\"\"\ndef loop(lmpptr,N,cut0):\n  from lammps import lammps\n  lmp = lammps(ptr=lmpptr)\n\n  # loop N times, increasing cutoff each time\n\n  for i in range(N):\n    cut = cut0 + i*0.1\n    lmp.set_variable(\"cut\",cut)               # set a variable in LAMMPS\n    lmp.command(\"pair_style lj/cut ${cut}\")   # LAMMPS commands\n    lmp.command(\"pair_coeff * * 1.0 1.0\")\n    lmp.command(\"run 100\")\n \"\"\"",
    "restrictions": "This command is part of the PYTHON package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nBuilding LAMMPS with the PYTHON package will link LAMMPS with the\nPython library on your system.  Settings to enable this are in the\nlib/python/Makefile.lammps file.  See the lib/python/README file for\ninformation on those settings.\nIf you use Python code which calls back to LAMMPS, via the SELF input\nargument explained above, there is an extra step required when\nbuilding LAMMPS.  LAMMPS must also be built as a shared library and\nyour Python function must be able to load the Python module in\npython/lammps.py that wraps the LAMMPS library interface.  These are\nthe same steps required to use Python by itself to wrap LAMMPS.\nDetails on these steps are explained on the Python\ndoc page.  Note that it is important that the stand-alone LAMMPS\nexecutable and the LAMMPS shared library be consistent (built from the\nsame source code files) in order for this to work.  If the two have\nbeen built at different times using different source files, problems\nmay occur."
},
{
    "command": "quit",
    "html_filename": "quit.html",
    "short_description": "This command causes LAMMPS to exit, after shutting down all output cleanly",
    "description": "This command causes LAMMPS to exit, after shutting down all output\ncleanly.\nIt can be used as a debug statement in an input script, to terminate\nthe script at some intermediate point.\nIt can also be used as an invoked command inside the “then” or “else”\nportion of an if command.\nThe optional status argument is an integer which signals the return\nstatus to a program calling LAMMPS.  A return status of 0 usually\nindicates success.  A status != 0 is failure, where the specified\nvalue can be used to distinguish the kind of error, e.g. where in the\ninput script the quit was invoked.  If not specified, a status of 0 is\nreturned.",
    "syntax": "quit status",
    "parameters": " * status = numerical exit status (optional)",
    "examples": "quit\nif \"$n > 10000\" then \"quit 1\"",
    "restrictions": "\nnone"
},
{
    "command": "read_data",
    "html_filename": "read_data.html",
    "short_description": "Read in a data file containing information LAMMPS needs to run a simulation",
    "description": "Read in a data file containing information LAMMPS needs to run a\nsimulation.  The file can be ASCII text or a gzipped text file\n(detected by a .gz suffix).  This is one of 3 ways to specify initial\natom coordinates; see the read_restart and\ncreate_atoms commands for alternative methods.\nAlso see the explanation of the -restart command-line switch which can convert a restart file to a data\nfile.\nThis command can be used multiple times to add new atoms and their\nproperties to an existing system by using the add, offset, and\nshift keywords.  See more details below, which includes the use case\nfor the extra keywords.\nThe group keyword adds all the atoms in the data file to the\nspecified group-ID.  The group will be created if it does not already\nexist.  This is useful if you are reading multiple data files and wish\nto put sets of atoms into different groups so they can be operated on\nlater.  E.g. a group of added atoms can be moved to new positions via\nthe displace_atoms command.  Note that atoms\nread from the data file are also always added to the “all” group.  The\ngroup command discusses atom groups, as used in LAMMPS.\nThe nocoeff keyword tells read_data to ignore force field parameters.\nThe various Coeff sections are still read and have to have the correct\nnumber of lines, but they are not applied. This also allows to read a\ndata file without having any pair, bond, angle, dihedral or improper\nstyles defined, or to read a data file for a different force field.\nThe use of the fix keyword is discussed below.\n\nReading multiple data files\nThe read_data command can be used multiple times with the same or\ndifferent data files to build up a complex system from components\ncontained in individual data files.  For example one data file could\ncontain fluid in a confined domain; a second could contain wall atoms,\nand the second file could be read a third time to create a wall on the\nother side of the fluid.  The third set of atoms could be rotated to\nan opposing direction using the displace_atoms\ncommand, after the third read_data command is used.\nThe add, offset, shift, extra, and group keywords are\nuseful in this context.\nIf a simulation box does not yet exist, the add keyword\ncannot be used; the read_data command is being used for the first\ntime.  If a simulation box does exist, due to using the\ncreate_box command, or a previous read_data command,\nthen the add keyword must be used.\n\nNote\nThe simulation box size (xlo to xhi, ylo to yhi, zlo to zhi) in\nthe new data file will be merged with the existing simulation box to\ncreate a large enough box in each dimension to contain both the\nexisting and new atoms.  Each box dimension never shrinks due to this\nmerge operation, it only stays the same or grows. Care must be used if\nyou are growing the existing simulation box in a periodic dimension.\nIf there are existing atoms with bonds that straddle that periodic\nboundary, then the atoms may become far apart if the box size grows.\nThis will separate the atoms in the bond, which can lead to “lost”\nbond atoms or bad dynamics.\n\nThe three choices for the add argument affect how the atom IDs and\nmolecule IDs of atoms in the data file are treated.  If append is\nspecified, atoms in the data file are added to the current system,\nwith their atom IDs reset so that an atom-ID = M in the data file\nbecomes atom-ID = N+M, where N is the largest atom ID in the current\nsystem.  This rule is applied to all occurrences of atom IDs in the\ndata file, e.g. in the Velocity or Bonds section. This is also done\nfor molecule IDs, if the atom style does support molecule IDs or\nthey are enabled via fix property/atom. If IDoffset is specified,\nthen IDoffset is a numeric value is given, e.g. 1000, so that an\natom-ID = M in the data file becomes atom-ID = 1000+M. For systems\nwith enabled molecule IDs, another numerical argument MOLoffset\nis required representing the equivalent offset for molecule IDs.\nIf merge is specified, the data file atoms\nare added to the current system without changing their IDs.  They are\nassumed to merge (without duplication) with the currently defined\natoms.  It is up to you to insure there are no multiply defined atom\nIDs, as LAMMPS only performs an incomplete check that this is the case\nby insuring the resulting max atom-ID >= the number of atoms. For\nmolecule IDs, there is no check done at all.\nThe offset and shift keywords can only be used if the add\nkeyword is also specified.\nThe offset keyword adds the specified offset values to the atom\ntypes, bond types, angle types, dihedral types, and improper types as\nthey are read from the data file.  E.g. if toff = 2, and the file\nuses atom types 1,2,3, then the added atoms will have atom types\n3,4,5.  These offsets apply to all occurrences of types in the data\nfile, e.g. for the Atoms or Masses or Pair Coeffs or Bond Coeffs\nsections.  This makes it easy to use atoms and molecules and their\nattributes from a data file in different simulations, where you want\ntheir types (atom, bond, angle, etc) to be different depending on what\nother types already exist.  All five offset values must be specified,\nbut individual values will be ignored if the data file does not use\nthat attribute (e.g. no bonds).\nThe shift keyword can be used to specify an (Sx, Sy, Sz)\ndisplacement applied to the coordinates of each atom.  Sz must be 0.0\nfor a 2d simulation.  This is a mechanism for adding structured\ncollections of atoms at different locations within the simulation box,\nto build up a complex geometry.  It is up to you to insure atoms do\nnot end up overlapping unphysically which would lead to bad dynamics.\nNote that the displace_atoms command can be used\nto move a subset of atoms after they have been read from a data file.\nLikewise, the delete_atoms command can be used to\nremove overlapping atoms.  Note that the shift values (Sx, Sy, Sz) are\nalso added to the simulation box information (xlo, xhi, ylo, yhi, zlo,\nzhi) in the data file to shift its boundaries.  E.g. xlo_new = xlo +\nSx, xhi_new = xhi + Sx.\nThe extra keywords can only be used the first time the read_data\ncommand is used.  They are useful if you intend to add new atom, bond,\nangle, etc types later with additional read_data commands.  This is\nbecause the maximum number of allowed atom, bond, angle, etc types is\nset by LAMMPS when the system is first initialized.  If you do not use\nthe extra keywords, then the number of these types will be limited\nto what appears in the first data file you read.  For example, if the\nfirst data file is a solid substrate of Si, it will likely specify a\nsingle atom type.  If you read a second data file with a different\nmaterial (water molecules) that sit on top of the substrate, you will\nwant to use different atom types for those atoms.  You can only do\nthis if you set the extra/atom/types keyword to a sufficiently large\nvalue when reading the substrate data file.  Note that use of the\nextra keywords also allows each data file to contain sections like\nMasses or Pair Coeffs or Bond Coeffs which are sized appropriately for\nthe number of types in that data file.  If the offset keyword is\nused appropriately when each data file is read, the values in those\nsections will be stored correctly in the larger data structures\nallocated by the use of the extra keywords.  E.g. the substrate file\ncan list mass and pair coefficients for type 1 silicon atoms.  The\nwater file can list mass and pair coefficients for type 1 and type 2\nhydrogen and oxygen atoms.  Use of the extra and offset keywords\nwill store those mass and pair coefficient values appropriately in\ndata structures that allow for 3 atom types (Si, H, O).  Of course,\nyou would still need to specify coefficients for H/Si and O/Si\ninteractions in your input script to have a complete pairwise\ninteraction model.\nAn alternative to using the extra keywords with the read_data\ncommand, is to use the create_box command to\ninitialize the simulation box and all the various type limits you need\nvia its extra keywords.  Then use the read_data command one or more\ntimes to populate the system with atoms, bonds, angles, etc, using the\noffset keyword if desired to alter types used in the various data\nfiles you read.\n\nFormat of a data file\nThe structure of the data file is important, though many settings and\nsections are optional or can come in any order.  See the examples\ndirectory for sample data files for different problems.\nA data file has a header and a body.  The header appears first.  The\nfirst line of the header is always skipped; it typically contains a\ndescription of the file.  Then lines are read one at a time.  Lines\ncan have a trailing comment starting with ‘#’ that is ignored.  If the\nline is blank (only white-space after comment is deleted), it is\nskipped.  If the line contains a header keyword, the corresponding\nvalue(s) is read from the line.  If it doesn’t contain a header\nkeyword, the line begins the body of the file.\nThe body of the file contains zero or more sections.  The first line\nof a section has only a keyword.  This line can have a trailing\ncomment starting with ‘#’ that is either ignored or can be used to\ncheck for a style match, as described below.  The next line is\nskipped.  The remaining lines of the section contain values.  The\nnumber of lines depends on the section keyword as described below.\nZero or more blank lines can be used between sections.  Sections can\nappear in any order, with a few exceptions as noted below.\nThe keyword fix can be used one or more times.  Each usage specifies\na fix that will be used to process a specific portion of the data\nfile.  Any header line containing header-string and any section with\na name containing section-string will be passed to the specified\nfix.  See the fix property/atom command for\nan example of a fix that operates in this manner.  The doc page for\nthe fix defines the syntax of the header line(s) and section(s) that\nit reads from the data file.  Note that the header-string can be\nspecified as NULL, in which case no header lines are passed to the\nfix.  This means that it can infer the length of its Section from\nstandard header settings, such as the number of atoms.\nThe formatting of individual lines in the data file (indentation,\nspacing between words and numbers) is not important except that header\nand section keywords (e.g. atoms, xlo xhi, Masses, Bond Coeffs) must\nbe capitalized as shown and can’t have extra white-space between their\nwords - e.g. two spaces or a tab between the 2 words in “xlo xhi” or\nthe 2 words in “Bond Coeffs”, is not valid.\n\nFormat of the header of a data file\nThese are the recognized header keywords.  Header lines can come in\nany order.  The value(s) are read from the beginning of the line.\nThus the keyword atoms should be in a line like “1000 atoms”; the\nkeyword ylo yhi should be in a line like “-10.0 10.0 ylo yhi”; the\nkeyword xy xz yz should be in a line like “0.0 5.0 6.0 xy xz yz”.\nAll these settings have a default value of 0, except the lo/hi box\nsize defaults are -0.5 and 0.5.  A line need only appear if the value\nis different than the default.\n\natoms = # of atoms in system\nbonds = # of bonds in system\nangles = # of angles in system\ndihedrals = # of dihedrals in system\nimpropers = # of impropers in system\natom types = # of atom types in system\nbond types = # of bond types in system\nangle types = # of angle types in system\ndihedral types = # of dihedral types in system\nimproper types = # of improper types in system\nextra bond per atom = leave space for this many new bonds per atom (deprecated, use extra/bond/per/atom keyword)\nextra angle per atom = leave space for this many new angles per atom (deprecated, use extra/angle/per/atom keyword)\nextra dihedral per atom = leave space for this many new dihedrals per atom (deprecated, use extra/dihedral/per/atom keyword)\nextra improper per atom = leave space for this many new impropers per atom (deprecated, use extra/improper/per/atom keyword)\nextra special per atom = leave space for this many new special bonds per atom (deprecated, use extra/special/per/atom keyword)\nellipsoids = # of ellipsoids in system\nlines = # of line segments in system\ntriangles = # of triangles in system\nbodies = # of bodies in system\nxlo xhi = simulation box boundaries in x dimension\nylo yhi = simulation box boundaries in y dimension\nzlo zhi = simulation box boundaries in z dimension\nxy xz yz = simulation box tilt factors for triclinic system\n\nThe initial simulation box size is determined by the lo/hi settings.\nIn any dimension, the system may be periodic or non-periodic; see the\nboundary command.  When the simulation box is created\nit is also partitioned into a regular 3d grid of rectangular bricks,\none per processor, based on the number of processors being used and\nthe settings of the processors command.  The\npartitioning can later be changed by the balance or\nfix balance commands.\nIf the xy xz yz line does not appear, LAMMPS will set up an\naxis-aligned (orthogonal) simulation box.  If the line does appear,\nLAMMPS creates a non-orthogonal simulation domain shaped as a\nparallelepiped with triclinic symmetry.  The parallelepiped has its\n“origin” at (xlo,ylo,zlo) and is defined by 3 edge vectors starting\nfrom the origin given by A = (xhi-xlo,0,0); B = (xy,yhi-ylo,0); C =\n(xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or positive or negative values\nand are called “tilt factors” because they are the amount of\ndisplacement applied to faces of an originally orthogonal box to\ntransform it into the parallelepiped.\nBy default, the tilt factors (xy,xz,yz) can not skew the box more than\nhalf the distance of the corresponding parallel box length.  For\nexample, if xlo = 2 and xhi = 12, then the x box length is 10 and the\nxy tilt factor must be between -5 and 5.  Similarly, both xz and yz\nmust be between -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not\na limitation, since if the maximum tilt factor is 5 (as in this\nexample), then configurations with tilt = …, -15, -5, 5, 15, 25,\n… are all geometrically equivalent.  If you wish to define a box\nwith tilt factors that exceed these limits, you can use the box tilt command, with a setting of large; a setting of\nsmall is the default.\nSee the Howto triclinic doc page for a\ngeometric description of triclinic boxes, as defined by LAMMPS, and\nhow to transform these parameters to and from other commonly used\ntriclinic representations.\nWhen a triclinic system is used, the simulation domain should normally\nbe periodic in the dimension that the tilt is applied to, which is\ngiven by the second dimension of the tilt factor (e.g. y for xy tilt).\nThis is so that pairs of atoms interacting across that boundary will\nhave one of them shifted by the tilt factor.  Periodicity is set by\nthe boundary command.  For example, if the xy tilt\nfactor is non-zero, then the y dimension should be periodic.\nSimilarly, the z dimension should be periodic if xz or yz is non-zero.\nLAMMPS does not require this periodicity, but you may lose atoms if\nthis is not the case.\nAlso note that if your simulation will tilt the box, e.g. via the fix deform command, the simulation box must be setup to\nbe triclinic, even if the tilt factors are initially 0.0.  You can\nalso change an orthogonal box to a triclinic box or vice versa by\nusing the change box command with its ortho and\ntriclinic options.\nFor 2d simulations, the zlo zhi values should be set to bound the z\ncoords for atoms that appear in the file; the default of -0.5 0.5 is\nvalid if all z coords are 0.0.  For 2d triclinic simulations, the xz\nand yz tilt factors must be 0.0.\nIf the system is periodic (in a dimension), then atom coordinates can\nbe outside the bounds (in that dimension); they will be remapped (in a\nperiodic sense) back inside the box.  Note that if the add option is\nbeing used to add atoms to a simulation box that already exists, this\nperiodic remapping will be performed using simulation box bounds that\nare the union of the existing box and the box boundaries in the new\ndata file.\n\nNote\nIf the system is non-periodic (in a dimension), then all atoms\nin the data file must have coordinates (in that dimension) that are\n“greater than or equal to” the lo value and “less than or equal to”\nthe hi value.  If the non-periodic dimension is of style “fixed” (see\nthe boundary command), then the atom coords must be\nstrictly “less than” the hi value, due to the way LAMMPS assign atoms\nto processors.  Note that you should not make the lo/hi values\nradically smaller/larger than the extent of the atoms.  For example,\nif your atoms extend from 0 to 50, you should not specify the box\nbounds as -10000 and 10000.  This is because LAMMPS uses the specified\nbox size to layout the 3d grid of processors.  A huge (mostly empty)\nbox will be sub-optimal for performance when using “fixed” boundary\nconditions (see the boundary command).  When using\n“shrink-wrap” boundary conditions (see the boundary\ncommand), a huge (mostly empty) box may cause a parallel simulation to\nlose atoms when LAMMPS shrink-wraps the box around the atoms.  The\nread_data command will generate an error in this case.\n\nThe “extra bond per atom” setting (angle, dihedral, improper) is only\nneeded if new bonds (angles, dihedrals, impropers) will be added to\nthe system when a simulation runs, e.g. by using the fix bond/create command. Using this header flag\nis deprecated; please use the extra/bond/per/atom keyword (and\ncorrespondingly for angles, dihedrals and impropers) in the read_data\ncommand instead. Either will pre-allocate space in LAMMPS data\nstructures for storing the new bonds (angles, dihedrals, impropers).\nThe “extra special per atom” setting is typically only needed if new\nbonds/angles/etc will be added to the system, e.g. by using the fix bond/create command.  Or if entire new molecules\nwill be added to the system, e.g. by using the\nfix deposit or fix pour commands,\nwhich will have more special 1-2,1-3,1-4 neighbors than any other\nmolecules defined in the data file.  Using this header flag is\ndeprecated; please use the extra/special/per/atom keyword instead.\nUsing this setting will pre-allocate space in the LAMMPS data\nstructures for storing these neighbors.  See the\nspecial_bonds and molecule doc\npages for more discussion of 1-2,1-3,1-4 neighbors.\n\nNote\nAll of the “extra” settings are only applied in the first data\nfile read and when no simulation box has yet been created; as soon as\nthe simulation box is created (and read_data implies that), these\nsettings are locked and cannot be changed anymore. Please see the\ndescription of the add keyword above for reading multiple data files.\nIf they appear in later data files, they are ignored.\n\nThe “ellipsoids” and “lines” and “triangles” and “bodies” settings are\nonly used with atom_style ellipsoid or line or tri or body and specify how many of the atoms are\nfinite-size ellipsoids or lines or triangles or bodies; the remainder\nare point particles.  See the discussion of ellipsoidflag and the\nEllipsoids section below.  See the discussion of lineflag and the\nLines section below.  See the discussion of triangleflag and the\nTriangles section below.  See the discussion of bodyflag and the\nBodies section below.\n\nNote\nFor atom_style template, the molecular\ntopology (bonds,angles,etc) is contained in the molecule templates\nread-in by the molecule command.  This means you\ncannot set the bonds, angles, etc header keywords in the data\nfile, nor can you define Bonds, Angles, etc sections as discussed\nbelow.  You can set the bond types, angle types, etc header\nkeywords, though it is not necessary.  If specified, they must match\nthe maximum values defined in any of the template molecules.\n\n\nFormat of the body of a data file\nThese are the section keywords for the body of the file.\n\nAtoms, Velocities, Masses, Ellipsoids, Lines, Triangles, Bodies = atom-property sections\nBonds, Angles, Dihedrals, Impropers = molecular topology sections\nPair Coeffs, PairIJ Coeffs, Bond Coeffs, Angle Coeffs, Dihedral Coeffs,    Improper Coeffs = force field sections\nBondBond Coeffs, BondAngle Coeffs, MiddleBondTorsion Coeffs,    EndBondTorsion Coeffs, AngleTorsion Coeffs, AngleAngleTorsion Coeffs,    BondBond13 Coeffs, AngleAngle Coeffs = class 2 force field sections\n\nThese keywords will check an appended comment for a match with the\ncurrently defined style:\n\nAtoms, Pair Coeffs, PairIJ Coeffs, Bond Coeffs, Angle Coeffs, Dihedral Coeffs, Improper Coeffs\n\nFor example, these lines:\nAtoms # sphere\nPair Coeffs # lj/cut\n\n\nwill check if the currently-defined atom_style is\nsphere, and the current pair_style is lj/cut.\nIf not, LAMMPS will issue a warning to indicate that the data file\nsection likely does not contain the correct number or type of\nparameters expected for the currently-defined style.\nEach section is listed below in alphabetic order.  The format of each\nsection is described including the number of lines it must contain and\nrules (if any) for where it can appear in the data file.\nAny individual line in the various sections can have a trailing\ncomment starting with “#” for annotation purposes.  E.g. in the\nAtoms section:\n10 1 17 -1.0 10.0 5.0 6.0   # salt ion\n\n\n\nAngle Coeffs section:\n\none line per angle type\nline syntax: ID coeffs\nID = angle type (1-N)\ncoeffs = list of coeffs\n\n\n\nexample:\n6 70 108.5 0 0\n\n\n\n\nThe number and meaning of the coefficients are specific to the defined\nangle style.  See the angle_style and\nangle_coeff commands for details.  Coefficients can\nalso be set via the angle_coeff command in the\ninput script.\n\nAngleAngle Coeffs section:\n\none line per improper type\nline syntax: ID coeffs\nID = improper type (1-N)\ncoeffs = list of coeffs (see improper_coeff)\n\n\n\nAngleAngleTorsion Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs (see dihedral_coeff)\n\n\n\nAngles section:\n\none line per angle\nline syntax: ID type atom1 atom2 atom3\nID = number of angle (1-Nangles)\ntype = angle type (1-Nangletype)\natom1,atom2,atom3 = IDs of 1st,2nd,3rd atoms in angle\n\n\n\n\nexample:\n\n2 2 17 29 430\n\n\n\nThe 3 atoms are ordered linearly within the angle.  Thus the central\natom (around which the angle is computed) is the atom2 in the list.\nE.g. H,O,H for a water molecule.  The Angles section must appear\nafter the Atoms section.  All values in this section must be\nintegers (1, not 1.0).\n\nAngleTorsion Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs (see dihedral_coeff)\n\n\n\nAtoms section:\n\none line per atom\nline syntax: depends on atom style\n\nAn Atoms section must appear in the data file if natoms > 0 in the\nheader section.  The atoms can be listed in any order.  These are the\nline formats for each atom style in LAMMPS.  As\ndiscussed below, each line can optionally have 3 flags (nx,ny,nz)\nappended to it, which indicate which image of a periodic simulation\nbox the atom is in.  These may be important to include for some kinds\nof analysis.\n\n\n\n\n\n\nangle\natom-ID molecule-ID atom-type x y z\n\natomic\natom-ID atom-type x y z\n\nbody\natom-ID atom-type bodyflag mass x y z\n\nbond\natom-ID molecule-ID atom-type x y z\n\ncharge\natom-ID atom-type q x y z\n\ndipole\natom-ID atom-type q x y z mux muy muz\n\ndpd\natom-ID atom-type theta x y z\n\nedpd\natom-ID atom-type edpd_temp edpd_cv x y z\n\nmdpd\natom-ID atom-type rho x y z\n\ntdpd\natom-ID atom-type x y z cc1 cc2 … ccNspecies\n\nelectron\natom-ID atom-type q spin eradius x y z\n\nellipsoid\natom-ID atom-type ellipsoidflag density x y z\n\nfull\natom-ID molecule-ID atom-type q x y z\n\nline\natom-ID molecule-ID atom-type lineflag density x y z\n\nmeso\natom-ID atom-type rho e cv x y z\n\nmolecular\natom-ID molecule-ID atom-type x y z\n\nperi\natom-ID atom-type volume density x y z\n\nsmd\natom-ID atom-type molecule volume mass kernel-radius contact-radius x y z\n\nsphere\natom-ID atom-type diameter density x y z\n\nspin\natom-ID atom-type sp x y z spx spy spz\n\ntemplate\natom-ID molecule-ID template-index template-atom atom-type x y z\n\ntri\natom-ID molecule-ID atom-type triangleflag density x y z\n\nwavepacket\natom-ID atom-type charge spin eradius etag cs_re cs_im x y z\n\nhybrid\natom-ID atom-type x y z sub-style1 sub-style2 …\n\n\n\nThe per-atom values have these meanings and units, listed alphabetically:\n\natom-ID = integer ID of atom\natom-type = type of atom (1-Ntype)\nbodyflag = 1 for body particles, 0 for point particles\ncc = chemical concentration for tDPD particles for each species (mole/volume units)\ncontact-radius = ??? (distance units)\ncs_re,cs_im = real/imaginary parts of wave packet coefficients\ncv = heat capacity (need units) for SPH particles\ndensity = density of particle (mass/distance^3 or mass/distance^2 or mass/distance units, depending on dimensionality of particle)\ndiameter = diameter of spherical atom (distance units)\ne = energy (need units) for SPH particles\nedpd_temp = temperature for eDPD particles (temperature units)\nedpd_cv = volumetric heat capacity for eDPD particles (energy/temperature/volume units)\nellipsoidflag = 1 for ellipsoidal particles, 0 for point particles\neradius = electron radius (or fixed-core radius)\netag = integer ID of electron that each wave packet belongs to\nkernel-radius = ??? (distance units)\nlineflag = 1 for line segment particles, 0 for point or spherical particles\nmass = mass of particle (mass units)\nmolecule-ID = integer ID of molecule the atom belongs to\nmux,muy,muz = components of dipole moment of atom (dipole units)\nq = charge on atom (charge units)\nrho = density (need units) for SPH particles\nspin = electron spin (+1/-1), 0 = nuclei, 2 = fixed-core, 3 = pseudo-cores (i.e. ECP)\nsp = norm of magnetic spin of atom (in number of Bohr magnetons)\nspx,spy,spz = components of magnetic spin of atom (adim normalized vector)\ntemplate-atom = which atom within a template molecule the atom is\ntemplate-index = which molecule within the molecule template the atom is part of\ntheta = internal temperature of a DPD particle\ntriangleflag = 1 for triangular particles, 0 for point or spherical particles\nvolume = volume of Peridynamic particle (distance^3 units)\nx,y,z = coordinates of atom (distance units)\n\nThe units for these quantities depend on the unit style; see the\nunits command for details.\nFor 2d simulations specify z as 0.0, or a value within the zlo zhi\nsetting in the data file header.\nThe atom-ID is used to identify the atom throughout the simulation and\nin dump files.  Normally, it is a unique value from 1 to Natoms for\neach atom.  Unique values larger than Natoms can be used, but they\nwill cause extra memory to be allocated on each processor, if an atom\nmap array is used, but not if an atom map hash is used; see the\natom_modify command for details.  If an atom map is\nnot used (e.g. an atomic system with no bonds), and you don’t care if\nunique atom IDs appear in dump files, then the atom-IDs can all be set\nto 0.\nThe molecule ID is a 2nd identifier attached to an atom.  Normally, it\nis a number from 1 to N, identifying which molecule the atom belongs\nto.  It can be 0 if it is a non-bonded atom or if you don’t care to\nkeep track of molecule assignments.\nThe diameter specifies the size of a finite-size spherical particle.\nIt can be set to 0.0, which means that atom is a point particle.\nThe ellipsoidflag, lineflag, triangleflag, and bodyflag determine\nwhether the particle is a finite-size ellipsoid or line or triangle or\nbody of finite size, or whether the particle is a point particle.\nAdditional attributes must be defined for each ellipsoid, line,\ntriangle, or body in the corresponding Ellipsoids, Lines,\nTriangles, or Bodies section.\nThe template-index and template-atom are only defined used by\natom_style template.  In this case the\nmolecule command is used to define a molecule template\nwhich contains one or more molecules.  If an atom belongs to one of\nthose molecules, its template-index and template-atom are both set\nto positive integers; if not the values are both 0.  The\ntemplate-index is which molecule (1 to Nmols) the atom belongs to.\nThe template-atom is which atom (1 to Natoms) within the molecule\nthe atom is.\nSome pair styles and fixes and computes that operate on finite-size\nparticles allow for a mixture of finite-size and point particles.  See\nthe doc pages of individual commands for details.\nFor finite-size particles, the density is used in conjunction with the\nparticle volume to set the mass of each particle as mass = density *\nvolume.  In this context, volume can be a 3d quantity (for spheres or\nellipsoids), a 2d quantity (for triangles), or a 1d quantity (for line\nsegments).  If the volume is 0.0, meaning a point particle, then the\ndensity value is used as the mass.  One exception is for the body atom\nstyle, in which case the mass of each particle (body or point\nparticle) is specified explicitly.  This is because the volume of the\nbody is unknown.\nNote that for 2d simulations of spheres, this command will treat them\nas spheres when converting density to mass.  However, they can also be\nmodeled as 2d discs (circles) if the set density/disc\ncommand is used to reset their mass after the read_data command is\nused.  A disc keyword can also be used with time integration fixes,\nsuch as fix nve/sphere and fix nvt/sphere to time integrate their motion as 2d\ndiscs (not 3d spheres), by changing their moment of inertia.\nFor atom_style hybrid, following the 5 initial values (ID,type,x,y,z),\nspecific values for each sub-style must be listed.  The order of the\nsub-styles is the same as they were listed in the\natom_style command.  The sub-style specific values\nare those that are not the 5 standard ones (ID,type,x,y,z).  For\nexample, for the “charge” sub-style, a “q” value would appear.  For\nthe “full” sub-style, a “molecule-ID” and “q” would appear.  These are\nlisted in the same order they appear as listed above.  Thus if\natom_style hybrid charge sphere\n\n\nwere used in the input script, each atom line would have these fields:\natom-ID atom-type x y z q diameter density\n\n\nNote that if a non-standard value is defined by multiple sub-styles,\nit must appear multiple times in the atom line.  E.g. the atom line\nfor atom_style hybrid dipole full would list “q” twice:\natom-ID atom-type x y z q mux muy myz molecule-ID q\n\n\nAtom lines specify the (x,y,z) coordinates of atoms.  These can be\ninside or outside the simulation box.  When the data file is read,\nLAMMPS wraps coordinates outside the box back into the box for\ndimensions that are periodic.  As discussed above, if an atom is\noutside the box in a non-periodic dimension, it will be lost.\nLAMMPS always stores atom coordinates as values which are inside the\nsimulation box.  It also stores 3 flags which indicate which image of\nthe simulation box (in each dimension) the atom would be in if its\ncoordinates were unwrapped across periodic boundaries.  An image flag\nof 0 means the atom is still inside the box when unwrapped.  A value\nof 2 means add 2 box lengths to get the unwrapped coordinate.  A value\nof -1 means subtract 1 box length to get the unwrapped coordinate.\nLAMMPS updates these flags as atoms cross periodic boundaries during\nthe simulation.  The dump command can output atom\ncoordinates in wrapped or unwrapped form, as well as the 3 image\nflags.\nIn the data file, atom lines (all lines or none of them) can\noptionally list 3 trailing integer values (nx,ny,nz), which are used\nto initialize the atom’s image flags.  If nx,ny,nz values are not\nlisted in the data file, LAMMPS initializes them to 0.  Note that the\nimage flags are immediately updated if an atom’s coordinates need to\nwrapped back into the simulation box.\nIt is only important to set image flags correctly in a data file if a\nsimulation model relies on unwrapped coordinates for some calculation;\notherwise they can be left unspecified.  Examples of LAMMPS commands\nthat use unwrapped coordinates internally are as follows:\n\nAtoms in a rigid body (see fix rigid, fix rigid/small) must have consistent image flags, so that\nwhen the atoms are unwrapped, they are near each other, i.e. as a\nsingle body.\nIf the replicate command is used to generate a larger\nsystem, image flags must be consistent for bonded atoms when the bond\ncrosses a periodic boundary.  I.e. the values of the image flags\nshould be different by 1 (in the appropriate dimension) for the two\natoms in such a bond.\nIf you plan to dump image flags and perform post-analysis\nthat will unwrap atom coordinates, it may be important that a\ncontinued run (restarted from a data file) begins with image flags\nthat are consistent with the previous run.\n\n\nNote\nIf your system is an infinite periodic crystal with bonds then\nit is impossible to have fully consistent image flags.  This is because\nsome bonds will cross periodic boundaries and connect two atoms with the\nsame image flag.\n\nAtom velocities and other atom quantities not defined above are set to\n0.0 when the Atoms section is read.  Velocities can be set later by\na Velocities section in the data file or by a\nvelocity or set command in the input\nscript.\n\nBodies section:\n\none or more lines per body\nfirst line syntax: atom-ID Ninteger Ndouble\nNinteger = # of integer quantities for this particle\nNdouble = # of floating-point quantities for this particle\n\n\n\n0 or more integer lines with total of Ninteger values\n0 or more double lines with total of Ndouble values\nexample:\n12 3 6\n2 3 2\n1.0 2.0 3.0 1.0 2.0 4.0\n\n\n\nexample:\n12 0 14\n1.0 2.0 3.0 1.0 2.0 4.0 1.0\n2.0 3.0 1.0 2.0 4.0 4.0 2.0\n\n\n\n\nThe Bodies section must appear if atom_style body\nis used and any atoms listed in the Atoms section have a bodyflag =\n1.  The number of bodies should be specified in the header section via\nthe “bodies” keyword.\nEach body can have a variable number of integer and/or floating-point\nvalues.  The number and meaning of the values is defined by the body\nstyle, as described in the Howto body doc page.  The\nbody style is given as an argument to the atom_style body command.\nThe Ninteger and Ndouble values determine how many integer and\nfloating-point values are specified for this particle.  Ninteger and\nNdouble can be as large as needed and can be different for every body.\nInteger values are then listed next on subsequent lines.  Lines are\nread one at a time until Ninteger values are read.  Floating-point\nvalues follow on subsequent lines, Again lines are read one at a time\nuntil Ndouble values are read.  Note that if there are no values of a\nparticular type, no lines appear for that type.\nThe Bodies section must appear after the Atoms section.\n\nBond Coeffs section:\n\none line per bond type\nline syntax: ID coeffs\nID = bond type (1-N)\ncoeffs = list of coeffs\n\n\n\nexample:\n4 250 1.49\n\n\n\n\nThe number and meaning of the coefficients are specific to the defined\nbond style.  See the bond_style and\nbond_coeff commands for details.  Coefficients can\nalso be set via the bond_coeff command in the input\nscript.\n\nBondAngle Coeffs section:\n\none line per angle type\nline syntax: ID coeffs\nID = angle type (1-N)\ncoeffs = list of coeffs (see class 2 section of angle_coeff)\n\n\n\nBondBond Coeffs section:\n\none line per angle type\nline syntax: ID coeffs\nID = angle type (1-N)\ncoeffs = list of coeffs (see class 2 section of angle_coeff)\n\n\n\nBondBond13 Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs (see class 2 section of dihedral_coeff)\n\n\n\nBonds section:\n\none line per bond\nline syntax: ID type atom1 atom2\nID = bond number (1-Nbonds)\ntype = bond type (1-Nbondtype)\natom1,atom2 = IDs of 1st,2nd atoms in bond\n\n\n\nexample:\n12 3 17 29\n\n\n\n\nThe Bonds section must appear after the Atoms section.  All values\nin this section must be integers (1, not 1.0).\n\nDihedral Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs\n\n\n\nexample:\n3 0.6 1 0 1\n\n\n\n\nThe number and meaning of the coefficients are specific to the defined\ndihedral style.  See the dihedral_style and\ndihedral_coeff commands for details.\nCoefficients can also be set via the\ndihedral_coeff command in the input script.\n\nDihedrals section:\n\none line per dihedral\nline syntax: ID type atom1 atom2 atom3 atom4\nID = number of dihedral (1-Ndihedrals)\ntype = dihedral type (1-Ndihedraltype)\natom1,atom2,atom3,atom4 = IDs of 1st,2nd,3rd,4th atoms in dihedral\n\n\n\nexample:\n12 4 17 29 30 21\n\n\n\n\nThe 4 atoms are ordered linearly within the dihedral.  The Dihedrals\nsection must appear after the Atoms section.  All values in this\nsection must be integers (1, not 1.0).\n\nEllipsoids section:\n\none line per ellipsoid\nline syntax: atom-ID shapex shapey shapez quatw quati quatj quatk\natom-ID = ID of atom which is an ellipsoid\nshapex,shapey,shapez = 3 diameters of ellipsoid (distance units)\nquatw,quati,quatj,quatk = quaternion components for orientation of atom\n\n\n\nexample:\n12 1 2 1 1 0 0 0\n\n\n\n\nThe Ellipsoids section must appear if atom_style ellipsoid is used and any atoms are listed in the\nAtoms section with an ellipsoidflag = 1.  The number of ellipsoids\nshould be specified in the header section via the “ellipsoids”\nkeyword.\nThe 3 shape values specify the 3 diameters or aspect ratios of a\nfinite-size ellipsoidal particle, when it is oriented along the 3\ncoordinate axes.  They must all be non-zero values.\nThe values quatw, quati, quatj, and quatk set the orientation\nof the atom as a quaternion (4-vector).  Note that the shape\nattributes specify the aspect ratios of an ellipsoidal particle, which\nis oriented by default with its x-axis along the simulation box’s\nx-axis, and similarly for y and z.  If this body is rotated (via the\nright-hand rule) by an angle theta around a unit vector (a,b,c), then\nthe quaternion that represents its new orientation is given by\n(cos(theta/2), a*sin(theta/2), b*sin(theta/2), c*sin(theta/2)).  These\n4 components are quatw, quati, quatj, and quatk as specified above.\nLAMMPS normalizes each atom’s quaternion in case (a,b,c) is not\nspecified as a unit vector.\nThe Ellipsoids section must appear after the Atoms section.\n\nEndBondTorsion Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs (see class 2 section of dihedral_coeff)\n\n\n\nImproper Coeffs section:\n\none line per improper type\nline syntax: ID coeffs\nID = improper type (1-N)\ncoeffs = list of coeffs\n\n\n\nexample:\n2 20 0.0548311\n\n\n\n\nThe number and meaning of the coefficients are specific to the defined\nimproper style.  See the improper_style and\nimproper_coeff commands for details.\nCoefficients can also be set via the\nimproper_coeff command in the input script.\n\nImpropers section:\n\none line per improper\nline syntax: ID type atom1 atom2 atom3 atom4\nID = number of improper (1-Nimpropers)\ntype = improper type (1-Nimpropertype)\natom1,atom2,atom3,atom4 = IDs of 1st,2nd,3rd,4th atoms in improper\n\n\n\nexample:\n12 3 17 29 13 100\n\n\n\n\nThe ordering of the 4 atoms determines the definition of the improper\nangle used in the formula for each improper style.  See the doc pages for individual styles\nfor details.\nThe Impropers section must appear after the Atoms section.  All\nvalues in this section must be integers (1, not 1.0).\n\nLines section:\n\none line per line segment\nline syntax: atom-ID x1 y1 x2 y2\natom-ID = ID of atom which is a line segment\nx1,y1 = 1st end point\nx2,y2 = 2nd end point\n\n\n\nexample:\n12 1.0 0.0 2.0 0.0\n\n\n\n\nThe Lines section must appear if atom_style line\nis used and any atoms are listed in the Atoms section with a\nlineflag = 1.  The number of lines should be specified in the header\nsection via the “lines” keyword.\nThe 2 end points are the end points of the line segment.  The ordering\nof the 2 points should be such that using a right-hand rule to cross\nthe line segment with a unit vector in the +z direction, gives an\n“outward” normal vector perpendicular to the line segment.\nI.e. normal = (c2-c1) x (0,0,1).  This orientation may be important\nfor defining some interactions.\nThe Lines section must appear after the Atoms section.\n\nMasses section:\n\none line per atom type\nline syntax: ID mass\nID = atom type (1-N)\nmass = mass value\n\n\n\nexample:\n3 1.01\n\n\n\n\nThis defines the mass of each atom type.  This can also be set via the\nmass command in the input script.  This section cannot be\nused for atom styles that define a mass for individual atoms -\ne.g. atom_style sphere.\n\nMiddleBondTorsion Coeffs section:\n\none line per dihedral type\nline syntax: ID coeffs\nID = dihedral type (1-N)\ncoeffs = list of coeffs (see class 2 section of dihedral_coeff)\n\n\n\nPair Coeffs section:\n\none line per atom type\nline syntax: ID coeffs\nID = atom type (1-N)\ncoeffs = list of coeffs\n\n\n\nexample:\n3 0.022 2.35197 0.022 2.35197\n\n\n\n\nThe number and meaning of the coefficients are specific to the defined\npair style.  See the pair_style and\npair_coeff commands for details.  Since pair\ncoefficients for types I != J are not specified, these will be\ngenerated automatically by the pair style’s mixing rule.  See the\nindividual pair_style doc pages and the pair_modify mix command for details.  Pair coefficients can also\nbe set via the pair_coeff command in the input\nscript.\n\nPairIJ Coeffs section:\n\none line per pair of atom types for all I,J with I <= J\nline syntax: ID1 ID2 coeffs\nID1 = atom type I = 1-N\nID2 = atom type J = I-N, with I <= J\ncoeffs = list of coeffs\n\n\n\nexamples:\n3 3 0.022 2.35197 0.022 2.35197\n3 5 0.022 2.35197 0.022 2.35197\n\n\n\n\nThis section must have N*(N+1)/2 lines where N = # of atom types.  The\nnumber and meaning of the coefficients are specific to the defined\npair style.  See the pair_style and\npair_coeff commands for details.  Since pair\ncoefficients for types I != J are all specified, these values will\nturn off the default mixing rule defined by the pair style.  See the\nindividual pair_style doc pages and the pair_modify mix command for details.  Pair coefficients can also\nbe set via the pair_coeff command in the input\nscript.\n\nTriangles section:\n\none line per triangle\nline syntax: atom-ID x1 y1 z1 x2 y2 z2 x3 y3 z3\natom-ID = ID of atom which is a line segment\nx1,y1,z1 = 1st corner point\nx2,y2,z2 = 2nd corner point\nx3,y3,z3 = 3rd corner point\n\n\n\nexample:\n12 0.0 0.0 0.0 2.0 0.0 1.0 0.0 2.0 1.0\n\n\n\n\nThe Triangles section must appear if atom_style tri is used and any atoms are listed in the Atoms\nsection with a triangleflag = 1.  The number of lines should be\nspecified in the header section via the “triangles” keyword.\nThe 3 corner points are the corner points of the triangle.  The\nordering of the 3 points should be such that using a right-hand rule\nto go from point1 to point2 to point3 gives an “outward” normal vector\nto the face of the triangle.  I.e. normal = (c2-c1) x (c3-c1).  This\norientation may be important for defining some interactions.\nThe Triangles section must appear after the Atoms section.\n\nVelocities section:\n\none line per atom\nline syntax: depends on atom style\n\n\n\n\n\n\n\nall styles except those listed\natom-ID vx vy vz\n\nelectron\natom-ID vx vy vz ervel\n\nellipsoid\natom-ID vx vy vz lx ly lz\n\nsphere\natom-ID vx vy vz wx wy wz\n\nhybrid\natom-ID vx vy vz sub-style1 sub-style2 …\n\n\n\nwhere the keywords have these meanings:\nvx,vy,vz = translational velocity of atom\nlx,ly,lz = angular momentum of aspherical atom\nwx,wy,wz = angular velocity of spherical atom\nervel = electron radial velocity (0 for fixed-core):ul\nThe velocity lines can appear in any order.  This section can only be\nused after an Atoms section.  This is because the Atoms section\nmust have assigned a unique atom ID to each atom so that velocities\ncan be assigned to them.\nVx, vy, vz, and ervel are in units of velocity.  Lx, ly,\nlz are in units of angular momentum (distance-velocity-mass).  Wx, Wy,\nWz are in units of angular velocity (radians/time).\nFor atom_style hybrid, following the 4 initial values (ID,vx,vy,vz),\nspecific values for each sub-style must be listed.  The order of the\nsub-styles is the same as they were listed in the\natom_style command.  The sub-style specific values\nare those that are not the 5 standard ones (ID,vx,vy,vz).  For\nexample, for the “sphere” sub-style, “wx”, “wy”, “wz” values would\nappear.  These are listed in the same order they appear as listed\nabove.  Thus if\natom_style hybrid electron sphere\n\n\nwere used in the input script, each velocity line would have these\nfields:\natom-ID vx vy vz ervel wx wy wz\n\n\nTranslational velocities can also be set by the\nvelocity command in the input script.",
    "syntax": "read_data file keyword args ...",
    "parameters": " * file = name of data file to read in\n * zero or more keyword/arg pairs may be appended\n * keyword = add or offset or shift or extra/atom/types or extra/bond/types or extra/angle/types or extra/dihedral/types or extra/improper/types or extra/bond/per/atom or extra/angle/per/atom or extra/dihedral/per/atom or extra/improper/per/atom or group or nocoeff or fix\n * add arg = append or IDoffset or IDoffset MOLoffset or merge\n *   append = add new atoms with atom IDs appended to current IDs\n *   IDoffset = add new atoms with atom IDs having IDoffset added\n *   MOLoffset = add new atoms with molecule IDs having MOLoffset added (only when molecule IDs are enabled)\n *   merge = add new atoms with their atom IDs (and molecule IDs) unchanged\n * offset args = toff boff aoff doff ioff\n *   toff = offset to add to atom types\n *   boff = offset to add to bond types\n *   aoff = offset to add to angle types\n *   doff = offset to add to dihedral types\n *   ioff = offset to add to improper types\n * shift args = Sx Sy Sz\n *   Sx,Sy,Sz = distance to shift atoms when adding to system (distance units)\n * extra/atom/types arg = # of extra atom types\n * extra/bond/types arg = # of extra bond types\n * extra/angle/types arg = # of extra angle types\n * extra/dihedral/types arg = # of extra dihedral types\n * extra/improper/types arg = # of extra improper types\n * extra/bond/per/atom arg = leave space for this many new bonds per atom\n * extra/angle/per/atom arg = leave space for this many new angles per atom\n * extra/dihedral/per/atom arg = leave space for this many new dihedrals per atom\n * extra/improper/per/atom arg = leave space for this many new impropers per atom\n * extra/special/per/atom arg = leave space for extra 1-2,1-3,1-4 interactions per atom\n * group args = groupID\n *   groupID = add atoms in data file to this group\n * nocoeff = ignore force field parameters\n * fix args = fix-ID header-string section-string\n *   fix-ID = ID of fix to process header lines and sections of data file\n *   header-string = header lines containing this string will be passed to fix\n *   section-string = section names with this string will be passed to fix",
    "examples": "read_data data.lj\nread_data ../run7/data.polymer.gz\nread_data data.protein fix mycmap crossterm CMAP\nread_data data.water add append offset 3 1 1 1 1 shift 0.0 0.0 50.0\nread_data data.water add merge 1 group solvent",
    "restrictions": "To read gzipped data files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option.  See the Build settings\ndoc page for details."
},
{
    "command": "read_dump",
    "html_filename": "read_dump.html",
    "short_description": "Read atom information from a dump file to overwrite the current atom coordinates, and optionally the atom velocities and image flags and the simulation box dimensions",
    "description": "Read atom information from a dump file to overwrite the current atom\ncoordinates, and optionally the atom velocities and image flags and\nthe simulation box dimensions.  This is useful for restarting a run\nfrom a particular snapshot in a dump file.  See the\nread_restart and read_data\ncommands for alternative methods to do this.  Also see the\nrerun command for a means of reading multiple snapshots\nfrom a dump file.\nNote that a simulation box must already be defined before using the\nread_dump command.  This can be done by the\ncreate_box, read_data, or\nread_restart commands.  The read_dump command can\nreset the simulation box dimensions, as explained below.\nAlso note that reading per-atom information from a dump snapshot is\nlimited to the atom coordinates, velocities and image flags, as\nexplained below.  Other atom properties, which may be necessary to run\na valid simulation, such as atom charge, or bond topology information\nfor a molecular system, are not read from (or even contained in) dump\nfiles.  Thus this auxiliary information should be defined in the usual\nway, e.g. in a data file read in by a read_data\ncommand, before using the read_dump command, or by the set\ncommand, after the dump snapshot is read.\n\nIf the dump filename specified as file ends with “.gz”, the dump\nfile is read in gzipped format.  You cannot (yet) read a dump file\nthat was written in binary format with a “.bin” suffix.\nYou can read dump files that were written (in parallel) to multiple\nfiles via the “%” wild-card character in the dump file name.  If any\nspecified dump file name contains a “%”, they must all contain it.\nSee the dump command for details.\nThe “%” wild-card character is only supported by the native format\nfor dump files, described next.\nIf reading parallel dump files, you must also use the nfile keyword\nto tell LAMMPS how many parallel files exist, via its specified\nNfiles value.\nThe format of the dump file is selected through the format keyword.\nIf specified, it must be the last keyword used, since all remaining\narguments are passed on to the dump reader.  The native format is\nfor native LAMMPS dump files, written with a dump atom or\ndump custom command.  The xyz format is for generic XYZ\nformatted dump files.  These formats take no additional values.\nThe molfile format supports reading data through using the VMD\nmolfile plugin interface. This dump reader format is only available,\nif the USER-MOLFILE package has been installed when compiling\nLAMMPS.\nThe molfile format takes one or two additional values.  The style\nvalue determines the file format to be used and can be any format that\nthe molfile plugins support, such as DCD or XYZ.  Note that DCD dump\nfiles can be written by LAMMPS via the dump dcd command.\nThe path value specifies a list of directories which LAMMPS will\nsearch for the molfile plugins appropriate to the specified style.\nThe syntax of the path value is like other search paths: it can\ncontain multiple directories separated by a colon (or semi-colon on\nwindows).  The path keyword is optional and defaults to “.”,\ni.e. the current directory.\nThe adios format supports reading data that was written by the\ndump adios command. The\nentire dump is read in parallel across all the processes, dividing\nthe atoms evenly among the processes. The number of writers that\nhas written the dump file does not matter. Using the adios style for\ndump and read_dump is a convenient way to dump all atoms from N\nwriters and read it back by M readers. If one is running two\nLAMMPS instances concurrently where one dumps data and the other is\nreading it with the rerun command, the timeout option can be specified\nto wait on the reader side for the arrival of the requested step.\nSupport for other dump format readers may be added in the future.\n\nGlobal information is first read from the dump file, namely timestep\nand box information.\nThe dump file is scanned for a snapshot with a timestamp that matches\nthe specified Nstep.  This means the LAMMPS timestep the dump file\nsnapshot was written on for the native or adios formats.\nThe list of timestamps available in an adios .bp file is stored in the\nvariable ntimestep:\n$ bpls dump.bp -d ntimestep\n  uint64_t  ntimestep  5*scalar\n    (0)    0 50 100 150 200\n\n\nNote that the xyz\nand molfile formats do not store the timestep.  For these formats,\ntimesteps are numbered logically, in a sequential manner, starting\nfrom 0.  Thus to access the 10th snapshot in an xyz or mofile\nformatted dump file, use Nstep = 9.\nThe dimensions of the simulation box for the selected snapshot are\nalso read; see the box keyword discussion below.  For the native\nformat, an error is generated if the snapshot is for a triclinic box\nand the current simulation box is orthogonal or vice versa.  A warning\nwill be generated if the snapshot box boundary conditions (periodic,\nshrink-wrapped, etc) do not match the current simulation boundary\nconditions, but the boundary condition information in the snapshot is\notherwise ignored.  See the “boundary” command for more details. The\nadios reader does the same as the native format reader.\nFor the xyz format, no information about the box is available, so\nyou must set the box flag to no.  See details below.\nFor the molfile format, reading simulation box information is\ntypically supported, but the location of the simulation box origin is\nlost and no explicit information about periodicity or\northogonal/triclinic box shape is available.  The USER-MOLFILE package\nmakes a best effort to guess based on heuristics, but this may not\nalways work perfectly.\n\nPer-atom information from the dump file snapshot is then read from the\ndump file snapshot.  This corresponds to the specified fields listed\nin the read_dump command.  It is an error to specify a z-dimension\nfield, namely z, vz, or iz, for a 2d simulation.\nFor dump files in native format, each column of per-atom data has a\ntext label listed in the file.  A matching label for each field must\nappear, e.g. the label “vy” for the field vy.  For the x, y, z\nfields any of the following labels are considered a match:\nx, xs, xu, xsu for field x\ny, ys, yu, ysu for field y\nz, zs, zu, zsu for field z\nThe meaning of xs (scaled), xu (unwrapped), and xsu (scaled and\nunwrapped) is explained on the dump command doc page.\nThese labels are searched for in the list of column labels in the dump\nfile, in order, until a match is found.\nThe dump file must also contain atom IDs, with a column label of “id”.\nIf the add keyword is specified with a value of yes or keep, as\ndiscussed below, the dump file must contain atom types, with a column\nlabel of “type”.\nIf a column label you want to read from the dump file is not a match\nto a specified field, the label keyword can be used to specify the\nspecific column label from the dump file to associate with that field.\nAn example is if a time-averaged coordinate is written to the dump\nfile via the fix ave/atom command.  The column\nwill then have a label corresponding to the fix-ID rather than “x” or\n“xs”.  The label keyword can also be used to specify new column\nlabels for fields id and type.\nFor dump files in xyz format, only the x, y, and z fields are\nsupported.  The dump file does not store atom IDs, so these are\nassigned consecutively to the atoms as they appear in the dump file,\nstarting from 1.  Thus you should insure that order of atoms is\nconsistent from snapshot to snapshot in the XYZ dump file.  See\nthe dump_modify sort command if the XYZ dump file\nwas written by LAMMPS.\nFor dump files in molfile format, the x, y, z, vx, vy, and\nvz fields can be specified.  However, not all molfile formats store\nvelocities, or their respective plugins may not support reading of\nvelocities.  The molfile dump files do not store atom IDs, so these\nare assigned consecutively to the atoms as they appear in the dump\nfile, starting from 1.  Thus you should insure that order of atoms are\nconsistent from snapshot to snapshot in the molfile dump file.\nSee the dump_modify sort command if the dump file\nwas written by LAMMPS.\nThe adios format supports all fields that the native format supports\nexcept for the q charge field.\nThe list of fields stored in an adios .bp file is recorded in the attributes\ncolumns (array of short strings) and columnstr (space-separated single string).\n$ bpls -la dump.bp column*\n  string    columns            attr   = {\"id\", \"type\", \"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\"}\n  string    columnstr          attr   = \"id type x y z vx vy vz \"\n\n\n\nInformation from the dump file snapshot is used to overwrite or\nreplace properties of the current system.  There are various options\nfor how this is done, determined by the specified fields and optional\nkeywords.\nThe timestep of the snapshot becomes the current timestep for the\nsimulation.  See the reset_timestep command if\nyou wish to change this after the dump snapshot is read.\nIf the box keyword is specified with a yes value, then the current\nsimulation box dimensions are replaced by the dump snapshot box\ndimensions.  If the box keyword is specified with a no value, the\ncurrent simulation box is unchanged.\nIf the purge keyword is specified with a yes value, then all\ncurrent atoms in the system are deleted before any of the operations\ninvoked by the replace, trim, or add keywords take place.\nIf the replace keyword is specified with a yes value, then atoms\nwith IDs that are in both the current system and the dump snapshot\nhave their properties overwritten by field values.  If the replace\nkeyword is specified with a no value, atoms with IDs that are in\nboth the current system and the dump snapshot are not modified.\nIf the trim keyword is specified with a yes value, then atoms with\nIDs that are in the current system but not in the dump snapshot are\ndeleted.  These atoms are unaffected if the trim keyword is\nspecified with a no value.\nIf the add keyword is specified with a no value (default), then\ndump file atoms with IDs that are not in the current system are not\nadded to the system.  They are simply ignored.\nIf a yes value is specified, the atoms with new IDs are added to the\nsystem but their atom IDs are not preserved.  Instead, after all the\natoms are added, new IDs are assigned to them in the same manner as is\ndescribed for the create_atoms command.  Basically\nthe largest existing atom ID in the system is identified, and all the\nadded atoms are assigned IDs that consecutively follow the largest ID.\nIf a keep value is specified, the atoms with new IDs are added to\nthe system and their atom IDs are preserved.  This may lead to\nnon-contiguous IDs for the combined system.\nNote that atoms added via the add keyword will only have the\nattributes read from the dump file due to the field arguments.  For\nexample, if x or y or z or q is not specified as a field, a\nvalue of 0.0 is used for added atoms.  Added atoms must have an atom\ntype, so this value must appear in the dump file.\nAny other attributes (e.g. charge or particle diameter for spherical\nparticles) will be set to default values, the same as if the\ncreate_atoms command were used.\n\nAtom coordinates read from the dump file are first converted into\nunscaled coordinates, relative to the box dimensions of the snapshot.\nThese coordinates are then be assigned to an existing or new atom in\nthe current simulation.  The coordinates will then be remapped to the\nsimulation box, whether it is the original box or the dump snapshot\nbox.  If periodic boundary conditions apply, this means the atom will\nbe remapped back into the simulation box if necessary.  If shrink-wrap\nboundary conditions apply, the new coordinates may change the\nsimulation box dimensions.  If fixed boundary conditions apply, the\natom will be lost if it is outside the simulation box.\nFor native format dump files, the 3 xyz image flags for an atom in\nthe dump file are set to the corresponding values appearing in the\ndump file if the ix, iy, iz fields are specified.  If not\nspecified, the image flags for replaced atoms are not changed and\nimage flags for new atoms are set to default values.  If coordinates\nread from the dump file are in unwrapped format (e.g. xu) then the\nimage flags for read-in atoms are also set to default values.  The\nremapping procedure described in the previous paragraph will then\nchange images flags for all atoms (old and new) if periodic boundary\nconditions are applied to remap an atom back into the simulation box.\n\nNote\nIf you get a warning about inconsistent image flags after\nreading in a dump snapshot, it means one or more pairs of bonded atoms\nnow have inconsistent image flags.  As discussed on the Errors common doc page this may or may not cause problems\nfor subsequent simulations.  One way this can happen is if you read\nimage flag fields from the dump file but do not also use the dump file\nbox parameters.\n\nLAMMPS knows how to compute unscaled and remapped coordinates for the\nsnapshot column labels discussed above, e.g. x, xs, xu, xsu.\nIf another column label is assigned to the x or y or z field via\nthe label keyword, e.g. for coordinates output by the fix ave/atom command, then LAMMPS needs to know whether\nthe coordinate information in the dump file is scaled and/or wrapped.\nThis can be set via the scaled and wrapped keywords.  Note that\nthe value of the scaled and wrapped keywords is ignored for fields\nx or y or z if the label keyword is not used to assign a\ncolumn label to that field.\nThe scaled/unscaled and wrapped/unwrapped setting must be identical\nfor any of the x, y, z fields that are specified.  Thus you\ncannot read xs and yu from the dump file.  Also, if the dump file\ncoordinates are scaled and the simulation box is triclinic, then all 3\nof the x, y, z fields must be specified, since they are all\nneeded to generate absolute, unscaled coordinates.",
    "syntax": "read_dump file Nstep field1 field2 ... keyword values ...",
    "parameters": " * file = name of dump file to read\n * Nstep = snapshot timestep to read from file\n * one or more fields may be appended\n * field = x or y or z or vx or vy or vz or q or ix or iy or iz or fx or fy or fz\n *   x,y,z = atom coordinates\n *   vx,vy,vz = velocity components\n *   q = charge\n *   ix,iy,iz = image flags in each dimension\n *   fx,fy,fz = force components\n * zero or more keyword/value pairs may be appended\n * keyword = nfile or box or replace or purge or trim or add or label or scaled or wrapped or format\n * nfile value = Nfiles = how many parallel dump files exist\n * box value = yes or no = replace simulation box with dump box\n * replace value = yes or no = overwrite atoms with dump atoms\n * purge value = yes or no = delete all atoms before adding dump atoms\n * trim value = yes or no = trim atoms not in dump snapshot\n * add value = yes or keep or no = add new dump atoms to system\n * label value = field column\n *   field = one of the listed fields or id or type\n *   column = label on corresponding column in dump file\n * scaled value = yes or no = coords in dump file are scaled/unscaled\n * wrapped value = yes or no = coords in dump file are wrapped/unwrapped\n * format values = format of dump file, must be last keyword if used\n *   native = native LAMMPS dump file\n *   xyz = XYZ file\n *   adios [timeout value] = dump file written by the dump adios command\n *     timeout = specify waiting time for the arrival of the timestep when running concurrently.\n *               The value is a float number and is interpreted in seconds.\n *   molfile style path = VMD molfile plugin interface\n *     style = dcd or xyz or others supported by molfile plugins\n *     path = optional path for location of molfile plugins",
    "examples": "read_dump dump.file 5000 x y z\nread_dump dump.xyz 5 x y z box no format xyz\nread_dump dump.xyz 10 x y z box no format molfile xyz \"../plugins\"\nread_dump dump.dcd 0 x y z box yes format molfile dcd\nread_dump dump.file 1000 x y z vx vy vz box yes format molfile lammpstrj /usr/local/lib/vmd/plugins/LINUXAMD64/plugins/molfile\nread_dump dump.file 5000 x y vx vy trim yes\nread_dump ../run7/dump.file.gz 10000 x y z box yes\nread_dump dump.xyz 10 x y z box no format molfile xyz ../plugins\nread_dump dump.dcd 0 x y z format molfile dcd\nread_dump dump.file 1000 x y z vx vy vz format molfile lammpstrj /usr/local/lib/vmd/plugins/LINUXAMD64/plugins/molfile\nread_dump dump.bp 5000 x y z vx vy vz format adios\nread_dump dump.bp 5000 x y z vx vy vz format adios timeout 60.0",
    "restrictions": "To read gzipped dump files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option.  See the Build settings\ndoc page for details.\nThe molfile dump file formats are part of the USER-MOLFILE package.\nThey are only enabled if LAMMPS was built with that packages.  See the\nBuild package doc page for more info.\nTo write and read adios .bp files, you must compile LAMMPS with the\nUSER-ADIOS package."
},
{
    "command": "read_restart",
    "html_filename": "read_restart.html",
    "short_description": "Read in a previously saved system configuration from a restart file",
    "description": "Read in a previously saved system configuration from a restart file.\nThis allows continuation of a previous run.  Details about what\ninformation is stored (and not stored) in a restart file is given\nbelow.  Basically this operation will re-create the simulation box\nwith all its atoms and their attributes as well as some related global\nsettings, at the point in time it was written to the restart file by a\nprevious simulation.  The simulation box will be partitioned into a\nregular 3d grid of rectangular bricks, one per processor, based on the\nnumber of processors in the current simulation and the settings of the\nprocessors command.  The partitioning can later be\nchanged by the balance or fix balance commands.\n\nNote\nNormally, restart files are written by the\nrestart or write_restart commands\nso that all atoms in the restart file are inside the simulation box.\nIf this is not the case, the read_restart command will print an error\nthat atoms were “lost” when the file is read.  This error should be\nreported to the LAMMPS developers so the invalid writing of the\nrestart file can be fixed.  If you still wish to use the restart file,\nthe optional remap flag can be appended to the read_restart command.\nThis should avoid the error, by explicitly remapping each atom back\ninto the simulation box, updating image flags for the atom\nappropriately.\n\nRestart files are saved in binary format to enable exact restarts,\nmeaning that the trajectories of a restarted run will precisely match\nthose produced by the original run had it continued on.\nSeveral things can prevent exact restarts due to round-off effects, in\nwhich case the trajectories in the 2 runs will slowly diverge.  These\ninclude running on a different number of processors or changing\ncertain settings such as those set by the newton or\nprocessors commands.  LAMMPS will issue a warning in\nthese cases.\nCertain fixes will not restart exactly, though they should provide\nstatistically similar results.  These include fix shake and fix langevin.\nCertain pair styles will not restart exactly, though they should\nprovide statistically similar results.  This is because the forces\nthey compute depend on atom velocities, which are used at half-step\nvalues every timestep when forces are computed.  When a run restarts,\nforces are initially evaluated with a full-step velocity, which is\ndifferent than if the run had continued.  These pair styles include\ngranular pair styles, pair dpd, and\npair lubricate.\nIf a restarted run is immediately different than the run which\nproduced the restart file, it could be a LAMMPS bug, so consider\nreporting it if you think the behavior is a bug.\nBecause restart files are binary, they may not be portable to other\nmachines.  In this case, you can use the -restart command-line switch to convert a restart file to a data file.\nSimilar to how restart files are written (see the\nwrite_restart and restart\ncommands), the restart filename can contain two wild-card characters.\nIf a “*” appears in the filename, the directory is searched for all\nfilenames that match the pattern where “*” is replaced with a timestep\nvalue.  The file with the largest timestep value is read in.  Thus,\nthis effectively means, read the latest restart file.  It’s useful if\nyou want your script to continue a run from where it left off.  See\nthe run command and its “upto” option for how to specify\nthe run command so it doesn’t need to be changed either.\nIf a “%” character appears in the restart filename, LAMMPS expects a\nset of multiple files to exist.  The restart and\nwrite_restart commands explain how such sets are\ncreated.  Read_restart will first read a filename where “%” is\nreplaced by “base”.  This file tells LAMMPS how many processors\ncreated the set and how many files are in it.  Read_restart then reads\nthe additional files.  For example, if the restart file was specified\nas save.% when it was written, then read_restart reads the files\nsave.base, save.0, save.1, … save.P-1, where P is the number of\nprocessors that created the restart file.\nNote that P could be the total number of processors in the previous\nsimulation, or some subset of those processors, if the fileper or\nnfile options were used when the restart file was written; see the\nrestart and write_restart commands\nfor details.  The processors in the current LAMMPS simulation share\nthe work of reading these files; each reads a roughly equal subset of\nthe files.  The number of processors which created the set can be\ndifferent the number of processors in the current LAMMPS simulation.\nThis can be a fast mode of input on parallel machines that support\nparallel I/O.\nA restart file can also be read in parallel as one large binary file\nvia the MPI-IO library, assuming it was also written with MPI-IO.\nMPI-IO is part of the MPI standard for versions 2.0 and above.  Using\nMPI-IO requires two steps.  First, build LAMMPS with its MPIIO package\ninstalled, e.g.\nmake yes-mpiio    # installs the MPIIO package\nmake mpi          # build LAMMPS for your platform\n\n\nSecond, use a restart filename which contains “.mpiio”.  Note that it\ndoes not have to end in “.mpiio”, just contain those characters.\nUnlike MPI-IO dump files, a particular restart file must be both\nwritten and read using MPI-IO.\n\nHere is the list of information included in a restart file, which\nmeans these quantities do not need to be re-specified in the input\nscript that reads the restart file, though you can redefine many of\nthese settings after the restart file is read.\n\nunits\nnewton bond (see discussion of newton command below)\natom style and atom_modify settings id, map, sort\ncomm style and comm_modify settings mode, cutoff, vel\ntimestep\nsimulation box size and shape and boundary settings\natom group definitions\nper-type atom settings such as mass\nper-atom attributes including their group assignments and molecular topology attributes (bonds, angles, etc)\nforce field styles (pair, bond, angle, etc)\nforce field coefficients (pair, bond, angle, etc) in some cases (see below)\npair_modify settings, except the compute option\nspecial_bonds settings\n\nHere is a list of information not stored in a restart file, which\nmeans you must re-issue these commands in your input script, after\nreading the restart file.\n\nnewton pair (see discussion of newton command below)\nfix commands (see below)\ncompute commands (see below)\nvariable commands\nregion commands\nneighbor list criteria including neigh_modify settings\nkspace_style and kspace_modify settings\ninfo for thermodynamic, dump, or restart output\n\nThe newton command has two settings, one for pairwise\ninteractions, the other for bonded.  Both settings are stored in the\nrestart file.  For the bond setting, the value in the file will\noverwrite the current value (at the time the read_restart command is\nissued) and warn if the two values are not the same and the current\nvalue is not the default.  For the pair setting, the value in the file\nwill not overwrite the current value (so that you can override the\nprevious run’s value), but a warning is issued if the two values are\nnot the same and the current value is not the default.\nNote that some force field styles (pair, bond, angle, etc) do not\nstore their coefficient info in restart files.  Typically these are\nmany-body or tabulated potentials which read their parameters from\nseparate files.  In these cases you will need to re-specify the\npair_coeff, bond_coeff, etc\ncommands in your restart input script.  The doc pages for individual\nforce field styles mention if this is the case.  This is also true of\npair_style hybrid (bond hybrid, angle hybrid, etc)\ncommands; they do not store coefficient info.\nAs indicated in the above list, the fixes used for a\nsimulation are not stored in the restart file.  This means the new\ninput script should specify all fixes it will use.  However, note that\nsome fixes store an internal “state” which is written to the restart\nfile.  This allows the fix to continue on with its calculations in a\nrestarted simulation.  To re-enable such a fix, the fix command in the\nnew input script must be of the same style and use the same fix-ID as\nwas used in the input script that wrote the restart file.\nIf a match is found, LAMMPS prints a message indicating that the fix\nis being re-enabled.  If no match is found before the first run or\nminimization is performed by the new script, the “state” information\nfor the saved fix is discarded.  At the time the discard occurs,\nLAMMPS will also print a list of fixes for which the information is\nbeing discarded.  See the doc pages for individual fixes for info on\nwhich ones can be restarted in this manner.  Note that fixes which are\ncreated internally by other LAMMPS commands (computes, fixes, etc)\nwill have style names which are all-capitalized, and IDs which are\ngenerated internally.\nLikewise, the computes used for a simulation are not stored\nin the restart file.  This means the new input script should specify\nall computes it will use.  However, some computes create a fix\ninternally to store “state” information that persists from timestep to\ntimestep.  An example is the compute msd command\nwhich uses a fix to store a reference coordinate for each atom, so\nthat a displacement can be calculated at any later time.  If the\ncompute command in the new input script uses the same compute-ID and\ngroup-ID as was used in the input script that wrote the restart file,\nthen it will create the same fix in the restarted run.  This means the\nre-created fix will be re-enabled with the stored state information as\ndescribed in the previous paragraph, so that the compute can continue\nits calculations in a consistent manner.\n\nNote\nThere are a handful of commands which can be used before or\nbetween runs which may require a system initialization.  Examples\ninclude the “balance”, “displace_atoms”, “delete_atoms”, “set” (some\noptions), and “velocity” (some options) commands.  This is because\nthey can migrate atoms to new processors.  Thus they will also discard\nunused “state” information from fixes.  You will know the discard has\noccurred because a list of discarded fixes will be printed to the\nscreen and log file, as explained above.  This means that if you wish\nto retain that info in a restarted run, you must re-specify the\nrelevant fixes and computes (which create fixes) before those commands\nare used.\n\nSome pair styles, like the granular pair styles, also\nuse a fix to store “state” information that persists from timestep to\ntimestep.  In the case of granular potentials, it is contact\ninformation between pairs of touching particles.  This info will also\nbe re-enabled in the restart script, assuming you re-use the same\ngranular pair style.\nLAMMPS allows bond interactions (angle, etc) to be turned off or\ndeleted in various ways, which can affect how their info is stored in\na restart file.\nIf bonds (angles, etc) have been turned off by the fix shake or delete_bonds command,\ntheir info will be written to a restart file as if they are turned on.\nThis means they will need to be turned off again in a new run after\nthe restart file is read.\nBonds that are broken (e.g. by a bond-breaking potential) are written\nto the restart file as broken bonds with a type of 0.  Thus these\nbonds will still be broken when the restart file is read.\nBonds that have been broken by the fix bond/break command have disappeared from the\nsystem.  No information about these bonds is written to the restart\nfile.",
    "syntax": "read_restart file flag",
    "parameters": " * file = name of binary restart file to read in\n * flag = remap (optional)",
    "examples": "read_restart save.10000\nread_restart save.10000 remap\nread_restart restart.*\nread_restart restart.*.mpiio\nread_restart poly.*.% remap",
    "restrictions": "To write and read restart files in parallel with MPI-IO, the MPIIO\npackage must be installed."
},
{
    "command": "region",
    "html_filename": "region.html",
    "short_description": "This command defines a geometric region of space",
    "description": "This command defines a geometric region of space.  Various other\ncommands use regions.  For example, the region can be filled with\natoms via the create_atoms command.  Or a bounding\nbox around the region, can be used to define the simulation box via\nthe create_box command.  Or the atoms in the region\ncan be identified as a group via the group command, or\ndeleted via the delete_atoms command.  Or the\nsurface of the region can be used as a boundary wall via the fix wall/region command.\nCommands which use regions typically test whether an atom’s position\nis contained in the region or not.  For this purpose, coordinates\nexactly on the region boundary are considered to be interior to the\nregion.  This means, for example, for a spherical region, an atom on\nthe sphere surface would be part of the region if the sphere were\ndefined with the side in keyword, but would not be part of the\nregion if it were defined using the side out keyword.  See more\ndetails on the side keyword below.\nNormally, regions in LAMMPS are “static”, meaning their geometric\nextent does not change with time.  If the move or rotate keyword\nis used, as described below, the region becomes “dynamic”, meaning\nit’s location or orientation changes with time.  This may be useful,\nfor example, when thermostatting a region, via the compute temp/region\ncommand, or when the fix wall/region command uses a region surface as\na bounding wall on particle motion, i.e. a rotating container.\nThe delete style removes the named region.  Since there is little\noverhead to defining extra regions, there is normally no need to do\nthis, unless you are defining and discarding large numbers of regions\nin your input script.\nThe lo/hi values for block or cone or cylinder or prism styles\ncan be specified as EDGE or INF.  EDGE means they extend all the way\nto the global simulation box boundary.  Note that this is the current\nbox boundary; if the box changes size during a simulation, the region\ndoes not.  INF means a large negative or positive number (1.0e20), so\nit should encompass the simulation box even if it changes size.  If a\nregion is defined before the simulation box has been created (via\ncreate_box or read_data or\nread_restart commands), then an EDGE or INF\nparameter cannot be used.  For a prism region, a non-zero tilt\nfactor in any pair of dimensions cannot be used if both the lo/hi\nvalues in either of those dimensions are INF.  E.g. if the xy tilt is\nnon-zero, then xlo and xhi cannot both be INF, nor can ylo and yhi.\n\nNote\nRegions in LAMMPS do not get wrapped across periodic boundaries,\nas specified by the boundary command.  For example, a\nspherical region that is defined so that it overlaps a periodic\nboundary is not treated as 2 half-spheres, one on either side of the\nsimulation box.\n\n\nNote\nRegions in LAMMPS are always 3d geometric objects, regardless of\nwhether the dimension of a simulation is 2d or 3d.\nThus when using regions in a 2d simulation, you should be careful to\ndefine the region so that its intersection with the 2d x-y plane of\nthe simulation has the 2d geometric extent you want.\n\nFor style cone, an axis-aligned cone is defined which is like a\ncylinder except that two different radii (one at each end) can be\ndefined.  Either of the radii (but not both) can be 0.0.\nFor style cone and cylinder, the c1,c2 params are coordinates in\nthe 2 other dimensions besides the cylinder axis dimension.  For dim =\nx, c1/c2 = y/z; for dim = y, c1/c2 = x/z; for dim = z, c1/c2 = x/y.\nThus the third example above specifies a cylinder with its axis in the\ny-direction located at x = 2.0 and z = 3.0, with a radius of 5.0, and\nextending in the y-direction from -5.0 to the upper box boundary.\nFor style plane, a plane is defined which contain the point\n(px,py,pz) and has a normal vector (nx,ny,nz).  The normal vector does\nnot have to be of unit length.  The “inside” of the plane is the\nhalf-space in the direction of the normal vector; see the discussion\nof the side option below.\nFor style prism, a parallelepiped is defined (it’s too hard to spell\nparallelepiped in an input script!).  The parallelepiped has its\n“origin” at (xlo,ylo,zlo) and is defined by 3 edge vectors starting\nfrom the origin given by A = (xhi-xlo,0,0); B = (xy,yhi-ylo,0); C =\n(xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or positive or negative values\nand are called “tilt factors” because they are the amount of\ndisplacement applied to faces of an originally orthogonal box to\ntransform it into the parallelepiped.\nA prism region that will be used with the create_box\ncommand to define a triclinic simulation box must have tilt factors\n(xy,xz,yz) that do not skew the box more than half the distance of\ncorresponding the parallel box length.  For example, if xlo = 2 and\nxhi = 12, then the x box length is 10 and the xy tilt factor must be\nbetween -5 and 5.  Similarly, both xz and yz must be between\n-(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a limitation,\nsince if the maximum tilt factor is 5 (as in this example), then\nconfigurations with tilt = …, -15, -5, 5, 15, 25, … are all\ngeometrically equivalent.\nThe radius value for style sphere and cylinder can be specified\nas an equal-style variable.  If the value is a\nvariable, it should be specified as v_name, where name is the variable\nname.  In this case, the variable will be evaluated each timestep, and\nits value used to determine the radius of the region. For style sphere\nalso the x-, y-, and z- coordinate of the center of the sphere and for\nstyle cylinder the two center positions c1 and c2 for the location of\nthe cylinder axes can be a variable with the same kind of effect and\nrequirements than for the radius.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  Thus it is easy to specify a time-dependent radius or have\na time dependent position of the sphere or cylinder region.\nSee the Howto tricilinc doc page for a\ngeometric description of triclinic boxes, as defined by LAMMPS, and\nhow to transform these parameters to and from other commonly used\ntriclinic representations.\nThe union style creates a region consisting of the volume of all the\nlisted regions combined.  The intersect style creates a region\nconsisting of the volume that is common to all the listed regions.\n\nNote\nThe union and intersect regions operate by invoking methods\nfrom their list of sub-regions.  Thus you cannot delete the\nsub-regions after defining a union or intersection region.\n\n\nThe side keyword determines whether the region is considered to be\ninside or outside of the specified geometry.  Using this keyword in\nconjunction with union and intersect regions, complex geometries\ncan be built up.  For example, if the interior of two spheres were\neach defined as regions, and a union style with side = out was\nconstructed listing the region-IDs of the 2 spheres, the resulting\nregion would be all the volume in the simulation box that was outside\nboth of the spheres.\nThe units keyword determines the meaning of the distance units used\nto define the region for any argument above listed as having distance\nunits.  It also affects the scaling of the velocity vector specified\nwith the vel keyword, the amplitude vector specified with the\nwiggle keyword, and the rotation point specified with the rotate\nkeyword, since they each involve a distance metric.\nA box value selects standard distance units as defined by the\nunits command, e.g. Angstroms for units = real or metal.\nA lattice value means the distance units are in lattice spacings.\nThe lattice command must have been previously used to\ndefine the lattice spacings which are used as follows:\n\nFor style block, the lattice spacing in dimension x is applied to\nxlo and xhi, similarly the spacings in dimensions y,z are applied to\nylo/yhi and zlo/zhi.\nFor style cone, the lattice spacing in argument dim is applied to\nlo and hi.  The spacings in the two radial dimensions are applied to\nc1 and c2.  The two cone radii are scaled by the lattice\nspacing in the dimension corresponding to c1.\nFor style cylinder, the lattice spacing in argument dim is applied\nto lo and hi.  The spacings in the two radial dimensions are applied\nto c1 and c2.  The cylinder radius is scaled by the lattice\nspacing in the dimension corresponding to c1.\nFor style plane, the lattice spacing in dimension x is applied to\npx and nx, similarly the spacings in dimensions y,z are applied to\npy/ny and pz/nz.\nFor style prism, the lattice spacing in dimension x is applied to\nxlo and xhi, similarly for ylo/yhi and zlo/zhi.  The lattice spacing\nin dimension x is applied to xy and xz, and the spacing in dimension y\nto yz.\nFor style sphere, the lattice spacing in dimensions x,y,z are\napplied to the sphere center x,y,z.  The spacing in dimension x is\napplied to the sphere radius.\n\n\nIf the move or rotate keywords are used, the region is “dynamic”,\nmeaning its location or orientation changes with time.  These keywords\ncannot be used with a union or intersect style region.  Instead,\nthe keywords should be used to make the individual sub-regions of the\nunion or intersect region dynamic.  Normally, each sub-region\nshould be “dynamic” in the same manner (e.g. rotate around the same\npoint), though this is not a requirement.\nThe move keyword allows one or more equal-style variables to be used to specify the x,y,z displacement\nof the region, typically as a function of time.  A variable is\nspecified as v_name, where name is the variable name.  Any of the\nthree variables can be specified as NULL, in which case no\ndisplacement is calculated in that dimension.\nNote that equal-style variables can specify formulas with various\nmathematical functions, and include thermo_style\ncommand keywords for the simulation box parameters and timestep and\nelapsed time.  Thus it is easy to specify a region displacement that\nchange as a function of time or spans consecutive runs in a continuous\nfashion.  For the latter, see the start and stop keywords of the\nrun command and the elaplong keyword of thermo_style custom for details.\nFor example, these commands would displace a region from its initial\nposition, in the positive x direction, effectively at a constant\nvelocity:\nvariable dx equal ramp(0,10)\nregion 2 sphere 10.0 10.0 0.0 5 move v_dx NULL NULL\n\n\nNote that the initial displacement is 0.0, though that is not required.\nEither of these variables would “wiggle” the region back and forth in\nthe y direction:\nvariable dy equal swiggle(0,5,100)\nvariable dysame equal 5*sin(2*PI*elaplong*dt/100)\nregion 2 sphere 10.0 10.0 0.0 5 move NULL v_dy NULL\nThe rotate keyword rotates the region around a rotation axis R =\n(Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The rotation\nangle is calculated, presumably as a function of time, by a variable\nspecified as v_theta, where theta is the variable name.  The variable\nshould generate its result in radians.  The direction of rotation for\nthe region around the rotation axis is consistent with the right-hand\nrule: if your right-hand thumb points along R, then your fingers\nwrap around the axis in the direction of rotation.\nThe move and rotate keywords can be used together.  In this case,\nthe displacement specified by the move keyword is applied to the P\npoint of the rotate keyword.\n\nThe open keyword can be used (multiple times) to indicate that one\nor more faces of the region are ignored for purposes of particle/wall\ninteractions.  This keyword is only relevant for regions used by the\nfix wall/region and fix wall/gran/region commands.  It can be used\nto create “open” containers where only some of the region faces are\nwalls.  For example, a funnel can be created with a cone style\nregion that has an open face at the smaller radius for particles to\nflow out, or at the larger radius for pouring particles into the cone,\nor both.\nNote that using the open keyword partly overrides the side\nkeyword, since both exterior and interior surfaces of an open region\nare tested for particle contacts.  The exception to this is a union\nor intersect region which includes an open sub-region.  In that case\nthe side keyword is still used to define the union/intersect region\nvolume, and the open settings are only applied to the individual\nsub-regions that use them.\nThe indices specified as part of the open keyword have the following\nmeanings:\nFor style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi,\nzlo, zhi surfaces of the block.  I.e. 1 is the yz plane at x = xlo, 2\nis the yz-plane at x = xhi, 3 is the xz plane at y = ylo, 4 is the xz\nplane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z\n= zhi).  In the second-to-last example above, the region is a box open\nat both xy planes.\nFor style prism, values 1-6 have the same mapping as for style\nblock.  I.e. in an untilted prism, open indices correspond to\nthe xlo, xhi, ylo, yhi, zlo, zhi surfaces.\nFor style cylinder, index 1 corresponds to the flat end cap at the\nlow coordinate along the cylinder axis, index 2 corresponds to the\nhigh-coordinate flat end cap along the cylinder axis, and index 3 is\nthe curved cylinder surface.  For example, a cylinder region with\nopen 1 open 2 keywords will be open at both ends (e.g. a section of\npipe), regardless of the cylinder orientation.\nFor style cone, the mapping is the same as for style cylinder.\nIndex 1 is the low-coordinate flat end cap, index 2 is the\nhigh-coordinate flat end cap, and index 3 is the curved cone surface.\nIn the last example above, a cone region is defined along the z-axis\nthat is open at the zlo value (e.g. for use as a funnel).\nFor all other styles, the open keyword is ignored.  As indicated\nabove, this includes the intersect and union regions, though their\nsub-regions can be defined with the open keyword.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThe code using the region (such as a fix or compute) must also be supported\nby Kokkos or no acceleration will occur. Currently, only block style\nregions are supported by Kokkos.\nThese accelerated styles are part of the Kokkos package.  They are\nonly enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "region ID style args keyword arg ...",
    "parameters": " * ID = user-assigned name for the region\n * style = delete or block or cone or cylinder or plane or prism or sphere or union or intersect\n * delete = no args\n * block args = xlo xhi ylo yhi zlo zhi\n *   xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)\n * cone args = dim c1 c2 radlo radhi lo hi\n *   dim = x or y or z = axis of cone\n *   c1,c2 = coords of cone axis in other 2 dimensions (distance units)\n *   radlo,radhi = cone radii at lo and hi end (distance units)\n *   lo,hi = bounds of cone in dim (distance units)\n * cylinder args = dim c1 c2 radius lo hi\n *   dim = x or y or z = axis of cylinder\n *   c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n *   radius = cylinder radius (distance units)\n *     c1,c2, and radius can be a variable (see below)\n *   lo,hi = bounds of cylinder in dim (distance units)\n * plane args = px py pz nx ny nz\n *   px,py,pz = point on the plane (distance units)\n *   nx,ny,nz = direction normal to plane (distance units)\n * prism args = xlo xhi ylo yhi zlo zhi xy xz yz\n *   xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)\n *   xy = distance to tilt y in x direction (distance units)\n *   xz = distance to tilt z in x direction (distance units)\n *   yz = distance to tilt z in y direction (distance units)\n * sphere args = x y z radius\n *   x,y,z = center of sphere (distance units)\n *   radius = radius of sphere (distance units)\n *     x,y,z, and radius can be a variable (see below)\n * union args = N reg-ID1 reg-ID2 ...\n *   N = # of regions to follow, must be 2 or greater\n *   reg-ID1,reg-ID2, ... = IDs of regions to join together\n * intersect args = N reg-ID1 reg-ID2 ...\n *   N = # of regions to follow, must be 2 or greater\n *   reg-ID1,reg-ID2, ... = IDs of regions to intersect\n * zero or more keyword/arg pairs may be appended\n * keyword = side or units or move or rotate or open\n * side value = in or out\n *   in = the region is inside the specified geometry\n *   out = the region is outside the specified geometry\n * units value = lattice or box\n *   lattice = the geometry is defined in lattice units\n *   box = the geometry is defined in simulation box units\n * move args = v_x v_y v_z\n *   v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time\n * rotate args = v_theta Px Py Pz Rx Ry Rz\n *   v_theta = equal-style variable for rotaton of region over time (in radians)\n *   Px,Py,Pz = origin for axis of rotation (distance units)\n *   Rx,Ry,Rz = axis of rotation vector\n * open value = integer from 1-6 corresponding to face index (see below)\n * accelerated styles (with same args) = block/kk",
    "examples": "region 1 block -3.0 5.0 INF 10.0 INF INF\nregion 2 sphere 0.0 0.0 0.0 5 side out\nregion void cylinder y 2 3 5 -5.0 EDGE units box\nregion 1 prism 0 10 0 10 0 10 2 0 0\nregion outside union 4 side1 side2 side3 side4\nregion 2 sphere 0.0 0.0 0.0 5 side out move v_left v_up NULL\nregion openbox block 0 10 0 10 0 10 open 5 open 6 units box\nregion funnel cone z 10 10 2 5 0 10 open 1 units box",
    "restrictions": "A prism cannot be of 0.0 thickness in any dimension; use a small z\nthickness for 2d simulations.  For 2d simulations, the xz and yz\nparameters must be 0.0."
},
{
    "command": "replicate",
    "html_filename": "replicate.html",
    "short_description": "Replicate the current simulation one or more times in each dimension",
    "description": "Replicate the current simulation one or more times in each dimension.\nFor example, replication factors of 2,2,2 will create a simulation\nwith 8x as many atoms by doubling the simulation domain in each\ndimension.  A replication factor of 1 in a dimension leaves the\nsimulation domain unchanged.  When the new simulation box is created\nit is also partitioned into a regular 3d grid of rectangular bricks,\none per processor, based on the number of processors being used and\nthe settings of the processors command.  The\npartitioning can later be changed by the balance or\nfix balance commands.\nAll properties of the atoms are replicated, including their\nvelocities, which may or may not be desirable.  New atom IDs are\nassigned to new atoms, as are molecule IDs.  Bonds and other topology\ninteractions are created between pairs of new atoms as well as between\nold and new atoms.  This is done by using the image flag for each atom\nto “unwrap” it out of the periodic box before replicating it.\nThis means that any molecular bond you specify in the original data\nfile that crosses a periodic boundary should be between two atoms with\nimage flags that differ by 1.  This will allow the bond to be\nunwrapped appropriately.\nThe optional keyword bbox uses a bounding box to only check atoms in\nreplicas that overlap with a processor’s sub-domain when assigning\natoms to processors.  It typically results in a substantial speedup\nwhen using the replicate command on a large number of processors.  It\ndoes require temporary use of more memory, specifically that each\nprocessor can store all atoms in the entire system before it is\nreplicated.",
    "syntax": "replicate nx ny nz keyword",
    "parameters": " * nx,ny,nz = replication factors in each dimension\n * optional keyword = bbox\n * bbox = only check atoms in replicas that overlap with a processor's sub-domain",
    "examples": "replicate 2 3 2",
    "restrictions": "A 2d simulation cannot be replicated in the z dimension.\nIf a simulation is non-periodic in a dimension, care should be used\nwhen replicating it in that dimension, as it may put atoms nearly on\ntop of each other.\n\nNote\nYou cannot use the replicate command on a system which has a\nmolecule that spans the box and is bonded to itself across a periodic\nboundary, so that the molecule is effectively a loop.  A simple\nexample would be a linear polymer chain that spans the simulation box\nand bonds back to itself across the periodic boundary.  More realistic\nexamples would be a CNT (meant to be an infinitely long CNT) or a\ngraphene sheet or a bulk periodic crystal where there are explicit\nbonds specified between near neighbors.  (Note that this only applies\nto systems that have permanent bonds as specified in the data file.  A\nCNT that is just atoms modeled with the AIREBO potential has no such permanent bonds, so it can be\nreplicated.)  The reason replication does not work with those systems\nis that the image flag settings described above cannot be made\nconsistent.  I.e. it is not possible to define images flags so that\nwhen every pair of bonded atoms is unwrapped (using the image flags),\nthey will be close to each other.  The only way the replicate command\ncould work in this scenario is for it to break a bond, insert more\natoms, and re-connect the loop for the larger simulation box.  But it\nis not clever enough to do this.  So you will have to construct a\nlarger version of your molecule as a pre-processing step and input a\nnew data file to LAMMPS.\n\nIf the current simulation was read in from a restart file (before a\nrun is performed), there must not be any fix information stored in\nthe file for individual atoms.  Similarly, no fixes can be defined at\nthe time the replicate command is used that require vectors of atom\ninformation to be stored.  This is because the replicate command does\nnot know how to replicate that information for new atoms it creates.\nTo work around this restriction, restart files may be converted into\ndata files and fixes may be undefined via the unfix\ncommand before and redefined after the replicate command.\nRelated commands: none\nDefault: none"
},
{
    "command": "rerun",
    "html_filename": "rerun.html",
    "short_description": "Perform a pseudo simulation run where atom information is read one snapshot at a time from a dump file(s), and energies and forces are computed on the shapshot to produce thermodynamic or other output",
    "description": "Perform a pseudo simulation run where atom information is read one\nsnapshot at a time from a dump file(s), and energies and forces are\ncomputed on the shapshot to produce thermodynamic or other output.\nThis can be useful in the following kinds of scenarios, after an\ninitial simulation produced the dump file:\n\nCompute the energy and forces of snaphots using a different potential.\nCalculate one or more diagnostic quantities on the snapshots that\nweren’t computed in the initial run.  These can also be computed with\nsettings not used in the initial run, e.g. computing an RDF via the\ncompute rdf command with a longer cutoff than was\nused initially.\nCalculate the portion of per-atom forces resulting from a subset of\nthe potential.  E.g. compute only Coulombic forces.  This can be done\nby only defining only a Coulombic pair style in the rerun script.\nDoing this in the original script would result in different (bad)\ndynamics.\n\nConceptually, using the rerun command is like running an input script\nthat has a loop in it (see the next and jump\ncommands).  Each iteration of the loop reads one snapshot from the\ndump file via the read_dump command, sets the\ntimestep to the appropriate value, and then invokes a run\ncommand for zero timesteps to simply compute energy and forces, and\nany other thermodynamic output or diagnostic info\nyou have defined.  This computation also invokes any fixes you have\ndefined that apply constraints to the system, such as fix shake or fix indent.\nNote that a simulation box must already be defined before using the\nrerun command.  This can be done by the create_box,\nread_data, or read_restart\ncommands.\nAlso note that reading per-atom information from dump snapshots is\nlimited to the atom coordinates, velocities and image flags as\nexplained in the read_dump command.  Other atom\nproperties, which may be necessary to compute energies and forces,\nsuch as atom charge, or bond topology information for a molecular\nsystem, are not read from (or even contained in) dump files.  Thus\nthis auxiliary information should be defined in the usual way, e.g. in\na data file read in by a read_data command, before\nusing the rerun command.\nAlso note that the frequency of thermodynamic or dump output from the\nrerun simulation will depend on settings made in the rerun script, the\nsame as for output from any LAMMPS simulation.  See further info below\nas to what that means if the timesteps for snapshots read from dump\nfiles do not match the specified output frequency.\n\nIf more than one dump file is specified, the dump files are read one\nafter the other.  It is assumed that snapshot timesteps will be in\nascending order.  If a snapshot is encountered that is not in\nascending order, it will skip the snapshot until it reads one that is.\nThis allows skipping of a duplicate snapshot (same timestep),\ne.g. that appeared at the end of one file and beginning of the next.\nHowever if you specify a series of dump files in an incorrect order\n(with respect to the timesteps they contain), you may skip large\nnumbers of snapshots\nNote that the dump files specified as part of the dump keyword can be\nparallel files, i.e. written as multiple files either per processor\nand/or per snapshot.  If that is the case they will also be read in\nparallel which can make the rerun command operate dramatically faster\nfor large systems.  See the doc page for the read_dump and dump commands which describe how to read\nand write parallel dump files.\nThe first, last, every, skip keywords determine which\nsnapshots are read from the dump file(s).  Snapshots are skipped until\nthey have a timestamp >= Nfirst.  When a snapshot with a timestamp >\nNlast is encountered, the rerun command finishes.  Note below that\nthe defaults for first and last are to read all snapshots.  If the\nevery keyword is set to a value > 0, then only snapshots with\ntimestamps that are a multiple of Nevery are read (the first\nsnapshot is always read).  If Nevery = 0, then this criterion is\nignored, i.e. every snapshot is read that meets the other criteria.\nIf the skip keyword is used, then after the first snapshot is read,\nevery Nth snapshot is read, where N = Nskip.  E.g. if Nskip = 3,\nthen only 1 out of every 3 snapshots is read, assuming the snapshot\ntimestamp is also consistent with the other criteria.\nThe start and stop keywords do not affect which snapshots are read\nfrom the dump file(s).  Rather, they have the same meaning that they\ndo for the run command.  They only need to be defined if\n(a) you are using a fix command that changes some value\nover time, and (b) you want the reference point for elapsed time (from\nstart to stop) to be different than the first and last settings.\nSee the doc page for individual fixes to see which ones can be used\nwith the start/stop keywords.  Note that if you define neither of\nthe start/stop or first/last keywords, then LAMMPS treats the\npseudo run as going from 0 to a huge value (effectively infinity).\nThis means that any quantity that a fix scales as a fraction of\nelapsed time in the run, will essentially remain at its initial value.\nAlso note that an error will occur if you read a snapshot from the\ndump file with a timestep value larger than the stop setting you\nhave specified.\nThe dump keyword is required and must be the last keyword specified.\nIts arguments are passed internally to the read_dump\ncommand.  The first argument following the dump keyword should be\nthe field1 argument of the read_dump command.  See\nthe read_dump doc page for details on the various\noptions it allows for extracting information from the dump file\nsnapshots, and for using that information to alter the LAMMPS\nsimulation.\n\nIn general, a LAMMPS input script that uses a rerun command can\ninclude and perform all the usual operations of an input script that\nuses the run command.  There are a few exceptions and\npoints to consider, as discussed here.\nFixes that perform time integration, such as fix nve or\nfix npt are not invoked, since no time integration is\nperformed.  Fixes that perturb or constrain the forces on atoms will\nbe invoked, just as they would during a normal run.  Examples are fix indent and fix langevin.  So you\nshould think carefully as to whether that makes sense for the manner\nin which you are reprocessing the dump snapshots.\nIf you only want the rerun script to perform an analysis that does\nnot involve pair interactions, such as use compute msd to calculated\ndisplacements over time, you do not need to define a pair style, which may also mean neighbor lists will not\nneed to be calculated which saves time.  The comm_modify cutoff command can also be used to insure ghost\natoms are acquired from far enough away for operations like bond and\nangle evaluations, if no pair style is being used.\nEvery time a snapshot is read, the timestep for the simulation is\nreset, as if the reset_timestep command were\nused.  This command has some restrictions as to what fixes can be\ndefined.  See its doc page for details.  For example, the fix deposit and fix dt/reset fixes\nare in this category.  They also make no sense to use with a rerun\ncommand.\nIf time-averaging fixes like fix ave/time are\nused, they are invoked on timesteps that are a function of their\nNevery, Nrepeat, and Nfreq settings.  As an example, see the\nfix ave/time doc page for details.  You must\ninsure those settings are consistent with the snapshot timestamps that\nare read from the dump file(s).  If an averaging fix is not invoked on\na timestep it expects to be, LAMMPS will flag an error.\nThe various forms of LAMMPS output, as defined by the\nthermo_style, thermo,\ndump, and restart commands occur with\nspecified frequency, e.g. every N steps.  If the timestep for a dump\nsnapshot is not a multiple of N, then it will be read and processed,\nbut no output will be produced.  If you want output for every dump\nsnapshot, you can simply use N=1 for an output frequency, e.g. for\nthermodynamic output or new dump file output.",
    "syntax": "rerun file1 file2 ... keyword args ...",
    "parameters": " * file1,file2,… = dump file(s) to read\n * one or more keywords may be appended, keyword dump must appear and be last\n * keyword = first or last or every or skip or start or stop or dump\n *  first args = Nfirst\n *    Nfirst = dump timestep to start on\n *  last args = Nlast\n *    Nlast = dumptimestep to stop on\n *  every args = Nevery\n *    Nevery = read snapshots matching every this many timesteps\n *  skip args = Nskip\n *    Nskip = read one out of every Nskip snapshots\n *  start args = Nstart\n *    Nstart = timestep on which pseudo run will start\n *  stop args = Nstop\n *    Nstop = timestep to which pseudo run will end\n *  dump args = same as read_dump command starting with its field arguments",
    "examples": "rerun dump.file dump x y z vx vy vz\nrerun dump1.txt dump2.txt first 10000 every 1000 dump x y z\nrerun dump.vels dump x y z vx vy vz box yes format molfile lammpstrj\nrerun dump.dcd dump x y z box no format molfile dcd\nrerun ../run7/dump.file.gz skip 2 dump x y z box yes\nrerun dump.bp dump x y z box no format adios\nrerun dump.bp dump x y z vx vy vz format adios timeout 10.0",
    "restrictions": "To read gzipped dump files, you must compile LAMMPS with the\n-DLAMMPS_GZIP option.  See the Build settings\ndoc page for details."
},
{
    "command": "reset_ids",
    "html_filename": "reset_ids.html",
    "short_description": "Reset atom IDs for the system, including all the global IDs stored for bond, angle, dihedral, improper topology data",
    "description": "Reset atom IDs for the system, including all the global IDs stored\nfor bond, angle, dihedral, improper topology data.  This will\ncreate a set of IDs that are numbered contiguously from 1 to N\nfor a N atoms system.\nThis can be useful to do after performing a “delete_atoms” command for\na molecular system.  The delete_atoms compress yes option will not\nperform this operation due to the existence of bond topology.  It can\nalso be useful to do after any simulation which has lost atoms,\ne.g. due to atoms moving outside a simulation box with fixed\nboundaries (see the “boundary command”), or due to evaporation (see\nthe “fix evaporate” command).\nNote that the resetting of IDs is not really a compression, where gaps\nin atom IDs are removed by decrementing atom IDs that are larger.\nInstead the IDs for all atoms are erased, and new IDs are assigned so\nthat the atoms owned by an individual processor have consecutive IDs,\nas the create_atoms command explains.\n\nNote\nIf this command is used before a pair style is\ndefined, an error about bond topology atom IDs not being found may\nresult.  This is because the cutoff distance for ghost atom\ncommunication was not sufficient to find atoms in bonds, angles, etc\nthat are owned by other processors.  The comm_modify cutoff command can be used to correct this issue.\nOr you can define a pair style before using this command.  If you do\nthe former, you should unset the comm_modify cutoff after using\nreset_ids so that subsequent communication is not inefficient.",
    "syntax": "reset_ids",
    "parameters": " * ",
    "examples": "reset_ids",
    "restrictions": "none"
},
{
    "command": "reset_timestep",
    "html_filename": "reset_timestep.html",
    "short_description": "Set the timestep counter to the specified value",
    "description": "Set the timestep counter to the specified value.  This command\nnormally comes after the timestep has been set by reading a restart\nfile via the read_restart command, or a previous\nsimulation advanced the timestep.\nThe read_data and create_box\ncommands set the timestep to 0; the read_restart\ncommand sets the timestep to the value it had when the restart file\nwas written.",
    "syntax": "reset_timestep N",
    "parameters": " * N = timestep number",
    "examples": "reset_timestep 0\nreset_timestep 4000000",
    "restrictions": "none\nThis command cannot be used when any fixes are defined that keep track\nof elapsed time to perform certain kinds of time-dependent operations.\nExamples are the fix deposit and fix dt/reset commands.  The former adds atoms on\nspecific timesteps.  The latter keeps track of accumulated time.\nVarious fixes use the current timestep to calculate related\nquantities.  If the timestep is reset, this may produce unexpected\nbehavior, but LAMMPS allows the fixes to be defined even if the\ntimestep is reset.  For example, commands which thermostat the system,\ne.g. fix nvt, allow you to specify a target temperature\nwhich ramps from Tstart to Tstop which may persist over several runs.\nIf you change the timestep, you may induce an instantaneous change in\nthe target temperature.\nResetting the timestep clears flags for computes that\nmay have calculated some quantity from a previous run.  This means\nthese quantity cannot be accessed by a variable in between runs until\na new run is performed.  See the variable command for\nmore details."
},
{
    "command": "restart",
    "html_filename": "restart.html",
    "short_description": "Write out a binary restart file with the current state of the simulation every so many timesteps, in either or both of two modes, as a run proceeds",
    "description": "Write out a binary restart file with the current state of the\nsimulation every so many timesteps, in either or both of two modes, as\na run proceeds.  A value of 0 means do not write out any restart\nfiles.  The two modes are as follows.  If one filename is specified, a\nseries of filenames will be created which include the timestep in the\nfilename.  If two filenames are specified, only 2 restart files will\nbe created, with those names.  LAMMPS will toggle between the 2 names\nas it writes successive restart files.\nNote that you can specify the restart command twice, once with a\nsingle filename and once with two filenames.  This would allow you,\nfor example, to write out archival restart files every 100000 steps\nusing a single filename, and more frequent temporary restart files\nevery 1000 steps, using two filenames.  Using restart 0 will turn off\nboth modes of output.\nSimilar to dump files, the restart filename(s) can contain\ntwo wild-card characters.\nIf a “*” appears in the single filename, it is replaced with the\ncurrent timestep value.  This is only recognized when a single\nfilename is used (not when toggling back and forth).  Thus, the 3rd\nexample above creates restart files as follows: restart.1000.equil,\nrestart.2000.equil, etc.  If a single filename is used with no “*”,\nthen the timestep value is appended.  E.g. the 2nd example above\ncreates restart files as follows: poly.restart.1000,\npoly.restart.2000, etc.\nIf a “%” character appears in the restart filename(s), then one file\nis written for each processor and the “%” character is replaced with\nthe processor ID from 0 to P-1.  An additional file with the “%”\nreplaced by “base” is also written, which contains global information.\nFor example, the files written on step 1000 for filename restart.%\nwould be restart.base.1000, restart.0.1000, restart.1.1000, …,\nrestart.P-1.1000.  This creates smaller files and can be a fast mode\nof output and subsequent input on parallel machines that support\nparallel I/O.  The optional fileper and nfile keywords discussed\nbelow can alter the number of files written.\nThe restart file can also be written in parallel as one large binary\nfile via the MPI-IO library, which is part of the MPI standard for\nversions 2.0 and above.  Using MPI-IO requires two steps.  First,\nbuild LAMMPS with its MPIIO package installed, e.g.\nmake yes-mpiio    # installs the MPIIO package\nmake mpi          # build LAMMPS for your platform\n\n\nSecond, use a restart filename which contains “.mpiio”.  Note that it\ndoes not have to end in “.mpiio”, just contain those characters.\nUnlike MPI-IO dump files, a particular restart file must be both\nwritten and read using MPI-IO.\nRestart files are written on timesteps that are a multiple of N but\nnot on the first timestep of a run or minimization.  You can use the\nwrite_restart command to write a restart file\nbefore a run begins.  A restart file is not written on the last\ntimestep of a run unless it is a multiple of N.  A restart file is\nwritten on the last timestep of a minimization if N > 0 and the\nminimization converges.\nInstead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\nname is the variable name.  In this case, the variable is evaluated at\nthe beginning of a run to determine the next timestep at which a\nrestart file will be written out.  On that timestep, the variable will\nbe evaluated again to determine the next timestep, etc.  Thus the\nvariable should return timestep values.  See the stagger() and\nlogfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\nthis context.  Other similar math functions could easily be added as\noptions for equal-style variables.\nFor example, the following commands will write restart files\nevery step from 1100 to 1200, and could be useful for debugging\na simulation where something goes wrong at step 1163:\nvariable       s equal stride(1100,1200,1)\nrestart        v_s tmp.restart\n\n\n\nSee the read_restart command for information about\nwhat is stored in a restart file.\nRestart files can be read by a read_restart\ncommand to restart a simulation from a particular state.  Because the\nfile is binary (to enable exact restarts), it may not be readable on\nanother machine.  In this case, you can use the -r command-line switch to convert a restart file to a data file.\n\nNote\nAlthough the purpose of restart files is to enable restarting a\nsimulation from where it left off, not all information about a\nsimulation is stored in the file.  For example, the list of fixes that\nwere specified during the initial run is not stored, which means the\nnew input script must specify any fixes you want to use.  Even when\nrestart information is stored in the file, as it is for some fixes,\ncommands may need to be re-specified in the new input script, in order\nto re-use that information.  See the read_restart\ncommand for information about what is stored in a restart file.\n\n\nThe optional nfile or fileper keywords can be used in conjunction\nwith the “%” wildcard character in the specified restart file name(s).\nAs explained above, the “%” character causes the restart file to be\nwritten in pieces, one piece for each of P processors.  By default P =\nthe number of processors the simulation is running on.  The nfile or\nfileper keyword can be used to set P to a smaller value, which can\nbe more efficient when running on a large number of processors.\nThe nfile keyword sets P to the specified Nf value.  For example, if\nNf = 4, and the simulation is running on 100 processors, 4 files will\nbe written, by processors 0,25,50,75.  Each will collect information\nfrom itself and the next 24 processors and write it to a restart file.\nFor the fileper keyword, the specified value of Np means write one\nfile for every Np processors.  For example, if Np = 4, every 4th\nprocessor (0,4,8,12,etc) will collect information from itself and the\nnext 3 processors and write it to a restart file.",
    "syntax": "restart 0",
    "parameters": " * restart N root keyword value ...\n * restart N file1 file2 keyword value ...\n * N = write a restart file every this many timesteps\n * N can be a variable (see below)\n * root = filename to which timestep # is appended\n * file1,file2 = two full filenames, toggle between them when writing file\n * zero or more keyword/value pairs may be appended\n * keyword = fileper or nfile\n * fileper arg = Np\n *   Np = write one file for every this many processors\n * nfile arg = Nf\n *   Nf = write this many files, one from each of Nf processors",
    "examples": "restart 0\nrestart 1000 poly.restart\nrestart 1000 poly.restart.mpiio\nrestart 1000 restart.*.equil\nrestart 10000 poly.%.1 poly.%.2 nfile 10\nrestart v_mystep poly.restart",
    "restrictions": "To write and read restart files in parallel with MPI-IO, the MPIIO\npackage must be installed."
},
{
    "command": "run",
    "html_filename": "run.html",
    "short_description": "Run or continue dynamics for a specified number of timesteps",
    "description": "Run or continue dynamics for a specified number of timesteps.\nWhen the run style is respa, N refers to outer\nloop (largest) timesteps.\nA value of N = 0 is acceptable; only the thermodynamics of the system\nare computed and printed without taking a timestep.\nThe upto keyword means to perform a run starting at the current\ntimestep up to the specified timestep.  E.g. if the current timestep\nis 10,000 and “run 100000 upto” is used, then an additional 90,000\ntimesteps will be run.  This can be useful for very long runs on a\nmachine that allocates chunks of time and terminate your job when time\nis exceeded.  If you need to restart your script multiple times\n(reading in the last restart file), you can keep restarting your\nscript with the same run command until the simulation finally\ncompletes.\nThe start or stop keywords can be used if multiple runs are being\nperformed and you want a fix command that changes some\nvalue over time (e.g. temperature) to make the change across the\nentire set of runs and not just a single run.  See the doc page for\nindividual fixes to see which ones can be used with the start/stop\nkeywords.\nFor example, consider this fix followed by 10 run commands:\nfix         1 all nvt 200.0 300.0 1.0\nrun         1000 start 0 stop 10000\nrun         1000 start 0 stop 10000\n...\nrun         1000 start 0 stop 10000\n\n\nThe NVT fix ramps the target temperature from 200.0 to 300.0 during a\nrun.  If the run commands did not have the start/stop keywords (just\n“run 1000”), then the temperature would ramp from 200.0 to 300.0\nduring the 1000 steps of each run.  With the start/stop keywords, the\nramping takes place over the 10000 steps of all runs together.\nThe pre and post keywords can be used to streamline the setup,\nclean-up, and associated output to the screen that happens before and\nafter a run.  This can be useful if you wish to do many short runs in\nsuccession (e.g. LAMMPS is being called as a library which is doing\nother computations between successive short LAMMPS runs).\nBy default (pre and post = yes), LAMMPS creates neighbor lists,\ncomputes forces, and imposes fix constraints before every run.  And\nafter every run it gathers and prints timings statistics.  If a run is\njust a continuation of a previous run (i.e. no settings are changed),\nthe initial computation is not necessary; the old neighbor list is\nstill valid as are the forces.  So if pre is specified as “no” then\nthe initial setup is skipped, except for printing thermodynamic info.\nNote that if pre is set to “no” for the very 1st run LAMMPS\nperforms, then it is overridden, since the initial setup computations\nmust be done.\n\nNote\nIf your input script changes the system between 2 runs, then the\ninitial setup must be performed to insure the change is recognized by\nall parts of the code that are affected.  Examples are adding a\nfix or dump or compute, changing\na neighbor list parameter, or writing restart file\nwhich can migrate atoms between processors.  LAMMPS has no easy way to\ncheck if this has happened, but it is an error to use the pre no\noption in this case.\n\nIf post is specified as “no”, the full timing summary is skipped;\nonly a one-line summary timing is printed.\nThe every keyword provides a means of breaking a LAMMPS run into a\nseries of shorter runs.  Optionally, one or more LAMMPS commands (c1,\nc2, …, cN) will be executed in between the short runs.  If used, the\nevery keyword must be the last keyword, since it has a variable\nnumber of arguments.  Each of the trailing arguments is a single\nLAMMPS command, and each command should be enclosed in quotes, so that\nthe entire command will be treated as a single argument.  This will\nalso prevent any variables in the command from being evaluated until\nit is executed multiple times during the run.  Note that if a command\nitself needs one of its arguments quoted (e.g. the print\ncommand), then you can use a combination of single and double quotes,\nas in the example above or below.\nThe every keyword is a means to avoid listing a long series of runs\nand interleaving commands in your input script.  For example, a\nprint command could be invoked or a fix could\nbe redefined, e.g. to reset a thermostat temperature.  Or this could\nbe useful for invoking a command you have added to LAMMPS that wraps\nsome other code (e.g. as a library) to perform a computation\nperiodically during a long LAMMPS run.  See the Modify\ndoc page for info about how to add new commands to LAMMPS.  See the\nHowto couple doc page for ideas about how to\ncouple LAMMPS to other codes.\nWith the every option, N total steps are simulated, in shorter runs\nof M steps each.  After each M-length run, the specified commands are\ninvoked.  If only a single command is specified as NULL, then no\ncommand is invoked.  Thus these lines:\nvariable q equal x[100]\nrun 6000 every 2000 \"print 'Coord = $q'\"\n\n\nare the equivalent of:\nvariable q equal x[100]\nrun 2000\nprint \"Coord = $q\"\nrun 2000\nprint \"Coord = $q\"\nrun 2000\nprint \"Coord = $q\"\n\n\nwhich does 3 runs of 2000 steps and prints the x-coordinate of a\nparticular atom between runs.  Note that the variable “$q” will\nbe evaluated afresh each time the print command is executed.\nNote that by using the line continuation character “&”, the run every\ncommand can be spread across many lines, though it is still a single\ncommand:\nrun 100000 every 1000 &\n  \"print 'Minimum value = $a'\" &\n  \"print 'Maximum value = $b'\" &\n  \"print 'Temp = $c'\" &\n  \"print 'Press = $d'\"\n\n\nIf the pre and post options are set to “no” when used with the\nevery keyword, then the 1st run will do the full setup and the last\nrun will print the full timing summary, but these operations will be\nskipped for intermediate runs.\n\nNote\nYou might wish to specify a command that exits the run by\njumping out of the loop, e.g.\n\nvariable t equal temp\nrun 10000 every 100 \"if '$t < 300.0' then 'jump SELF afterrun'\"\n\n\nHowever, this will not work.  The run command simply executes each\ncommand one at a time each time it pauses, then continues the run.\nInstead, you should use the fix halt command, which\nhas additional options for how to exit the run.",
    "syntax": "run N keyword values ...",
    "parameters": " * N = # of timesteps\n * zero or more keyword/value pairs may be appended\n * keyword = upto or start or stop or pre or post or every\n * upto value = none\n * start value = N1\n *   N1 = timestep at which 1st run started\n * stop value = N2\n *   N2 = timestep at which last run will end\n * pre value = no or yes\n * post value = no or yes\n * every values = M c1 c2 ...\n *   M = break the run into M-timestep segments and invoke one or more commands between each segment\n *   c1,c2,...,cN = one or more LAMMPS commands, each enclosed in quotes\n *   c1 = NULL means no command will be invoked",
    "examples": "run 10000\nrun 1000000 upto\nrun 100 start 0 stop 1000\nrun 1000 pre no post yes\nrun 100000 start 0 stop 1000000 every 1000 \"print 'Protein Rg = $r'\"\nrun 100000 every 1000 NULL",
    "restrictions": "When not using the upto keyword, the number of specified timesteps N\nmust fit in a signed 32-bit integer, so you are limited to slightly\nmore than 2 billion steps (2^31) in a single run.  When using upto,\nN can be larger than a signed 32-bit integer, however the difference\nbetween N and the current timestep must still be no larger than\n2^31 steps.\nHowever, with or without the upto keyword, you can perform\nsuccessive runs to run a simulation for any number of steps (ok, up to\n2^63 total steps).  I.e. the timestep counter within LAMMPS is a\n64-bit signed integer."
},
{
    "command": "run_style",
    "html_filename": "run_style.html",
    "short_description": "Choose the style of time integrator used for molecular dynamics simulations performed by LAMMPS",
    "description": "Choose the style of time integrator used for molecular dynamics\nsimulations performed by LAMMPS.\nThe verlet style is a standard velocity-Verlet integrator.\n\nThe verlet/split style is also a velocity-Verlet integrator, but it\nsplits the force calculation within each timestep over 2 partitions of\nprocessors.  See the -partition command-line switch\nfor info on how to run LAMMPS with multiple partitions.\nSpecifically, this style performs all computation except the\nkspace_style portion of the force field on the 1st\npartition.  This include the pair style, bond style, neighbor list building,\nfixes including time integration, and output.  The\nkspace_style portion of the calculation is\nperformed on the 2nd partition.\nThis is most useful for the PPPM kspace_style when its performance on\na large number of processors degrades due to the cost of communication\nin its 3d FFTs.  In this scenario, splitting your P total processors\ninto 2 subsets of processors, P1 in the 1st partition and P2 in the\n2nd partition, can enable your simulation to run faster.  This is\nbecause the long-range forces in PPPM can be calculated at the same\ntime as pair-wise and bonded forces are being calculated, and the FFTs\ncan actually speed up when running on fewer processors.\nTo use this style, you must define 2 partitions where P1 is a multiple\nof P2.  Typically having P1 be 3x larger than P2 is a good choice.\nThe 3d processor layouts in each partition must overlay in the\nfollowing sense.  If P1 is a Px1 by Py1 by Pz1 grid, and P2 = Px2 by\nPy2 by Pz2, then Px1 must be an integer multiple of Px2, and similarly\nfor Py1 a multiple of Py2, and Pz1 a multiple of Pz2.\nTypically the best way to do this is to let the 1st partition choose\nits onn optimal layout, then require the 2nd partition’s layout to\nmatch the integer multiple constraint.  See the\nprocessors command with its part keyword for a way\nto control this, e.g.\nprocessors * * * part 1 2 multiple\n\n\nYou can also use the partition command to explicitly\nspecify the processor layout on each partition.  E.g. for 2 partitions\nof 60 and 15 processors each:\npartition yes 1 processors 3 4 5\npartition yes 2 processors 3 1 5\n\n\nWhen you run in 2-partition mode with the verlet/split style, the\nthermodynamic data for the entire simulation will be output to the log\nand screen file of the 1st partition, which are log.lammps.0 and\nscreen.0 by default; see the -plog and -pscreen command-line switches to change this.  The log and screen file\nfor the 2nd partition will not contain thermodynamic output beyond the\n1st timestep of the run.\nSee the Speed packages doc page for performance\ndetails of the speed-up offered by the verlet/split style.  One\nimportant performance consideration is the assignment of logical\nprocessors in the 2 partitions to the physical cores of a parallel\nmachine.  The processors command has options to\nsupport this, and strategies are discussed in Section 5 of the manual.\n\nThe respa style implements the rRESPA multi-timescale integrator\n(Tuckerman) with N hierarchical levels, where level 1 is\nthe innermost loop (shortest timestep) and level N is the outermost\nloop (largest timestep).  The loop factor arguments specify what the\nlooping factor is between levels.  N1 specifies the number of\niterations of level 1 for a single iteration of level 2, N2 is the\niterations of level 2 per iteration of level 3, etc.  N-1 looping\nparameters must be specified.\nThus with a 4-level respa setting of “2 2 2” for the 3 loop factors,\nyou could choose to have bond interactions computed 8x per large\ntimestep, angle interactions computed 4x, pair interactions computed\n2x, and long-range interactions once per large timestep.\nThe timestep command sets the large timestep for the\noutermost rRESPA level.  Thus if the 3 loop factors are “2 2 2” for\n4-level rRESPA, and the outer timestep is set to 4.0 fmsec, then the\ninner timestep would be 8x smaller or 0.5 fmsec.  All other LAMMPS\ncommands that specify number of timesteps (e.g. thermo\nfor thermo output every N steps, neigh_modify delay/every parameters, dump every N\nsteps, etc) refer to the outermost timesteps.\nThe rRESPA keywords enable you to specify at what level of the\nhierarchy various forces will be computed.  If not specified, the\ndefaults are that bond forces are computed at level 1 (innermost\nloop), angle forces are computed where bond forces are, dihedral\nforces are computed where angle forces are, improper forces are\ncomputed where dihedral forces are, pair forces are computed at the\noutermost level, and kspace forces are computed where pair forces are.\nThe inner, middle, outer forces have no defaults.\nFor fixes that support it, the rRESPA level at which a given fix is\nactive, can be selected through the fix_modify command.\nThe inner and middle keywords take additional arguments for\ncutoffs that are used by the pairwise force computations.  If the 2\ncutoffs for inner are 5.0 and 6.0, this means that all pairs up to\n6.0 apart are computed by the inner force.  Those between 5.0 and 6.0\nhave their force go ramped to 0.0 so the overlap with the next regime\n(middle or outer) is smooth.  The next regime (middle or outer) will\ncompute forces for all pairs from 5.0 outward, with those from 5.0 to\n6.0 having their value ramped in an inverse manner.\nNote that you can use inner and outer without using middle to\nsplit the pairwise computations into two portions instead of three.\nUnless you are using a very long pairwise cutoff, a 2-way split is\noften faster than a 3-way split, since it avoids too much duplicate\ncomputation of pairwise interactions near the intermediate cutoffs.\nAlso note that only a few pair potentials support the use of the\ninner and middle and outer keywords.  If not, only the pair\nkeyword can be used with that pair style, meaning all pairwise forces\nare computed at the same rRESPA level.  See the doc pages for\nindividual pair styles for details.\nAnother option for using pair potentials with rRESPA is with the\nhybrid keyword, which requires the use of the pair_style hybrid or hybrid/overlay command.  In this scenario, different\nsub-styles of the hybrid pair style are evaluated at different rRESPA\nlevels.  This can be useful, for example, to set different timesteps\nfor hybrid coarse-grained/all-atom models.  The hybrid keyword\nrequires as many level assignments as there are hybrid sub-styles,\nwhich assigns each sub-style to a rRESPA level, following their order\nof definition in the pair_style command. Since the hybrid keyword\noperates on pair style computations, it is mutually exclusive with\neither the pair or the inner/middle/outer keywords.\nWhen using rRESPA (or for any MD simulation) care must be taken to\nchoose a timestep size(s) that insures the Hamiltonian for the chosen\nensemble is conserved.  For the constant NVE ensemble, total energy\nmust be conserved.  Unfortunately, it is difficult to know a priori\nhow well energy will be conserved, and a fairly long test simulation\n(~10 ps) is usually necessary in order to verify that no long-term\ndrift in energy occurs with the trial set of parameters.\nWith that caveat, a few rules-of-thumb may be useful in selecting\nrespa settings.  The following applies mostly to biomolecular\nsimulations using the CHARMM or a similar all-atom force field, but\nthe concepts are adaptable to other problems.  Without SHAKE, bonds\ninvolving hydrogen atoms exhibit high-frequency vibrations and require\na timestep on the order of 0.5 fmsec in order to conserve energy.  The\nrelatively inexpensive force computations for the bonds, angles,\nimpropers, and dihedrals can be computed on this innermost 0.5 fmsec\nstep.  The outermost timestep cannot be greater than 4.0 fmsec without\nrisking energy drift.  Smooth switching of forces between the levels\nof the rRESPA hierarchy is also necessary to avoid drift, and a 1-2\nangstrom “healing distance” (the distance between the outer and inner\ncutoffs) works reasonably well.  We thus recommend the following\nsettings for use of the respa style without SHAKE in biomolecular\nsimulations:\ntimestep  4.0\nrun_style respa 4 2 2 2 inner 2 4.5 6.0 middle 3 8.0 10.0 outer 4\n\n\nWith these settings, users can expect good energy conservation and\nroughly a 2.5 fold speedup over the verlet style with a 0.5 fmsec\ntimestep.\nIf SHAKE is used with the respa style, time reversibility is lost,\nbut substantially longer time steps can be achieved.  For biomolecular\nsimulations using the CHARMM or similar all-atom force field, bonds\ninvolving hydrogen atoms exhibit high frequency vibrations and require\na time step on the order of 0.5 fmsec in order to conserve energy.\nThese high frequency modes also limit the outer time step sizes since\nthe modes are coupled.  It is therefore desirable to use SHAKE with\nrespa in order to freeze out these high frequency motions and increase\nthe size of the time steps in the respa hierarchy.  The following\nsettings can be used for biomolecular simulations with SHAKE and\nrRESPA:\nfix             2 all shake 0.000001 500 0 m 1.0 a 1\ntimestep        4.0\nrun_style       respa 2 2 inner 1 4.0 5.0 outer 2\n\n\nWith these settings, users can expect good energy conservation and\nroughly a 1.5 fold speedup over the verlet style with SHAKE and a\n2.0 fmsec timestep.\nFor non-biomolecular simulations, the respa style can be\nadvantageous if there is a clear separation of time scales - fast and\nslow modes in the simulation.  For example, a system of slowly-moving\ncharged polymer chains could be setup as follows:\ntimestep 4.0\nrun_style respa 2 8\n\n\nThis is two-level rRESPA with an 8x difference between the short and\nlong timesteps.  The bonds, angles, dihedrals will be computed every\n0.5 fs (assuming real units), while the pair and kspace interactions\nwill be computed once every 4 fs.  These are the default settings for\neach kind of interaction, so no additional keywords are necessary.\nEven a LJ system can benefit from rRESPA if the interactions are\ndivided by the inner, middle and outer keywords.  A 2-fold or more\nspeedup can be obtained while maintaining good energy conservation.\nIn real units, for a pure LJ fluid at liquid density, with a sigma of\n3.0 angstroms, and epsilon of 0.1 Kcal/mol, the following settings\nseem to work well:\ntimestep  36.0\nrun_style respa 3 3 4 inner 1 3.0 4.0 middle 2 6.0 7.0 outer 3\n\n\n\nThe respa/omp style is a variant of respa adapted for use with\npair, bond, angle, dihedral, improper, or kspace styles with an omp\nsuffix. It is functionally equivalent to respa but performs\nadditional operations required for managing omp styles.  For more on\nomp styles see the Speed omp doc page.  Accelerated\nstyles take the same arguments and should produce the same results,\nexcept for round-off and precision issues.\nYou can specify respa/omp explicitly in your input script, or you\ncan use the -suffix command-line switch when you\ninvoke LAMMPS, or you can use the suffix command in your\ninput script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "run_style style args",
    "parameters": " * style = verlet or verlet/split or respa or respa/omp\n * verlet args = none\n * verlet/split args = none\n * respa args = N n1 n2 ... keyword values ...\n *   N = # of levels of rRESPA\n *   n1, n2, ... = loop factors between rRESPA levels (N-1 values)\n *   zero or more keyword/value pairings may be appended to the loop factors\n *   keyword = bond or angle or dihedral or improper or\n *             pair or inner or middle or outer or hybrid or kspace\n *     bond value = M\n *       M = which level (1-N) to compute bond forces in\n *     angle value = M\n *       M = which level (1-N) to compute angle forces in\n *     dihedral value = M\n *       M = which level (1-N) to compute dihedral forces in\n *     improper value = M\n *       M = which level (1-N) to compute improper forces in\n *     pair value = M\n *       M = which level (1-N) to compute pair forces in\n *     inner values = M cut1 cut2\n *       M = which level (1-N) to compute pair inner forces in\n *       cut1 = inner cutoff between pair inner and\n *              pair middle or outer  (distance units)\n *       cut2 = outer cutoff between pair inner and\n *              pair middle or outer  (distance units)\n *     middle values = M cut1 cut2\n *       M = which level (1-N) to compute pair middle forces in\n *       cut1 = inner cutoff between pair middle and pair outer (distance units)\n *       cut2 = outer cutoff between pair middle and pair outer (distance units)\n *     outer value = M\n *       M = which level (1-N) to compute pair outer forces in\n *     hybrid values = M1 M2 ... (as many values as there are hybrid sub-styles\n *       M1 = which level (1-N) to compute the first pair_style hybrid sub-style in\n *       M2 = which level (1-N) to compute the second pair_style hybrid sub-style in\n *       M3,etc\n *     kspace value = M\n *       M = which level (1-N) to compute kspace forces in",
    "examples": "run_style verlet\nrun_style respa 4 2 2 2 bond 1 dihedral 2 pair 3 kspace 4\nrun_style respa 4 2 2 2 bond 1 dihedral 2 inner 3 5.0 6.0 outer 4 kspace 4\nrun_style respa 3 4 2 bond 1 hybrid 2 2 1 kspace 3",
    "restrictions": "The verlet/split style can only be used if LAMMPS was built with the\nREPLICA package. Correspondingly the respa/omp style is available\nonly if the USER-OMP package was included. See the Build package doc page for more info.\nWhenever using rRESPA, the user should experiment with trade-offs in\nspeed and accuracy for their system, and verify that they are\nconserving energy to adequate precision."
},
{
    "command": "server",
    "html_filename": "server.html",
    "short_description": "This command starts LAMMPS running in “server” mode, where it receives messages from a separate “client” code and responds by sending a reply message back to the client",
    "description": "This command starts LAMMPS running in “server” mode, where it receives\nmessages from a separate “client” code and responds by sending a reply\nmessage back to the client.  The specified protocol determines the\nformat and content of messages LAMMPS expects to receive and how it\nresponds.\nThe Howto client/server doc page gives an\noverview of client/server coupling of LAMMPS with another code where\none code is the “client” and sends request messages to a “server”\ncode.  The server responds to each request with a reply message.  This\nenables the two codes to work in tandem to perform a simulation.\nWhen this command is invoked, LAMMPS will run in server mode in an\nendless loop, waiting for messages from the client code.  The client\nsignals when it is done sending messages to LAMMPS, at which point the\nloop will exit, and the remainder of the LAMMPS input script will be\nprocessed.\nThe protocol argument defines the format and content of messages\nthat will be exchanged between the two codes.  The current options\nare:\n\nmd = run dynamics with another code\nmc = perform Monte Carlo moves with another code\n\nFor protocol md, LAMMPS can be either a client (via the fix client/md command) or server.  See the server md doc page for details on the protocol.\nFor protocol mc, LAMMPS can be the server.  See the server mc doc page for details on the protocol.",
    "syntax": "server protocol",
    "parameters": " * protocol = md or mc",
    "examples": "server md",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nA script that uses this command must also use the\nmessage command to setup the messaging protocol with\nthe other client code."
},
{
    "command": "server mc",
    "html_filename": "server_mc.html",
    "short_description": "This command starts LAMMPS running in “server” mode, where it will expect messages from a separate “client” code that match the mc protocol for format and content explained below",
    "description": "This command starts LAMMPS running in “server” mode, where it will\nexpect messages from a separate “client” code that match the mc\nprotocol for format and content explained below.  For each message\nLAMMPS receives it will send a message back to the client.\nThe Howto client/server doc page gives an\noverview of client/server coupling of LAMMPS with another code where\none code is the “client” and sends request messages to a “server”\ncode.  The server responds to each request with a reply message.  This\nenables the two codes to work in tandem to perform a simulation.\nWhen this command is invoked, LAMMPS will run in server mode in an\nendless loop, waiting for messages from the client code.  The client\nsignals when it is done sending messages to LAMMPS, at which point the\nloop will exit, and the remainder of the LAMMPS script will be\nprocessed.\nThe server doc page gives other options for using LAMMPS\nSee an example of how this command is used in\nexamples/COUPLE/lammps_mc/in.server.\n\nWhen using this command, LAMMPS (as the server code) receives\ninstructions from a Monte Carlo (MC) driver to displace random atoms,\ncompute the energy before and after displacement, and run dynamics to\nequilibrate the system.\nThe MC driver performs the random displacements on random atoms,\naccepts or rejects the move in an MC sense, and orchestrates the MD\nruns.\nThe format and content of the exchanged messages are explained here in\na conceptual sense.  Python-style pseudo code for the library calls to\nthe CSlib is shown, which performs the actual message exchange between\nthe two codes.  See the CSlib website doc\npages for more details on the actual library syntax.  The “cs” object\nin this pseudo code is a pointer to an instance of the CSlib.\nSee the src/MESSAGE/server_mc.cpp file for details on how LAMMPS uses\nthese messages.  See the examples/COUPLE/lammps_mc/mc.cpp file for an\nexample of how an MC driver code can use these messages.\nDefine NATOMS=1, EINIT=2, DISPLACE=3, ACCEPT=4, RUN=5.\nClient sends one of these kinds of message:\ncs->send(NATOMS,0)      # msgID = 1 with no fields\n\ncs->send(EINIT,0)       # msgID = 2 with no fields\n\ncs->send(DISPLACE,2)    # msgID = 3 with 2 fields\ncs->pack_int(1,ID)        # 1st field = ID of atom to displace\ncs->pack(2,3,xnew)      # 2nd field = new xyz coords of displaced atom\n\ncs->send(ACCEPT,1)      # msgID = 4 with 1 field\ncs->pack_int(1,flag)    # 1st field = accept/reject flag\n\ncs->send(RUN,1)         # msgID = 5 with 1 field\ncs->pack_int(1,nsteps)  # 1st field = # of timesteps to run MD\n\n\nServer replies:\ncs->send(NATOMS,1)      # msgID = 1 with 1 field\ncs->pack_int(1,natoms)  # 1st field = number of atoms\n\ncs->send(EINIT,2)         # msgID = 2 with 2 fields\ncs->pack_double(1,poteng) # 1st field = potential energy of system\ncs->pack(2,3*natoms,x)    # 2nd field = 3N coords of Natoms\n\ncs->send(DISPLACE,1)      # msgID = 3 with 1 field\ncs->pack_double(1,poteng) # 1st field = new potential energy of system\n\ncs->send(ACCEPT,0)      # msgID = 4 with no fields\n\ncs->send(RUN,0)         # msgID = 5 with no fields",
    "syntax": "server mc",
    "parameters": " * mc = the protocol argument to the server command",
    "examples": "server mc",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info.\nA script that uses this command must also use the\nmessage command to setup the messaging protocol with\nthe other client code."
},
{
    "command": "server md",
    "html_filename": "server_md.html",
    "short_description": "This command starts LAMMPS running in “server” mode, where it will expect messages from a separate “client” code that match the md protocol for format and content explained below",
    "description": "This command starts LAMMPS running in “server” mode, where it will\nexpect messages from a separate “client” code that match the md\nprotocol for format and content explained below.  For each message\nLAMMPS receives it will send a message back to the client.\nThe Howto client/server doc page gives an\noverview of client/server coupling of LAMMPS with another code where\none code is the “client” and sends request messages to a “server”\ncode.  The server responds to each request with a reply message.  This\nenables the two codes to work in tandem to perform a simulation.\nWhen this command is invoked, LAMMPS will run in server mode in an\nendless loop, waiting for messages from the client code.  The client\nsignals when it is done sending messages to LAMMPS, at which point the\nloop will exit, and the remainder of the LAMMPS script will be\nprocessed.\nThe server doc page gives other options for using LAMMPS\nin server mode.  See an example of how this command is used in\nexamples/message/in.message.server.\n\nWhen using this command, LAMMPS (as the server code) receives the\ncurrent coordinates of all particles from the client code each\ntimestep, computes their interaction, and returns the energy, forces,\nand pressure for the interacting particles to the client code, so it\ncan complete the timestep.  This command could also be used with a\nclient code that performs energy minimization, using the server to\ncompute forces and energy each iteration of its minimizer.\nWhen using the fix client/md command, LAMMPS (as\nthe client code) does the timestepping and receives needed energy,\nforces, and pressure values from the server code.\nThe format and content of the exchanged messages are explained here in\na conceptual sense.  Python-style pseudo code for the library calls to\nthe CSlib is shown, which performs the actual message exchange between\nthe two codes.  See the CSlib website doc\npages for more details on the actual library syntax.  The “cs” object\nin this pseudo code is a pointer to an instance of the CSlib.\nSee the src/MESSAGE/server_md.cpp and src/MESSAGE/fix_client_md.cpp\nfiles for details on how LAMMPS uses these messages.  See the\nexamples/COUPLE/lammps_vasp/vasp_wrap.py or\nexamples/COUPLE/lammps_nwchem/nwchem_wrap.py files for examples of how\na quantum code (VASP or NWChem) can use these messages.\nThe following pseudo-code uses these values, defined as enums.\nDefine:\nSETUP=1, STEP=2\nDIM=1, PERIODICITY=2, ORIGIN=3, BOX=4, NATOMS=5, NTYPES=6, TYPES=7, COORDS=8, UNITS-9, CHARGE=10\nFORCES=1, ENERGY=2, PRESSURE=3, ERROR=4\n\n\nClient sends 2 kinds of messages:\n# required fields: DIM, PERIODICTY, ORIGIN, BOX, NATOMS, NTYPES, TYPES, COORDS\n# optional fields: UNITS, CHARGE\n\ncs->send(SETUP,nfields)        # msgID with nfields\n\ncs->pack_int(DIM,dim)          # dimension (2,3) of simulation\ncs->pack(PERIODICITY,3,xyz)    # periodicity flags in 3 dims\ncs->pack(ORIGIN,3,origin)      # lower-left corner of simulation box\ncs->pack(BOX,9,box)            # 3 edge vectors of simulation box\ncs->pack_int(NATOMS,natoms)    # total number of atoms\ncs->pack_int(NTYPES,ntypes)    # number of atom types\ncs->pack(TYPES,natoms,type)    # vector of per-atom types\ncs->pack(COORDS,3*natoms,x)    # vector of 3N atom coords\ncs->pack_string(UNITS,units)   # units = \"lj\", \"real\", \"metal\", etc\ncs->pack(CHARGE,natoms,q)      # vector of per-atom charge\n\n# required fields: COORDS\n# optional fields: ORIGIN, BOX\n\ncs->send(STEP,nfields)         # msgID with nfields\n\ncs->pack(COORDS,3*natoms,x)    # vector of 3N atom coords\ncs->pack(ORIGIN,3,origin)      # lower-left corner of simulation box\ncs->pack(BOX,9,box)            # 3 edge vectors of simulation box\nServer replies to either kind of message:\n# required fields: FORCES, ENERGY, PRESSURE\n# optional fields: ERROR\n\ncs->send(msgID,nfields)      # msgID with nfields\ncs->pack(FORCES,3*Natoms,f)  # vector of 3N forces on atoms\ncs->pack(ENERGY,1,poteng)    # total potential energy of system\ncs->pack(PRESSURE,6,press)   # global pressure tensor (6-vector)\ncs->pack_int(ERROR,flag)     # server had an error (e.g. DFT non-convergence)\n\nThe units for various quantities that are sent and received iva\nmessages are defined for atomic-scale simulations in the table below.\nThe client and server codes (including LAMMPS) can use internal units\ndifferent than these (e.g. real units in LAMMPS), so long\nas they convert to these units for messaging.\n\nCOORDS, ORIGIN, BOX = Angstroms\nCHARGE = multiple of electron charge (1.0 is a proton)\nENERGY = eV\nFORCES = eV/Angstrom\nPRESSURE = bars\n\nNote that these are metal units in LAMMPS.\nIf you wish to run LAMMPS in another its non-atomic units, e.g. lj units, then the client and server should exchange a UNITS\nmessage as indicated above, and both the client and server should\nagree on the units for the data they exchange.",
    "syntax": "server md",
    "parameters": " * md = the protocol argument to the server command",
    "examples": "server md",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "set",
    "html_filename": "set.html",
    "short_description": "Set one or more properties of one or more atoms",
    "description": "Set one or more properties of one or more atoms.  Since atom\nproperties are initially assigned by the read_data,\nread_restart or create_atoms\ncommands, this command changes those assignments.  This can be useful\nfor overriding the default values assigned by the\ncreate_atoms command (e.g. charge = 0.0).  It can\nbe useful for altering pairwise and molecular force interactions,\nsince force-field coefficients are defined in terms of types.  It can\nbe used to change the labeling of atoms by atom type or molecule ID\nwhen they are output in dump files.  It can also be useful\nfor debugging purposes; i.e. positioning an atom at a precise location\nto compute subsequent forces or energy.\nNote that the style and ID arguments determine which atoms have\ntheir properties reset.  The remaining keywords specify which\nproperties to reset and what the new values are.  Some strings like\ntype or mol can be used as a style and/or a keyword.\n\nThis section describes how to select which atoms to change\nthe properties of, via the style and ID arguments.\nThe style atom selects all the atoms in a range of atom IDs.  The\nstyle type selects all the atoms in a range of types.  The style\nmol selects all the atoms in a range of molecule IDs.\nIn each of the range cases, the range can be specified as a single\nnumeric value, or a wildcard asterisk can be used to specify a range\nof values.  This takes the form “*” or “*n” or “n*” or “m*n”.  For\nexample, for the style type, if N = the number of atom types, then\nan asterisk with no numeric values means all types from 1 to N.  A\nleading asterisk means all types from 1 to n (inclusive).  A trailing\nasterisk means all types from n to N (inclusive).  A middle asterisk\nmeans all types from m to n (inclusive).  For all the styles except\nmol, the lowest value for the wildcard is 1; for mol it is 0.\nThe style group selects all the atoms in the specified group.  The\nstyle region selects all the atoms in the specified geometric\nregion.  See the group and region commands\nfor details of how to specify a group or region.\n\nThis section describes the keyword options for which properties to\nchange, for the selected atoms.\nNote that except where explicitly prohibited below, all of the\nkeywords allow an atom-style or atomfile-style variable to be used as the specified value(s).  If the value is a\nvariable, it should be specified as v_name, where name is the\nvariable name.  In this case, the variable will be evaluated, and its\nresulting per-atom value used to determine the value assigned to each\nselected atom.  Note that the per-atom value from the variable will be\nignored for atoms that are not selected via the style and ID\nsettings explained above.  A simple way to use per-atom values from\nthe variable to reset a property for all atoms is to use style atom\nwith ID = “*”; this selects all atom IDs.\nAtom-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters and timestep and elapsed\ntime.  They can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a time-dependent or\nspatially-dependent set of per-atom values.  As explained on the\nvariable doc page, atomfile-style variables can be\nused in place of atom-style variables, and thus as arguments to the\nset command.  Atomfile-style variables read their per-atoms values\nfrom a file.\n\nNote\nAtom-style and atomfile-style variables return floating point\nper-atom values.  If the values are assigned to an integer variable,\nsuch as the molecule ID, then the floating point value is truncated to\nits integer portion, e.g. a value of 2.6 would become 2.\n\nKeyword type sets the atom type for all selected atoms.  The\nspecified value must be from 1 to ntypes, where ntypes was set by the\ncreate_box command or the atom types field in the\nheader of the data file read by the read_data\ncommand.\nKeyword type/fraction sets the atom type for a fraction of the\nselected atoms.  The actual number of atoms changed is not guaranteed\nto be exactly the specified fraction (0 <= fraction <= 1), but\nshould be statistically close.  Random numbers are used in such a way\nthat a particular atom is changed or not changed, regardless of how\nmany processors are being used.  This keyword does not allow use of an\natom-style variable.\nKeywords type/ratio and type/subset also set the atom type for a\nfraction of the selected atoms.  The actual number of atoms changed\nwill be exactly the requested number.  For type/ratio the specified\nfraction (0 <= fraction <= 1) determines the number.  For\ntype/subset, the specified Nsubset is the number.  An iterative\nalgorithm is used which insures the correct number of atoms are\nselected, in a perfectly random fashion.  Which atoms are selected\nwill change with the number of processors used.  These keywords do not\nallow use of an atom-style variable.\nKeyword mol sets the molecule ID for all selected atoms.  The\natom style being used must support the use of\nmolecule IDs.\nKeywords x, y, z, and charge set the coordinates or\ncharge of all selected atoms.  For charge, the atom style being used must support the use of atomic\ncharge. Keywords vx, vy, and vz set the velocities of all\nselected atoms.\nKeyword dipole uses the specified x,y,z values as components of a\nvector to set as the orientation of the dipole moment vectors of the\nselected atoms.  The magnitude of the dipole moment is set by the\nlength of this orientation vector.\nKeyword dipole/random randomizes the orientation of the dipole\nmoment vectors for the selected atoms and sets the magnitude of each\nto the specified Dlen value.  For 2d systems, the z component of the\norientation is set to 0.0.  Random numbers are used in such a way that\nthe orientation of a particular atom is the same, regardless of how\nmany processors are being used.  This keyword does not allow use of an\natom-style variable.\nKeyword spin uses the specified g value to set the magnitude of the\nmagnetic spin vectors, and the x,y,z values as components of a vector\nto set as the orientation of the magnetic spin vectors of the selected\natoms.\nKeyword spin/random randomizes the orientation of the magnetic spin\nvectors for the selected atoms and sets the magnitude of each to the\nspecified Dlen value.\nKeyword quat uses the specified values to create a quaternion\n(4-vector) that represents the orientation of the selected atoms.  The\nparticles must define a quaternion for their orientation\n(e.g. ellipsoids, triangles, body particles) as defined by the\natom_style command.  Note that particles defined by\natom_style ellipsoid have 3 shape parameters.  The 3\nvalues must be non-zero for each particle set by this command.  They\nare used to specify the aspect ratios of an ellipsoidal particle,\nwhich is oriented by default with its x-axis along the simulation\nbox’s x-axis, and similarly for y and z.  If this body is rotated (via\nthe right-hand rule) by an angle theta around a unit rotation vector\n(a,b,c), then the quaternion that represents its new orientation is\ngiven by (cos(theta/2), a*sin(theta/2), b*sin(theta/2),\nc*sin(theta/2)).  The theta and a,b,c values are the arguments to the\nquat keyword.  LAMMPS normalizes the quaternion in case (a,b,c) was\nnot specified as a unit vector.  For 2d systems, the a,b,c values are\nignored, since a rotation vector of (0,0,1) is the only valid choice.\nKeyword quat/random randomizes the orientation of the quaternion for\nthe selected atoms.  The particles must define a quaternion for their\norientation (e.g. ellipsoids, triangles, body particles) as defined by\nthe atom_style command.  Random numbers are used in\nsuch a way that the orientation of a particular atom is the same,\nregardless of how many processors are being used.  For 2d systems,\nonly orientations in the xy plane are generated.  As with keyword\nquat, for ellipsoidal particles, the 3 shape values must be non-zero\nfor each particle set by this command.  This keyword does not allow\nuse of an atom-style variable.\nKeyword diameter sets the size of the selected atoms.  The particles\nmust be finite-size spheres as defined by the atom_style sphere command.  The diameter of a particle can be\nset to 0.0, which means they will be treated as point particles.  Note\nthat this command does not adjust the particle mass, even if it was\ndefined with a density, e.g. via the read_data\ncommand.\nKeyword shape sets the size and shape of the selected atoms.  The\nparticles must be ellipsoids as defined by the atom_style ellipsoid command.  The Sx, Sy, Sz settings are\nthe 3 diameters of the ellipsoid in each direction.  All 3 can be set\nto the same value, which means the ellipsoid is effectively a sphere.\nThey can also all be set to 0.0 which means the particle will be\ntreated as a point particle.  Note that this command does not adjust\nthe particle mass, even if it was defined with a density, e.g. via the\nread_data command.\nKeyword length sets the length of selected atoms.  The particles\nmust be line segments as defined by the atom_style line command.  If the specified value is non-zero the\nline segment is (re)set to a length = the specified value, centered\naround the particle position, with an orientation along the x-axis.\nIf the specified value is 0.0, the particle will become a point\nparticle.  Note that this command does not adjust the particle mass,\neven if it was defined with a density, e.g. via the\nread_data command.\nKeyword tri sets the size of selected atoms.  The particles must be\ntriangles as defined by the atom_style tri command.\nIf the specified value is non-zero the triangle is (re)set to be an\nequilateral triangle in the xy plane with side length = the specified\nvalue, with a centroid at the particle position, with its base\nparallel to the x axis, and the y-axis running from the center of the\nbase to the top point of the triangle.  If the specified value is 0.0,\nthe particle will become a point particle.  Note that this command\ndoes not adjust the particle mass, even if it was defined with a\ndensity, e.g. via the read_data command.\nKeyword theta sets the orientation of selected atoms.  The particles\nmust be line segments as defined by the atom_style line command.  The specified value is used to set the\norientation angle of the line segments with respect to the x axis.\nKeyword theta/random randomizes the orientation of theta for the\nselected atoms.  The particles must be line segments as defined by the\natom_style line command.  Random numbers are used in\nsuch a way that the orientation of a particular atom is the same,\nregardless of how many processors are being used.  This keyword does\nnot allow use of an atom-style variable.\nKeyword angmom sets the angular momentum of selected atoms.  The\nparticles must be ellipsoids as defined by the atom_style ellipsoid command or triangles as defined by the\natom_style tri command.  The angular momentum vector\nof the particles is set to the 3 specified components.\nKeyword omega sets the angular velocity of selected atoms.  The\nparticles must be spheres as defined by the\natom_style sphere command.  The angular velocity\nvector of the particles is set to the 3 specified components.\nKeyword mass sets the mass of all selected particles.  The particles\nmust have a per-atom mass attribute, as defined by the\natom_style command.  See the “mass” command for how\nto set mass values on a per-type basis.\nKeyword density or density/disc also sets the mass of all selected\nparticles, but in a different way.  The particles must have a per-atom\nmass attribute, as defined by the atom_style\ncommand.  If the atom has a radius attribute (see atom_style sphere) and its radius is non-zero, its mass is set\nfrom the density and particle volume for 3d systems (the input density\nis assumed to be in mass/distance^3 units).  For 2d, the default is\nfor LAMMPS to model particles with a radius attribute as spheres.\nHowever, if the density/disc keyword is used, then they can be\nmodeled as 2d discs (circles).  Their mass is set from the density and\nparticle area (the input density is assumed to be in mass/distance^2\nunits).\nIf the atom has a shape attribute (see atom_style ellipsoid) and its 3 shape parameters are non-zero,\nthen its mass is set from the density and particle volume (the input\ndensity is assumed to be in mass/distance^3 units).  The\ndensity/disc keyword has no effect; it does not (yet) treat 3d\nellipsoids as 2d ellipses.\nIf the atom has a length attribute (see atom_style line) and its length is non-zero, then its mass is\nset from the density and line segment length (the input density is\nassumed to be in mass/distance units).  If the atom has an area\nattribute (see atom_style tri) and its area is\nnon-zero, then its mass is set from the density and triangle area (the\ninput density is assumed to be in mass/distance^2 units).\nIf none of these cases are valid, then the mass is set to the density\nvalue directly (the input density is assumed to be in mass units).\nKeyword volume sets the volume of all selected particles.\nCurrently, only the atom_style peri command defines\nparticles with a volume attribute.  Note that this command does not\nadjust the particle mass.\nKeyword image sets which image of the simulation box the atom is\nconsidered to be in.  An image of 0 means it is inside the box as\ndefined.  A value of 2 means add 2 box lengths to get the true value.\nA value of -1 means subtract 1 box length to get the true value.\nLAMMPS updates these flags as atoms cross periodic boundaries during\nthe simulation.  The flags can be output with atom snapshots via the\ndump command.  If a value of NULL is specified for any of\nnx,ny,nz, then the current image value for that dimension is unchanged.\nFor non-periodic dimensions only a value of 0 can be specified.\nThis command can be useful after a system has been equilibrated and\natoms have diffused one or more box lengths in various directions.\nThis command can then reset the image values for atoms so that they\nare effectively inside the simulation box, e.g if a diffusion\ncoefficient is about to be measured via the compute msd command.  Care should be taken not to reset the\nimage flags of two atoms in a bond to the same value if the bond\nstraddles a periodic boundary (rather they should be different by +/-\n1).  This will not affect the dynamics of a simulation, but may mess\nup analysis of the trajectories if a LAMMPS diagnostic or your own\nanalysis relies on the image flags to unwrap a molecule which\nstraddles the periodic box.\nKeywords bond, angle, dihedral, and improper, set the bond\ntype (angle type, etc) of all bonds (angles, etc) of selected atoms to\nthe specified value from 1 to nbondtypes (nangletypes, etc).  All\natoms in a particular bond (angle, etc) must be selected atoms in\norder for the change to be made.  The value of nbondtype (nangletypes,\netc) was set by the bond types (angle types, etc) field in the\nheader of the data file read by the read_data\ncommand.  These keywords do not allow use of an atom-style variable.\nKeywords meso/e, meso/cv, and meso/rho set the energy, heat\ncapacity, and density of smoothed particle hydrodynamics (SPH)\nparticles.  See this PDF guide to\nusing SPH in LAMMPS.\nKeyword smd/mass/density sets the mass of all selected particles,\nbut it is only applicable to the Smooth Mach Dynamics package\nUSER-SMD.  It assumes that the particle volume has already been\ncorrectly set and calculates particle mass from the provided mass\ndensity value.\nKeyword smd/contact/radius only applies to simulations with the\nSmooth Mach Dynamics package USER-SMD.  Itsets an interaction radius\nfor computing short-range interactions, e.g. repulsive forces to\nprevent different individual physical bodies from penetrating each\nother. Note that the SPH smoothing kernel diameter used for computing\nlong range, nonlocal interactions, is set using the diameter\nkeyword.\nKeyword dpd/theta sets the internal temperature of a DPD particle as\ndefined by the USER-DPD package.  If the specified value is a number\nit must be >= 0.0.  If the specified value is NULL, then the kinetic\ntemperature Tkin of each particle is computed as 3/2 k Tkin = KE = 1/2\nm v^2 = 1/2 m (vx*vx+vy*vy+vz*vz).  Each particle’s internal\ntemperature is set to Tkin.  If the specified value is an atom-style\nvariable, then the variable is evaluated for each particle.  If a\nvalue >= 0.0, the internal temperature is set to that value.  If it is\n< 0.0, the computation of Tkin is performed and the internal\ntemperature is set to that value.\nKeywords edpd/temp and edpd/cv set the temperature and volumetric\nheat capacity of an eDPD particle as defined by the USER-MESO package.\nCurrently, only atom_style edpd defines particles\nwith these attributes. The values for the temperature and heat\ncapacity must be positive.\nKeyword cc sets the chemical concentration of a tDPD particle for a\nspecified species as defined by the USER-MESO package. Currently, only\natom_style tdpd defines particles with this\nattribute. An integer for “index” selects a chemical species (1 to\nNspecies) where Nspecies is set by the atom_style command. The value\nfor the chemical concentration must be >= 0.0.\nKeywords i_name and d_name refer to custom integer and\nfloating-point properties that have been added to each atom via the\nfix property/atom command.  When that command\nis used specific names are given to each attribute which are what is\nspecified as the “name” portion of i_name or d_name.",
    "syntax": "set style ID keyword values ...",
    "parameters": " * style = atom or type or mol or group or region\n * ID = atom ID range or type range or mol ID range or group ID or region ID\n * one or more keyword/value pairs may be appended\n * keyword = type or type/fraction or type/ratio or type/subset or mol or x or y or z or           charge or dipole or dipole/random or quat or           spin or spin/random or quat or           quat/random or diameter or shape or           length or tri or theta or theta/random or           angmom or omega or           mass or density or density/disc or volume or image or           bond or angle or dihedral or improper or           meso/e or meso/cv or meso/rho or           smd/contact/radius or smd/mass/density or dpd/theta or           edpd/temp or edpd/cv or cc or i_name or d_name\n * type value = atom type\n *   value can be an atom-style variable (see below)\n * type/fraction values = type fraction seed\n *   type = new atom type\n *   fraction = approximate fraction of selected atoms to set to new atom type\n *   seed = random # seed (positive integer)\n * type/ratio values = type fraction seed\n *   type = new atom type\n *   fraction = exact fraction of selected atoms to set to new atom type\n *   seed = random # seed (positive integer)\n * type/subset values = type Nsubset seed\n *   type = new atom type\n *   Nsubset = exact number of selected atoms to set to new atom type\n *   seed = random # seed (positive integer)\n * mol value = molecule ID\n *   value can be an atom-style variable (see below)\n * x,y,z value = atom coordinate (distance units)\n *   value can be an atom-style variable (see below)\n * vx,vy,vz value = atom velocity (velocity units)\n *   value can be an atom-style variable (see below)\n * charge value = atomic charge (charge units)\n *   value can be an atom-style variable (see below)\n * dipole values = x y z\n *   x,y,z = orientation of dipole moment vector\n *   any of x,y,z can be an atom-style variable (see below)\n * dipole/random value = seed Dlen\n *   seed = random # seed (positive integer) for dipole moment orientations\n *   Dlen = magnitude of dipole moment (dipole units)\n * spin values = g x y z\n *   g = magnitude of magnetic spin vector (in Bohr magneton's unit)\n *   x,y,z = orientation of magnetic spin vector\n *   any of x,y,z can be an atom-style variable (see below)\n * spin/random value = seed Dlen\n *   seed = random # seed (positive integer) for magnetic spin orientations\n *   Dlen = magnitude of magnetic spin vector (in Bohr magneton's unit)\n * quat values = a b c theta\n *   a,b,c = unit vector to rotate particle around via right-hand rule\n *   theta = rotation angle (degrees)\n *   any of a,b,c,theta can be an atom-style variable (see below)\n * quat/random value = seed\n *   seed = random # seed (positive integer) for quaternion orientations\n * diameter value = diameter of spherical particle (distance units)\n *   value can be an atom-style variable (see below)\n * shape value = Sx Sy Sz\n *   Sx,Sy,Sz = 3 diameters of ellipsoid (distance units)\n * length value = len\n *   len = length of line segment (distance units)\n *   len can be an atom-style variable (see below)\n * tri value = side\n *   side = side length of equilateral triangle (distance units)\n *   side can be an atom-style variable (see below)\n * theta value = angle (degrees)\n *   angle = orientation of line segment with respect to x-axis\n *   angle can be an atom-style variable (see below)\n * theta/random value = seed\n *   seed = random # seed (positive integer) for line segment orienations\n * angmom values = Lx Ly Lz\n *   Lx,Ly,Lz = components of angular momentum vector (distance-mass-velocity units)\n *   any of Lx,Ly,Lz can be an atom-style variable (see below)\n * omega values = Wx Wy Wz\n *   Wx,Wy,Wz = components of angular velocity vector (radians/time units)\n *   any of wx,wy,wz can be an atom-style variable (see below)\n * mass value = per-atom mass (mass units)\n *   value can be an atom-style variable (see below)\n * density value = particle density for a sphere or ellipsoid (mass/distance^3 units), or for a triangle (mass/distance^2 units) or line (mass/distance units) particle\n *   value can be an atom-style variable (see below)\n * density/disc value = particle density for a 2d disc or ellipse (mass/distance^2 units)\n *   value can be an atom-style variable (see below)\n * volume value = particle volume for Peridynamic particle (distance^3 units)\n *   value can be an atom-style variable (see below)\n * image nx ny nz\n *   nx,ny,nz = which periodic image of the simulation box the atom is in\n *   any of nx,ny,nz can be an atom-style variable (see below)\n * bond value = bond type for all bonds between selected atoms\n * angle value = angle type for all angles between selected atoms\n * dihedral value = dihedral type for all dihedrals between selected atoms\n * improper value = improper type for all impropers between selected atoms\n * meso/e value = energy of SPH particles (need units)\n *   value can be an atom-style variable (see below)\n * meso/cv value = heat capacity of SPH particles (need units)\n *   value can be an atom-style variable (see below)\n * meso/rho value = density of SPH particles (need units)\n *   value can be an atom-style variable (see below)\n * smd/contact/radius = radius for short range interactions, i.e. contact and friction\n *   value can be an atom-style variable (see below)\n * smd/mass/density = set particle mass based on volume by providing a mass density\n *   value can be an atom-style variable (see below)\n * dpd/theta value = internal temperature of DPD particles (temperature units)\n *   value can be an atom-style variable (see below)\n *   value can be NULL which sets internal temp of each particle to KE temp\n * edpd/temp value = temperature of eDPD particles (temperature units)\n *   value can be an atom-style variable (see below)\n * edpd/cv value = volumetric heat capacity of eDPD particles (energy/temperature/volume units)\n *   value can be an atom-style variable (see below)\n * cc values = index cc\n *   index = index of a chemical species (1 to Nspecies)\n *   cc = chemical concentration of tDPD particles for a species (mole/volume units)\n * i_name value = value for custom integer vector with name\n * d_name value = value for custom floating-point vector with name",
    "examples": "set group solvent type 2\nset group solvent type/fraction 2 0.5 12393\nset group edge bond 4\nset region half charge 0.5\nset type 3 charge 0.5\nset type 1*3 charge 0.5\nset atom * charge v_atomfile\nset atom 100*200 x 0.5 y 1.0\nset atom 100 vx 0.0 vy 0.0 vz -1.0\nset atom 1492 type 3",
    "restrictions": "You cannot set an atom attribute (e.g. mol or q or volume) if\nthe atom_style does not have that attribute.\nThis command requires inter-processor communication to coordinate the\nsetting of bond types (angle types, etc).  This means that your system\nmust be ready to perform a simulation before using one of these\nkeywords (force fields set, atom mass set, etc).  This is not\nnecessary for other keywords.\nUsing the region style with the bond (angle, etc) keywords can give\nunpredictable results if there are bonds (angles, etc) that straddle\nperiodic boundaries.  This is because the region may only extend up to\nthe boundary and partner atoms in the bond (angle, etc) may have\ncoordinates outside the simulation box if they are ghost atoms."
},
{
    "command": "shell",
    "html_filename": "shell.html",
    "short_description": "Execute a shell command",
    "description": "Execute a shell command.  A few simple file-based shell commands are\nsupported directly, in Unix-style syntax.  Any command not listed\nabove is passed as-is to the C-library system() call, which invokes\nthe command in a shell.\nThis is means to invoke other commands from your input script.  For\nexample, you can move files around in preparation for the next section\nof the input script.  Or you can run a program that pre-processes data\nfor input into LAMMPS.  Or you can run a program that post-processes\nLAMMPS output data.\nWith the exception of cd, all commands, including ones invoked via a\nsystem() call, are executed by only a single processor, so that\nfiles/directories are not being manipulated by multiple processors.\nThe cd cmd executes the Unix “cd” command to change the working\ndirectory.  All subsequent LAMMPS commands that read/write files will\nuse the new directory.  All processors execute this command.\nThe mkdir cmd executes the Unix “mkdir” command to create one or\nmore directories.\nThe mv cmd executes the Unix “mv” command to rename a file and/or\nmove it to a new directory.\nThe rm cmd executes the Unix “rm” command to remove one or more\nfiles.\nThe rmdir cmd executes the Unix “rmdir” command to remove one or\nmore directories.  A directory must be empty to be successfully\nremoved.\nThe putenv cmd defines or updates an environment variable directly.\nSince this command does not pass through the shell, no shell variable\nexpansion or globbing is performed, only the usual substitution for\nLAMMPS variables defined with the variable command is\nperformed.  The resulting string is then used literally.\nAny other cmd is passed as-is to the shell along with its arguments as\none string, invoked by the C-library system() call.  For example,\nthese lines in your input script:\nvariable n equal 10\nvariable foo string file2\nshell my_setup file1 $n ${foo}\n\n\nwould be the same as invoking\n% my_setup file1 10 file2\n\n\nfrom a command-line prompt.  The executable program “my_setup” is run\nwith 3 arguments: file1 10 file2.",
    "syntax": "shell cmd args",
    "parameters": " * cmd = cd or mkdir or mv or rm or rmdir or putenv or arbitrary command\n * cd arg = dir\n *   dir = directory to change to\n * mkdir args = dir1 dir2 ...\n *   dir1,dir2 = one or more directories to create\n * mv args = old new\n *   old = old filename\n *   new = new filename\n * rm args = file1 file2 ...\n *   file1,file2 = one or more filenames to delete\n * rmdir args = dir1 dir2 ...\n *   dir1,dir2 = one or more directories to delete\n * putenv args = var1=value1 var2=value2\n *   var=value = one of more definitions of environment variables\n * anything else is passed as a command to the shell for direct execution",
    "examples": "shell cd sub1\nshell cd ..\nshell mkdir tmp1 tmp2 tmp3\nshell rmdir tmp1\nshell mv log.lammps hold/log.1\nshell rm TMP/file1 TMP/file2\nshell putenv LAMMPS_POTENTIALS=../../potentials\nshell my_setup file1 10 file2\nshell my_post_process 100 dump.out",
    "restrictions": "LAMMPS does not detect errors or print warnings when any of these\ncommands execute.  E.g. if the specified directory does not exist,\nexecuting the cd command will silently do nothing.\nRelated commands: none\nDefault: none"
},
{
    "command": "special_bonds",
    "html_filename": "special_bonds.html",
    "short_description": "Set weighting coefficients for pairwise energy and force contributions between pairs of atoms that are also permanently bonded to each other, either directly or via one or two intermediate bonds",
    "description": "Set weighting coefficients for pairwise energy and force contributions\nbetween pairs of atoms that are also permanently bonded to each other,\neither directly or via one or two intermediate bonds.  These weighting\nfactors are used by nearly all pair styles in LAMMPS\nthat compute simple pairwise interactions.  Permanent bonds between\natoms are specified by defining the bond topology in the data file\nread by the read_data command.  Typically a\nbond_style command is also used to define a bond\npotential.  The rationale for using these weighting factors is that\nthe interaction between a pair of bonded atoms is all (or mostly)\nspecified by the bond, angle, dihedral potentials, and thus the\nnon-bonded Lennard-Jones or Coulombic interaction between the pair of\natoms should be excluded (or reduced by a weighting factor).\n\nNote\nThese weighting factors are NOT used by pair styles that compute many-body interactions, since the\n“bonds” that result from such interactions are not permanent, but are\ncreated and broken dynamically as atom conformations change.  Examples\nof pair styles in this category are EAM, MEAM, Stillinger-Weber,\nTersoff, COMB, AIREBO, and ReaxFF.  In fact, it generally makes no\nsense to define permanent bonds between atoms that interact via these\npotentials, though such bonds may exist elsewhere in your system,\ne.g. when using the pair_style hybrid command.\nThus LAMMPS ignores special_bonds settings when many-body potentials\nare calculated.  Please note, that the existence of explicit bonds\nfor atoms that are described by a many-body potential will alter the\nneighbor list and thus can render the computation of those interactions\ninvalid, since those pairs are not only used to determine direct\npairwise interactions but also neighbors of neighbors and more.\nThe recommended course of action is to remove such bonds, or - if\nthat is not possible - use a special bonds setting of 1.0 1.0 1.0.\n\n\nNote\nUnlike some commands in LAMMPS, you cannot use this command\nmultiple times in an incremental fashion: e.g. to first set the LJ\nsettings and then the Coulombic ones.  Each time you use this command\nit sets all the coefficients to default values and only overrides the\none you specify, so you should set all the options you need each time\nyou use it.  See more details at the bottom of this page.\n\nThe Coulomb factors are applied to any Coulomb (charge interaction)\nterm that the potential calculates.  The LJ factors are applied to the\nremaining terms that the potential calculates, whether they represent\nLJ interactions or not.  The weighting factors are a scaling\npre-factor on the energy and force between the pair of atoms.  A value\nof 1.0 means include the full interaction; a value of 0.0 means\nexclude it completely.\nThe 1st of the 3 coefficients (LJ or Coulombic) is the weighting\nfactor on 1-2 atom pairs, which are pairs of atoms directly bonded to\neach other.  The 2nd coefficient is the weighting factor on 1-3 atom\npairs which are those separated by 2 bonds (e.g. the two H atoms in a\nwater molecule).  The 3rd coefficient is the weighting factor on 1-4\natom pairs which are those separated by 3 bonds (e.g. the 1st and 4th\natoms in a dihedral interaction).  Thus if the 1-2 coefficient is set\nto 0.0, then the pairwise interaction is effectively turned off for\nall pairs of atoms bonded to each other.  If it is set to 1.0, then\nthat interaction will be at full strength.\n\nNote\nFor purposes of computing weighted pairwise interactions, 1-3\nand 1-4 interactions are not defined from the list of angles or\ndihedrals used by the simulation.  Rather, they are inferred\ntopologically from the set of bonds specified when the simulation is\ndefined from a data or restart file (see read_data or\nread_restart commands).  Thus the set of\n1-2,1-3,1-4 interactions that the weights apply to is the same whether\nangle and dihedral potentials are computed or not, and remains the\nsame even if bonds are constrained, or turned off, or removed during a\nsimulation.\n\nThe two exceptions to this rule are (a) if the angle or dihedral\nkeywords are set to yes (see below), or (b) if the\ndelete_bonds command is used with the special\noption that re-computes the 1-2,1-3,1-4 topologies after bonds are\ndeleted; see the delete_bonds command for more\ndetails.\nThe amber keyword sets the 3 coefficients to 0.0, 0.0, 0.5 for LJ\ninteractions and to 0.0, 0.0, 0.8333 for Coulombic interactions, which\nis the default for a commonly used version of the AMBER force field,\nwhere the last value is really 5/6.  See (Cornell) for a\ndescription of the AMBER force field.\nThe charmm keyword sets the 3 coefficients to 0.0, 0.0, 0.0 for both\nLJ and Coulombic interactions, which is the default for a commonly\nused version of the CHARMM force field.  Note that in pair styles\nlj/charmm/coul/charmm and lj/charmm/coul/long the 1-4 coefficients\nare defined explicitly, and these pairwise contributions are computed\nas part of the charmm dihedral style - see the\npair_coeff and dihedral_style\ncommands for more information.  See (MacKerell) for a\ndescription of the CHARMM force field.\nThe dreiding keyword sets the 3 coefficients to 0.0, 0.0, 1.0 for both\nLJ and Coulombic interactions, which is the default for the Dreiding\nforce field, as discussed in (Mayo).\nThe fene keyword sets the 3 coefficients to 0.0, 1.0, 1.0 for both\nLJ and Coulombic interactions, which is consistent with a\ncoarse-grained polymer model with FENE bonds.  See\n(Kremer) for a description of FENE bonds.\nThe lj/coul, lj, and coul keywords allow the 3 coefficients to\nbe set explicitly.  The lj/coul keyword sets both the LJ and\nCoulombic coefficients to the same 3 values.  The lj and coul\nkeywords only set either the LJ or Coulombic coefficients.  Use both\nof them if you wish to set the LJ coefficients to different values\nthan the Coulombic coefficients.\nThe angle keyword allows the 1-3 weighting factor to be ignored for\nindividual atom pairs if they are not listed as the first and last\natoms in any angle defined in the simulation or as 1,3 or 2,4 atoms in\nany dihedral defined in the simulation.  For example, imagine the 1-3\nweighting factor is set to 0.5 and you have a linear molecule with 4\natoms and bonds as follows: 1-2-3-4.  If your data file defines 1-2-3\nas an angle, but does not define 2-3-4 as an angle or 1-2-3-4 as a\ndihedral, then the pairwise interaction between atoms 1 and 3 will\nalways be weighted by 0.5, but different force fields use different\nrules for weighting the pairwise interaction between atoms 2 and 4.\nIf the angle keyword is specified as yes, then the pairwise\ninteraction between atoms 2 and 4 will be unaffected (full weighting\nof 1.0).  If the angle keyword is specified as no which is the\ndefault, then the 2,4 interaction will also be weighted by 0.5.\nThe dihedral keyword allows the 1-4 weighting factor to be ignored\nfor individual atom pairs if they are not listed as the first and last\natoms in any dihedral defined in the simulation.  For example, imagine\nthe 1-4 weighting factor is set to 0.5 and you have a linear molecule\nwith 5 atoms and bonds as follows: 1-2-3-4-5.  If your data file\ndefines 1-2-3-4 as a dihedral, but does not define 2-3-4-5 as a\ndihedral, then the pairwise interaction between atoms 1 and 4 will\nalways be weighted by 0.5, but different force fields use different\nrules for weighting the pairwise interaction between atoms 2 and 5.\nIf the dihedral keyword is specified as yes, then the pairwise\ninteraction between atoms 2 and 5 will be unaffected (full weighting\nof 1.0).  If the dihedral keyword is specified as no which is the\ndefault, then the 2,5 interaction will also be weighted by 0.5.\n\n\nNote\nLAMMPS stores and maintains a data structure with a list of the\n1st, 2nd, and 3rd neighbors of each atom (within the bond topology of\nthe system).  If new bonds are created (or molecules added containing\natoms with more special neighbors), the size of this list needs to\ngrow.  Note that adding a single bond always adds a new 1st neighbor\nbut may also induce *many* new 2nd and 3rd neighbors, depending on the\nmolecular topology of your system.  Using the extra/special/per/atom\nkeyword to either read_data or create_box\nreserves empty space in the list for this N additional 1st, 2nd, or 3rd\nneighbors to be added.  If you do not do this, you may get an error\nwhen bonds (or molecules) are added.\n\n\n\nNote\nIf you reuse this command in an input script, you should set all\nthe options you need each time.  This command cannot be used a 2nd\ntime incrementally.  E.g. these two commands:\n\nspecial_bonds lj 0.0 1.0 1.0\nspecial_bonds coul 0.0 0.0 1.0\n\n\nare not the same as\nspecial_bonds lj 0.0 1.0 1.0 coul 0.0 0.0 1.0\n\n\nIn the first case you end up with (after the 2nd command):\nLJ: 0.0 0.0 0.0\nCoul: 0.0 0.0 1.0\n\n\nwhile only in the second case, you get the desired settings of:\nLJ: 0.0 1.0 1.0\nCoul: 0.0 0.0 1.0\n\n\nThis happens because the LJ (and Coul) settings are reset to\ntheir default values before modifying them, each time the\nspecial_bonds command is issued.",
    "syntax": "special_bonds keyword values ...",
    "parameters": " * one or more keyword/value pairs may be appended\n * keyword = amber or charmm or dreiding or fene or lj/coul or lj or coul or angle or dihedral\n * amber values = none\n * charmm values = none\n * dreiding values = none\n * fene values = none\n * lj/coul values = w1,w2,w3\n *   w1,w2,w3 = weights (0.0 to 1.0) on pairwise Lennard-Jones and Coulombic interactions\n * lj values = w1,w2,w3\n *   w1,w2,w3 = weights (0.0 to 1.0) on pairwise Lennard-Jones interactions\n * coul values = w1,w2,w3\n *   w1,w2,w3 = weights (0.0 to 1.0) on pairwise Coulombic interactions\n * angle value = yes or no\n * dihedral value = yes or no\n * Examples:\n * special_bonds amber\n * special_bonds charmm\n * special_bonds fene dihedral no\n * special_bonds lj/coul 0.0 0.0 0.5 angle yes dihedral yes\n * special_bonds lj 0.0 0.0 0.5 coul 0.0 0.0 0.0 dihedral yes",
    "examples": "shell cd sub1\nshell cd ..\nshell mkdir tmp1 tmp2 tmp3\nshell rmdir tmp1\nshell mv log.lammps hold/log.1\nshell rm TMP/file1 TMP/file2\nshell putenv LAMMPS_POTENTIALS=../../potentials\nshell my_setup file1 10 file2\nshell my_post_process 100 dump.out",
    "restrictions": "none"
},
{
    "command": "suffix",
    "html_filename": "suffix.html",
    "short_description": "This command allows you to use variants of various styles if they exist",
    "description": "This command allows you to use variants of various styles if they\nexist.  In that respect it operates the same as the -suffix command-line switch.  It also has options to turn\noff or back on any suffix setting made via the command line.\nThe specified style can be gpu, intel, kk, omp, opt or\nhybrid. These refer to optional packages that LAMMPS can be built\nwith, as described on the Build package doc page.\nThe “gpu” style corresponds to the GPU package, the “intel” style to\nthe USER-INTEL package, the “kk” style to the KOKKOS package, the\n“omp” style to the USER-OMP package, and the “opt” style to the OPT\npackage.\nThese are the variants these packages provide:\n\nGPU = a handful of pair styles and the PPPM kspace_style, optimized to\nrun on one or more GPUs or multicore CPU/GPU nodes\nUSER-INTEL = a collection of pair styles and neighbor routines\noptimized to run in single, mixed, or double precision on CPUs and\nIntel(R) Xeon Phi(TM) co-processors.\nKOKKOS = a collection of atom, pair, and fix styles optimized to run\nusing the Kokkos library on various kinds of hardware, including GPUs\nvia CUDA and many-core chips via OpenMP or threading.\nUSER-OMP = a collection of pair, bond, angle, dihedral, improper,\nkspace, compute, and fix styles with support for OpenMP\nmulti-threading\nOPT = a handful of pair styles, cache-optimized for faster CPU\nperformance\nHYBRID = a combination of two packages can be specified (see below)\n\nAs an example, all of the packages provide a pair_style lj/cut variant, with style names lj/cut/opt, lj/cut/omp,\nlj/cut/gpu, lj/cut/intel, or lj/cut/kk.  A variant styles\ncan be specified explicitly in your input script, e.g. pair_style\nlj/cut/gpu. If the suffix command is used with the appropriate style,\nyou do not need to modify your input script.  The specified suffix\n(opt,omp,gpu,intel,kk) is automatically appended whenever your\ninput script command creates a new atom,\npair, bond,\nangle, dihedral,\nimproper, kspace,\nfix, compute, or run style.\nIf the variant version does not exist, the standard version is\ncreated.\nFor “hybrid”, two packages are specified. The first is used whenever\navailable. If a style with the first suffix is not available, the style\nwith the suffix for the second package will be used if available. For\nexample, “hybrid intel omp” will use styles from the USER-INTEL package\nas a first choice and styles from the USER-OMP package as a second choice\nif no USER-INTEL variant is available.\nIf the specified style is off, then any previously specified suffix\nis temporarily disabled, whether it was specified by a command-line\nswitch or a previous suffix command.  If the specified style is on,\na disabled suffix is turned back on.  The use of these 2 commands lets\nyour input script use a standard LAMMPS style (i.e. a non-accelerated\nvariant), which can be useful for testing or benchmarking purposes.\nOf course this is also possible by not using any suffix commands, and\nexplicitly appending or not appending the suffix to the relevant\ncommands in your input script.\n\nNote\nThe default run_style verlet is invoked prior to\nreading the input script and is therefore not affected by a suffix command\nin the input script. The KOKKOS package requires “run_style verlet/kk”,\nso when using the KOKKOS package it is necessary to either use the command\nline “-sf kk” command or add an explicit “run_style verlet” command to the\ninput script.",
    "syntax": "suffix style args",
    "parameters": " * style = off or on or gpu or intel or kk or omp or opt or hybrid\n * args = for hybrid style, default suffix to be used and alternative suffix",
    "examples": "suffix off\nsuffix on\nsuffix gpu\nsuffix intel\nsuffix hybrid intel omp\nsuffix kk",
    "restrictions": "\nnone"
},
{
    "command": "tad",
    "html_filename": "tad.html",
    "short_description": "Run a temperature accelerated dynamics (TAD) simulation",
    "description": "Run a temperature accelerated dynamics (TAD) simulation. This method\nrequires two or more partitions to perform NEB transition state\nsearches.\nTAD is described in this paper by Art Voter.  It is a method\nthat uses accelerated dynamics at an elevated temperature to generate\nresults at a specified lower temperature.  A good overview of\naccelerated dynamics methods for such systems is given in this review paper from the same group. In general, these methods assume\nthat the long-time dynamics is dominated by infrequent events i.e. the\nsystem is confined to low energy basins for long periods,\npunctuated by brief, randomly-occurring transitions to adjacent\nbasins.  TAD is suitable for infrequent-event systems, where in\naddition, the transition kinetics are well-approximated by harmonic\ntransition state theory (hTST). In hTST, the temperature dependence of\ntransition rates follows the Arrhenius relation.  As a consequence a\nset of event times generated in a high-temperature simulation can be\nmapped to a set of much longer estimated times in the low-temperature\nsystem. However, because this mapping involves the energy barrier of\nthe transition event, which is different for each event, the first\nevent at the high temperature may not be the earliest event at the low\ntemperature. TAD handles this by first generating a set of possible\nevents from the current basin. After each event, the simulation is\nreflected backwards into the current basin.  This is repeated until\nthe stopping criterion is satisfied, at which point the event with the\nearliest low-temperature occurrence time is selected.  The stopping\ncriterion is that the confidence measure be greater than\n1-delta. The confidence measure is the probability that no earlier\nlow-temperature event will occur at some later time in the\nhigh-temperature simulation.  hTST provides an lower bound for this\nprobability, based on the user-specified minimum pre-exponential\nfactor (reciprocal of tmax).\nIn order to estimate the energy barrier for each event, the TAD method\ninvokes the NEB method. Each NEB replica runs on a\npartition of processors. The current NEB implementation in LAMMPS\nrestricts you to having exactly one processor per replica. For more\ninformation, see the documentation for the neb command.  In\nthe current LAMMPS implementation of TAD, all the non-NEB TAD\noperations are performed on the first partition, while the other\npartitions remain idle. See the Howto replica doc\npage for further discussion of multi-replica simulations.\nA TAD run has several stages, which are repeated each time an event is\nperformed.  The logic for a TAD run is as follows:\nwhile (time remains):\n  while (time < tstop):\n    until (event occurs):\n      run dynamics for t_event steps\n      quench\n    run neb calculation using all replicas\n    compute tlo from energy barrier\n    update earliest event\n    update tstop\n    reflect back into current basin\n  execute earliest event\n\n\nBefore this outer loop begins, the initial potential energy basin is\nidentified by quenching (an energy minimization, see below) the\ninitial state and storing the resulting coordinates for reference.\nInside the inner loop, dynamics is run continuously according to\nwhatever integrator has been specified by the user, stopping every\nt_event steps to check if a transition event has occurred.  This\ncheck is performed by quenching the system and comparing the resulting\natom coordinates to the coordinates from the previous basin.\nA quench is an energy minimization and is performed by whichever\nalgorithm has been defined by the min_style command;\nits default is the CG minimizer.  The tolerances and limits for each\nquench can be set by the min keyword.  Note that typically, you do\nnot need to perform a highly-converged minimization to detect a\ntransition event.\nThe event check is performed by a compute with the specified\ncompute-ID.  Currently there is only one compute that works with the\nTAD command, which is the compute event/displace command.  Other\nevent-checking computes may be added.  Compute event/displace checks whether any atom in\nthe compute group has moved further than a specified threshold\ndistance.  If so, an “event” has occurred.\nThe NEB calculation is similar to that invoked by the neb\ncommand, except that the final state is generated internally, instead\nof being read in from a file.  The style of minimization performed by\nNEB is determined by the neb_style keyword and must be a damped\ndynamics minimizer.  The tolerances and limits for each NEB\ncalculation can be set by the neb keyword.  As discussed on the\nneb, it is often advantageous to use a larger timestep for\nNEB than for normal dynamics.  Since the size of the timestep set by\nthe timestep command is used by TAD for performing\ndynamics, there is a neb_step keyword which can be used to set a\nlarger timestep for each NEB calculation if desired.\n\nA key aspect of the TAD method is setting the stopping criterion\nappropriately.  If this criterion is too conservative, then many\nevents must be generated before one is finally executed.  Conversely,\nif this criterion is too aggressive, high-entropy high-barrier events\nwill be over-sampled, while low-entropy low-barrier events will be\nunder-sampled. If the lowest pre-exponential factor is known fairly\naccurately, then it can be used to estimate tmax, and the value of\ndelta can be set to the desired confidence level e.g. delta = 0.05\ncorresponds to 95% confidence. However, for systems where the dynamics\nare not well characterized (the most common case), it will be\nnecessary to experiment with the values of delta and tmax to get a\ngood trade-off between accuracy and performance.\nA second key aspect is the choice of t_hi. A larger value greatly\nincreases the rate at which new events are generated.  However, too\nlarge a value introduces errors due to anharmonicity (not accounted\nfor within hTST). Once again, for any given system, experimentation is\nnecessary to determine the best value of t_hi.\n\nFive kinds of output can be generated during a TAD run: event\nstatistics, NEB statistics, thermodynamic output by each replica, dump\nfiles, and restart files.\nEvent statistics are printed to the screen and master log.lammps file\neach time an event is executed. The quantities are the timestep, CPU\ntime, global event number N, local event number M, event status,\nenergy barrier, time margin, t_lo and delt_lo.  The timestep is\nthe usual LAMMPS timestep, which corresponds to the high-temperature\ntime at which the event was detected, in units of timestep.  The CPU\ntime is the total processor time since the start of the TAD run.  The\nglobal event number N is a counter that increments with each\nexecuted event. The local event number M is a counter that resets to\nzero upon entering each new basin.  The event status is E when an\nevent is executed, and is D for an event that is detected, while\nDF is for a detected event that is also the earliest (first) event\nat the low temperature.\nThe time margin is the ratio of the high temperature time in the\ncurrent basin to the stopping time. This last number can be used to\njudge whether the stopping time is too short or too long (see above).\nt_lo is the low-temperature event time when the current basin was\nentered, in units of timestep.  del*t_lo* is the time of each detected\nevent, measured relative to t_lo.  delt_lo is equal to the\nhigh-temperature time since entering the current basin, scaled by an\nexponential factor that depends on the hi/lo temperature ratio and the\nenergy barrier for that event.\nOn lines for executed events, with status E, the global event number\nis incremented by one,\nthe local event number and time margin are reset to zero,\nwhile the global event number, energy barrier, and\ndelt_lo match the last event with status DF\nin the immediately preceding block of detected events.\nThe low-temperature event time t_lo is incremented by delt_lo.\nNEB statistics are written to the file specified by the neb_log\nkeyword. If the keyword value is “none”, then no NEB statistics are\nprinted out. The statistics are written every Nevery timesteps.  See\nthe neb command for a full description of the NEB\nstatistics. When invoked from TAD, NEB statistics are never printed to\nthe screen.\nBecause the NEB calculation must run on multiple partitions, LAMMPS\nproduces additional screen and log files for each partition,\ne.g. log.lammps.0, log.lammps.1, etc. For the TAD command, these\ncontain the thermodynamic output of each NEB replica. In addition, the\nlog file for the first partition, log.lammps.0, will contain\nthermodynamic output from short runs and minimizations corresponding\nto the dynamics and quench operations, as well as a line for each new\ndetected event, as described above.\nAfter the TAD command completes, timing statistics for the TAD run are\nprinted in each replica’s log file, giving a breakdown of how much CPU\ntime was spent in each stage (NEB, dynamics, quenching, etc).\nAny dump files defined in the input script will be written\nto during a TAD run at timesteps when an event is executed.  This\nmeans the requested dump frequency in the dump command\nis ignored.  There will be one dump file (per dump command) created\nfor all partitions.  The atom coordinates of the dump snapshot are\nthose of the minimum energy configuration resulting from quenching\nfollowing the executed event.  The timesteps written into the dump\nfiles correspond to the timestep at which the event occurred and NOT\nthe clock.  A dump snapshot corresponding to the initial minimum state\nused for event detection is written to the dump file at the beginning\nof each TAD run.\nIf the restart command is used, a single restart file\nfor all the partitions is generated, which allows a TAD run to be\ncontinued by a new input script in the usual manner.  The restart file\nis generated after an event is executed. The restart file contains a\nsnapshot of the system in the new quenched state, including the event\nnumber and the low-temperature time.  The restart frequency specified\nin the restart command is interpreted differently when\nperforming a TAD run.  It does not mean the timestep interval between\nrestart files.  Instead it means an event interval for executed\nevents.  Thus a frequency of 1 means write a restart file every time\nan event is executed.  A frequency of 10 means write a restart file\nevery 10th executed event.  When an input script reads a restart file\nfrom a previous TAD run, the new script can be run on a different\nnumber of replicas or processors.\nNote that within a single state, the dynamics will typically\ntemporarily continue beyond the event that is ultimately chosen, until\nthe stopping criterion is satisfied.  When the event is eventually\nexecuted, the timestep counter is reset to the value when the event\nwas detected. Similarly, after each quench and NEB minimization, the\ntimestep counter is reset to the value at the start of the\nminimization. This means that the timesteps listed in the replica log\nfiles do not always increase monotonically. However, the timestep\nvalues printed to the master log file, dump files, and restart files\nare always monotonically increasing.",
    "syntax": "tad N t_event T_lo T_hi delta tmax compute-ID keyword value ...",
    "parameters": " * N = # of timesteps to run (not including dephasing/quenching)\n * t_event = timestep interval between event checks\n * T_lo = temperature at which event times are desired\n * T_hi = temperature at which MD simulation is performed\n * delta = desired confidence level for stopping criterion\n * tmax = reciprocal of lowest expected pre-exponential factor (time units)\n * compute-ID = ID of the compute used for event detection\n * zero or more keyword/value pairs may be appended\n * keyword = min or neb or min_style or neb_style or neb_log\n * min values = etol ftol maxiter maxeval\n *   etol = stopping tolerance for energy (energy units)\n *   ftol = stopping tolerance for force (force units)\n *   maxiter = max iterations of minimize\n *   maxeval = max number of force/energy evaluations\n * neb values = ftol N1 N2 Nevery\n *   etol = stopping tolerance for energy (energy units)\n *   ftol = stopping tolerance for force (force units)\n *   N1 = max # of iterations (timesteps) to run initial NEB\n *   N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n *   Nevery = print NEB statistics every this many timesteps\n * neb_style value = quickmin or fire\n * neb_step value = dtneb\n *   dtneb = timestep for NEB damped dynamics minimization\n * neb_log value = file where NEB statistics are printed",
    "examples": "tad 2000 50 1800 2300 0.01 0.01 event\ntad 2000 50 1800 2300 0.01 0.01 event &\n    min 1e-05 1e-05 100 100 &\n    neb 0.0 0.01 200 200 20 &\n    min_style cg &\n    neb_style fire &\n    neb_log log.neb",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info.\nN setting must be integer multiple of t_event.\nRuns restarted from restart files written during a TAD run will only\nproduce identical results if the user-specified integrator supports\nexact restarts. So fix nvt will produce an exact\nrestart, but fix langevin will not.\nThis command cannot be used when any fixes are defined that keep track\nof elapsed time to perform time-dependent operations.  Examples\ninclude the “ave” fixes such as fix ave/chunk.\nAlso fix dt/reset and fix deposit."
},
{
    "command": "temper",
    "html_filename": "temper.html",
    "short_description": "Run a parallel tempering or replica exchange simulation using multiple replicas (ensembles) of a system",
    "description": "Run a parallel tempering or replica exchange simulation using multiple\nreplicas (ensembles) of a system.  Two or more replicas must be used.\nEach replica runs on a partition of one or more processors.  Processor\npartitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\ncan run a multi-replica simulation with more replicas (partitions)\nthan you have physical processors, e.g you can run a 10-replica\nsimulation on one or two processors.  You will simply not get the\nperformance speed-up you would see with one or more physical\nprocessors per replica.  See the Howto replica\ndoc page for further discussion.\nEach replica’s temperature is controlled at a different value by a fix\nwith fix-ID that controls temperature. Most thermostat fix styles\n(with and without included time integration) are supported. The command\nwill print an error message and abort, if the chosen fix is unsupported.\nThe desired temperature is specified by temp, which is typically a\nvariable previously set in the input script, so that each partition is\nassigned a different temperature.  See the variable\ncommand for more details.  For example:\nvariable t world 300.0 310.0 320.0 330.0\nfix myfix all nvt temp $t $t 100.0\ntemper 100000 100 $t myfix 3847 58382\n\n\nwould define 4 temperatures, and assign one of them to the thermostat\nused by each replica, and to the temper command.\nAs the tempering simulation runs for N timesteps, a temperature swap\nbetween adjacent ensembles will be attempted every M timesteps.  If\nseed1 is 0, then the swap attempts will alternate between odd and\neven pairings.  If seed1 is non-zero then it is used as a seed in a\nrandom number generator to randomly choose an odd or even pairing each\ntime.  Each attempted swap of temperatures is either accepted or\nrejected based on a Boltzmann-weighted Metropolis criterion which uses\nseed2 in the random number generator.\nAs a tempering run proceeds, multiple log files and screen output\nfiles are created, one per replica.  By default these files are named\nlog.lammps.M and screen.M where M is the replica number from 0 to N-1,\nwith N = # of replicas.  See the -log and -screen command-line swiches for info on how to change these names.\nThe main screen and log file (log.lammps) will list information about\nwhich temperature is assigned to each replica at each thermodynamic\noutput timestep.  E.g. for a simulation with 16 replicas:\nRunning on 16 partitions of processors\nStep T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15\n0    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n500  1 0 3 2 5 4 6 7 8 9 10 11 12 13 14 15\n1000 2 0 4 1 5 3 6 7 8 9 10 11 12 14 13 15\n1500 2 1 4 0 5 3 6 7 9 8 10 11 12 14 13 15\n2000 2 1 3 0 6 4 5 7 10 8 9 11 12 14 13 15\n2500 2 1 3 0 6 4 5 7 11 8 9 10 12 14 13 15\n...\n\n\nThe column headings T0 to TN-1 mean which temperature is currently\nassigned to the replica 0 to N-1.  Thus the columns represent replicas\nand the value in each column is its temperature (also numbered 0 to\nN-1).  For example, a 0 in the 4th column (column T3, step 2500) means\nthat the 4th replica is assigned temperature 0, i.e. the lowest\ntemperature.  You can verify this time sequence of temperature\nassignments for the Nth replica by comparing the Nth column of screen\noutput to the thermodynamic data in the corresponding log.lammps.N or\nscreen.N files as time proceeds.\nYou can have each replica create its own dump file in the following\nmanner:\nvariable rep world 0 1 2 3 4 5 6 7\ndump 1 all atom 1000 dump.temper.$rep\n\nNote\nEach replica’s dump file will contain a continuous trajectory\nfor its atoms where the temperature varies over time as swaps take\nplace involving that replica.  If you want a series of dump files,\neach with snapshots (from all replicas) that are all at a single\ntemperature, then you will need to post-process the dump files using\nthe information from the log.lammps file.  E.g. you could produce one\ndump file with snapshots at 300K (from all replicas), another with\nsnapshots at 310K, etc.  Note that these new dump files will not\ncontain “continuous trajectories” for individual atoms, because two\nsuccessive snapshots (in time) may be from different replicas. The\nreorder_remd_traj python script can do the reordering for you\n(and additionally also calculated configurational log-weights of\ntrajectory snapshots in the canonical ensemble). The script can be found\nin the tools/replica directory while instructions on how to use it is\navailable in doc/Tools (in brief) and as a README file in tools/replica\n(in detail).\n\nThe last argument index in the temper command is optional and is\nused when restarting a tempering run from a set of restart files (one\nfor each replica) which had previously swapped to new temperatures.\nThe index value (from 0 to N-1, where N is the # of replicas)\nidentifies which temperature the replica was simulating on the\ntimestep the restart files were written.  Obviously, this argument\nmust be a variable so that each partition has the correct value.  Set\nthe variable to the N values listed in the log file for the previous\nrun for the replica temperatures at that timestep.  For example if the\nlog file listed the following for a simulation with 5 replicas:\n500000 2 4 0 1 3\n\n\nthen a setting of\nvariable w world 2 4 0 1 3\n\n\nwould be used to restart the run with a tempering command like the\nexample above with $w as the last argument.",
    "syntax": "temper N M temp fix-ID seed1 seed2 index",
    "parameters": " * N = total # of timesteps to run\n * M = attempt a tempering swap every this many steps\n * temp = initial temperature for this ensemble\n * fix-ID = ID of the fix that will control temperature during the run\n * seed1 = random # seed used to decide on adjacent temperature to partner with\n * seed2 = random # seed for Boltzmann factor in Metropolis swap\n * index = which temperature (0 to N-1) I am simulating (optional)",
    "examples": "temper 100000 100 $t tempfix 0 58728\ntemper 40000 100 $t tempfix 0 32285 $w",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\npackage.  See the Build package doc\npage for more info."
},
{
    "command": "temper/grem",
    "html_filename": "temper_grem.html",
    "short_description": "Run a parallel tempering or replica exchange simulation in LAMMPS partition mode using multiple generalized replicas (ensembles) of a system defined by fix grem, which stands for the generalized replica exchange method (gREM) originally developed by (Kim)",
    "description": "Run a parallel tempering or replica exchange simulation in LAMMPS\npartition mode using multiple generalized replicas (ensembles) of a\nsystem defined by fix grem, which stands for the\ngeneralized replica exchange method (gREM) originally developed by\n(Kim).  It uses non-Boltzmann ensembles to sample over first\norder phase transitions. The is done by defining replicas with an\nenthalpy dependent effective temperature\nTwo or more replicas must be used.  See the temper\ncommand for an explanation of how to run replicas on multiple\npartitions of one or more processors.\nThis command is a modification of the temper command and\nhas the same dependencies, restraints, and input variables which are\ndiscussed there in greater detail.\nInstead of temperature, this command performs replica exchanges in\nlambda as per the generalized ensemble enforced by fix grem.  The desired lambda is specified by lambda,\nwhich is typically a variable previously set in the input script, so\nthat each partition is assigned a different temperature.  See the\nvariable command for more details.  For example:\nvariable lambda world 400 420 440 460\nfix fxnvt all nvt temp 300.0 300.0 100.0\nfix fxgREM all grem $lambda -0.05 -50000 fxnvt\ntemper 100000 100 $lambda fxgREM fxnvt 3847 58382\nwould define 4 lambdas with constant kinetic temperature but unique\ngeneralized temperature, and assign one of them to fix grem used by each replica, and to the grem command.\nAs the gREM simulation runs for N timesteps, a swap between adjacent\nensembles will be attempted every M timesteps.  If seed1 is 0,\nthen the swap attempts will alternate between odd and even pairings.\nIf seed1 is non-zero then it is used as a seed in a random number\ngenerator to randomly choose an odd or even pairing each time.  Each\nattempted swap of temperatures is either accepted or rejected based on\na Metropolis criterion, derived for gREM by (Kim), which uses\nseed2 in the random number generator.\nFile management works identical to the temper command.\nDump files created by this fix contain continuous trajectories and\nrequire post-processing to obtain per-replica information.\nThe last argument index in the grem command is optional and is used\nwhen restarting a run from a set of restart files (one for each\nreplica) which had previously swapped to new lambda.  This is done\nusing a variable. For example if the log file listed the following for\na simulation with 5 replicas:\n500000 2 4 0 1 3\n\n\nthen a setting of\nvariable walkers world 2 4 0 1 3\n\n\nwould be used to restart the run with a grem command like the example\nabove with $walkers as the last argument. This functionality is\nidentical to temper.",
    "syntax": "temper/grem N M lambda fix-ID thermostat-ID seed1 seed2 index",
    "parameters": " * N = total # of timesteps to run\n * M = attempt a tempering swap every this many steps\n * lambda = initial lambda for this ensemble\n * fix-ID = ID of fix grem\n * thermostat-ID = ID of the thermostat that controls kinetic temperature\n * seed1 = random # seed used to decide on adjacent temperature to partner with\n * seed2 = random # seed for Boltzmann factor in Metropolis swap\n * index = which temperature (0 to N-1) I am simulating (optional)",
    "examples": "temper/grem 100000 1000 $lambda fxgREM fxnvt 0 58728\ntemper/grem 40000 100 $lambda fxgREM fxnpt 0 32285 $walkers",
    "restrictions": "This command can only be used if LAMMPS was built with the USER-MISC\npackage.  See the Build package doc\npage for more info.\nThis command must be used with fix grem."
},
{
    "command": "temper/npt",
    "html_filename": "temper_npt.html",
    "short_description": "Run a parallel tempering or replica exchange simulation using multiple replicas (ensembles) of a system in the isothermal-isobaric (NPT) ensemble",
    "description": "Run a parallel tempering or replica exchange simulation using multiple\nreplicas (ensembles) of a system in the isothermal-isobaric (NPT)\nensemble.  The command temper/npt works like temper but\nrequires running replicas in the NPT ensemble instead of the canonical\n(NVT) ensemble and allows for pressure to be set in the ensembles.\nThese multiple ensembles can run in parallel at different temperatures\nor different pressures.  The acceptance criteria for temper/npt is\nspecific to the NPT ensemble and can be found in references\n(Okabe) and (Mori).\nApart from the difference in acceptance criteria and the specification\nof pressure, this command works much like the temper\ncommand. See the documentation on temper for information\non how the parallel tempering is handled in general.",
    "syntax": "temper/npt  N M temp fix-ID seed1 seed2 pressure index",
    "parameters": " * N = total # of timesteps to run\n * M = attempt a tempering swap every this many steps\n * temp = initial temperature for this ensemble\n * fix-ID = ID of the fix that will control temperature and pressure during the run\n * seed1 = random # seed used to decide on adjacent temperature to partner with\n * seed2 = random # seed for Boltzmann factor in Metropolis swap\n * pressure = setpoint pressure for the ensemble\n * index = which temperature (0 to N-1) I am simulating (optional)",
    "examples": "temper/npt 100000 100 $t nptfix 0 58728 1\ntemper/npt 2500000 1000 300 nptfix  0 32285 $p\ntemper/npt 5000000 2000 $t nptfix 0 12523 1 $w",
    "restrictions": "This command can only be used if LAMMPS was built with the USER-MISC\npackage.  See the Build package doc page for more\ninfo.\nThis command should be used with a fix that maintains the\nisothermal-isobaric (NPT) ensemble."
},
{
    "command": "thermo",
    "html_filename": "thermo.html",
    "short_description": "Compute and print thermodynamic info (e",
    "description": "Compute and print thermodynamic info (e.g. temperature, energy,\npressure) on timesteps that are a multiple of N and at the beginning\nand end of a simulation.  A value of 0 will only print thermodynamics\nat the beginning and end.\nThe content and format of what is printed is controlled by the\nthermo_style and\nthermo_modify commands.\nInstead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\nname is the variable name.  In this case, the variable is evaluated at\nthe beginning of a run to determine the next timestep at which\nthermodynamic info will be written out.  On that timestep, the\nvariable will be evaluated again to determine the next timestep, etc.\nThus the variable should return timestep values.  See the stagger()\nand logfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\nthis context.  Other similar math functions could easily be added as\noptions for equal-style variables.\nFor example, the following commands will output thermodynamic info at\ntimesteps 0,10,20,30,100,200,300,1000,2000,etc:\nvariable        s equal logfreq(10,3,10)\nthermo          v_s",
    "syntax": "thermo N",
    "parameters": " * N = output thermodynamics every N timesteps\n * N can be a variable (see below)",
    "examples": "thermo 100",
    "restrictions": "\nnone"
},
{
    "command": "thermo_modify",
    "html_filename": "thermo_modify.html",
    "short_description": "Set options for how thermodynamic information is computed and printed by LAMMPS",
    "description": "Set options for how thermodynamic information is computed and printed\nby LAMMPS.\n\nNote\nThese options apply to the currently defined thermo style.  When\nyou specify a thermo_style command, all\nthermodynamic settings are restored to their default values, including\nthose previously reset by a thermo_modify command.  Thus if your input\nscript specifies a thermo_style command, you should use the\nthermo_modify command after it.\n\nThe lost keyword determines whether LAMMPS checks for lost atoms\neach time it computes thermodynamics and what it does if atoms are\nlost.  An atom can be “lost” if it moves across a non-periodic\nsimulation box boundary or if it moves more than a box\nlength outside the simulation domain (or more than a processor\nsub-domain length) before reneighboring occurs.  The latter case is\ntypically due to bad dynamics, e.g. too large a timestep or huge\nforces and velocities.  If the value is ignore, LAMMPS does not\ncheck for lost atoms.  If the value is error or warn, LAMMPS\nchecks and either issues an error or warning.  The code will exit with\nan error and continue with a warning.  A warning will only be issued\nonce, the first time an atom is lost.  This can be a useful debugging\noption.\nThe lost/bond keyword determines whether LAMMPS throws an error or\nnot if an atom in a bonded interaction (bond, angle, etc) cannot be\nfound when it creates bonded neighbor lists.  By default this is a\nfatal error.  However in some scenarios it may be desirable to only\nissue a warning or ignore it and skip the computation of the missing\nbond, angle, etc.  An example would be when gas molecules in a vapor\nare drifting out of the box through a fixed boundary condition (see\nthe boundary command).  In this case one atom may be\ndeleted before the rest of the molecule is, on a later timestep.\nThe norm keyword determines whether various thermodynamic output\nvalues are normalized by the number of atoms or not, depending on\nwhether it is set to yes or no.  Different unit styles have\ndifferent defaults for this setting (see below).  Even if norm is\nset to yes, a value is only normalized if it is an “extensive”\nquantity, meaning that it scales with the number of atoms in the\nsystem.  For the thermo keywords described by the doc page for the\nthermo_style command, all energy-related keywords\nare extensive, such as pe or ebond or enthalpy.  Other keywords\nsuch as temp or press are “intensive” meaning their value is\nindependent (in a statistical sense) of the number of atoms in the\nsystem and thus are never normalized.  For thermodynamic output values\nextracted from fixes and computes in a thermo_style custom command, the doc page for the individual\nfix or compute lists whether the value is\n“extensive” or “intensive” and thus whether it is normalized.\nThermodynamic output values calculated by a variable formula are\nassumed to be “intensive” and thus are never normalized.  You can\nalways include a divide by the number of atoms in the variable formula\nif this is not the case.\nThe flush keyword invokes a flush operation after thermodynamic info\nis written to the log file.  This insures the output in that file is\ncurrent (no buffering by the OS), even if LAMMPS halts before the\nsimulation completes.\nThe line keyword determines whether thermodynamics will be output as\na series of numeric values on one line or in a multi-line format with\n3 quantities with text strings per line and a dashed-line header\ncontaining the timestep and CPU time.  This modify option overrides\nthe one and multi thermo_style settings.\nThe format keyword can be used to change the default numeric format\nof any of quantities the thermo_style command\noutputs.  All the specified format strings are C-style formats,\ne.g. as used by the C/C++ printf() command.  The line keyword takes\na single argument which is the format string for the entire line of\nthermo output, with N fields, which you must enclose in quotes if it\nis more than one field.  The int and float keywords take a single\nformat argument and are applied to all integer or floating-point\nquantities output.  The setting for M string also takes a single\nformat argument which is used for the Mth value output in each line,\ne.g. the 5th column is output in high precision for “format 5\n%20.15g”.\nThe format keyword can be used multiple times.  The precedence is\nthat for each value in a line of output, the M format (if specified)\nis used, else the int or float setting (if specified) is used,\nelse the line setting (if specified) for that value is used, else\nthe default setting is used.  A setting of none clears all previous\nsettings, reverting all values to their default format.\n\nNote\nThe thermo output values step and atoms are stored\ninternally as 8-byte signed integers, rather than the usual 4-byte\nsigned integers.  When specifying the format int option you can use\na “%d”-style format identifier in the format string and LAMMPS will\nconvert this to the corresponding 8-byte form when it is applied to\nthose keywords.  However, when specifying the line option or format\nM string option for step and natoms, you should specify a format\nstring appropriate for an 8-byte signed integer, e.g. one with “%ld”.\n\nThe temp keyword is used to determine how thermodynamic temperature\nis calculated, which is used by all thermo quantities that require a\ntemperature (“temp”, “press”, “ke”, “etotal”, “enthalpy”, “pxx”, etc).\nThe specified compute ID must have been previously defined by the user\nvia the compute command and it must be a style of\ncompute that calculates a temperature.  As described in the\nthermo_style command, thermo output uses a default\ncompute for temperature with ID = thermo_temp.  This option allows\nthe user to override the default.\nThe press keyword is used to determine how thermodynamic pressure is\ncalculated, which is used by all thermo quantities that require a\npressure (“press”, “enthalpy”, “pxx”, etc).  The specified compute ID\nmust have been previously defined by the user via the\ncompute command and it must be a style of compute that\ncalculates a pressure.  As described in the\nthermo_style command, thermo output uses a default\ncompute for pressure with ID = thermo_press.  This option allows the\nuser to override the default.\n\nNote\nIf both the temp and press keywords are used in a single\nthermo_modify command (or in two separate commands), then the order in\nwhich the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\nan argument when it is specified.  The temp keyword will override\nthis (for the pressure compute being used by thermodynamics), but only\nif the temp keyword comes after the press keyword.  If the temp\nkeyword comes before the press keyword, then the new pressure\ncompute specified by the press keyword will be unaffected by the\ntemp setting.",
    "syntax": "thermo_modify keyword value ...",
    "parameters": " * one or more keyword/value pairs may be listed\n * keyword = lost or lost/bond or norm or flush or line or format or temp or press:l\n *   lost value = error or warn or ignore\n *   lost/bond value = error or warn or ignore\n *   norm value = yes or no\n *   flush value = yes or no\n *   line value = one or multi\n *   format values = line string, int string, float string, M string, or none\n *     string = C-style format string\n *     M = integer from 1 to N, where N = # of quantities being output\n *   temp value = compute ID that calculates a temperature\n *   press value = compute ID that calculates a pressure",
    "examples": "thermo_modify lost ignore flush yes\nthermo_modify temp myTemp format 3 %15.8g\nthermo_modify temp myTemp format line \"%ld %g %g %15.8g\"\nthermo_modify line multi format float %g",
    "restrictions": "none"
},
{
    "command": "thermo_style",
    "html_filename": "thermo_style.html",
    "short_description": "Set the style and content for printing thermodynamic data to the screen and log file",
    "description": "Set the style and content for printing thermodynamic data to the\nscreen and log file.\nStyle one prints a one-line summary of thermodynamic info that is\nthe equivalent of “thermo_style custom step temp epair emol etotal\npress”.  The line contains only numeric values.\nStyle multi prints a multiple-line listing of thermodynamic info\nthat is the equivalent of “thermo_style custom etotal ke temp pe ebond\neangle edihed eimp evdwl ecoul elong press”.  The listing contains\nnumeric values and a string ID for each quantity.\nStyle custom is the most general setting and allows you to specify\nwhich of the keywords listed above you want printed on each\nthermodynamic timestep.  Note that the keywords c_ID, f_ID, v_name are\nreferences to computes, fixes, and\nequal-style variables that have been defined elsewhere\nin the input script or can even be new styles which users have added\nto LAMMPS.  See the Modify doc page for details on the\nlatter.  Thus the custom style provides a flexible means of\noutputting essentially any desired quantity as a simulation proceeds.\nAll styles except custom have vol appended to their list of\noutputs if the simulation box volume changes during the simulation.\nThe values printed by the various keywords are instantaneous values,\ncalculated on the current timestep.  Time-averaged quantities, which\ninclude values from previous timesteps, can be output by using the\nf_ID keyword and accessing a fix that does time-averaging such as the\nfix ave/time command.\nOptions invoked by the thermo_modify command can\nbe used to set the one- or multi-line format of the print-out, the\nnormalization of thermodynamic output (total values versus per-atom\nvalues for extensive quantities (ones which scale with the number of\natoms in the system), and the numeric precision of each printed value.\n\nNote\nWhen you use a “thermo_style” command, all thermodynamic\nsettings are restored to their default values, including those\npreviously set by a thermo_modify command.  Thus\nif your input script specifies a thermo_style command, you should use\nthe thermo_modify command after it.\n\n\nSeveral of the thermodynamic quantities require a temperature to be\ncomputed: “temp”, “press”, “ke”, “etotal”, “enthalpy”, “pxx”, etc.  By\ndefault this is done by using a temperature compute which is created\nwhen LAMMPS starts up, as if this command had been issued:\ncompute thermo_temp all temp\n\n\nSee the compute temp command for details.  Note\nthat the ID of this compute is thermo_temp and the group is all.\nYou can change the attributes of this temperature (e.g. its\ndegrees-of-freedom) via the compute_modify\ncommand.  Alternatively, you can directly assign a new compute (that\ncalculates temperature) which you have defined, to be used for\ncalculating any thermodynamic quantity that requires a temperature.\nThis is done via the thermo_modify command.\nSeveral of the thermodynamic quantities require a pressure to be\ncomputed: “press”, “enthalpy”, “pxx”, etc.  By default this is done by\nusing a pressure compute which is created when LAMMPS starts up, as\nif this command had been issued:\ncompute thermo_press all pressure thermo_temp\n\n\nSee the compute pressure command for details.\nNote that the ID of this compute is thermo_press and the group is\nall.  You can change the attributes of this pressure via the\ncompute_modify command.  Alternatively, you can\ndirectly assign a new compute (that calculates pressure) which you\nhave defined, to be used for calculating any thermodynamic quantity\nthat requires a pressure.  This is done via the\nthermo_modify command.\nSeveral of the thermodynamic quantities require a potential energy to\nbe computed: “pe”, “etotal”, “ebond”, etc.  This is done by using a\npe compute which is created when LAMMPS starts up, as if this\ncommand had been issued:\ncompute thermo_pe all pe\n\n\nSee the compute pe command for details.  Note that\nthe ID of this compute is thermo_pe and the group is all.  You can\nchange the attributes of this potential energy via the\ncompute_modify command.\n\nThe kinetic energy of the system ke is inferred from the temperature\nof the system with \\(\\frac{1}{2} k_B T\\) of energy for each degree\nof freedom.  Thus, using different compute commands for\ncalculating temperature, via the thermo_modify temp command, may yield different kinetic energies, since\ndifferent computes that calculate temperature can subtract out different\nnon-thermal components of velocity and/or include different degrees of\nfreedom (translational, rotational, etc).\nThe potential energy of the system pe will include contributions\nfrom fixes if the fix_modify thermo option is set\nfor a fix that calculates such a contribution.  For example, the fix wall/lj93 fix calculates the energy of atoms\ninteracting with the wall.  See the doc pages for “individual fixes”\nto see which ones contribute.\nA long-range tail correction etail for the van der Waals pairwise\nenergy will be non-zero only if the pair_modify tail option is turned on.  The etail contribution\nis included in evdwl, epair, pe, and etotal, and the\ncorresponding tail correction to the pressure is included in press\nand pxx, pyy, etc.\n\nThe step, elapsed, and elaplong keywords refer to timestep\ncount.  Step is the current timestep, or iteration count when a\nminimization is being performed.  Elapsed is the\nnumber of timesteps elapsed since the beginning of this run.\nElaplong is the number of timesteps elapsed since the beginning of\nan initial run in a series of runs.  See the start and stop\nkeywords for the run for info on how to invoke a series of\nruns that keep track of an initial starting time.  If these keywords\nare not used, then elapsed and elaplong are the same value.\nThe dt keyword is the current timestep size in time\nunits.  The time keyword is the current elapsed\nsimulation time, also in time units, which is simply\n(step*dt) if the timestep size has not changed and the timestep has\nnot been reset.  If the timestep has changed (e.g. via fix dt/reset) or the timestep has been reset (e.g. via\nthe “reset_timestep” command), then the simulation time is effectively\na cumulative value up to the current point.\nThe cpu keyword is elapsed CPU seconds since the beginning of this\nrun.  The tpcpu and spcpu keywords are measures of how fast your\nsimulation is currently running.  The tpcpu keyword is simulation\ntime per CPU second, where simulation time is in time\nunits.  E.g. for metal units, the tpcpu value would be\npicoseconds per CPU second.  The spcpu keyword is the number of\ntimesteps per CPU second.  Both quantities are on-the-fly metrics,\nmeasured relative to the last time they were invoked.  Thus if you are\nprinting out thermodynamic output every 100 timesteps, the two keywords\nwill continually output the time and timestep rate for the last 100\nsteps.  The tpcpu keyword does not attempt to track any changes in\ntimestep size, e.g. due to using the fix dt/reset\ncommand.\nThe cpuremain keyword estimates the CPU time remaining in the\ncurrent run, based on the time elapsed thus far.  It will only be a\ngood estimate if the CPU time/timestep for the rest of the run is\nsimilar to the preceding timesteps.  On the initial timestep the value\nwill be 0.0 since there is no history to estimate from.  For a\nminimization run performed by the “minimize” command, the estimate is\nbased on the maxiter parameter, assuming the minimization will\nproceed for the maximum number of allowed iterations.\nThe part keyword is useful for multi-replica or multi-partition\nsimulations to indicate which partition this output and this file\ncorresponds to, or for use in a variable to append to\na filename for output specific to this partition.  See discussion of\nthe -partition command-line switch for details on\nrunning in multi-partition mode.\nThe timeremain keyword returns the remaining seconds when a\ntimeout has been configured via the timer timeout command.\nIf the timeout timer is inactive, the value of this keyword is 0.0 and\nif the timer is expired, it is negative. This allows for example to exit\nloops cleanly, if the timeout is expired with:\nif \"$(timeremain) < 0.0\" then \"quit 0\"\n\n\nThe fmax and fnorm keywords are useful for monitoring the progress\nof an energy minimization.  The fmax keyword\ncalculates the maximum force in any dimension on any atom in the\nsystem, or the infinity-norm of the force vector for the system.  The\nfnorm keyword calculates the 2-norm or length of the force vector.\nThe nbuild and ndanger keywords are useful for monitoring neighbor\nlist builds during a run.  Note that both these values are also\nprinted with the end-of-run statistics.  The nbuild keyword is the\nnumber of re-builds during the current run.  The ndanger keyword is\nthe number of re-builds that LAMMPS considered potentially\n“dangerous”.  If atom movement triggered neighbor list rebuilding (see\nthe neigh_modify command), then dangerous\nreneighborings are those that were triggered on the first timestep\natom movement was checked for.  If this count is non-zero you may wish\nto reduce the delay factor to insure no force interactions are missed\nby atoms moving beyond the neighbor skin distance before a rebuild\ntakes place.\nThe keywords cella, cellb, cellc, cellalpha, cellbeta,\ncellgamma, correspond to the usual crystallographic quantities that\ndefine the periodic unit cell of a crystal.  See the Howto triclinic doc page for a geometric description\nof triclinic periodic cells, including a precise definition of these\nquantities in terms of the internal LAMMPS cell dimensions lx, ly,\nlz, yz, xz, xy.\n\nFor output values from a compute or fix, the bracketed index I used to\nindex a vector, as in c_ID[I] or f_ID[I], can be specified\nusing a wildcard asterisk with the index to effectively specify\nmultiple values.  This takes the form “*” or “*n” or “n*” or “m*n”.\nIf N = the size of the vector (for mode = scalar) or the number of\ncolumns in the array (for mode = vector), then an asterisk with no\nnumeric values means all indices from 1 to N.  A leading asterisk\nmeans all indices from 1 to n (inclusive).  A trailing asterisk means\nall indices from n to N (inclusive).  A middle asterisk means all\nindices from m to n (inclusive).\nUsing a wildcard is the same as if the individual elements of the\nvector had been listed one by one.  E.g. these 2 thermo_style commands\nare equivalent, since the compute temp command\ncreates a global vector with 6 values.\ncompute myTemp all temp\nthermo_style custom step temp etotal c_myTemp[*]\nthermo_style custom step temp etotal &\n             c_myTemp[1] c_myTemp[2] c_myTemp[3] &\n             c_myTemp[4] c_myTemp[5] c_myTemp[6]\n\n\n\nThe c_ID and c_ID[I] and c_ID[I][J] keywords allow global\nvalues calculated by a compute to be output.  As discussed on the\ncompute doc page, computes can calculate global,\nper-atom, or local values.  Only global values can be referenced by\nthis command.  However, per-atom compute values for an individual atom\ncan be referenced in a variable and the variable\nreferenced by thermo_style custom, as discussed below.  See the\ndiscussion above for how the I in c_ID[I] can be specified with a\nwildcard asterisk to effectively specify multiple values from a global\ncompute vector.\nThe ID in the keyword should be replaced by the actual ID of a compute\nthat has been defined elsewhere in the input script.  See the\ncompute command for details.  If the compute calculates\na global scalar, vector, or array, then the keyword formats with 0, 1,\nor 2 brackets will reference a scalar value from the compute.\nNote that some computes calculate “intensive” global quantities like\ntemperature; others calculate “extensive” global quantities like\nkinetic energy that are summed over all atoms in the compute group.\nIntensive quantities are printed directly without normalization by\nthermo_style custom.  Extensive quantities may be normalized by the\ntotal number of atoms in the simulation (NOT the number of atoms in\nthe compute group) when output, depending on the thermo_modify norm option being used.\nThe f_ID and f_ID[I] and f_ID[I][J] keywords allow global\nvalues calculated by a fix to be output.  As discussed on the\nfix doc page, fixes can calculate global, per-atom, or\nlocal values.  Only global values can be referenced by this command.\nHowever, per-atom fix values can be referenced for an individual atom\nin a variable and the variable referenced by\nthermo_style custom, as discussed below.  See the discussion above for\nhow the I in f_ID[I] can be specified with a wildcard asterisk to\neffectively specify multiple values from a global fix vector.\nThe ID in the keyword should be replaced by the actual ID of a fix\nthat has been defined elsewhere in the input script.  See the\nfix command for details.  If the fix calculates a global\nscalar, vector, or array, then the keyword formats with 0, 1, or 2\nbrackets will reference a scalar value from the fix.\nNote that some fixes calculate “intensive” global quantities like\ntimestep size; others calculate “extensive” global quantities like\nenergy that are summed over all atoms in the fix group.  Intensive\nquantities are printed directly without normalization by thermo_style\ncustom.  Extensive quantities may be normalized by the total number of\natoms in the simulation (NOT the number of atoms in the fix group)\nwhen output, depending on the thermo_modify norm\noption being used.\nThe v_name keyword allow the current value of a variable to be\noutput.  The name in the keyword should be replaced by the variable\nname that has been defined elsewhere in the input script.  Only\nequal-style and vector-style variables can be referenced; the latter\nrequires a bracketed term to specify the Ith element of the vector\ncalculated by the variable.  However, an atom-style variable can be\nreferenced for an individual atom by an equal-style variable and that\nvariable referenced.  See the variable command for\ndetails.  Variables of style equal and vector and atom define a\nformula which can reference per-atom properties or thermodynamic\nkeywords, or they can invoke other computes, fixes, or variables when\nevaluated, so this is a very general means of creating thermodynamic\noutput.\nNote that equal-style and vector-style variables are assumed to\nproduce “intensive” global quantities, which are thus printed as-is,\nwithout normalization by thermo_style custom.  You can include a\ndivision by “natoms” in the variable formula if this is not the case.",
    "syntax": "thermo_style style args",
    "parameters": " * style = one or multi or custom\n * args = list of arguments for a particular style\n * one args = none\n * multi args = none\n * custom args = list of keywords\n *   possible keywords = step, elapsed, elaplong, dt, time,\n *                       cpu, tpcpu, spcpu, cpuremain, part, timeremain,\n *                       atoms, temp, press, pe, ke, etotal, enthalpy,\n *                       evdwl, ecoul, epair, ebond, eangle, edihed, eimp,\n *                       emol, elong, etail,\n *                       vol, density, lx, ly, lz, xlo, xhi, ylo, yhi, zlo, zhi,\n *                       xy, xz, yz, xlat, ylat, zlat,\n *                       bonds, angles, dihedrals, impropers,\n *                       pxx, pyy, pzz, pxy, pxz, pyz,\n *                       fmax, fnorm, nbuild, ndanger,\n *                       cella, cellb, cellc, cellalpha, cellbeta, cellgamma,\n *                       c_ID, c_ID[I], c_ID[I][J],\n *                       f_ID, f_ID[I], f_ID[I][J],\n *                       v_name, v_name[I]\n *     step = timestep\n *     elapsed = timesteps since start of this run\n *     elaplong = timesteps since start of initial run in a series of runs\n *     dt = timestep size\n *     time = simulation time\n *     cpu = elapsed CPU time in seconds since start of this run\n *     tpcpu = time per CPU second\n *     spcpu = timesteps per CPU second\n *     cpuremain = estimated CPU time remaining in run\n *     part = which partition (0 to Npartition-1) this is\n *     timeremain = remaining time in seconds on timer timeout.\n *     atoms = # of atoms\n *     temp = temperature\n *     press = pressure\n *     pe = total potential energy\n *     ke = kinetic energy\n *     etotal = total energy (pe + ke)\n *     enthalpy = enthalpy (etotal + press*vol)\n *     evdwl = van der Waals pairwise energy (includes etail)\n *     ecoul = Coulombic pairwise energy\n *     epair = pairwise energy (evdwl + ecoul + elong)\n *     ebond = bond energy\n *     eangle = angle energy\n *     edihed = dihedral energy\n *     eimp = improper energy\n *     emol = molecular energy (ebond + eangle + edihed + eimp)\n *     elong = long-range kspace energy\n *     etail = van der Waals energy long-range tail correction\n *     vol = volume\n *     density = mass density of system\n *     lx,ly,lz = box lengths in x,y,z\n *     xlo,xhi,ylo,yhi,zlo,zhi = box boundaries\n *     xy,xz,yz = box tilt for triclinic (non-orthogonal) simulation boxes\n *     xlat,ylat,zlat = lattice spacings as calculated by lattice command\n *     bonds,angles,dihedrals,impropers = # of these interactions defined\n *     pxx,pyy,pzz,pxy,pxz,pyz = 6 components of pressure tensor\n *     fmax = max component of force on any atom in any dimension\n *     fnorm = length of force vector for all atoms\n *     nbuild = # of neighbor list builds\n *     ndanger = # of dangerous neighbor list builds\n *     cella,cellb,cellc = periodic cell lattice constants a,b,c\n *     cellalpha, cellbeta, cellgamma = periodic cell angles alpha,beta,gamma\n *     c_ID = global scalar value calculated by a compute with ID\n *     c_ID[I] = Ith component of global vector calculated by a compute with ID, I can include wildcard (see below)\n *     c_ID[I][J] = I,J component of global array calculated by a compute with ID\n *     f_ID = global scalar value calculated by a fix with ID\n *     f_ID[I] = Ith component of global vector calculated by a fix with ID, I can include wildcard (see below)\n *     f_ID[I][J] = I,J component of global array calculated by a fix with ID\n *     v_name = value calculated by an equal-style variable with name\n *     v_name[I] = value calculated by a vector-style variable with name",
    "examples": "thermo_style multi\nthermo_style custom step temp pe etotal press vol\nthermo_style custom step temp etotal c_myTemp v_abc\nthermo_style custom step temp etotal c_myTemp[*] v_abc",
    "restrictions": "This command must come after the simulation box is defined by a\nread_data, read_restart, or\ncreate_box command."
},
{
    "command": "timer",
    "html_filename": "timer.html",
    "short_description": "Select the level of detail at which LAMMPS performs its CPU timings",
    "description": "Select the level of detail at which LAMMPS performs its CPU timings.\nMultiple keywords can be specified with the timer command.  For\nkeywords that are mutually exclusive, the last one specified takes\nprecedence.\nDuring a simulation run LAMMPS collects information about how much\ntime is spent in different sections of the code and thus can provide\ninformation for determining performance and load imbalance problems.\nThis can be done at different levels of detail and accuracy.  For more\ninformation about the timing output, see the Run output doc page.\nThe off setting will turn all time measurements off. The loop\nsetting will only measure the total time for a run and not collect any\ndetailed per section information.  With the normal setting, timing\ninformation for portions of the timestep (pairwise calculations,\nneighbor list construction, output, etc) are collected as well as\ninformation about load imbalances for those sections across\nprocessors.  The full setting adds information about CPU\nutilization and thread utilization, when multi-threading is enabled.\nWith the sync setting, all MPI tasks are synchronized at each timer\ncall which measures load imbalance for each section more accurately,\nthough it can also slow down the simulation by prohibiting overlapping\nindependent computations on different MPI ranks  Using the nosync\nsetting (which is the default) turns this synchronization off.\nWith the timeout keyword a wall time limit can be imposed, that\naffects the run and minimize commands.\nThis can be convenient when calculations have to comply with execution\ntime limits, e.g. when running under a batch system when you want to\nmaximize the utilization of the batch time slot, especially for runs\nwhere the time per timestep varies much and thus it becomes difficult\nto predict how many steps a simulation can perform for a given wall time\nlimit. This also applies for difficult to converge minimizations.\nThe timeout elapse value should be somewhat smaller than the maximum\nwall time requested from the batch system, as there is usually\nsome overhead to launch jobs, and it is advisable to write\nout a restart after terminating a run due to a timeout.\nThe timeout timer starts when the command is issued. When the time\nlimit is reached, the run or energy minimization will exit on the\nnext step or iteration that is a multiple of the Ncheck value\nwhich can be set with the every keyword. Default is checking\nevery 10 steps. After the timer timeout has expired all subsequent\nrun or minimize commands in the input script will be skipped.\nThe remaining time or timer status can be accessed with the\nthermo variable timeremain, which will be\nzero, if the timeout is inactive (default setting), it will be\nnegative, if the timeout time is expired and positive if there\nis time remaining and in this case the value of the variable are\nthe number of seconds remaining.\nWhen the timeout key word is used a second time, the timer is\nrestarted with a new time limit. The timeout elapse value can\nbe specified as off or unlimited to impose a no timeout condition\n(which is the default).  The elapse setting can be specified as\na single number for seconds, two numbers separated by a colon (MM:SS)\nfor minutes and seconds, or as three numbers separated by colons for\nhours, minutes, and seconds (H:MM:SS).\nThe every keyword sets how frequently during a run or energy\nminimization the wall clock will be checked.  This check count applies\nto the outer iterations or time steps during minimizations or r-RESPA runs, respectively.  Checking for timeout too often,\ncan slow a calculation down.  Checking too infrequently can make the\ntimeout measurement less accurate, with the run being stopped later\nthan desired.\n\nNote\nUsing the full and sync options provides the most detailed\nand accurate timing information, but can also have a negative\nperformance impact due to the overhead of the many required system\ncalls. It is thus recommended to use these settings only when testing\ntests to identify performance bottlenecks. For calculations with few\natoms or a very large number of processors, even the normal setting\ncan have a measurable negative performance impact. In those cases you\ncan just use the loop or off setting.",
    "syntax": "timer args",
    "parameters": " * args = one or more of off or loop or normal or full or sync or nosync or timeout or every\n * off = do not collect or print any timing information\n * loop = collect only the total time for the simulation loop\n * normal = collect timer information broken down by sections (default)\n * full = like normal but also include CPU and thread utilization\n * sync = explicitly synchronize MPI tasks between sections\n * nosync = do not synchronize MPI tasks between sections (default)\n * timeout elapse = set wall time limit to elapse\n * every Ncheck = perform timeout check every Ncheck steps",
    "examples": "timer full sync\ntimer timeout 2:00:00 every 100\ntimer loop",
    "restrictions": "\nnone"
},
{
    "command": "timestep",
    "html_filename": "timestep.html",
    "short_description": "Set the timestep size for subsequent molecular dynamics simulations",
    "description": "Set the timestep size for subsequent molecular dynamics simulations.\nSee the units command for the time units associated with\neach choice of units that LAMMPS supports.\nThe default value for the timestep size also depends on the choice of\nunits for the simulation; see the default values below.\nWhen the run style is respa, dt is the timestep for\nthe outer loop (largest) timestep.",
    "syntax": "timestep dt",
    "parameters": " * dt = timestep size (time units)",
    "examples": "timestep 2.0\ntimestep 0.003",
    "restrictions": "\nnone"
},
{
    "command": "uncompute",
    "html_filename": "uncompute.html",
    "short_description": "Delete a compute that was previously defined with a compute command",
    "description": "Delete a compute that was previously defined with a compute\ncommand.  This also wipes out any additional changes made to the compute\nvia the compute_modify command.",
    "syntax": "uncompute compute-ID",
    "parameters": " * compute-ID = ID of a previously defined compute",
    "examples": "uncompute 2\nuncompute lower-boundary",
    "restrictions": "\nnone"
},
{
    "command": "undump",
    "html_filename": "undump.html",
    "short_description": "Turn off a previously defined dump so that it is no longer active",
    "description": "Turn off a previously defined dump so that it is no longer active.\nThis closes the file associated with the dump.",
    "syntax": "undump dump-ID",
    "parameters": " * dump-ID = ID of previously defined dump",
    "examples": "undump mine\nundump 2",
    "restrictions": "\nnone"
},
{
    "command": "unfix",
    "html_filename": "unfix.html",
    "short_description": "Delete a fix that was previously defined with a fix command",
    "description": "Delete a fix that was previously defined with a fix\ncommand.  This also wipes out any additional changes made to the fix\nvia the fix_modify command.",
    "syntax": "unfix fix-ID",
    "parameters": " * fix-ID = ID of a previously defined fix",
    "examples": "unfix 2\nunfix lower-boundary",
    "restrictions": "\nnone"
},
{
    "command": "units",
    "html_filename": "units.html",
    "short_description": "This command sets the style of units used for a simulation",
    "description": "This command sets the style of units used for a simulation.  It\ndetermines the units of all quantities specified in the input script\nand data file, as well as quantities output to the screen, log file,\nand dump files.  Typically, this command is used at the very beginning\nof an input script.\nFor all units except lj, LAMMPS uses physical constants from\nwww.physics.nist.gov.  For the definition of Kcal in real units,\nLAMMPS uses the thermochemical calorie = 4.184 J.\nThe choice you make for units simply sets some internal conversion\nfactors within LAMMPS.  This means that any simulation you perform for\none choice of units can be duplicated with any other unit setting\nLAMMPS supports.  In this context “duplicate” means the particles will\nhave identical trajectories and all output generated by the simulation\nwill be identical.  This will be the case for some number of timesteps\nuntil round-off effects accumulate, since the conversion factors for\ntwo different unit systems are not identical to infinite precision.\nTo perform the same simulation in a different set of units you must\nchange all the unit-based input parameters in your input script and\nother input files (data file, potential files, etc) correctly to the\nnew units.  And you must correctly convert all output from the new\nunits to the old units when comparing to the original results.  That\nis often not simple to do.\n\nFor style lj, all quantities are unitless.  Without loss of\ngenerality, LAMMPS sets the fundamental quantities mass, \\(\\sigma\\),\n\\(\\epsilon\\), and the Boltzmann constant \\(k_B = 1\\).  The\nmasses, distances, energies you specify are multiples of these\nfundamental values.  The formulas relating the reduced or unitless\nquantity (with an asterisk) to the same quantity with units is also\ngiven.  Thus you can use the mass & \\(\\sigma\\) & \\(\\epsilon\\)\nvalues for a specific material and convert the results from a unitless\nLJ simulation into physical quantities.\n\nmass = mass or m\ndistance = \\(\\sigma\\), where \\(x^* = \\frac{x}{\\sigma}\\)\ntime = \\(\\tau\\), where \\(\\tau^* = \\tau \\sqrt{\\frac{\\epsilon}{m \\sigma^2}}\\)\nenergy = \\(\\epsilon\\), where \\(E^* = \\frac{E}{\\epsilon}\\)\nvelocity = \\(\\frac{\\sigma}{\\tau}\\), where \\(v^* = v \\frac{\\tau}{\\sigma}\\)\nforce = \\(\\frac{\\epsilon}{\\sigma}\\), where \\(f^* = f \\frac{\\sigma}{\\epsilon}\\)\ntorque = \\(\\epsilon\\), where \\(t^* = \\frac{t}{\\epsilon}\\)\ntemperature = reduced LJ temperature, where \\(T^* = \\frac{T k_B}{\\epsilon}\\)\npressure = reduced LJ pressure, where \\(p^* = p \\frac{\\sigma^3}{\\epsilon}\\)\ndynamic viscosity = reduced LJ viscosity, where \\(\\eta^* = \\eta \\frac{\\sigma^3}{\\epsilon\\tau}\\)\ncharge = reduced LJ charge, where \\(q^* = q \\frac{1}{\\sqrt{4 \\pi \\varepsilon_0 \\sigma \\epsilon}}\\)\ndipole = reduced LJ dipole, moment where \\(\\mu^* = \\mu \\frac{1}{\\sqrt{4 \\pi \\varepsilon_0 \\sigma^3 \\epsilon}}\\)\nelectric field = force/charge, where \\(E^* = E \\frac{\\sqrt{4 \\pi \\varepsilon_0 \\sigma \\epsilon} \\sigma}{\\epsilon}\\)\ndensity = mass/volume, where \\(\\rho^* = \\rho \\sigma^{dim}\\)\n\nNote that for LJ units, the default mode of thermodynamic output via\nthe thermo_style command is to normalize all\nextensive quantities by the number of atoms.  E.g. potential energy is\nextensive because it is summed over atoms, so it is output as\nenergy/atom.  Temperature is intensive since it is already normalized\nby the number of atoms, so it is output as-is.  This behavior can be\nchanged via the thermo_modify norm command.\nFor style real, these are the units:\n\nmass = grams/mole\ndistance = Angstroms\ntime = femtoseconds\nenergy = Kcal/mole\nvelocity = Angstroms/femtosecond\nforce = Kcal/mole-Angstrom\ntorque = Kcal/mole\ntemperature = Kelvin\npressure = atmospheres\ndynamic viscosity = Poise\ncharge = multiple of electron charge (1.0 is a proton)\ndipole = charge*Angstroms\nelectric field = volts/Angstrom\ndensity = gram/cm^dim\n\nFor style metal, these are the units:\n\nmass = grams/mole\ndistance = Angstroms\ntime = picoseconds\nenergy = eV\nvelocity = Angstroms/picosecond\nforce = eV/Angstrom\ntorque = eV\ntemperature = Kelvin\npressure = bars\ndynamic viscosity = Poise\ncharge = multiple of electron charge (1.0 is a proton)\ndipole = charge*Angstroms\nelectric field = volts/Angstrom\ndensity = gram/cm^dim\n\nFor style si, these are the units:\n\nmass = kilograms\ndistance = meters\ntime = seconds\nenergy = Joules\nvelocity = meters/second\nforce = Newtons\ntorque = Newton-meters\ntemperature = Kelvin\npressure = Pascals\ndynamic viscosity = Pascal*second\ncharge = Coulombs (1.6021765e-19 is a proton)\ndipole = Coulombs*meters\nelectric field = volts/meter\ndensity = kilograms/meter^dim\n\nFor style cgs, these are the units:\n\nmass = grams\ndistance = centimeters\ntime = seconds\nenergy = ergs\nvelocity = centimeters/second\nforce = dynes\ntorque = dyne-centimeters\ntemperature = Kelvin\npressure = dyne/cm^2 or barye = 1.0e-6 bars\ndynamic viscosity = Poise\ncharge = statcoulombs or esu (4.8032044e-10 is a proton)\ndipole = statcoul-cm = 10^18 debye\nelectric field = statvolt/cm or dyne/esu\ndensity = grams/cm^dim\n\nFor style electron, these are the units:\n\nmass = atomic mass units\ndistance = Bohr\ntime = femtoseconds\nenergy = Hartrees\nvelocity = Bohr/atomic time units [1.03275e-15 seconds]\nforce = Hartrees/Bohr\ntemperature = Kelvin\npressure = Pascals\ncharge = multiple of electron charge (1.0 is a proton)\ndipole moment = Debye\nelectric field = volts/cm\n\nFor style micro, these are the units:\n\nmass = picograms\ndistance = micrometers\ntime = microseconds\nenergy = picogram-micrometer^2/microsecond^2\nvelocity = micrometers/microsecond\nforce = picogram-micrometer/microsecond^2\ntorque = picogram-micrometer^2/microsecond^2\ntemperature = Kelvin\npressure = picogram/(micrometer-microsecond^2)\ndynamic viscosity = picogram/(micrometer-microsecond)\ncharge = picocoulombs (1.6021765e-7 is a proton)\ndipole = picocoulomb-micrometer\nelectric field = volt/micrometer\ndensity = picograms/micrometer^dim\n\nFor style nano, these are the units:\n\nmass = attograms\ndistance = nanometers\ntime = nanoseconds\nenergy = attogram-nanometer^2/nanosecond^2\nvelocity = nanometers/nanosecond\nforce = attogram-nanometer/nanosecond^2\ntorque = attogram-nanometer^2/nanosecond^2\ntemperature = Kelvin\npressure = attogram/(nanometer-nanosecond^2)\ndynamic viscosity = attogram/(nanometer-nanosecond)\ncharge = multiple of electron charge (1.0 is a proton)\ndipole = charge-nanometer\nelectric field = volt/nanometer\ndensity = attograms/nanometer^dim\n\nThe units command also sets the timestep size and neighbor skin\ndistance to default values for each style:\n\nFor style lj these are dt = 0.005 tau and skin = 0.3 sigma.\nFor style real these are dt = 1.0 femtoseconds and skin = 2.0 Angstroms.\nFor style metal these are dt = 0.001 picoseconds and skin = 2.0 Angstroms.\nFor style si these are dt = 1.0e-8 seconds and skin = 0.001 meters.\nFor style cgs these are dt = 1.0e-8 seconds and skin = 0.1 centimeters.\nFor style electron these are dt = 0.001 femtoseconds and skin = 2.0 Bohr.\nFor style micro these are dt = 2.0 microseconds and skin = 0.1 micrometers.\nFor style nano these are dt = 0.00045 nanoseconds and skin = 0.1 nanometers.",
    "syntax": "units style",
    "parameters": " * style = lj or real or metal or si or cgs or electron or micro or nano",
    "examples": "units metal\nunits lj",
    "restrictions": "This command cannot be used after the simulation box is defined by a\nread_data or create_box command.\nRelated commands: none"
},
{
    "command": "variable",
    "html_filename": "variable.html",
    "short_description": "This command assigns one or more strings to a variable name for evaluation later in the input script or during a simulation",
    "description": "This command assigns one or more strings to a variable name for\nevaluation later in the input script or during a simulation.\nVariables can thus be useful in several contexts.  A variable can be\ndefined and then referenced elsewhere in an input script to become\npart of a new input command.  For variable styles that store multiple\nstrings, the next command can be used to increment which\nstring is assigned to the variable.  Variables of style equal store\na formula which when evaluated produces a single numeric value which\ncan be output either directly (see the print, fix print, and run every commands) or as part\nof thermodynamic output (see the thermo_style\ncommand), or used as input to an averaging fix (see the fix ave/time command).  Variables of style vector\nstore a formula which produces a vector of such values which can be\nused as input to various averaging fixes, or elements of which can be\npart of thermodynamic output.  Variables of style atom store a\nformula which when evaluated produces one numeric value per atom which\ncan be output to a dump file (see the dump custom command)\nor used as input to an averaging fix (see the fix ave/chunk and fix ave/atom\ncommands).  Variables of style atomfile can be used anywhere in an\ninput script that atom-style variables are used; they get their\nper-atom values from a file rather than from a formula.  Variables of\nstyle python can be hooked to Python functions using code you\nprovide, so that the variable gets its value from the evaluation of\nthe Python code.  Variables of style internal are used by a few\ncommands which set their value directly.\n\nNote\nAs discussed on the Commands parse doc\npage, an input script can use “immediate” variables, specified as\n$(formula) with parenthesis, where the formula has the same syntax as\nequal-style variables described on this page.  This is a convenient\nway to evaluate a formula immediately without using the variable\ncommand to define a named variable and then evaluate that\nvariable. See below for a more detailed discussion of this feature.\n\nIn the discussion that follows, the “name” of the variable is the\narbitrary string that is the 1st argument in the variable command.\nThis name can only contain alphanumeric characters and underscores.\nThe “string” is one or more of the subsequent arguments.  The “string”\ncan be simple text as in the 1st example above, it can contain other\nvariables as in the 2nd example, or it can be a formula as in the 3rd\nexample.  The “value” is the numeric quantity resulting from\nevaluation of the string.  Note that the same string can generate\ndifferent values when it is evaluated at different times during a\nsimulation.\n\nNote\nWhen an input script line is encountered that defines a variable\nof style equal or vector or atom or python that contains a\nformula or Python code, the formula is NOT immediately evaluated.  It\nwill be evaluated every time when the variable is used instead.  If\nyou simply want to evaluate a formula in place you can use as\nso-called. See the section below about “Immediate Evaluation of\nVariables” for more details on the topic.  This is also true of a\nformat style variable since it evaluates another variable when it is\ninvoked.\n\nVariables of style equal and vector and atom can be used as\ninputs to various other commands which evaluate their formulas as\nneeded, e.g. at different timesteps during a run.\nVariables of style internal can be used in place of an equal-style\nvariable, except by commands that set the value stored by the\ninternal-style variable.  Thus any command that states it can use an\nequal-style variable as an argument, can also use an internal-style\nvariable.  This means that when the command evaluates the variable, it\nwill use the value set (internally) by another command.\nVariables of style python can be used in place of an equal-style\nvariable so long as the associated Python function, as defined by the\npython command, returns a numeric value.  Thus any\ncommand that states it can use an equal-style variable as an argument,\ncan also use such a python-style variable.  This means that when the\nLAMMPS command evaluates the variable, the Python function will be\nexecuted.\n\nNote\nWhen a variable command is encountered in the input script and\nthe variable name has already been specified, the command is ignored.\nThis means variables can NOT be re-defined in an input script (with\ntwo exceptions, read further).  This is to allow an input script to be\nprocessed multiple times without resetting the variables; see the\njump or include commands.  It also means\nthat using the command-line switch -var will\noverride a corresponding index variable setting in the input script.\n\nThere are two exceptions to this rule.  First, variables of style\nstring, getenv, internal, equal, vector, atom, and\npython ARE redefined each time the command is encountered.  This\nallows these style of variables to be redefined multiple times in an\ninput script.  In a loop, this means the formula associated with an\nequal or atom style variable can change if it contains a\nsubstitution for another variable, e.g. $x or v_x.\nSecond, as described below, if a variable is iterated on to the end of\nits list of strings via the next command, it is removed\nfrom the list of active variables, and is thus available to be\nre-defined in a subsequent variable command.  The delete style does\nthe same thing.\n\nThe Commands parse doc page explains how\noccurrences of a variable name in an input script line are replaced by\nthe variable’s string.  The variable name can be referenced as $x if\nthe name “x” is a single character, or as ${LoopVar} if the name\n“LoopVar” is one or more characters.\nAs described below, for variable styles index, loop, file,\nuniverse, and uloop, which string is assigned to a variable can be\nincremented via the next command.  When there are no more\nstrings to assign, the variable is exhausted and a flag is set that\ncauses the next jump command encountered in the input\nscript to be skipped.  This enables the construction of simple loops\nin the input script that are iterated over and then exited from.\nAs explained above, an exhausted variable can be re-used in an input\nscript.  The delete style also removes the variable, the same as if\nit were exhausted, allowing it to be redefined later in the input\nscript or when the input script is looped over.  This can be useful\nwhen breaking out of a loop via the if and jump\ncommands before the variable would become exhausted.  For example,\nlabel       loop\nvariable    a loop 5\nprint       \"A = $a\"\nif          \"$a > 2\" then \"jump in.script break\"\nnext        a\njump        in.script loop\nlabel       break\nvariable    a delete\n\n\n\nThis section describes how all the various variable styles are defined\nand what they store.  Except for the equal and vector and atom\nstyles, which are explained in the next section.\nMany of the styles store one or more strings.  Note that a single\nstring can contain spaces (multiple words), if it is enclosed in\nquotes in the variable command.  When the variable is substituted for\nin another input script command, its returned string will then be\ninterpreted as multiple arguments in the expanded command.\nFor the index style, one or more strings are specified.  Initially,\nthe 1st string is assigned to the variable.  Each time a\nnext command is used with the variable name, the next\nstring is assigned.  All processors assign the same string to the\nvariable.\nIndex style variables with a single string value can also be set by\nusing the command-line switch -var.\nThe loop style is identical to the index style except that the\nstrings are the integers from 1 to N inclusive, if only one argument N\nis specified.  This allows generation of a long list of runs\n(e.g. 1000) without having to list N strings in the input script.\nInitially, the string “1” is assigned to the variable.  Each time a\nnext command is used with the variable name, the next\nstring (“2”, “3”, etc) is assigned.  All processors assign the same\nstring to the variable.  The loop style can also be specified with\ntwo arguments N1 and N2.  In this case the loop runs from N1 to N2\ninclusive, and the string N1 is initially assigned to the variable.\nN1 <= N2 and N2 >= 0 is required.\nFor the world style, one or more strings are specified.  There must\nbe one string for each processor partition or “world”.  LAMMPS can be\nrun with multiple partitions via the -partition command-line switch.  This variable command assigns one string to\neach world.  All processors in the world are assigned the same string.\nThe next command cannot be used with equal style variables, since\nthere is only one value per world.  This style of variable is useful\nwhen you wish to run different simulations on different partitions, or\nwhen performing a parallel tempering simulation (see the\ntemper command), to assign different temperatures to\ndifferent partitions.\nFor the universe style, one or more strings are specified.  There\nmust be at least as many strings as there are processor partitions or\n“worlds”.  LAMMPS can be run with multiple partitions via the\n-partition command-line switch.  This variable\ncommand initially assigns one string to each world.  When a\nnext command is encountered using this variable, the first\nprocessor partition to encounter it, is assigned the next available\nstring.  This continues until all the variable strings are consumed.\nThus, this command can be used to run 50 simulations on 8 processor\npartitions.  The simulations will be run one after the other on\nwhatever partition becomes available, until they are all finished.\nUniverse style variables are incremented using the files\n“tmp.lammps.variable” and “tmp.lammps.variable.lock” which you will\nsee in your directory during such a LAMMPS run.\nThe uloop style is identical to the universe style except that the\nstrings are the integers from 1 to N.  This allows generation of long\nlist of runs (e.g. 1000) without having to list N strings in the input\nscript.\nFor the string style, a single string is assigned to the variable.\nTwo differences between this style and using the index style exist:\na variable with string style can be redefined, e.g. by another command later\nin the input script, or if the script is read again in a loop. The other\ndifference is that string performs variable substitution even if the\nstring parameter is quoted.\nFor the format style, an equal-style variable is specified along\nwith a C-style format string, e.g. “%f” or “%.10g”, which must be\nappropriate for formatting a double-precision floating-point value.\nThe default format is “%.15g”.  This variable style allows an\nequal-style variable to be formatted precisely when it is evaluated.\nIf you simply wish to print a variable value with desired precision to\nthe screen or logfile via the print or fix print commands, you can also do this by specifying an\n“immediate” variable with a trailing colon and format string, as part\nof the string argument of those commands.  This is explained on the\nCommands parse doc page.\nFor the getenv style, a single string is assigned to the variable\nwhich should be the name of an environment variable.  When the\nvariable is evaluated, it returns the value of the environment\nvariable, or an empty string if it not defined.  This style of\nvariable can be used to adapt the behavior of LAMMPS input scripts via\nenvironment variable settings, or to retrieve information that has\nbeen previously stored with the shell putenv command.\nNote that because environment variable settings are stored by the\noperating systems, they persist beyond a clear command.\nFor the file style, a filename is provided which contains a list of\nstrings to assign to the variable, one per line.  The strings can be\nnumeric values if desired.  See the discussion of the next() function\nbelow for equal-style variables, which will convert the string of a\nfile-style variable into a numeric value in a formula.\nWhen a file-style variable is defined, the file is opened and the\nstring on the first line is read and stored with the variable.  This\nmeans the variable can then be evaluated as many times as desired and\nwill return that string.  There are two ways to cause the next string\nfrom the file to be read: use the next command or the\nnext() function in an equal- or atom-style variable, as discussed\nbelow.\nThe rules for formatting the file are as follows.  A comment character\n“#” can be used anywhere on a line; text starting with the comment\ncharacter is stripped.  Blank lines are skipped.  The first “word” of\na non-blank line, delimited by white-space, is the “string” assigned\nto the variable.\nFor the atomfile style, a filename is provided which contains one or\nmore sets of values, to assign on a per-atom basis to the variable.\nThe format of the file is described below.\nWhen an atomfile-style variable is defined, the file is opened and the\nfirst set of per-atom values are read and stored with the variable.\nThis means the variable can then be evaluated as many times as desired\nand will return those values.  There are two ways to cause the next\nset of per-atom values from the file to be read: use the\nnext command or the next() function in an atom-style\nvariable, as discussed below.\nThe rules for formatting the file are as follows.  Each time a set of\nper-atom values is read, a non-blank line is searched for in the file.\nA comment character “#” can be used anywhere on a line; text starting\nwith the comment character is stripped.  Blank lines are skipped.  The\nfirst “word” of a non-blank line, delimited by white-space, is read as\nthe count N of per-atom lines to immediately follow.  N can be the\ntotal number of atoms in the system, or only a subset.  The next N\nlines have the following format\nID value\n\n\nwhere ID is an atom ID and value is the per-atom numeric value that\nwill be assigned to that atom.  IDs can be listed in any order.\n\nNote\nEvery time a set of per-atom lines is read, the value for all\natoms is first set to 0.0.  Thus values for atoms whose ID does not\nappear in the set, will remain 0.0.\n\nFor the python style a Python function name is provided.  This needs\nto match a function name specified in a python command\nwhich returns a value to this variable as defined by its return\nkeyword.  For example these two commands would be self-consistent:\nvariable foo python myMultiply\npython myMultiply return v_foo format f file funcs.py\n\n\nThe two commands can appear in either order so long as both are\nspecified before the Python function is invoked for the first time.\nEach time the variable is evaluated, the associated Python function is\ninvoked, and the value it returns is also returned by the variable.\nSince the Python function can use other LAMMPS variables as input, or\nquery interal LAMMPS quantities to perform its computation, this means\nthe variable can return a different value each time it is evaluated.\nThe type of value stored in the variable is determined by the format\nkeyword of the python command.  It can be an integer\n(i), floating point (f), or string (s) value.  As mentioned above, if\nit is a numeric value (integer or floating point), then the\npython-style variable can be used in place of an equal-style variable\nanywhere in an input script, e.g. as an argument to another command\nthat allows for equal-style variables.\nFor the internal style a numeric value is provided.  This value will\nbe assigned to the variable until a LAMMPS command sets it to a new\nvalue.  There are currently only two LAMMPS commands that require\ninternal variables as inputs, because they reset them:\ncreate_atoms and fix controller.  As mentioned above, an\ninternal-style variable can be used in place of an equal-style\nvariable anywhere else in an input script, e.g. as an argument to\nanother command that allows for equal-style variables.\n\nFor the equal and vector and atom styles, a single string is\nspecified which represents a formula that will be evaluated afresh\neach time the variable is used.  If you want spaces in the string,\nenclose it in double quotes so the parser will treat it as a single\nargument.  For equal-style variables the formula computes a scalar\nquantity, which becomes the value of the variable whenever it is\nevaluated.  For vector-style variables the formula must compute a\nvector of quantities, which becomes the value of the variable whenever\nit is evaluated.  The calculated vector can be on length one, but it\ncannot be a simple scalar value like that produced by an equal-style\ncompute.  I.e. the formula for a vector-style variable must have at\nleast one quantity in it that refers to a global vector produced by a\ncompute, fix, or other vector-style variable.  For atom-style\nvariables the formula computes one quantity for each atom whenever it\nis evaluated.\nNote that equal, vector, and atom variables can produce\ndifferent values at different stages of the input script or at\ndifferent times during a run.  For example, if an equal variable is\nused in a fix print command, different values could\nbe printed each timestep it was invoked.  If you want a variable to be\nevaluated immediately, so that the result is stored by the variable\ninstead of the string, see the section below on “Immediate Evaluation\nof Variables”.\nThe next command cannot be used with equal or vector or atom\nstyle variables, since there is only one string.\nThe formula for an equal, vector, or atom variable can contain a\nvariety of quantities.  The syntax for each kind of quantity is\nsimple, but multiple quantities can be nested and combined in various\nways to build up formulas of arbitrary complexity.  For example, this\nis a valid (though strange) variable formula:\nvariable x equal \"pe + c_MyTemp / vol^(1/3)\"\nSpecifically, a formula can contain numbers, constants, thermo\nkeywords, math operators, math functions, group functions, region\nfunctions, atom values, atom vectors, compute references, fix\nreferences, and references to other variables.\n\n\n\n\n\n\nNumber\n0.2, 100, 1.0e20, -15.4, etc\n\nConstant\nPI, version, on, off, true, false, yes, no\n\nThermo keywords\nvol, pe, ebond, etc\n\nMath operators\n(), -x, x+y, x-y, x*y, x/y, x^y, x%y,      x == y, x != y, x < y, x <= y, x > y, x >= y, x && y, x || y, x |^ y, !x\n\nMath functions\nsqrt(x), exp(x), ln(x), log(x), abs(x),      sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),      random(x,y,z), normal(x,y,z), ceil(x), floor(x), round(x),      ramp(x,y), stagger(x,y), logfreq(x,y,z), logfreq2(x,y,z),      logfreq3(x,y,z), stride(x,y,z), stride2(x,y,z,a,b,c),      vdisplace(x,y), swiggle(x,y,z), cwiggle(x,y,z)\n\nGroup functions\ncount(ID), mass(ID), charge(ID), xcm(ID,dim),      vcm(ID,dim), fcm(ID,dim), bound(ID,dir),      gyration(ID), ke(ID), angmom(ID,dim), torque(ID,dim),      inertia(ID,dimdim), omega(ID,dim)\n\nRegion functions\ncount(ID,IDR), mass(ID,IDR), charge(ID,IDR),      xcm(ID,dim,IDR), vcm(ID,dim,IDR), fcm(ID,dim,IDR),      bound(ID,dir,IDR), gyration(ID,IDR), ke(ID,IDR),      angmom(ID,dim,IDR), torque(ID,dim,IDR),      inertia(ID,dimdim,IDR), omega(ID,dim,IDR)\n\nSpecial functions\nsum(x), min(x), max(x), ave(x), trap(x),      slope(x), gmask(x), rmask(x), grmask(x,y), next(x)\n\nAtom values\nid[i], mass[i], type[i], mol[i], x[i], y[i], z[i],              vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]\n\nAtom vectors\nid, mass, type, mol, x, y, z, vx, vy, vz, fx, fy, fz, q\n\nCompute references\nc_ID, c_ID[i], c_ID[i][j], C_ID, C_ID[i]\n\nFix references\nf_ID, f_ID[i], f_ID[i][j], F_ID, F_ID[i]\n\nOther variables\nv_name, v_name[i]\n\n\n\nMost of the formula elements produce a scalar value.  Some produce a\nglobal or per-atom vector of values.  Global vectors can be produced\nby computes or fixes or by other vector-style variables.  Per-atom\nvectors are produced by atom vectors, compute references that\nrepresent a per-atom vector, fix references that represent a per-atom\nvector, and variables that are atom-style variables.  Math functions\nthat operate on scalar values produce a scalar value; math function\nthat operate on global or per-atom vectors do so element-by-element\nand produce a global or per-atom vector.\nA formula for equal-style variables cannot use any formula element\nthat produces a global or per-atom vector.  A formula for a\nvector-style variable can use formula elements that produce either a\nscalar value or a global vector value, but cannot use a formula\nelement that produces a per-atom vector.  A formula for an atom-style\nvariable can use formula elements that produce either a scalar value\nor a per-atom vector, but not one that produces a global vector.\nAtom-style variables are evaluated by other commands that define a\ngroup on which they operate, e.g. a dump or\ncompute or fix command.  When they invoke\nthe atom-style variable, only atoms in the group are included in the\nformula evaluation.  The variable evaluates to 0.0 for atoms not in\nthe group.\n\n\nNumbers, constants, and thermo keywords\nNumbers can contain digits, scientific notation\n(3.0e20,3.0e-20,3.0E20,3.0E-20), and leading minus signs.\nConstants are set at compile time and cannot be changed. PI will\nreturn the number 3.14159265358979323846; on, true or yes will\nreturn 1.0; off, false or no will return 0.0; version will\nreturn a numeric version code of the current LAMMPS version (e.g.\nversion 2 Sep 2015 will return the number 20150902). The corresponding\nvalue for newer versions of LAMMPS will be larger, for older versions\nof LAMMPS will be smaller. This can be used to have input scripts\nadapt automatically to LAMMPS versions, when non-backwards compatible\nsyntax changes are introduced. Here is an illustrative example (which\nwill not work, since the version has been introduced more recently):\nif $(version<20140513) then \"communicate vel yes\" else \"comm_modify vel yes\"\n\n\nThe thermo keywords allowed in a formula are those defined by the\nthermo_style custom command.  Thermo keywords that\nrequire a compute to calculate their values such as\n“temp” or “press”, use computes stored and invoked by the\nthermo_style command.  This means that you can\nonly use those keywords in a variable if the style you are using with\nthe thermo_style command (and the thermo keywords associated with that\nstyle) also define and use the needed compute.  Note that some thermo\nkeywords use a compute indirectly to calculate their value (e.g. the\nenthalpy keyword uses temp, pe, and pressure).  If a variable is\nevaluated directly in an input script (not during a run), then the\nvalues accessed by the thermo keyword must be current.  See the\ndiscussion below about “Variable Accuracy”.\n\n\n\nMath Operators\nMath operators are written in the usual way, where the “x” and “y” in\nthe examples can themselves be arbitrarily complex formulas, as in the\nexamples above.  In this syntax, “x” and “y” can be scalar values or\nper-atom vectors.  For example, “ke/natoms” is the division of two\nscalars, where “vy+vz” is the element-by-element sum of two per-atom\nvectors of y and z velocities.\nOperators are evaluated left to right and have the usual C-style\nprecedence: unary minus and unary logical NOT operator “!” have the\nhighest precedence, exponentiation “^” is next; multiplication and\ndivision and the modulo operator “%” are next; addition and\nsubtraction are next; the 4 relational operators “<”, “<=”, “>”, and\n“>=” are next; the two remaining relational operators “==” and “!=”\nare next; then the logical AND operator “&&”; and finally the logical\nOR operator “||” and logical XOR (exclusive or) operator “|^” have the\nlowest precedence.  Parenthesis can be used to group one or more\nportions of a formula and/or enforce a different order of evaluation\nthan what would occur with the default precedence.\n\nNote\nBecause a unary minus is higher precedence than exponentiation,\nthe formula “-2^2” will evaluate to 4, not -4.  This convention is\ncompatible with some programming languages, but not others.  As\nmentioned, this behavior can be easily overridden with parenthesis;\nthe formula “-(2^2)” will evaluate to -4.\n\nThe 6 relational operators return either a 1.0 or 0.0 depending on\nwhether the relationship between x and y is TRUE or FALSE.  For\nexample the expression x<10.0 in an atom-style variable formula will\nreturn 1.0 for all atoms whose x-coordinate is less than 10.0, and 0.0\nfor the others.  The logical AND operator will return 1.0 if both its\narguments are non-zero, else it returns 0.0.  The logical OR operator\nwill return 1.0 if either of its arguments is non-zero, else it\nreturns 0.0.  The logical XOR operator will return 1.0 if one of its\narguments is zero and the other non-zero, else it returns 0.0.  The\nlogical NOT operator returns 1.0 if its argument is 0.0, else it\nreturns 0.0.\nThese relational and logical operators can be used as a masking or\nselection operation in a formula.  For example, the number of atoms\nwhose properties satisfy one or more criteria could be calculated by\ntaking the returned per-atom vector of ones and zeroes and passing it\nto the compute reduce command.\n\n\n\nMath Functions\nMath functions are specified as keywords followed by one or more\nparenthesized arguments “x”, “y”, “z”, each of which can themselves be\narbitrarily complex formulas.  In this syntax, the arguments can\nrepresent scalar values or global vectors or per-atom vectors.  In the\nlatter case, the math operation is performed on each element of the\nvector.  For example, “sqrt(natoms)” is the sqrt() of a scalar, where\n“sqrt(y*z)” yields a per-atom vector with each element being the\nsqrt() of the product of one atom’s y and z coordinates.\nMost of the math functions perform obvious operations.  The ln() is\nthe natural log; log() is the base 10 log.\nThe random(x,y,z) function takes 3 arguments: x = lo, y = hi, and z =\nseed.  It generates a uniform random number between lo and hi.  The\nnormal(x,y,z) function also takes 3 arguments: x = mu, y = sigma, and\nz = seed.  It generates a Gaussian variate centered on mu with\nvariance sigma^2.  In both cases the seed is used the first time the\ninternal random number generator is invoked, to initialize it.  For\nequal-style and vector-style variables, every processor uses the same\nseed so that they each generate the same sequence of random numbers.\nFor atom-style variables, a unique seed is created for each processor,\nbased on the specified seed.  This effectively generates a different\nrandom number for each atom being looped over in the atom-style\nvariable.\n\nNote\nInternally, there is just one random number generator for all\nequal-style and vector-style variables and another one for all\natom-style variables.  If you define multiple variables (of each\nstyle) which use the random() or normal() math functions, then the\ninternal random number generators will only be initialized once, which\nmeans only one of the specified seeds will determine the sequence of\ngenerated random numbers.\n\nThe ceil(), floor(), and round() functions are those in the C math\nlibrary.  Ceil() is the smallest integer not less than its argument.\nFloor() if the largest integer not greater than its argument.  Round()\nis the nearest integer to its argument.\nThe ramp(x,y) function uses the current timestep to generate a value\nlinearly interpolated between the specified x,y values over the course\nof a run, according to this formula:\nvalue = x + (y-x) * (timestep-startstep) / (stopstep-startstep)\nThe run begins on startstep and ends on stopstep.  Startstep and\nstopstep can span multiple runs, using the start and stop keywords\nof the run command.  See the run command for\ndetails of how to do this.\nThe stagger(x,y) function uses the current timestep to generate a new\ntimestep.  X,y > 0 and x > y are required.  The generated timesteps\nincrease in a staggered fashion, as the sequence\nx,x+y,2x,2x+y,3x,3x+y,etc.  For any current timestep, the next\ntimestep in the sequence is returned.  Thus if stagger(1000,100) is\nused in a variable by the dump_modify every\ncommand, it will generate the sequence of output timesteps:\n100,1000,1100,2000,2100,3000,etc\n\n\nThe logfreq(x,y,z) function uses the current timestep to generate a\nnew timestep.  X,y,z > 0 and y < z are required.  The generated\ntimesteps are on a base-z logarithmic scale, starting with x, and the\ny value is how many of the z-1 possible timesteps within one\nlogarithmic interval are generated.  I.e. the timesteps follow the\nsequence x,2x,3x,…y*x,x*z,2x*z,3x*z,…y*x*z,x*z^2,2x*z^2,etc.  For\nany current timestep, the next timestep in the sequence is returned.\nThus if logfreq(100,4,10) is used in a variable by the dump_modify every command, it will generate this sequence of\noutput timesteps:\n100,200,300,400,1000,2000,3000,4000,10000,20000,etc\n\n\nThe logfreq2(x,y,z) function is similar to logfreq, except a single\nlogarithmic interval is divided into y equally-spaced timesteps and\nall of them are output.  Y < z is not required.  Thus, if\nlogfreq2(100,18,10) is used in a variable by the dump_modify every command, then the interval between 100 and\n1000 is divided as 900/18 = 50 steps, and it will generate the\nsequence of output timesteps:\n100,150,200,...950,1000,1500,2000,...9500,10000,15000,etc\n\n\nThe logfreq3(x,y,z) function generates y points between x and z (inclusive),\nthat are separated by a multiplicative ratio: (z/x)^(1/(y-1)). Constraints\nare: x,z > 0, y > 1, z-x >= y-1. For eg., if logfreq3(10,25,1000) is used in\na variable by the fix print command, then the interval\nbetween 10 and 1000 is divided into 24 parts with a multiplicative\nseparation of ~1.21, and it will generate the following sequence of output\ntimesteps:\n10, 13, 15, 18, 22, 27, 32,...384, 465, 563, 682, 826, 1000\n\n\nThe stride(x,y,z) function uses the current timestep to generate a new\ntimestep.  X,y >= 0 and z > 0 and x <= y are required.  The generated\ntimesteps increase in increments of z, from x to y, i.e. it generates\nthe sequence x,x+z,x+2z,…,y.  If y-x is not a multiple of z, then\nsimilar to the way a for loop operates, the last value will be one\nthat does not exceed y.  For any current timestep, the next timestep\nin the sequence is returned.  Thus if stride(1000,2000,100) is used\nin a variable by the dump_modify every command, it\nwill generate the sequence of output timesteps:\n1000,1100,1200, ... ,1900,2000\n\n\nThe stride2(x,y,z,a,b,c) function is similar to the stride() function\nexcept it generates two sets of strided timesteps, one at a coarser\nlevel and one at a finer level.  Thus it is useful for debugging,\ne.g. to produce output every timestep at the point in simulation when\na problem occurs.  X,y >= 0 and z > 0 and x <= y are required, as are\na,b >= 0 and c > 0 and a < b.  Also, a >= x and b <= y are required so\nthat the second stride is inside the first.  The generated timesteps\nincrease in increments of z, starting at x, until a is reached.  At\nthat point the timestep increases in increments of c, from a to b,\nthen after b, increments by z are resumed until y is reached.  For any\ncurrent timestep, the next timestep in the sequence is returned.  Thus\nif stride2(1000,2000,100,1350,1360,1) is used in a variable by the\ndump_modify every command, it will generate the\nsequence of output timesteps:\n1000,1100,1200,1300,1350,1351,1352, ... 1359,1360,1400,1500, ... ,2000\n\n\nThe vdisplace(x,y) function takes 2 arguments: x = value0 and y =\nvelocity, and uses the elapsed time to change the value by a linear\ndisplacement due to the applied velocity over the course of a run,\naccording to this formula:\nvalue = value0 + velocity*(timestep-startstep)*dt\nwhere dt = the timestep size.\nThe run begins on startstep.  Startstep can span multiple runs, using\nthe start keyword of the run command.  See the\nrun command for details of how to do this.  Note that the\nthermo_style keyword elaplong =\ntimestep-startstep.\nThe swiggle(x,y,z) and cwiggle(x,y,z) functions each take 3 arguments:\nx = value0, y = amplitude, z = period.  They use the elapsed time to\noscillate the value by a sin() or cos() function over the course of a\nrun, according to one of these formulas, where omega = 2 PI / period:\nvalue = value0 + Amplitude * sin(omega*(timestep-startstep)*dt)\nvalue = value0 + Amplitude * (1 - cos(omega*(timestep-startstep)*dt))\nwhere dt = the timestep size.\nThe run begins on startstep.  Startstep can span multiple runs, using\nthe start keyword of the run command.  See the\nrun command for details of how to do this.  Note that the\nthermo_style keyword elaplong =\ntimestep-startstep.\n\n\n\nGroup and Region Functions\nGroup functions are specified as keywords followed by one or two\nparenthesized arguments.  The first argument ID is the group-ID.\nThe dim argument, if it exists, is x or y or z.  The dir\nargument, if it exists, is xmin, xmax, ymin, ymax, zmin, or\nzmax.  The dimdim argument, if it exists, is xx or yy or zz\nor xy or yz or xz.\nThe group function count() is the number of atoms in the group.  The\ngroup functions mass() and charge() are the total mass and charge of\nthe group.  Xcm() and vcm() return components of the position and\nvelocity of the center of mass of the group.  Fcm() returns a\ncomponent of the total force on the group of atoms.  Bound() returns\nthe min/max of a particular coordinate for all atoms in the group.\nGyration() computes the radius-of-gyration of the group of atoms.  See\nthe compute gyration command for a definition\nof the formula.  Angmom() returns components of the angular momentum\nof the group of atoms around its center of mass.  Torque() returns\ncomponents of the torque on the group of atoms around its center of\nmass, based on current forces on the atoms.  Inertia() returns one of\n6 components of the symmetric inertia tensor of the group of atoms\naround its center of mass, ordered as Ixx,Iyy,Izz,Ixy,Iyz,Ixz.\nOmega() returns components of the angular velocity of the group of\natoms around its center of mass.\nRegion functions are specified exactly the same way as group functions\nexcept they take an extra final argument IDR which is the region ID.\nThe function is computed for all atoms that are in both the group and\nthe region.  If the group is “all”, then the only criteria for atom\ninclusion is that it be in the region.\n\n\n\nSpecial Functions\nSpecial functions take specific kinds of arguments, meaning their\narguments cannot be formulas themselves.\nThe sum(x), min(x), max(x), ave(x), trap(x), and slope(x) functions\neach take 1 argument which is of the form “c_ID” or “c_ID[N]” or\n“f_ID” or “f_ID[N]” or “v_name”.  The first two are computes and the\nsecond two are fixes; the ID in the reference should be replaced by\nthe ID of a compute or fix defined elsewhere in the input script.  The\ncompute or fix must produce either a global vector or array.  If it\nproduces a global vector, then the notation without “[N]” should be\nused.  If it produces a global array, then the notation with “[N]”\nshould be used, when N is an integer, to specify which column of the\nglobal array is being referenced.  The last form of argument “v_name”\nis for a vector-style variable where “name” is replaced by the name of\nthe variable.\nThese functions operate on a global vector of inputs and reduce it to\na single scalar value.  This is analogous to the operation of the\ncompute reduce command, which performs similar\noperations on per-atom and local vectors.\nThe sum() function calculates the sum of all the vector elements.  The\nmin() and max() functions find the minimum and maximum element\nrespectively.  The ave() function is the same as sum() except that it\ndivides the result by the length of the vector.\nThe trap() function is the same as sum() except the first and last\nelements are multiplied by a weighting factor of 1/2 when performing\nthe sum.  This effectively implements an integration via the\ntrapezoidal rule on the global vector of data.  I.e. consider a set of\npoints, equally spaced by 1 in their x coordinate: (1,V1), (2,V2),\n…, (N,VN), where the Vi are the values in the global vector of\nlength N.  The integral from 1 to N of these points is trap().  When\nappropriately normalized by the timestep size, this function is useful\nfor calculating integrals of time-series data, like that generated by\nthe fix ave/correlate command.\nThe slope() function uses linear regression to fit a line to the set\nof points, equally spaced by 1 in their x coordinate: (1,V1), (2,V2),\n…, (N,VN), where the Vi are the values in the global vector of\nlength N.  The returned value is the slope of the line.  If the line\nhas a single point or is vertical, it returns 1.0e20.\nThe gmask(x) function takes 1 argument which is a group ID.  It\ncan only be used in atom-style variables.  It returns a 1 for\natoms that are in the group, and a 0 for atoms that are not.\nThe rmask(x) function takes 1 argument which is a region ID.  It can\nonly be used in atom-style variables.  It returns a 1 for atoms that\nare in the geometric region, and a 0 for atoms that are not.\nThe grmask(x,y) function takes 2 arguments.  The first is a group ID,\nand the second is a region ID.  It can only be used in atom-style\nvariables.  It returns a 1 for atoms that are in both the group and\nregion, and a 0 for atoms that are not in both.\nThe next(x) function takes 1 argument which is a variable ID (not\n“v_foo”, just “foo”).  It must be for a file-style or atomfile-style\nvariable.  Each time the next() function is invoked (i.e. each time\nthe equal-style or atom-style variable is evaluated), the following\nsteps occur.\nFor file-style variables, the current string value stored by the\nfile-style variable is converted to a numeric value and returned by\nthe function.  And the next string value in the file is read and\nstored.  Note that if the line previously read from the file was not a\nnumeric string, then it will typically evaluate to 0.0, which is\nlikely not what you want.\nFor atomfile-style variables, the current per-atom values stored by\nthe atomfile-style variable are returned by the function.  And the\nnext set of per-atom values in the file is read and stored.\nSince file-style and atomfile-style variables read and store the first\nline of the file or first set of per-atoms values when they are\ndefined in the input script, these are the value(s) that will be\nreturned the first time the next() function is invoked.  If next() is\ninvoked more times than there are lines or sets of lines in the file,\nthe variable is deleted, similar to how the next command\noperates.\n\n\n\nFeature Functions\nFeature functions allow to probe the running LAMMPS executable for\nwhether specific features are either active, defined, or available.\nThe functions take two arguments, a category and a corresponding\nargument. The arguments are strings thus cannot be formulas\nthemselves (only $-style immediate variable expansion is possible).\nReturn value is either 1.0 or 0.0 depending on whether the function\nevaluates to true or false, respectively.\nThe is_active() function allows to query for active settings which\nare grouped by categories. Currently supported categories and\narguments are:\n\npackage (argument = gpu or intel or kokkos or omp)\nnewton (argument = pair or bond or any)\npair (argument = single or respa or manybody or tail or shift)\ncomm_style (argument = brick or tiled)\nmin_style (argument = any of the compiled in minimizer styles)\nrun_style (argument = any of the compiled in run styles)\natom_style (argument = any of the compiled in atom styles)\npair_style (argument = any of the compiled in pair styles)\nbond_style (argument = any of the compiled in bond styles)\nangle_style (argument = any of the compiled in angle styles)\ndihedral_style (argument = any of the compiled in dihedral styles)\nimproper_style (argument = any of the compiled in improper styles)\nkspace_style (argument = any of the compiled in kspace styles)\n\nMost of the settings are self-explanatory, the single argument in the\npair category allows to check whether a pair style supports a\nPair::single() function as needed by compute group/group and others\nfeatures or LAMMPS, respa allows to check whether the inner/middle/outer\nmode of r-RESPA is supported. In the various style categories,\nthe checking is also done using suffix flags, if available and enabled.\nExample 1: disable use of suffix for pppm when using GPU package (i.e. run it on the CPU concurrently to running the pair style on the GPU), but do use the suffix otherwise (e.g. with USER-OMP).\npair_style lj/cut/coul/long 14.0\nif $(is_active(package,gpu)) then \"suffix off\"\nkspace_style pppm\n\n\nExample 2: use r-RESPA with inner/outer cutoff, if supported by pair style, otherwise fall back to using pair and reducing the outer time step\ntimestep $(2.0*(1.0+2.0*is_active(pair,respa))\nif $(is_active(pair,respa)) then \"run_style respa 4 3 2 2  improper 1 inner 2 5.5 7.0 outer 3 kspace 4\" else \"run_style respa 3 3 2  improper 1 pair 2 kspace 3\"\nThe is_defined() function allows to query categories like compute,\ndump, fix, group, region, and variable whether an entry\nwith the provided name or id is defined.\nThe is_available(category,name) function allows to query whether\na specific optional feature is available, i.e. compiled in.\nThis currently works for the following categories: command,\ncompute, fix, pair_style and feature. For all categories\nexcept command and feature also appending active suffixes is\ntried before reporting failure.\nThe feature category is used to check the availability of compiled in\nfeatures such as GZIP support, PNG support, JPEG support, FFMPEG support,\nand C++ exceptions for error handling. Corresponding values for name are\ngzip, png, jpeg, ffmpeg and exceptions.\nThis enables writing input scripts which only dump using a given format if\nthe compiled binary supports it.\nif \"$(is_available(feature,png))\" then \"print 'PNG supported'\" else \"print 'PNG not supported'\"\n\nif \"$(is_available(feature,ffmpeg)\" then \"dump 3 all movie 25 movie.mp4 type type zoom 1.6 adiam 1.0\"\n\n\n\n\n\nAtom Values and Vectors\nAtom values take an integer argument I from 1 to N, where I is the\natom-ID, e.g. x[243], which means use the x coordinate of the atom\nwith ID = 243.  Or they can take a variable name, specified as v_name,\nwhere name is the name of the variable, like x[v_myIndex].  The\nvariable can be of any style except vector or atom or atomfile\nvariables.  The variable is evaluated and the result is expected to be\nnumeric and is cast to an integer (i.e. 3.4 becomes 3), to use an\nindex, which must be a value from 1 to N.  Note that a “formula”\ncannot be used as the argument between the brackets, e.g. x[243+10]\nor x[v_myIndex+1] are not allowed.  To do this a single variable can\nbe defined that contains the needed formula.\nNote that the 0 < atom-ID <= N, where N is the largest atom ID\nin the system.  If an ID is specified for an atom that does not\ncurrently exist, then the generated value is 0.0.\nAtom vectors generate one value per atom, so that a reference like\n“vx” means the x-component of each atom’s velocity will be used when\nevaluating the variable.\nThe meaning of the different atom values and vectors is mostly\nself-explanatory.  Mol refers to the molecule ID of an atom, and is\nonly defined if an atom_style is being used that\ndefines molecule IDs.\nNote that many other atom attributes can be used as inputs to a\nvariable by using the compute property/atom command and then specifying\na quantity from that compute.\n\n\n\nCompute References\nCompute references access quantities calculated by a\ncompute.  The ID in the reference should be replaced by\nthe ID of a compute defined elsewhere in the input script.  As\ndiscussed in the doc page for the compute command,\ncomputes can produce global, per-atom, or local values.  Only global\nand per-atom values can be used in a variable.  Computes can also\nproduce a scalar, vector, or array.\nAn equal-style variable can only use scalar values, which means a\nglobal scalar, or an element of a global or per-atom vector or array.\nA vector-style variable can use scalar values or a global vector of\nvalues, or a column of a global array of values.  Atom-style variables\ncan use global scalar values.  They can also use per-atom vector\nvalues, or a column of a per-atom array.  See the doc pages for\nindividual computes to see what kind of values they produce.\nExamples of different kinds of compute references are as follows.\nThere is typically no ambiguity (see exception below) as to what a\nreference means, since computes only produce either global or per-atom\nquantities, never both.\n\n\n\n\n\n\nc_ID\nglobal scalar, or per-atom vector\n\nc_ID[I]\nIth element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array\n\nc_ID[I][J]\nI,J element of global array, or atom I’s Jth value in per-atom array\n\n\n\nFor I and J indices, integers can be specified or a variable name,\nspecified as v_name, where name is the name of the variable.  The\nrules for this syntax are the same as for the “Atom Values and\nVectors” discussion above.\nOne source of ambiguity for compute references is when a vector-style\nvariable refers to a compute that produces both a global scalar and a\nglobal vector.  Consider a compute with ID “foo” that does this,\nreferenced as follows by variable “a”, where “myVec” is another\nvector-style variable:\nvariable a vector c_foo*v_myVec\nThe reference “c_foo” could refer to either the global scalar or\nglobal vector produced by compute “foo”.  In this case, “c_foo” will\nalways refer to the global scalar, and “C_foo” can be used to\nreference the global vector.  Similarly if the compute produces both a\nglobal vector and global array, then “c_foo[I]” will always refer to\nan element of the global vector, and “C_foo[I]” can be used to\nreference the Ith column of the global array.\nNote that if a variable containing a compute is evaluated directly in\nan input script (not during a run), then the values accessed by the\ncompute must be current.  See the discussion below about “Variable\nAccuracy”.\n\n\n\nFix References\nFix references access quantities calculated by a fix.\nThe ID in the reference should be replaced by the ID of a fix defined\nelsewhere in the input script.  As discussed in the doc page for the\nfix command, fixes can produce global, per-atom, or local\nvalues.  Only global and per-atom values can be used in a variable.\nFixes can also produce a scalar, vector, or array.  An equal-style\nvariable can only use scalar values, which means a global scalar, or\nan element of a global or per-atom vector or array.  Atom-style\nvariables can use the same scalar values.  They can also use per-atom\nvector values.  A vector value can be a per-atom vector itself, or a\ncolumn of an per-atom array.  See the doc pages for individual fixes\nto see what kind of values they produce.\nThe different kinds of fix references are exactly the same as the\ncompute references listed in the above table, where “c_” is replaced\nby “f_”.  Again, there is typically no ambiguity (see exception below)\nas to what a reference means, since fixes only produce either global\nor per-atom quantities, never both.\n\n\n\n\n\n\nf_ID\nglobal scalar, or per-atom vector\n\nf_ID[I]\nIth element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array\n\nf_ID[I][J]\nI,J element of global array, or atom I’s Jth value in per-atom array\n\n\n\nFor I and J indices, integers can be specified or a variable name,\nspecified as v_name, where name is the name of the variable.  The\nrules for this syntax are the same as for the “Atom Values and\nVectors” discussion above.\nOne source of ambiguity for fix references is the same ambiguity\ndiscussed for compute references above.  Namely when a vector-style\nvariable refers to a fix that produces both a global scalar and a\nglobal vector.  The solution is the same as for compute references.\nFor a fix with ID “foo”, “f_foo” will always refer to the global\nscalar, and “F_foo” can be used to reference the global vector.  And\nsimilarly for distinguishing between a fix’s global vector versus\nglobal array with “f_foo[I]” versus “F_foo[I]”.\nNote that if a variable containing a fix is evaluated directly in an\ninput script (not during a run), then the values accessed by the fix\nshould be current.  See the discussion below about “Variable\nAccuracy”.\nNote that some fixes only generate quantities on certain timesteps.\nIf a variable attempts to access the fix on non-allowed timesteps, an\nerror is generated.  For example, the fix ave/time\ncommand may only generate averaged quantities every 100 steps.  See\nthe doc pages for individual fix commands for details.\n\n\n\nVariable References\nVariable references access quantities stored or calculated by other\nvariables, which will cause those variables to be evaluated.  The name\nin the reference should be replaced by the name of a variable defined\nelsewhere in the input script.\nAs discussed on this doc page, equal-style variables generate a single\nglobal numeric value, vector-style variables generate a vector of\nglobal numeric values, and atom-style and atomfile-style variables\ngenerate a per-atom vector of numeric values.  All other variables\nstore one or more strings.\nThe formula for an equal-style variable can use any style of variable\nincluding a vector_style or atom-style or atomfile-style.  For these\n3 styles, a subscript must be used to access a single value from\nthe vector-, atom-, or atomfile-style variable.  If a string-storing\nvariable is used, the string is converted to a numeric value.  Note\nthat this will typically produce a 0.0 if the string is not a numeric\nstring, which is likely not what you want.\nThe formula for a vector-style variable can use any style of variable,\nincluding atom-style or atomfile-style variables.  For these 2 styles,\na subscript must be used to access a single value from the atom-, or\natomfile-style variable.\nThe formula for an atom-style variable can use any style of variable,\nincluding other atom-style or atomfile-style variables.  If it uses a\nvector-style variable, a subscript must be used to access a single\nvalue from the vector-style variable.\nExamples of different kinds of variable references are as follows.\nThere is no ambiguity as to what a reference means, since variables\nproduce only a global scalar or global vector or per-atom vector.\n\n\n\n\n\n\nv_name\nglobal scalar from equal-style variable\n\nv_name\nglobal vector from vector-style variable\n\nv_name\nper-atom vector from atom-style or atomfile-style variable\n\nv_name[I]\nIth element of a global vector from vector-style variable\n\nv_name[I]\nvalue of atom with ID = I from atom-style or atomfile-style variable\n\n\n\nFor the I index, an integer can be specified or a variable name,\nspecified as v_name, where name is the name of the variable.  The\nrules for this syntax are the same as for the “Atom Values and\nVectors” discussion above.\n\nImmediate Evaluation of Variables:\nIf you want an equal-style variable to be evaluated immediately, it\nmay be the case that you do not need to define a variable at all.  See\nthe Commands parse doc page for info on how to\nuse “immediate” variables in an input script, specified as $(formula)\nwith parenthesis, where the formula has the same syntax as equal-style\nvariables described on this page.  This effectively evaluates a\nformula immediately without using the variable command to define a\nnamed variable.\nMore generally, there is a difference between referencing a variable\nwith a leading $ sign (e.g. $x or ${abc}) versus with a leading “v_”\n(e.g. v_x or v_abc).  The former can be used in any input script\ncommand, including a variable command.  The input script parser\nevaluates the reference variable immediately and substitutes its value\ninto the command.  As explained on the Commands parse doc page, you can also use un-named\n“immediate” variables for this purpose.  For example, a string like\nthis $((xlo+xhi)/2+sqrt(v_area)) in an input script command evaluates\nthe string between the parenthesis as an equal-style variable formula.\nReferencing a variable with a leading “v_” is an optional or required\nkind of argument for some commands (e.g. the fix ave/chunk or dump custom or\nthermo_style commands) if you wish it to evaluate\na variable periodically during a run.  It can also be used in a\nvariable formula if you wish to reference a second variable.  The\nsecond variable will be evaluated whenever the first variable is\nevaluated.\nAs an example, suppose you use this command in your input script to\ndefine the variable “v” as\nvariable v equal vol\n\n\nbefore a run where the simulation box size changes.  You might think\nthis will assign the initial volume to the variable “v”.  That is not\nthe case.  Rather it assigns a formula which evaluates the volume\n(using the thermo_style keyword “vol”) to the variable “v”.  If you\nuse the variable “v” in some other command like fix ave/time then the current volume of the box will be\nevaluated continuously during the run.\nIf you want to store the initial volume of the system, you can do it\nthis way:\nvariable v equal vol\nvariable v0 equal $v\n\n\nThe second command will force “v” to be evaluated (yielding the\ninitial volume) and assign that value to the variable “v0”.  Thus the\ncommand\nthermo_style custom step v_v v_v0\n\n\nwould print out both the current and initial volume periodically\nduring the run.\nNote that it is a mistake to enclose a variable formula in double\nquotes if it contains variables preceded by $ signs.  For example,\nvariable vratio equal \"${vfinal}/${v0}\"\n\n\nThis is because the quotes prevent variable substitution (explained on\nthe Commands parse doc page), and thus an error\nwill occur when the formula for “vratio” is evaluated later.\n\nVariable Accuracy:\nObviously, LAMMPS attempts to evaluate variables containing formulas\n(equal and atom style variables) accurately whenever the\nevaluation is performed.  Depending on what is included in the\nformula, this may require invoking a compute, either\ndirectly or indirectly via a thermo keyword, or accessing a value\npreviously calculated by a compute, or accessing a value calculated\nand stored by a fix.  If the compute is one that calculates\nthe pressure or energy of the system, then these quantities need to be\ntallied during the evaluation of the interatomic potentials (pair,\nbond, etc) on timesteps that the variable will need the values.\nLAMMPS keeps track of all of this during a run or energy minimization.  An error will be generated if you\nattempt to evaluate a variable on timesteps when it cannot produce\naccurate values.  For example, if a thermo_style custom command prints a variable which accesses\nvalues stored by a fix ave/time command and the\ntimesteps on which thermo output is generated are not multiples of the\naveraging frequency used in the fix command, then an error will occur.\nAn input script can also request variables be evaluated before or\nafter or in between runs, e.g. by including them in a\nprint command.  In this case, if a compute is needed to\nevaluate a variable (either directly or indirectly), LAMMPS will not\ninvoke the compute, but it will use a value previously calculated by\nthe compute, and can do this only if it was invoked on the current\ntimestep.  Fixes will always provide a quantity needed by a variable,\nbut the quantity may or may not be current.  This leads to one of\nthree kinds of behavior:\n(1) The variable may be evaluated accurately.  If it contains\nreferences to a compute or fix, and these values were calculated on\nthe last timestep of a preceding run, then they will be accessed and\nused by the variable and the result will be accurate.\n(2) LAMMPS may not be able to evaluate the variable and will generate\nan error message stating so.  For example, if the variable requires a\nquantity from a compute that has not been invoked on\nthe current timestep, LAMMPS will generate an error.  This means, for\nexample, that such a variable cannot be evaluated before the first run\nhas occurred.  Likewise, in between runs, a variable containing a\ncompute cannot be evaluated unless the compute was invoked on the last\ntimestep of the preceding run, e.g. by thermodynamic output.\nOne way to get around this problem is to perform a 0-timestep run\nbefore using the variable.  For example, these commands\nvariable t equal temp\nprint \"Initial temperature = $t\"\nrun 1000\n\n\nwill generate an error if the run is the first run specified in the\ninput script, because generating a value for the “t” variable requires\na compute for calculating the temperature to be invoked.\nHowever, this sequence of commands would be fine:\nrun 0\nvariable t equal temp\nprint \"Initial temperature = $t\"\nrun 1000\n\n\nThe 0-timestep run initializes and invokes various computes, including\nthe one for temperature, so that the value it stores is current and\ncan be accessed by the variable “t” after the run has completed.  Note\nthat a 0-timestep run does not alter the state of the system, so it\ndoes not change the input state for the 1000-timestep run that\nfollows.  Also note that the 0-timestep run must actually use and\ninvoke the compute in question (e.g. via thermo or\ndump output) in order for it to enable the compute to be\nused in a variable after the run.  Thus if you are trying to print a\nvariable that uses a compute you have defined, you can insure it is\ninvoked on the last timestep of the preceding run by including it in\nthermodynamic output.\nUnlike computes, fixes will never generate an error if\ntheir values are accessed by a variable in between runs.  They always\nreturn some value to the variable.  However, the value may not be what\nyou expect if the fix has not yet calculated the quantity of interest\nor it is not current.  For example, the fix indent\ncommand stores the force on the indenter.  But this is not computed\nuntil a run is performed.  Thus if a variable attempts to print this\nvalue before the first run, zeroes will be output.  Again, performing\na 0-timestep run before printing the variable has the desired effect.\n(3) The variable may be evaluated incorrectly and LAMMPS may have no\nway to detect this has occurred.  Consider the following sequence of\ncommands:\npair_coeff 1 1 1.0 1.0\nrun 1000\npair_coeff 1 1 1.5 1.0\nvariable e equal pe\nprint \"Final potential energy = $e\"\n\n\nThe first run is performed using one setting for the pairwise\npotential defined by the pair_style and\npair_coeff commands.  The potential energy is\nevaluated on the final timestep and stored by the compute pe compute (this is done by the\nthermo_style command).  Then a pair coefficient is\nchanged, altering the potential energy of the system.  When the\npotential energy is printed via the “e” variable, LAMMPS will use the\npotential energy value stored by the compute pe\ncompute, thinking it is current.  There are many other commands which\ncould alter the state of the system between runs, causing a variable\nto evaluate incorrectly.\nThe solution to this issue is the same as for case (2) above, namely\nperform a 0-timestep run before the variable is evaluated to insure\nthe system is up-to-date.  For example, this sequence of commands\nwould print a potential energy that reflected the changed pairwise\ncoefficient:\npair_coeff 1 1 1.0 1.0\nrun 1000\npair_coeff 1 1 1.5 1.0\nrun 0\nvariable e equal pe\nprint \"Final potential energy = $e\"",
    "syntax": "variable name style args ...",
    "parameters": " * name = name of variable to define\n * style = delete or index or loop or world or universe or uloop or string or format or getenv or file or atomfile or python or internal or equal or vector or atom\n * delete = no args\n * index args = one or more strings\n * loop args = N\n *   N = integer size of loop, loop from 1 to N inclusive\n * loop args = N pad\n *   N = integer size of loop, loop from 1 to N inclusive\n *   pad = all values will be same length, e.g. 001, 002, ..., 100\n * loop args = N1 N2\n *   N1,N2 = loop from N1 to N2 inclusive\n * loop args = N1 N2 pad\n *   N1,N2 = loop from N1 to N2 inclusive\n *   pad = all values will be same length, e.g. 050, 051, ..., 100\n * world args = one string for each partition of processors\n * universe args = one or more strings\n * uloop args = N\n *   N = integer size of loop\n * uloop args = N pad\n *   N = integer size of loop\n *   pad = all values will be same length, e.g. 001, 002, ..., 100\n * string arg = one string\n * format args = vname fstr\n *   vname = name of equal-style variable to evaluate\n *   fstr = C-style format string\n * getenv arg = one string\n * file arg = filename\n * atomfile arg = filename\n * python arg = function\n * internal arg = numeric value\n * equal or vector or atom args = one formula containing numbers, thermo keywords, math operations, group functions, atom values and vectors, compute/fix/variable references\n *   numbers = 0.0, 100, -5.4, 2.8e-4, etc\n *   constants = PI, version, on, off, true, false, yes, no\n *   thermo keywords = vol, ke, press, etc from thermo_style\n *   math operators = (), -x, x+y, x-y, x*y, x/y, x^y, x%y,\n *                    x == y, x != y, x < y, x <= y, x > y, x >= y, x && y, x || y, x |^ y, !x\n *   math functions = sqrt(x), exp(x), ln(x), log(x), abs(x),\n *                    sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),\n *                    random(x,y,z), normal(x,y,z), ceil(x), floor(x), round(x)\n *                    ramp(x,y), stagger(x,y), logfreq(x,y,z), logfreq2(x,y,z),\n *                    logfreq3(x,y,z), stride(x,y,z), stride2(x,y,z,a,b,c),\n *                    vdisplace(x,y), swiggle(x,y,z), cwiggle(x,y,z)\n *   group functions = count(group), mass(group), charge(group),\n *                     xcm(group,dim), vcm(group,dim), fcm(group,dim),\n *                     bound(group,dir), gyration(group), ke(group),\n *                     angmom(group,dim), torque(group,dim),\n *                     inertia(group,dimdim), omega(group,dim)\n *   region functions = count(group,region), mass(group,region), charge(group,region),\n *                     xcm(group,dim,region), vcm(group,dim,region), fcm(group,dim,region),\n *                     bound(group,dir,region), gyration(group,region), ke(group,reigon),\n *                     angmom(group,dim,region), torque(group,dim,region),\n *                     inertia(group,dimdim,region), omega(group,dim,region)\n *   special functions = sum(x), min(x), max(x), ave(x), trap(x), slope(x), gmask(x), rmask(x), grmask(x,y), next(x)\n *   feature functions = is_active(category,feature,exact), is_defined(category,id,exact)\n *   atom value = id[i], mass[i], type[i], mol[i], x[i], y[i], z[i], vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]\n *   atom vector = id, mass, type, mol, x, y, z, vx, vy, vz, fx, fy, fz, q\n *   compute references = c_ID, c_ID[i], c_ID[i][j], C_ID, C_ID[i]\n *   fix references = f_ID, f_ID[i], f_ID[i][j], F_ID, F_ID[i]\n *   variable references = v_name, v_name[i]",
    "examples": "variable x index run1 run2 run3 run4 run5 run6 run7 run8\nvariable LoopVar loop $n\nvariable beta equal temp/3.0\nvariable b1 equal x[234]+0.5*vol\nvariable b1 equal \"x[234] + 0.5*vol\"\nvariable b equal xcm(mol1,x)/2.0\nvariable b equal c_myTemp\nvariable b atom x*y/vol\nvariable foo string myfile\nvariable foo internal 3.5\nvariable myPy python increase\nvariable f file values.txt\nvariable temp world 300.0 310.0 320.0 ${Tfinal}\nvariable x universe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nvariable x uloop 15 pad\nvariable str format x %.6g\nvariable x delete",
    "restrictions": "Indexing any formula element by global atom ID, such as an atom value,\nrequires the atom style to use a global mapping in\norder to look up the vector indices.  By default, only atom styles\nwith molecular information create global maps.  The atom_modify map command can override the default, e.g. for\natomic-style atom styles.\nAll universe- and uloop-style variables defined in an input script\nmust have the same number of values."
},
{
    "command": "velocity",
    "html_filename": "velocity.html",
    "short_description": "Set or change the velocities of a group of atoms in one of several styles",
    "description": "Set or change the velocities of a group of atoms in one of several\nstyles.  For each style, there are required arguments and optional\nkeyword/value parameters.  Not all options are used by each style.\nEach option has a default as listed below.\nThe create style generates an ensemble of velocities using a random\nnumber generator with the specified seed at the specified temperature.\nThe set style sets the velocities of all atoms in the group to the\nspecified values.  If any component is specified as NULL, then it is\nnot set.  Any of the vx,vy,vz velocity components can be specified as\nan equal-style or atom-style variable.  If the value\nis a variable, it should be specified as v_name, where name is the\nvariable name.  In this case, the variable will be evaluated, and its\nvalue used to determine the velocity component.  Note that if a\nvariable is used, the velocity it calculates must be in box units, not\nlattice units; see the discussion of the units keyword below.\nEqual-style variables can specify formulas with various mathematical\nfunctions, and include thermo_style command\nkeywords for the simulation box parameters or other parameters.\nAtom-style variables can specify the same formulas as equal-style\nvariables but can also include per-atom values, such as atom\ncoordinates.  Thus it is easy to specify a spatially-dependent\nvelocity field.\nThe scale style computes the current temperature of the group of\natoms and then rescales the velocities to the specified temperature.\nThe ramp style is similar to that used by the compute temp/ramp command.  Velocities ramped\nuniformly from vlo to vhi are applied to dimension vx, or vy, or vz.\nThe value assigned to a particular atom depends on its relative\ncoordinate value (in dim) from clo to chi.  For the example above, an\natom with y-coordinate of 10 (1/4 of the way from 5 to 25), would be\nassigned a x-velocity of 1.25 (1/4 of the way from 0.0 to 5.0).  Atoms\noutside the coordinate bounds (less than 5 or greater than 25 in this\ncase), are assigned velocities equal to vlo or vhi (0.0 or 5.0 in this\ncase).\nThe zero style adjusts the velocities of the group of atoms so that\nthe aggregate linear or angular momentum is zero.  No other changes\nare made to the velocities of the atoms.  If the rigid option is\nspecified (see below), then the zeroing is performed on individual\nrigid bodies, as defined by the fix rigid or fix rigid/small commands.  In other words, zero linear\nwill set the linear momentum of each rigid body to zero, and zero\nangular will set the angular momentum of each rigid body to zero.\nThis is done by adjusting the velocities of the atoms in each rigid\nbody.\nAll temperatures specified in the velocity command are in temperature\nunits; see the units command.  The units of velocities and\ncoordinates depend on whether the units keyword is set to box or\nlattice, as discussed below.\nFor all styles, no atoms are assigned z-component velocities if the\nsimulation is 2d; see the dimension command.\n\nThe keyword/value options are used in the following ways by the\nvarious styles.\nThe dist keyword is used by create.  The ensemble of generated\nvelocities can be a uniform distribution from some minimum to\nmaximum value, scaled to produce the requested temperature.  Or it can\nbe a gaussian distribution with a mean of 0.0 and a sigma scaled to\nproduce the requested temperature.\nThe sum keyword is used by all styles, except zero.  The new\nvelocities will be added to the existing ones if sum = yes, or will\nreplace them if sum = no.\nThe mom and rot keywords are used by create.  If mom = yes, the\nlinear momentum of the newly created ensemble of velocities is zeroed;\nif rot = yes, the angular momentum is zeroed.\n\nIf specified, the temp keyword is used by create and scale to\nspecify a compute that calculates temperature in a\ndesired way, e.g. by first subtracting out a velocity bias, as\ndiscussed on the Howto thermostat doc page.\nIf this keyword is not specified, create and scale calculate\ntemperature using a compute that is defined internally as follows:\ncompute velocity_temp group-ID temp\n\n\nwhere group-ID is the same ID used in the velocity command. i.e. the\ngroup of atoms whose velocity is being altered.  This compute is\ndeleted when the velocity command is finished.  See the compute temp command for details.  If the calculated\ntemperature should have degrees-of-freedom removed due to fix\nconstraints (e.g. SHAKE or rigid-body constraints), then the\nappropriate fix command must be specified before the velocity command\nis issued.\nThe bias keyword with a yes setting is used by create and\nscale, but only if the temp keyword is also used to specify a\ncompute that calculates temperature in a desired way.\nIf the temperature compute also calculates a velocity bias, the\nbias is subtracted from atom velocities before the create and\nscale operations are performed.  After the operations, the bias is\nadded back to the atom velocities.  See the Howto thermostat doc page for more discussion of\ntemperature computes with biases.  Note that the velocity bias is only\napplied to atoms in the temperature compute specified with the temp\nkeyword.\nAs an example, assume atoms are currently streaming in a flow\ndirection (which could be separately initialized with the ramp\nstyle), and you wish to initialize their thermal velocity to a desired\ntemperature.  In this context thermal velocity means the per-particle\nvelocity that remains when the streaming velocity is subtracted.  This\ncan be done using the create style with the temp keyword\nspecifying the ID of a compute temp/ramp or\ncompute temp/profile command, and the\nbias keyword set to a yes value.\n\nThe loop keyword is used by create in the following ways.\nIf loop = all, then each processor loops over all atoms in the\nsimulation to create velocities, but only stores velocities for atoms\nit owns.  This can be a slow loop for a large simulation.  If atoms\nwere read from a data file, the velocity assigned to a particular atom\nwill be the same, independent of how many processors are being used.\nThis will not be the case if atoms were created using the\ncreate_atoms command, since atom IDs will likely\nbe assigned to atoms differently.\nIf loop = local, then each processor loops over only its atoms to\nproduce velocities.  The random number seed is adjusted to give a\ndifferent set of velocities on each processor.  This is a fast loop,\nbut the velocity assigned to a particular atom will depend on which\nprocessor owns it.  Thus the results will always be different when a\nsimulation is run on a different number of processors.\nIf loop = geom, then each processor loops over only its atoms.  For\neach atom a unique random number seed is created, based on the atom’s\nxyz coordinates.  A velocity is generated using that seed.  This is a\nfast loop and the velocity assigned to a particular atom will be the\nsame, independent of how many processors are used.  However, the set\nof generated velocities may be more correlated than if the all or\nlocal keywords are used.\nNote that the loop geom keyword will not necessarily assign\nidentical velocities for two simulations run on different machines.\nThis is because the computations based on xyz coordinates are\nsensitive to tiny differences in the double-precision value for a\ncoordinate as stored on a particular machine.\n\nThe rigid keyword only has meaning when used with the zero style.\nIt allows specification of a fix-ID for one of the rigid-body fix variants which defines a set of rigid bodies.  The\nzeroing of linear or angular momentum is then performed for each rigid\nbody defined by the fix, as described above.\nThe units keyword is used by set and ramp.  If units = box,\nthe velocities and coordinates specified in the velocity command are\nin the standard units described by the units command\n(e.g. Angstroms/fmsec for real units).  If units = lattice, velocities\nare in units of lattice spacings per time (e.g. spacings/fmsec) and\ncoordinates are in lattice spacings.  The lattice\ncommand must have been previously used to define the lattice spacing.",
    "syntax": "velocity group-ID style args keyword value ...",
    "parameters": " * group-ID = ID of group of atoms whose velocity will be changed\n * style = create or set or scale or ramp or zero\n * create args = temp seed\n *   temp = temperature value (temperature units)\n *   seed = random # seed (positive integer)\n * set args = vx vy vz\n *   vx,vy,vz = velocity value or NULL (velocity units)\n *   any of vx,vy,vz van be a variable (see below)\n * scale arg = temp\n *   temp = temperature value (temperature units)\n * ramp args = vdim vlo vhi dim clo chi\n *   vdim = vx or vy or vz\n *   vlo,vhi = lower and upper velocity value (velocity units)\n *   dim = x or y or z\n *   clo,chi = lower and upper coordinate bound (distance units)\n * zero arg = linear or angular\n *   linear = zero the linear momentum\n *   angular = zero the angular momentum\n * zero or more keyword/value pairs may be appended\n * keyword = dist or sum or mom or rot or temp or bias or loop or units\n * dist value = uniform or gaussian\n * sum value = no or yes\n * mom value = no or yes\n * rot value = no or yes\n * temp value = temperature compute ID\n * bias value = no or yes\n * loop value = all or local or geom\n * rigid value = fix-ID\n *   fix-ID = ID of rigid body fix\n * units value = box or lattice",
    "examples": "velocity all create 300.0 4928459 rot yes dist gaussian\nvelocity border set NULL 4.0 v_vz sum yes units box\nvelocity flow scale 300.0\nvelocity flow ramp vx 0.0 5.0 y 5 25 temp mytemp\nvelocity all zero linear",
    "restrictions": "Assigning a temperature via the create style to a system with rigid bodies or SHAKE constraints may not\nhave the desired outcome for two reasons.  First, the velocity command\ncan be invoked before all of the relevant fixes are created and\ninitialized and the number of adjusted degrees of freedom (DOFs) is\nknown.  Thus it is not possible to compute the target temperature\ncorrectly.  Second, the assigned velocities may be partially canceled\nwhen constraints are first enforced, leading to a different\ntemperature than desired.  A workaround for this is to perform a run 0 command, which insures all DOFs are accounted for\nproperly, and then rescale the temperature to the desired value before\nperforming a simulation.  For example:\nvelocity all create 300.0 12345\nrun 0                             # temperature may not be 300K\nvelocity all scale 300.0          # now it should be"
},
{
    "command": "write_coeff",
    "html_filename": "write_coeff.html",
    "short_description": "Write a text format file with the currently defined force field coefficients in a way, that it can be read by LAMMPS with the include command",
    "description": "Write a text format file with the currently defined force field\ncoefficients in a way, that it can be read by LAMMPS with the\ninclude command. In combination with the nocoeff\noption of write_data this can be used to move\nthe Coeffs sections from a data file into a separate file.\n\nNote\nThe write_coeff command is not yet fully implemented as\nsome pair styles do not output their coefficient information.\nThis means you will need to add/copy this information manually.",
    "syntax": "write_coeff file",
    "parameters": " * file = name of data file to write out",
    "examples": "write_coeff polymer.coeff",
    "restrictions": "none"
},
{
    "command": "write_data",
    "html_filename": "write_data.html",
    "short_description": "Write a data file in text format of the current state of the simulation",
    "description": "Write a data file in text format of the current state of the\nsimulation.  Data files can be read by the read data\ncommand to begin a simulation.  The read_data command\nalso describes their format.\nSimilar to dump files, the data filename can contain a “*”\nwild-card character.  The “*” is replaced with the current timestep\nvalue.\n\nNote\nThe write-data command is not yet fully implemented in two\nrespects.  First, most pair styles do not yet write their coefficient\ninformation into the data file.  This means you will need to specify\nthat information in your input script that reads the data file, via\nthe pair_coeff command.  Second, a few of the atom styles (body, ellipsoid, line, tri) that store\nauxiliary “bonus” information about aspherical particles, do not yet\nwrite the bonus info into the data file.  Both these functionalities\nwill be added to the write_data command later.\n\nBecause a data file is in text format, if you use a data file written\nout by this command to restart a simulation, the initial state of the\nnew run will be slightly different than the final state of the old run\n(when the file was written) which was represented internally by LAMMPS\nin binary format.  A new simulation which reads the data file will\nthus typically diverge from a simulation that continued in the\noriginal input script.\nIf you want to do more exact restarts, using binary files, see the\nrestart, write_restart, and\nread_restart commands.  You can also convert\nbinary restart files to text data files, after a simulation has run,\nusing the -r command-line switch.\n\nNote\nOnly limited information about a simulation is stored in a data\nfile.  For example, no information about atom groups and\nfixes are stored.  Binary restart files\nstore more information.\n\nBond interactions (angle, etc) that have been turned off by the fix shake or delete_bonds command will\nbe written to a data file as if they are turned on.  This means they\nwill need to be turned off again in a new run after the data file is\nread.\nBonds that are broken (e.g. by a bond-breaking potential) are not\nwritten to the data file.  Thus these bonds will not exist when the\ndata file is read.\n\nThe nocoeff keyword requests that no force field parameters should\nbe written to the data file. This can be very helpful, if one wants\nto make significant changes to the force field or if the parameters\nare read in separately anyway, e.g. from an include file.\nThe nofix keyword requests that no extra sections read by fixes\nshould be written to the data file (see the fix option of the\nread_data command for details). For example, this\noption excludes sections for user-created per-atom properties\nfrom fix property/atom.\nThe pair keyword lets you specify in what format the pair\ncoefficient information is written into the data file.  If the value\nis specified as ii, then one line per atom type is written, to\nspecify the coefficients for each of the I=J interactions.  This means\nthat no cross-interactions for I != J will be specified in the data\nfile and the pair style will apply its mixing rule, as documented on\nindividual pair_style doc pages.  Of course this\nbehavior can be overridden in the input script after reading the data\nfile, by specifying additional pair_coeff commands\nfor any desired I,J pairs.\nIf the value is specified as ij, then one line of coefficients is\nwritten for all I,J pairs where I <= J.  These coefficients will\ninclude any specific settings made in the input script up to that\npoint.  The presence of these I != J coefficients in the data file\nwill effectively turn off the default mixing rule for the pair style.\nAgain, the coefficient values in the data file can be overridden\nin the input script after reading the data file, by specifying\nadditional pair_coeff commands for any desired I,J\npairs.",
    "syntax": "write_data file keyword value ...",
    "parameters": " * file = name of data file to write out\n * zero or more keyword/value pairs may be appended\n * keyword = pair or nocoeff\n * nocoeff = do not write out force field info\n * nofix = do not write out extra sections read by fixes\n * pair value = ii or ij\n *   ii = write one line of pair coefficient info per atom type\n *   ij = write one line of pair coefficient info per IJ atom type pair",
    "examples": "write_data data.polymer\nwrite_data data.*",
    "restrictions": "This command requires inter-processor communication to migrate atoms\nbefore the data file is written.  This means that your system must be\nready to perform a simulation before using this command (force fields\nsetup, atom masses initialized, etc)."
},
{
    "command": "write_dump",
    "html_filename": "write_dump.html",
    "short_description": "Dump a single snapshot of atom quantities to one or more files for the current state of the system",
    "description": "Dump a single snapshot of atom quantities to one or more files for the\ncurrent state of the system.  This is a one-time immediate operation,\nin contrast to the dump command which will will set up a\ndump style to write out snapshots periodically during a running\nsimulation.\nThe syntax for this command is mostly identical to that of the\ndump and dump_modify commands as if\nthey were concatenated together, with the following exceptions: There\nis no need for a dump ID or dump frequency and the keyword modify is\nadded.  The latter is so that the full range of\ndump_modify options can be specified for the single\nsnapshot, just as they can be for multiple snapshots.  The modify\nkeyword separates the arguments that would normally be passed to the\ndump command from those that would be given the dump_modify.  Both\nsupport optional arguments and thus LAMMPS needs to be able to cleanly\nseparate the two sets of args.\nNote that if the specified filename uses wildcard characters “*” or\n“%”, as supported by the dump command, they will operate\nin the same fashion to create the new filename(s).  Normally, dump image files require a filename with a “*” character\nfor the timestep.  That is not the case for the write_dump command; no\nwildcard “*” character is necessary.",
    "syntax": "write_dump group-ID style file dump-args modify dump_modify-args",
    "parameters": " * group-ID = ID of the group of atoms to be dumped\n * style = any of the supported dump styles\n * file = name of file to write dump info to\n * dump-args = any additional args needed for a particular dump style\n * modify = all args after this keyword are passed to dump_modify (optional)\n * dump-modify-args = args for dump_modify (optional)",
    "examples": "write_dump all atom dump.atom\nwrite_dump subgroup atom dump.run.bin\nwrite_dump all custom dump.myforce.* id type x y vx fx\nwrite_dump flow custom dump.%.myforce id type c_myF[3] v_ke modify sort id\nwrite_dump all xyz system.xyz modify sort id element O H\nwrite_dump all image snap*.jpg type type size 960 960 modify backcolor white\nwrite_dump all image snap*.jpg element element &\n   bond atom 0.3 shiny 0.1 ssao yes 6345 0.2 size 1600 1600  &\n   modify backcolor white element C C O H N C C C O H H S O H",
    "restrictions": "All restrictions for the dump and\ndump_modify commands apply to this command as well,\nwith the exception of the dump image filename not\nrequiring a wildcard “*” character, as noted above.\nSince dumps are normally written during a run or energy minimization, the simulation has to be ready to run\nbefore this command can be used.  Similarly, if the dump requires\ninformation from a compute, fix, or variable, the information needs to\nhave been calculated for the current timestep (e.g. by a prior run),\nelse LAMMPS will generate an error message.\nFor example, it is not possible to dump per-atom energy with this\ncommand before a run has been performed, since no energies and forces\nhave yet been calculated.  See the variable doc page\nsection on Variable Accuracy for more information on this topic."
},
{
    "command": "write_restart",
    "html_filename": "write_restart.html",
    "short_description": "Write a binary restart file of the current state of the simulation",
    "description": "Write a binary restart file of the current state of the simulation.\nDuring a long simulation, the restart command is\ntypically used to output restart files periodically.  The\nwrite_restart command is useful after a minimization or whenever you\nwish to write out a single current restart file.\nSimilar to dump files, the restart filename can contain\ntwo wild-card characters.  If a “*” appears in the filename, it is\nreplaced with the current timestep value.  If a “%” character appears\nin the filename, then one file is written by each processor and the\n“%” character is replaced with the processor ID from 0 to P-1.  An\nadditional file with the “%” replaced by “base” is also written, which\ncontains global information.  For example, the files written for\nfilename restart.% would be restart.base, restart.0, restart.1, …\nrestart.P-1.  This creates smaller files and can be a fast mode of\noutput and subsequent input on parallel machines that support parallel\nI/O.  The optional fileper and nfile keywords discussed below can\nalter the number of files written.\nThe restart file can also be written in parallel as one large binary\nfile via the MPI-IO library, which is part of the MPI standard for\nversions 2.0 and above.  Using MPI-IO requires two steps.  First,\nbuild LAMMPS with its MPIIO package installed, e.g.\nmake yes-mpiio    # installs the MPIIO package\nmake mpi          # build LAMMPS for your platform\n\n\nSecond, use a restart filename which contains “.mpiio”.  Note that it\ndoes not have to end in “.mpiio”, just contain those characters.\nUnlike MPI-IO dump files, a particular restart file must be both\nwritten and read using MPI-IO.\nRestart files can be read by a read_restart\ncommand to restart a simulation from a particular state.  Because the\nfile is binary (to enable exact restarts), it may not be readable on\nanother machine.  In this case, you can use the -r command-line switch to convert a restart file to a data file.\n\nNote\nAlthough the purpose of restart files is to enable restarting a\nsimulation from where it left off, not all information about a\nsimulation is stored in the file.  For example, the list of fixes that\nwere specified during the initial run is not stored, which means the\nnew input script must specify any fixes you want to use.  Even when\nrestart information is stored in the file, as it is for some fixes,\ncommands may need to be re-specified in the new input script, in order\nto re-use that information. Details are usually given in the\ndocumentation of the respective command. Also, see the\nread_restart command for general information about\nwhat is stored in a restart file.\n\n\nThe optional nfile or fileper keywords can be used in conjunction\nwith the “%” wildcard character in the specified restart file name.\nAs explained above, the “%” character causes the restart file to be\nwritten in pieces, one piece for each of P processors.  By default P =\nthe number of processors the simulation is running on.  The nfile or\nfileper keyword can be used to set P to a smaller value, which can\nbe more efficient when running on a large number of processors.\nThe nfile keyword sets P to the specified Nf value.  For example, if\nNf = 4, and the simulation is running on 100 processors, 4 files will\nbe written, by processors 0,25,50,75.  Each will collect information\nfrom itself and the next 24 processors and write it to a restart file.\nFor the fileper keyword, the specified value of Np means write one\nfile for every Np processors.  For example, if Np = 4, every 4th\nprocessor (0,4,8,12,etc) will collect information from itself and the\nnext 3 processors and write it to a restart file.",
    "syntax": "write_restart file keyword value ...",
    "parameters": " * file = name of file to write restart information to\n * zero or more keyword/value pairs may be appended\n * keyword = fileper or nfile\n * fileper arg = Np\n *   Np = write one file for every this many processors\n * nfile arg = Nf\n *   Nf = write this many files, one from each of Nf processors",
    "examples": "write_restart restart.equil\nwrite_restart restart.equil.mpiio\nwrite_restart poly.%.* nfile 10",
    "restrictions": "This command requires inter-processor communication to migrate atoms\nbefore the restart file is written.  This means that your system must\nbe ready to perform a simulation before using this command (force\nfields setup, atom masses initialized, etc).\nTo write and read restart files in parallel with MPI-IO, the MPIIO\npackage must be installed."
},
{
    "command": "angle_style charmm",
    "html_filename": "angle_charmm.html",
    "short_description": "The charmm angle style uses the potential  \\[E = K (\\theta - \\theta_0)^2 + K_{ub} (r - r_{ub})^2\\] with an additional Urey_Bradley term based on the distance \\(r\\) between the 1st and 3rd atoms in the angle",
    "description": "The charmm angle style uses the potential\n\n\\[E = K (\\theta - \\theta_0)^2 + K_{ub} (r - r_{ub})^2\\]\nwith an additional Urey_Bradley term based on the distance \\(r\\) between\nthe 1st and 3rd atoms in the angle.  \\(K\\), \\(\\theta_0\\),\n\\(K_{ub}\\), and \\(R_{ub}\\) are coefficients defined for each angle\ntype.\nSee (MacKerell) for a description of the CHARMM force\nfield.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/radian^2)\n\\(\\theta_0\\) (degrees)\n\\(K_{ub}\\) (energy/distance^2)\n\\(r_{ub}\\) (distance)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K\\) are in energy/radian^2.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style charmm",
    "parameters": " * ",
    "examples": "angle_style charmm\nangle_coeff 1 300.0 107.0 50.0 3.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style class2",
    "html_filename": "angle_class2.html",
    "short_description": "The class2 angle style uses the potential  \\[\\begin{split}E & = E_a + E_{bb} + E_{ba} \\\\ E_a & = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4(\\theta - \\theta_0)^4 \\\\ E_{bb} & = M (r_{ij} - r_1) (r_{jk} - r_2) \\\\ E_{ba} & = N_1 (r_{ij} - r_1) (\\theta - \\theta_0) + N_2(r_{jk} - r_2)(\\theta - \\theta_0)\\end{split}\\] where \\(E_a\\) is the angle term, \\(E_{bb}\\) is a bond-bond term, and \\(E_{ba}\\) is a bond-angle term",
    "description": "The class2 angle style uses the potential\n\n\\[\\begin{split}E & = E_a + E_{bb} + E_{ba} \\\\\nE_a & = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4(\\theta - \\theta_0)^4 \\\\\nE_{bb} & = M (r_{ij} - r_1) (r_{jk} - r_2) \\\\\nE_{ba} & = N_1 (r_{ij} - r_1) (\\theta - \\theta_0) + N_2(r_{jk} - r_2)(\\theta - \\theta_0)\\end{split}\\]\nwhere \\(E_a\\) is the angle term, \\(E_{bb}\\) is a bond-bond term, and \\(E_{ba}\\) is a\nbond-angle term.  \\(\\theta_0\\) is the equilibrium angle and \\(r_1\\) and \\(r_2\\) are\nthe equilibrium bond lengths.\nSee (Sun) for a description of the COMPASS class2 force field.\nCoefficients for the \\(E_a\\), \\(E_{bb}\\), and \\(E_{ba}\\) formulas must be defined for\neach angle type via the angle_coeff command as in\nthe example above, or in the data file or restart files read by the\nread_data or read_restart\ncommands.\nThese are the 4 coefficients for the \\(E_a\\) formula:\n\n\\(\\theta_0\\) (degrees)\n\\(K_2\\) (energy/radian^2)\n\\(K_3\\) (energy/radian^3)\n\\(K_4\\) (energy/radian^4)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of the various \\(K\\) are in per-radian.\nFor the \\(E_{bb}\\) formula, each line in a angle_coeff\ncommand in the input script lists 4 coefficients, the first of which\nis “bb” to indicate they are BondBond coefficients.  In a data file,\nthese coefficients should be listed under a “BondBond Coeffs” heading\nand you must leave out the “bb”, i.e. only list 3 coefficients after\nthe angle type.\n\nbb\n\\(M\\) (energy/distance^2)\n\\(r_1\\) (distance)\n\\(r_2\\) (distance)\n\nFor the \\(E_{ba}\\) formula, each line in a angle_coeff\ncommand in the input script lists 5 coefficients, the first of which\nis “ba” to indicate they are BondAngle coefficients.  In a data file,\nthese coefficients should be listed under a “BondAngle Coeffs” heading\nand you must leave out the “ba”, i.e. only list 4 coefficients after\nthe angle type.\n\nba\n\\(N_1\\) (energy/distance^2)\n\\(N_2\\) (energy/distance^2)\n\\(r_1\\) (distance)\n\\(r_2\\) (distance)\n\nThe \\(\\theta_0\\) value in the \\(E_{ba}\\) formula is not specified,\nsince it is the same value from the \\(E_a\\) formula.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nThe class2/p6 angle style uses the class2 potential expanded to sixth order:\n\n\\[E_{a} = K_2\\left(\\theta - \\theta_0\\right)^2 + K_3\\left(\\theta - \\theta_0\\right)^3 + K_4\\left(\\theta - \\theta_0\\right)^4 + K_5\\left(\\theta - \\theta_0\\right)^5 + K_6\\left(\\theta - \\theta_0\\right)^6\\]\nIn this expanded term 6 coefficients for the \\(E_a\\) formula need to be set:\n\n\\(\\theta_0\\) (degrees)\n\\(K_2\\) (energy/radian^2)\n\\(K_3\\) (energy/radian^3)\n\\(K_4\\) (energy/radian^4)\n\\(K_5\\) (energy/radian^5)\n\\(K_6\\) (energy/radian^6)\n\nThe bond-bond and bond-angle terms remain unchanged.",
    "syntax": "angle_style class2",
    "parameters": " * ",
    "examples": "angle_style class2\nangle_coeff * 75.0\nangle_coeff 1 bb 10.5872 1.0119 1.5228\nangle_coeff * ba 3.6551 24.895 1.0119 1.5228",
    "restrictions": "This angle style can only be used if LAMMPS was built with the CLASS2\npackage.  For the class2/p6 style LAMMPS needs to be built with the\nUSER-MOFFF package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style cosine",
    "html_filename": "angle_cosine.html",
    "short_description": "The cosine angle style uses the potential  \\[E = K [1 + \\cos(\\theta)]\\] where \\(K\\) is defined for each angle type",
    "description": "The cosine angle style uses the potential\n\n\\[E = K [1 + \\cos(\\theta)]\\]\nwhere \\(K\\) is defined for each angle type.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine",
    "parameters": " * ",
    "examples": "angle_style cosine\nangle_coeff * 75.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style cosine/buck6d",
    "html_filename": "angle_cosine_buck6d.html",
    "short_description": "The cosine/buck6d angle style uses the potential  \\[E = K \\left[ 1 + \\cos(n\\theta - \\theta_0)\\right]\\] where \\(K\\) is the energy constant, \\(n\\) is the periodic multiplicity and \\(\\theta_0\\) is the equilibrium angle",
    "description": "The cosine/buck6d angle style uses the potential\n\n\\[E = K \\left[ 1 + \\cos(n\\theta - \\theta_0)\\right]\\]\nwhere \\(K\\) is the energy constant, \\(n\\) is the periodic multiplicity and\n\\(\\theta_0\\) is the equilibrium angle.\nThe coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands in the following order:\n\n\\(K\\) (energy)\n\\(n\\)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally.\nAdditional to the cosine term the cosine/buck6d angle style computes\nthe short range (vdW) interaction belonging to the\npair_style buck6d between the end atoms of the\nangle.  For this reason this angle style only works in combination\nwith the pair_style buck6d styles and needs\nthe special_bonds 1-3 interactions to be weighted\n0.0 to prevent double counting.",
    "syntax": "angle_style cosine/buck6d",
    "parameters": " * ",
    "examples": "angle_style cosine/buck6d\nangle_coeff 1  cosine/buck6d  1.978350  4  180.000000",
    "restrictions": "cosine/buck6d can only be used in combination with the\npair_style buck6d style and with a\nspecial_bonds 0.0 weighting of 1-3 interactions.\nThis angle style can only be used if LAMMPS was built with the\nUSER-MOFFF package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style cosine/delta",
    "html_filename": "angle_cosine_delta.html",
    "short_description": "The cosine/delta angle style uses the potential  \\[E = K [1 - \\cos(\\theta - \\theta_0)]\\] where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a prefactor",
    "description": "The cosine/delta angle style uses the potential\n\n\\[E = K [1 - \\cos(\\theta - \\theta_0)]\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\nprefactor.  Note that the usual 1/2 factor is included in \\(K\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine/delta",
    "parameters": " * ",
    "examples": "angle_style cosine/delta\nangle_coeff 2*4 75.0 100.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style cosine/periodic",
    "html_filename": "angle_cosine_periodic.html",
    "short_description": "The cosine/periodic angle style uses the following potential, which is commonly used in the DREIDING force field, particularly for organometallic systems where \\(n\\) = 4 might be used for an octahedral complex and \\(n\\) = 3 might be used for a trigonal center:  \\[E = C \\left[ 1 - B(-1)^n\\cos\\left( n\\theta\\right) \\right]\\] where \\(C\\), \\(B\\) and \\(n\\) are coefficients defined for each angle type",
    "description": "The cosine/periodic angle style uses the following potential, which\nis commonly used in the DREIDING force field,\nparticularly for organometallic systems where \\(n\\) = 4 might be used\nfor an octahedral complex and \\(n\\) = 3 might be used for a trigonal\ncenter:\n\n\\[E = C \\left[ 1 - B(-1)^n\\cos\\left( n\\theta\\right) \\right]\\]\nwhere \\(C\\), \\(B\\) and \\(n\\) are coefficients defined for each angle type.\nSee (Mayo) for a description of the DREIDING force field\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(C\\) (energy)\n\\(B\\) = 1 or -1\n\\(n\\) = 1, 2, 3, 4, 5 or 6 for periodicity\n\nNote that the prefactor \\(C\\) is specified and not the overall force\nconstant \\(K = \\frac{C}{n^2}\\).  When \\(B = 1\\), it leads to a minimum for the\nlinear geometry.  When \\(B = -1\\), it leads to a maximum for the linear\ngeometry.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine/periodic",
    "parameters": " * ",
    "examples": "angle_style cosine/periodic\nangle_coeff * 75.0 1 6",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style cosine/shift",
    "html_filename": "angle_cosine_shift.html",
    "short_description": "The cosine/shift angle style uses the potential  \\[E = -\\frac{U_{\\text{min}}}{2} \\left[ 1 + \\cos(\\theta-\\theta_0) \\right]\\] where \\(\\theta_0\\) is the equilibrium angle",
    "description": "The cosine/shift angle style uses the potential\n\n\\[E = -\\frac{U_{\\text{min}}}{2} \\left[ 1 + \\cos(\\theta-\\theta_0) \\right]\\]\nwhere \\(\\theta_0\\) is the equilibrium angle. The potential is bounded\nbetween \\(-U_{\\text{min}}\\) and zero. In the neighborhood of the minimum\n\\(E = - U_{\\text{min}} + U_{\\text{min}}/4(\\theta - \\theta_0)^2\\) hence\nthe spring constant is \\(\\frac{U_{\\text{min}}}{2}\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(U_{\\text{min}}\\) (energy)\n\\(\\theta\\) (angle)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine/shift",
    "parameters": " * ",
    "examples": "angle_style cosine/shift\nangle_coeff * 10.0 45.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER-MISC package."
},
{
    "command": "angle_style cosine/shift/exp",
    "html_filename": "angle_cosine_shift_exp.html",
    "short_description": "The cosine/shift/exp angle style uses the potential  \\[E = -U_{\\text{min}} \\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad \\text{with} \\quad U(\\theta,\\theta_0) = -0",
    "description": "The cosine/shift/exp angle style uses the potential\n\n\\[E = -U_{\\text{min}} \\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad \\text{with} \\quad U(\\theta,\\theta_0) = -0.5 \\left(1+\\cos(\\theta-\\theta_0) \\right)\\]\nwhere \\(U_{\\text{min}}\\), \\(\\theta\\), and \\(a\\) are defined for each angle type.\nThe potential is bounded between \\([-U_{\\text{min}}, 0]\\) and the minimum is\nlocated at the angle \\(\\theta_0\\). The a parameter can be both positive or\nnegative and is used to control the spring constant at the\nequilibrium.\nThe spring constant is given by \\(k = A \\exp(A) U_{\\text{min}} / [2 (\\exp(a)-1)]\\).\nFor \\(a > 3\\), \\(\\frac{k}{U_{\\text{min}}} = \\frac{a}{2}\\) to better than 5% relative error. For negative\nvalues of the \\(a\\) parameter, the spring constant is essentially zero,\nand anharmonic terms takes over. The potential is furthermore well\nbehaved in the limit \\(a \\rightarrow 0\\), where it has been implemented to linear\norder in \\(a\\) for \\(a < 0.001\\). In this limit the potential reduces to the\ncosineshifted potential.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(U_min\\) (energy)\n\\(\\theta\\) (angle)\n\\(A\\) (real number)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine/shift/exp",
    "parameters": " * ",
    "examples": "angle_style cosine/shift/exp\nangle_coeff * 10.0 45.0 2.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style cosine/squared",
    "html_filename": "angle_cosine_squared.html",
    "short_description": "The cosine/squared angle style uses the potential  \\[E = K [\\cos(\\theta) - \\cos(\\theta_0)]^2\\] where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a prefactor",
    "description": "The cosine/squared angle style uses the potential\n\n\\[E = K [\\cos(\\theta) - \\cos(\\theta_0)]^2\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\nprefactor.  Note that the usual 1/2 factor is included in \\(K\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style cosine/squared",
    "parameters": " * ",
    "examples": "angle_style cosine/squared\nangle_coeff 2*4 75.0 100.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style cross",
    "html_filename": "angle_cross.html",
    "short_description": "The cross angle style uses a potential that couples the bond stretches of a bend with the angle stretch of that bend:  \\[E = K_{SS} \\left(r_{12}-r_{12,0}\\right)\\left(r_{32}-r_{32,0}\\right) + K_{BS0}\\left(r_{12}-r_{12,0}\\right)\\left(\\theta-\\theta_0\\right) + K_{BS1}\\left(r_{32}-r_{32,0}\\right)\\left(\\theta-\\theta_0\\right)\\] where \\(r_{12,0}\\) is the rest value of the bond length between atom 1 and 2, \\(r_{32,0}\\) is the rest value of the bond length between atom 3 and 2, and \\(\\theta_0\\) is the rest value of the angle",
    "description": "The cross angle style uses a potential that couples the bond stretches of\na bend with the angle stretch of that bend:\n\n\\[E = K_{SS} \\left(r_{12}-r_{12,0}\\right)\\left(r_{32}-r_{32,0}\\right) + K_{BS0}\\left(r_{12}-r_{12,0}\\right)\\left(\\theta-\\theta_0\\right) + K_{BS1}\\left(r_{32}-r_{32,0}\\right)\\left(\\theta-\\theta_0\\right)\\]\nwhere \\(r_{12,0}\\) is the rest value of the bond length between atom 1 and 2,\n\\(r_{32,0}\\) is the rest value of the bond length between atom 3 and 2,\nand \\(\\theta_0\\) is the rest value of the angle. \\(K_{SS}\\) is the force constant of\nthe bond stretch-bond stretch term and \\(K_{BS0}\\) and \\(K_{BS1}\\) are the force constants\nof the bond stretch-angle stretch terms.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K_{SS}\\) (energy/distance^2)\n\\(K_{BS0}\\) (energy/distance/rad)\n\\(K_{BS1}\\) (energy/distance/rad)\n\\(r_{12,0}\\) (distance)\n\\(r_{32,0}\\) (distance)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K_{BS0}\\) and \\(K_{BS1}\\) are in energy/distance/radian.",
    "syntax": "angle_style cross",
    "parameters": " * ",
    "examples": "angle_style cross\nangle_coeff 1 200.0 100.0 100.0 1.25 1.25 107.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_YAFF package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style dipole",
    "html_filename": "angle_dipole.html",
    "short_description": "The dipole angle style is used to control the orientation of a dipolar atom within a molecule (Orsi)",
    "description": "The dipole angle style is used to control the orientation of a dipolar\natom within a molecule (Orsi). Specifically, the dipole angle\nstyle restrains the orientation of a point dipole \\(\\mu_j\\) (embedded in atom\n\\(j\\)) with respect to a reference (bond) vector\n\\(\\vec{r_{ij}} = \\vec{r_i} - \\vec{r_j}\\), where \\(i\\) is another atom of\nthe same molecule (typically, \\(i\\) and \\(j\\) are also covalently bonded).\nIt is convenient to define an angle gamma between the ‘free’ vector \\(\\vec{\\mu_j}\\)\nand the reference (bond) vector \\(\\vec{r_{ij}}\\):\n\n\\[\\cos\\gamma = \\frac{\\vec{\\mu_j}\\cdot\\vec{r_{ij}}}{\\mu_j\\,r_{ij}}\\]\nThe dipole angle style uses the potential:\n\n\\[E = K (\\cos\\gamma - \\cos\\gamma_0)^2\\]\nwhere \\(K\\) is a rigidity constant and gamma0 is an equilibrium (reference)\nangle.\nThe torque on the dipole can be obtained by differentiating the\npotential using the ‘chain rule’ as in appendix C.3 of\n(Allen):\n\n\\[\\vec{T_j} = \\frac{2K(\\cos\\gamma - \\cos\\gamma_0)}{\\mu_j\\,r_{ij}}\\, \\vec{r_{ij}} \\times \\vec{\\mu_j}\\]\nExample: if \\(\\gamma_0\\) is set to 0 degrees, the torque generated by\nthe potential will tend to align the dipole along the reference\ndirection defined by the (bond) vector \\(\\vec{r_{ij}}\\) (in other words, \\(\\vec{\\mu_j}\\) is\nrestrained to point towards atom \\(i\\)).\nThe dipolar torque \\(\\vec{T_j}\\) must be counterbalanced in order to conserve\nthe local angular momentum. This is achieved via an additional force\ncouple generating a torque equivalent to the opposite of \\(\\vec{T_j}\\):\n\n\\[\\begin{split}-\\vec{T_j} & = \\vec{r_{ij}} \\times \\vec{F_i} \\\\\n\\vec{F_j}  & = -\\vec{F_i}\\end{split}\\]\nwhere \\(\\vec{F_i}\\) and \\(\\vec{F_j}\\) are applied on atoms \\(i\\)\nand \\(j\\), respectively.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(\\gamma_0\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style dipole",
    "parameters": " * ",
    "examples": "angle_style dipole\nangle_coeff 6 2.1 180.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info.\n\nNote\nIn the “Angles” section of the data file, the atom ID \\(j\\)\ndefining the direction of the dipole vector to restrain must come\nbefore the atom ID of the reference atom \\(i\\). A third atom ID \\(k\\) must\nalso be provided to comply with the requirement of a valid angle\ndefinition. This atom ID \\(k\\) should be chosen to be that of an atom\nbonded to atom \\(i\\) to avoid errors with “lost angle atoms” when running\nin parallel. Since the LAMMPS code checks for valid angle definitions,\ncannot use the same atom ID of either \\(i\\) or \\(j\\) (this was allowed\nand recommended with older LAMMPS versions).\n\nThe newton command for intramolecular interactions must be “on”\n(which is the default except when using some accelerator packages).\nThis angle style should not be used with SHAKE."
},
{
    "command": "angle_style fourier",
    "html_filename": "angle_fourier.html",
    "short_description": "The fourier angle style uses the potential  \\[E = K [C_0 + C_1 \\cos ( \\theta) + C_2 \\cos( 2 \\theta) ]\\] The following coefficients must be defined for each angle type via the angle_coeff command as in the example above, or in the data file or restart files read by the read_data or read_restart commands:  \\(K\\) (energy) \\(C_0\\) (real) \\(C_1\\) (real) \\(C_2\\) (real)   Styles with a gpu, intel, kk, omp, or opt suffix are functionally the same as the corresponding style without the suffix",
    "description": "The fourier angle style uses the potential\n\n\\[E = K [C_0 + C_1 \\cos ( \\theta) + C_2 \\cos( 2 \\theta) ]\\]\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(C_0\\) (real)\n\\(C_1\\) (real)\n\\(C_2\\) (real)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style fourier",
    "parameters": " * ",
    "examples": "angle_style fourier\nangle_coeff 75.0 1.0 1.0 1.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style fourier/simple",
    "html_filename": "angle_fourier_simple.html",
    "short_description": "The fourier/simple angle style uses the potential  \\[E = K [ 1",
    "description": "The fourier/simple angle style uses the potential\n\n\\[E = K [ 1.0 + c \\cos ( n \\theta) ]\\]\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy)\n\\(c\\) (real)\n\\(n\\) (real)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style fourier/simple",
    "parameters": " * ",
    "examples": "angle_style fourier/simple\nangle_coeff 100.0 -1.0 1.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style harmonic",
    "html_filename": "angle_harmonic.html",
    "short_description": "The harmonic angle style uses the potential  \\[E = K (\\theta - \\theta_0)^2\\] where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a prefactor",
    "description": "The harmonic angle style uses the potential\n\n\\[E = K (\\theta - \\theta_0)^2\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\nprefactor.  Note that the usual 1/2 factor is included in \\(K\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/radian^2)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K\\) are in energy/radian^2.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style harmonic",
    "parameters": " * ",
    "examples": "angle_style harmonic\nangle_coeff 1 300.0 107.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style hybrid",
    "html_filename": "angle_hybrid.html",
    "short_description": "The hybrid style enables the use of multiple angle styles in one simulation",
    "description": "The hybrid style enables the use of multiple angle styles in one\nsimulation.  An angle style is assigned to each angle type.  For\nexample, angles in a polymer flow (of angle type 1) could be computed\nwith a harmonic potential and angles in the wall boundary (of angle\ntype 2) could be computed with a cosine potential.  The assignment\nof angle type to style is made via the angle_coeff\ncommand or in the data file.\nIn the angle_coeff commands, the name of an angle style must be added\nafter the angle type, with the remaining coefficients being those\nappropriate to that style.  In the example above, the 2 angle_coeff\ncommands set angles of angle type 1 to be computed with a harmonic\npotential with coefficients 80.0, 30.0 for \\(K\\), \\(\\theta_0\\).  All other angle\ntypes \\((2 - N)\\) are computed with a cosine potential with coefficient\n50.0 for \\(K\\).\nIf angle coefficients are specified in the data file read via the\nread_data command, then the same rule applies.\nE.g. “harmonic” or “cosine”, must be added after the angle type, for each\nline in the “Angle Coeffs” section, e.g.\nAngle Coeffs\n\n1 harmonic 80.0 30.0\n2 cosine 50.0\n...\n\n\nIf class2 is one of the angle hybrid styles, the same rule holds for\nspecifying additional BondBond (and BondAngle) coefficients either via\nthe input script or in the data file.  I.e. class2 must be added to\neach line after the angle type.  For lines in the BondBond (or\nBondAngle) section of the data file for angle types that are not\nclass2, you must use an angle style of skip as a placeholder, e.g.\nBondBond Coeffs\n\n1 skip\n2 class2 3.6512 1.0119 1.0119\n...\n\n\nNote that it is not necessary to use the angle style skip in the\ninput script, since BondBond (or BondAngle) coefficients need not be\nspecified at all for angle types that are not class2.\nAn angle style of none with no additional coefficients can be used\nin place of an angle style, either in a input script angle_coeff\ncommand or in the data file, if you desire to turn off interactions\nfor specific angle types.",
    "syntax": "angle_style hybrid style1 style2 ...",
    "parameters": " * style1,style2 = list of one or more angle styles",
    "examples": "angle_style hybrid harmonic cosine\nangle_coeff 1 harmonic 80.0 30.0\nangle_coeff 2* cosine 50.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info.\nUnlike other angle styles, the hybrid angle style does not store angle\ncoefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a restart\nfile, you need to re-specify angle_coeff commands."
},
{
    "command": "angle_style mm3",
    "html_filename": "angle_mm3.html",
    "short_description": "The mm3 angle style uses the potential that is anharmonic in the angle as defined in (Allinger)  \\[E = K (\\theta - \\theta_0)^2 \\left[ 1 - 0",
    "description": "The mm3 angle style uses the potential that is anharmonic in the angle\nas defined in (Allinger)\n\n\\[E = K (\\theta - \\theta_0)^2 \\left[ 1 - 0.014(\\theta - \\theta_0) + 5.6(10)^{-5} (\\theta - \\theta_0)^2 - 7.0(10)^{-7} (\\theta - \\theta_0)^3 + 9(10)^{-10} (\\theta - \\theta_0)^4 \\right]\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\nprefactor. The anharmonic prefactors have units \\(\\deg^{-n}\\), for example\n\\(-0.014 \\deg^{-1}\\), \\(5.6 \\cdot 10^{-5} \\deg^{-2}\\), …\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/radian^2)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K\\) are in energy/radian^2.",
    "syntax": "angle_style mm3",
    "parameters": " * ",
    "examples": "angle_style mm3\nangle_coeff 1 100.0 107.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_YAFF package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style none",
    "html_filename": "angle_none.html",
    "short_description": "Using an angle style of none means angle forces and energies are not computed, even if triplets of angle atoms were listed in the data file read by the read_data command",
    "description": "Using an angle style of none means angle forces and energies are not\ncomputed, even if triplets of angle atoms were listed in the data file\nread by the read_data command.\nSee the angle_style zero command for a way to\ncalculate angle statistics, but compute no angle interactions.",
    "syntax": "angle_style none",
    "parameters": " * ",
    "examples": "angle_style none",
    "restrictions": "none"
},
{
    "command": "angle_style quartic",
    "html_filename": "angle_quartic.html",
    "short_description": "The quartic angle style uses the potential  \\[E = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4 (\\theta - \\theta_0)^4\\] where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a prefactor",
    "description": "The quartic angle style uses the potential\n\n\\[E = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4 (\\theta - \\theta_0)^4\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\nprefactor.  Note that the usual 1/2 factor is included in \\(K\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(\\theta_0\\) (degrees)\n\\(K_2\\) (energy/radian^2)\n\\(K_3\\) (energy/radian^3)\n\\(K_4\\) (energy/radian^4)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K\\) are in energy/radian^2.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style quartic",
    "parameters": " * ",
    "examples": "angle_style quartic\nangle_coeff 1 129.1948 56.8726 -25.9442 -14.2221",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style sdk",
    "html_filename": "angle_sdk.html",
    "short_description": "The sdk angle style is a combination of the harmonic angle potential,  \\[E = K (\\theta - \\theta_0)^2\\] where \\(\\theta_0\\) is the equilibrium value of the angle and \\(K\\) a prefactor, with the repulsive part of the non-bonded lj/sdk pair style between the atoms 1 and 3",
    "description": "The sdk angle style is a combination of the harmonic angle potential,\n\n\\[E = K (\\theta - \\theta_0)^2\\]\nwhere \\(\\theta_0\\) is the equilibrium value of the angle and\n\\(K\\) a prefactor, with the repulsive part of the non-bonded\nlj/sdk pair style between the atoms 1 and 3.  This angle potential is\nintended for coarse grained MD simulations with the CMM parameterization\nusing the pair_style lj/sdk.  Relative to the\npair_style lj/sdk, however, the energy is shifted by\n\\(\\epsilon\\), to avoid sudden jumps.  Note that the usual 1/2 factor\nis included in \\(K\\).\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above:\n\n\\(K\\) (energy/radian^2)\n\\(\\theta_0\\) (degrees)\n\n\\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of \\(K\\) are in energy/radian^2.\nThe also required lj/sdk parameters will be extracted automatically\nfrom the pair_style.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "angle_style sdk",
    "parameters": " * angle_style sdk/omp",
    "examples": "angle_style sdk\nangle_coeff 1 300.0 107.0",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER-CGSDK package.  See the Build package doc\npage for more info."
},
{
    "command": "angle_style table",
    "html_filename": "angle_table.html",
    "short_description": "Style table creates interpolation tables of length N from angle potential and derivative values listed in a file(s) as a function of angle The files are read by the angle_coeff command",
    "description": "Style table creates interpolation tables of length N from angle\npotential and derivative values listed in a file(s) as a function of\nangle The files are read by the angle_coeff\ncommand.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy and derivative values at each of\nN angles.  During a simulation, these tables are used to interpolate\nenergy and force values on individual atoms as needed.  The\ninterpolation is done in one of 2 styles: linear or spline.\nFor the linear style, the angle is used to find 2 surrounding table\nvalues from which an energy or its derivative is computed by linear\ninterpolation.\nFor the spline style, a cubic spline coefficients are computed and\nstored at each of the N values in the table.  The angle is used to\nfind the appropriate set of coefficients which are used to evaluate a\ncubic polynomial which computes the energy or derivative.\nThe following coefficients must be defined for each angle type via the\nangle_coeff command as in the example above.\n\nfilename\nkeyword\n\nThe filename specifies a file containing tabulated energy and\nderivative values.  The keyword specifies a section of the file.  The\nformat of this file is described below.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# Angle potential for harmonic (one or more comment or blank lines)\n\nHAM                           (keyword is the first text on line)\nN 181 FP 0 0 EQ 90.0          (N, FP, EQ parameters)\n                              (blank line)\nN 181 FP 0 0                  (N, FP parameters)\n1 0.0 200.5 2.5               (index, angle, energy, derivative)\n2 1.0 198.0 2.5\n...\n181 180.0 0.0 0.0\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the\nangle_coeff command.  The next line lists (in any\norder) one or more parameters for the table.  Each parameter is a\nkeyword followed by one or more numeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the angle_style table command.  Let\nNtable = N in the angle_style command, and Nfile = “N” in the\ntabulated file.  What LAMMPS does is a preliminary interpolation by\ncreating splines using the Nfile tabulated values as nodal points.  It\nuses these to interpolate as needed to generate energy and derivative\nvalues at Ntable different points.  The resulting tables of length\nNtable are then used as described above, when computing energy and\nforce for individual angles and their atoms.  This means that if you\nwant the interpolation tables of length Ntable to match exactly what\nis in the tabulated file (with effectively no preliminary\ninterpolation), you should set Ntable = Nfile.\nThe “FP” parameter is optional.  If used, it is followed by two values\nfplo and fphi, which are the 2nd derivatives at the innermost and\noutermost angle settings.  These values are needed by the spline\nconstruction routines.  If not specified by the “FP” parameter, they\nare estimated (less accurately) by the first two and last two\nderivative values in the table.\nThe “EQ” parameter is also optional.  If used, it is followed by a the\nequilibrium angle value, which is used, for example, by the fix shake command.  If not used, the equilibrium angle is\nset to 180.0.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nthe angle value (in degrees), the 3rd value is the energy (in energy\nunits), and the 4th is -dE/d(theta) (also in energy units).  The 3rd\nterm is the energy of the 3-atom configuration for the specified\nangle.  The last term is the derivative of the energy with respect to\nthe angle (in degrees, not radians).  Thus the units of the last term\nare still energy, not force.  The angle values must increase from one\nline to the next.  The angle values must also begin with 0.0 and end\nwith 180.0, i.e. span the full range of possible angles.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart info:\nThis angle style writes the settings for the “angle_style table”\ncommand to binary restart files, so a angle_style\ncommand does not need to specified in an input script that reads a\nrestart file.  However, the coefficient information is not stored in\nthe restart file, since it is tabulated in the potential files.  Thus,\nangle_coeff commands do need to be specified in the restart input\nscript.",
    "syntax": "angle_style table style N",
    "parameters": " * style = linear or spline = method of interpolation\n * N = use N values in table",
    "examples": "angle_style table linear 1000\nangle_coeff 3 file.table ENTRY1",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "angle_style zero",
    "html_filename": "angle_zero.html",
    "short_description": "Using an angle style of zero means angle forces and energies are not computed, but the geometry of angle triplets is still accessible to other commands",
    "description": "Using an angle style of zero means angle forces and energies are not\ncomputed, but the geometry of angle triplets is still accessible to\nother commands.\nAs an example, the compute angle/local\ncommand can be used to compute the theta values for the list of\ntriplets of angle atoms listed in the data file read by the\nread_data command.  If no angle style is defined,\nthis command cannot be used.\nThe optional nocoeff flag allows to read data files with AngleCoeff\nsection for any angle style. Similarly, any angle_coeff commands\nwill only be checked for the angle type number and the rest ignored.\nNote that the angle_coeff command must be used for\nall angle types. If specified, there can be only one value, which is\ngoing to be used to assign an equilibrium angle, e.g. for use with\nfix shake.",
    "syntax": "angle_style zero *nocoeff*",
    "parameters": " * ",
    "examples": "angle_style zero\nangle_style zero nocoeff\nangle_coeff *\nangle_coeff * 120.0",
    "restrictions": "\nnone"
},
{
    "command": "third_order",
    "html_filename": "third_order.html",
    "short_description": "Calculate the third order force constant tensor by finite difference of the selected group,  where Phi is the third order force constant tensor",
    "description": "Calculate the third order force constant tensor by finite difference of the selected group,\n\nwhere Phi is the third order force constant tensor.\nThe output of the command is the tensor, three elements at a time. The\nthree elements correspond to the three gamma elements for a specific i/alpha/j/beta/k.\nThe initial five numbers are i, alpha, j, beta, and k respectively.\nIf the style eskm is selected, the tensor will be using energy units of 10 J/mol.\nThese units conform to eskm style from the dynamical_matrix command, which\nwill simplify operations using dynamical matrices with third order tensors.",
    "syntax": "third_order group-ID style delta args keyword value ...",
    "parameters": " * group-ID = ID of group of atoms to displace\n * style = regular or eskm\n * delta = finite different displacement length (distance units)\n * one or more keyword/arg pairs may be appended\n * keyword = file or binary\n *   file name = name of output file for the third order tensor\n *   binary arg = yes or no or gzip",
    "examples": "third_order 1 regular 0.000001\nthird_order 1 eskm 0.000001\nthird_order 3 regular 0.00004 file third_order.dat\nthird_order 5 eskm 0.00000001 file third_order.dat binary yes",
    "restrictions": "The command collects a 9 times the number of atoms in the group on every single MPI rank,\nso the memory requirements can be very significant for large systems.\nThis command is part of the USER-PHONON package.  It is only enabled if\nLAMMPS was built with that package.  See the Build package doc page for more info."
},
{
    "command": "improper_style class2",
    "html_filename": "improper_class2.html",
    "short_description": "The class2 improper style uses the potential  \\[\\begin{split}E      = & E_i + E_{aa} \\\\ E_i    = & K [ \\frac{\\chi_{ijkl} + \\chi_{kjli} + \\chi_{ljik}}{3} - \\chi_0 ]^2 \\\\ E_{aa} = & M_1 (\\theta_{ijk} - \\theta_1) (\\theta_{kjl} - \\theta_3) + \\\\          & M_2 (\\theta_{ijk} - \\theta_1) (\\theta_{ijl} - \\theta_2) + \\\\          & M_3 (\\theta_{ijl} - \\theta_2) (\\theta_{kjl} - \\theta_3)\\end{split}\\] where \\(E_i\\) is the improper term and \\(E_{aa}\\) is an angle-angle term",
    "description": "The class2 improper style uses the potential\n\n\\[\\begin{split}E      = & E_i + E_{aa} \\\\\nE_i    = & K [ \\frac{\\chi_{ijkl} + \\chi_{kjli} + \\chi_{ljik}}{3} - \\chi_0 ]^2 \\\\\nE_{aa} = & M_1 (\\theta_{ijk} - \\theta_1) (\\theta_{kjl} - \\theta_3) + \\\\\n         & M_2 (\\theta_{ijk} - \\theta_1) (\\theta_{ijl} - \\theta_2) + \\\\\n         & M_3 (\\theta_{ijl} - \\theta_2) (\\theta_{kjl} - \\theta_3)\\end{split}\\]\nwhere \\(E_i\\) is the improper term and \\(E_{aa}\\) is an\nangle-angle term.  The 3 \\(\\chi\\) terms in \\(E_i\\) are an\naverage over 3 out-of-plane angles.\nThe 4 atoms in an improper quadruplet (listed in the data file read by\nthe read_data command) are ordered I,J,K,L.\n\\(\\chi_{ijkl}\\) refers to the angle between the plane of I,J,K and\nthe plane of J,K,L, and the bond JK lies in both planes.  Similarly for\n\\(\\chi_{kjli}\\) and \\(\\chi_{ljik}\\).\nNote that atom J appears in the common bonds (JI, JK, JL) of all 3 X\nterms.  Thus J (the 2nd atom in the quadruplet) is the atom of\nsymmetry in the 3 \\(\\chi\\) angles.\nThe subscripts on the various \\(\\theta\\)s refer to different\ncombinations of 3 atoms (I,J,K,L) used to form a particular angle.\nE.g. \\(\\theta_{ijl}\\) is the angle formed by atoms I,J,L with J\nin the middle.  \\(\\theta_1\\), \\(\\theta_2\\), \\(\\theta_3\\)\nare the equilibrium positions of those angles.  Again,\natom J (the 2nd atom in the quadruplet) is the atom of symmetry in the\ntheta angles, since it is always the center atom.\nSince atom J is the atom of symmetry, normally the bonds J-I, J-K, J-L\nwould exist for an improper to be defined between the 4 atoms, but\nthis is not required.\nSee (Sun) for a description of the COMPASS class2 force field.\nCoefficients for the \\(E_i\\) and \\(E_{aa}\\) formulas must be\ndefined for each\nimproper type via the improper_coeff command as\nin the example above, or in the data file or restart files read by the\nread_data or read_restart\ncommands.\nThese are the 2 coefficients for the \\(E_i\\) formula:\n\n\\(K\\) (energy/radian^2)\n\\(\\chi_0\\) (degrees)\n\n\\(\\chi_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of K are in energy/radian^2.\nFor the \\(E_{aa}\\) formula, each line in a\nimproper_coeff command in the input script lists\n7 coefficients, the first of which is aa to indicate they are\nAngleAngle coefficients.  In a data file, these coefficients should be\nlisted under a AngleAngle Coeffs heading and you must leave out the\naa, i.e. only list 6 coefficients after the improper type.\n\naa\n\\(M_1\\) (energy/distance)\n\\(M_2\\) (energy/distance)\n\\(M_3\\) (energy/distance)\n\\(\\theta_1\\) (degrees)\n\\(\\theta_2\\) (degrees)\n\\(\\theta_3\\) (degrees)\n\nThe theta values are specified in degrees, but LAMMPS converts them to\nradians internally; hence the units of M are in energy/radian^2.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style class2",
    "parameters": " * ",
    "examples": "improper_style class2\nimproper_coeff 1 100.0 0\nimproper_coeff * aa 0.0 0.0 0.0 115.06 130.01 115.06",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nCLASS2 package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style cossq",
    "html_filename": "improper_cossq.html",
    "short_description": "The cossq improper style uses the potential  \\[E = \\frac{1}{2} K \\cos^2{\\left(\\chi - \\chi_0\\right)}\\] where \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its equilibrium value, and \\(K\\) is a prefactor",
    "description": "The cossq improper style uses the potential\n\n\\[E = \\frac{1}{2} K \\cos^2{\\left(\\chi - \\chi_0\\right)}\\]\nwhere \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its\nequilibrium value, and \\(K\\) is a prefactor.\nIf the 4 atoms in an improper quadruplet (listed in the data file read\nby the read_data command) are ordered I,J,K,L then\n\\(\\chi\\) is the angle between the plane of I,J,K and the plane of J,K,L.\nAlternatively, you can think of atoms J,K,L as being in a plane, and\natom I above the plane, and \\(\\chi\\) as a measure of how far\nout-of-plane I is with respect to the other 3 atoms.\nNote that defining 4 atoms to interact in this way, does not mean that\nbonds necessarily exist between I-J, J-K, or K-L, as they would in a\nlinear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\nimproper to be defined between the 4 atoms.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(\\chi_0\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style cossq",
    "parameters": " * ",
    "examples": "improper_style cossq\nimproper_coeff 1 4.0 0.0",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style cvff",
    "html_filename": "improper_cvff.html",
    "short_description": "The cvff improper style uses the potential  \\[E = K [1 + d  \\cos (n \\phi) ]\\] where phi is the improper dihedral angle",
    "description": "The cvff improper style uses the potential\n\n\\[E = K [1 + d  \\cos (n \\phi) ]\\]\nwhere phi is the improper dihedral angle.\nIf the 4 atoms in an improper quadruplet (listed in the data file read\nby the read_data command) are ordered I,J,K,L then\nthe improper dihedral angle is between the plane of I,J,K and the\nplane of J,K,L.  Note that because this is effectively a dihedral\nangle, the formula for this improper style is the same as for\ndihedral_style harmonic.\nNote that defining 4 atoms to interact in this way, does not mean that\nbonds necessarily exist between I-J, J-K, or K-L, as they would in a\nlinear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\nimproper to be defined between the 4 atoms.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(d\\) (+1 or -1)\n\\(n\\) (0,1,2,3,4,6)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style cvff",
    "parameters": " * ",
    "examples": "improper_style cvff\nimproper_coeff 1 80.0 -1 4",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "improper_style distance",
    "html_filename": "improper_distance.html",
    "short_description": "The distance improper style uses the potential  \\[E = K_2 d^2 + K_4 d^4\\] where \\(d\\) is the distance between the central atom and the plane formed by the other three atoms",
    "description": "The distance improper style uses the potential\n\n\\[E = K_2 d^2 + K_4 d^4\\]\nwhere \\(d\\) is the distance between the central atom and the plane formed\nby the other three atoms.  If the 4 atoms in an improper quadruplet\n(listed in the data file read by the read_data\ncommand) are ordered I,J,K,L then the I-atom is assumed to be the\ncentral atom.\n\nNote that defining 4 atoms to interact in this way, does not mean that\nbonds necessarily exist between I-J, J-K, or K-L, as they would in a\nlinear dihedral. Normally, the bonds I-J, I-K, I-L would exist for an\nimproper to be defined between the 4 atoms.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example above, or in the data\nfile or restart files read by the read_data or read_restart commands:\n\n\\(K_2\\) (energy/distance^2)\n\\(K_4\\) (energy/distance^4)",
    "syntax": "improper_style distance",
    "parameters": " * ",
    "examples": "improper_style distance\nimproper_coeff 1 80.0 100.0",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style distharm",
    "html_filename": "improper_distharm.html",
    "short_description": "The distharm improper style uses the potential  \\[E = K (d - d_0)^2\\] where \\(d\\) is the oriented distance between the central atom and the plane formed by the other three atoms",
    "description": "The distharm improper style uses the potential\n\n\\[E = K (d - d_0)^2\\]\nwhere \\(d\\) is the oriented distance between the central atom and the plane formed\nby the other three atoms.  If the 4 atoms in an improper quadruplet\n(listed in the data file read by the read_data\ncommand) are ordered I,J,K,L then the L-atom is assumed to be the\ncentral atom. Note that this is different from the convention used\nin the improper_style distance. The distance \\(d\\) is oriented and can take\non negative values. This may lead to unwanted behavior if \\(d_0\\) is not equal to zero.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example above, or in the data\nfile or restart files read by the read_data or read_restart commands:\n\n\\(K\\) (energy/distance^2)\n\\(d_0\\) (distance)",
    "syntax": "improper_style distharm",
    "parameters": " * ",
    "examples": "improper_style distharm\nimproper_coeff 1 25.0 0.5",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-YAFF package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style fourier",
    "html_filename": "improper_fourier.html",
    "short_description": "The fourier improper style uses the following potential:  \\[E = K [C_0 + C_1 \\cos ( \\omega) + C_2 \\cos( 2 \\omega) ]\\] where K is the force constant, C0, C1, C2 are dimensionless coefficients, and omega is the angle between the IL axis and the IJK plane:  If all parameter (see below) is not zero, the all the three possible angles will taken in account",
    "description": "The fourier improper style uses the following potential:\n\n\\[E = K [C_0 + C_1 \\cos ( \\omega) + C_2 \\cos( 2 \\omega) ]\\]\nwhere K is the force constant, C0, C1, C2 are dimensionless coefficients,\nand omega is the angle between the IL axis and the IJK plane:\n\nIf all parameter (see below) is not zero, the all the three possible angles will taken in account.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(C_0\\) (unitless)\n\\(C_1\\) (unitless)\n\\(C_2\\) (unitless)\nall  (0 or 1, optional)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style fourier",
    "parameters": " * ",
    "examples": "improper_style fourier\nimproper_coeff 1 100.0 0.0 1.0 0.5 1",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\nUSER_MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style harmonic",
    "html_filename": "improper_harmonic.html",
    "short_description": "The harmonic improper style uses the potential  \\[E = K (\\chi - \\chi_0)^2\\] where \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its equilibrium value, and \\(K\\) is a prefactor",
    "description": "The harmonic improper style uses the potential\n\n\\[E = K (\\chi - \\chi_0)^2\\]\nwhere \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its equilibrium\nvalue, and \\(K\\) is a prefactor.  Note that the usual 1/2 factor is\nincluded in \\(K\\).\nIf the 4 atoms in an improper quadruplet (listed in the data file read\nby the read_data command) are ordered I,J,K,L then\n\\(\\chi\\)\nis the angle between the plane of I,J,K and the plane of J,K,L.\nAlternatively, you can think of atoms J,K,L as being in a plane, and\natom I above the plane, and \\(\\chi\\) as a measure of how far out-of-plane\nI is with respect to the other 3 atoms.\nNote that defining 4 atoms to interact in this way, does not mean that\nbonds necessarily exist between I-J, J-K, or K-L, as they would in a\nlinear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\nimproper to be defined between the 4 atoms.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy/radian^2)\n\\(\\chi_0\\) (degrees)\n\n\\(\\chi_0\\) is specified in degrees, but LAMMPS converts it to radians\ninternally; hence the units of K are in energy/radian^2.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style harmonic",
    "parameters": " * ",
    "examples": "improper_style harmonic\nimproper_coeff 1 100.0 0",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "improper_style hybrid",
    "html_filename": "improper_hybrid.html",
    "short_description": "The hybrid style enables the use of multiple improper styles in one simulation",
    "description": "The hybrid style enables the use of multiple improper styles in one\nsimulation.  An improper style is assigned to each improper type.  For\nexample, impropers in a polymer flow (of improper type 1) could be\ncomputed with a harmonic potential and impropers in the wall\nboundary (of improper type 2) could be computed with a cvff\npotential.  The assignment of improper type to style is made via the\nimproper_coeff command or in the data file.\nIn the improper_coeff command, the first coefficient sets the improper\nstyle and the remaining coefficients are those appropriate to that\nstyle.  In the example above, the 2 improper_coeff commands would set\nimpropers of improper type 1 to be computed with a harmonic\npotential with coefficients 120.0, 30 for \\(K\\), \\(\\chi_0\\).\nImproper type 2 would be computed with a cvff potential with coefficients\n20.0, -1, 2 for K, d, and n, respectively.\nIf the improper class2 potential is one of the hybrid styles, it\nrequires additional AngleAngle coefficients be specified in the data\nfile.  These lines must also have an additional “class2” argument\nadded after the improper type.  For improper types which are assigned\nto other hybrid styles, use the style name (e.g. “harmonic”)\nappropriate to that style.  The AngleAngle coeffs for that improper\ntype will then be ignored.\nAn improper style of none can be specified as the 2nd argument to\nthe improper_coeff command, if you desire to turn off certain improper\ntypes.",
    "syntax": "improper_style hybrid style1 style2 ...",
    "parameters": " * style1,style2 = list of one or more improper styles",
    "examples": "improper_style hybrid harmonic helix\nimproper_coeff 1 harmonic 120.0 30\nimproper_coeff 2 cvff 20.0 -1 2",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info.\nUnlike other improper styles, the hybrid improper style does not store\nimproper coefficient info for individual sub-styles in a binary restart files.\nThus when restarting a simulation from a\nrestart file, you need to re-specify improper_coeff commands."
},
{
    "command": "improper_style inversion/harmonic",
    "html_filename": "improper_inversion_harmonic.html",
    "short_description": "The inversion/harmonic improper style follows the Wilson-Decius out-of-plane angle definition and uses an harmonic potential:  \\[E = K \\left(\\omega - \\omega_0\\right)^2\\] where \\(K\\) is the force constant and \\(\\omega\\) is the angle evaluated for all three axis-plane combinations centered around the atom I",
    "description": "The inversion/harmonic improper style follows the Wilson-Decius\nout-of-plane angle definition and uses an harmonic potential:\n\n\\[E = K \\left(\\omega - \\omega_0\\right)^2\\]\nwhere \\(K\\) is the force constant and \\(\\omega\\) is the angle\nevaluated for all three axis-plane combinations centered around the atom I.\nFor the IL axis and the IJK plane \\(\\omega\\) looks as follows:\n\nNote that the inversion/harmonic angle term evaluation differs to\nthe improper_umbrella due to the cyclic\nevaluation of all possible angles \\(\\omega\\).\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(\\omega_0\\) (degrees)\n\nIf \\(\\omega_0 = 0\\) the potential term has a single minimum for\nthe planar structure.  Otherwise it has two minima at +/- \\(\\omega_0\\),\nwith a barrier in between.",
    "syntax": "improper_style inversion/harmonic",
    "parameters": " * ",
    "examples": "improper_style inversion/harmonic\nimproper_coeff 1 18.776340 0.000000",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-MOFFF package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style none",
    "html_filename": "improper_none.html",
    "short_description": "Using an improper style of none means improper forces and energies are not computed, even if quadruplets of improper atoms were listed in the data file read by the read_data command",
    "description": "Using an improper style of none means improper forces and energies are\nnot computed, even if quadruplets of improper atoms were listed in the\ndata file read by the read_data command.\nSee the improper_style zero command for a way to\ncalculate improper statistics, but compute no improper interactions.",
    "syntax": "improper_style none",
    "parameters": " * ",
    "examples": "improper_style none",
    "restrictions": "\nnone"
},
{
    "command": "improper_style ring",
    "html_filename": "improper_ring.html",
    "short_description": "The ring improper style uses the potential  \\[\\begin{split}E = &\\frac{1}{6} K \\left(\\Delta_{ijl} + \\Delta_{ijk} + \\Delta_{kjl} \\right)^6 \\\\ \\Delta_{ijl} = & \\cos{\\theta_{ijl} - \\cos{\\theta_0}} \\\\ \\Delta_{ijk} = & \\cos{\\theta_{ijk} - \\cos{\\theta_0}} \\\\ \\Delta_{kjl} = & \\cos{\\theta_{kjl} - \\cos{\\theta_0}}\\end{split}\\] where \\(K\\) is a prefactor, \\(\\theta\\) is the angle formed by the atoms specified by (i,j,k,l) indices and \\(\\theta_0\\) its equilibrium value",
    "description": "The ring improper style uses the potential\n\n\\[\\begin{split}E = &\\frac{1}{6} K \\left(\\Delta_{ijl} + \\Delta_{ijk} + \\Delta_{kjl} \\right)^6 \\\\\n\\Delta_{ijl} = & \\cos{\\theta_{ijl} - \\cos{\\theta_0}} \\\\\n\\Delta_{ijk} = & \\cos{\\theta_{ijk} - \\cos{\\theta_0}} \\\\\n\\Delta_{kjl} = & \\cos{\\theta_{kjl} - \\cos{\\theta_0}}\\end{split}\\]\nwhere \\(K\\) is a prefactor, \\(\\theta\\) is the angle formed by\nthe atoms specified by (i,j,k,l) indices and \\(\\theta_0\\) its\nequilibrium value.\nIf the 4 atoms in an improper quadruplet (listed in the data file read\nby the read_data command) are ordered i,j,k,l then\ntheta_ijl is the angle between atoms i,j and l, theta_ijk is the\nangle between atoms i,j and k, theta_kjl is the angle between atoms\nj,k, and l.\nThe “ring” improper style implements the improper potential introduced\nby Destree et al., in Equation (9) of (Destree).  This\npotential does not affect small amplitude vibrations but is used in an\nad-hoc way to prevent the onset of accidentally large amplitude\nfluctuations leading to the occurrence of a planar conformation of the\nthree bonds i-j, j-k and j-l, an intermediate conformation toward the\nchiral inversion of a methine carbon.  In the “Impropers” section of\ndata file four atoms: i, j, k and l are specified with i,j and l lying\non the backbone of the chain and k specifying the chirality of j.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(\\theta_0\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style ring",
    "parameters": " * ",
    "examples": "improper_style ring\nimproper_coeff 1 8000 70.5",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "improper_style umbrella",
    "html_filename": "improper_umbrella.html",
    "short_description": "The umbrella improper style uses the following potential, which is commonly referred to as a classic inversion and used in the DREIDING force field:  \\[\\begin{split}E = & \\frac{1}{2}K\\left( \\frac{1}{\\sin\\omega_0}\\right) ^2 \\left( \\cos\\omega - \\cos\\omega_0\\right) ^2 \\qquad \\omega_0 \\neq 0^o \\\\ E = & K\\left( 1-cos\\omega\\right)  \\qquad \\omega_0 = 0^o\\end{split}\\] where \\(K\\) is the force constant and \\(\\omega\\) is the angle between the IL axis and the IJK plane:  If \\(\\omega_0 = 0\\) the potential term has a minimum for the planar structure",
    "description": "The umbrella improper style uses the following potential, which is\ncommonly referred to as a classic inversion and used in the\nDREIDING force field:\n\n\\[\\begin{split}E = & \\frac{1}{2}K\\left( \\frac{1}{\\sin\\omega_0}\\right) ^2 \\left( \\cos\\omega - \\cos\\omega_0\\right) ^2 \\qquad \\omega_0 \\neq 0^o \\\\\nE = & K\\left( 1-cos\\omega\\right)  \\qquad \\omega_0 = 0^o\\end{split}\\]\nwhere \\(K\\) is the force constant and \\(\\omega\\) is the angle between the IL\naxis and the IJK plane:\n\nIf \\(\\omega_0 = 0\\) the potential term has a minimum for the planar\nstructure.  Otherwise it has two minima at \\(\\omega +/- \\omega_0\\),\nwith a barrier in between.\nSee (Mayo) for a description of the DREIDING force field.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example\nabove, or in the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(K\\) (energy)\n\\(\\omega_0\\) (degrees)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "improper_style umbrella",
    "parameters": " * ",
    "examples": "improper_style umbrella\nimproper_coeff 1 100.0 180.0",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nMOLECULE package.  See the Build package doc page\nfor more info."
},
{
    "command": "improper_style zero",
    "html_filename": "improper_zero.html",
    "short_description": "Using an improper style of zero means improper forces and energies are not computed, but the geometry of improper quadruplets is still accessible to other commands",
    "description": "Using an improper style of zero means improper forces and energies are\nnot computed, but the geometry of improper quadruplets is still\naccessible to other commands.\nAs an example, the compute improper/local command can be used to\ncompute the chi values for the list of quadruplets of improper atoms\nlisted in the data file read by the read_data\ncommand.  If no improper style is defined, this command cannot be\nused.\nThe optional nocoeff flag allows to read data files with a ImproperCoeff\nsection for any improper style. Similarly, any improper_coeff commands\nwill only be checked for the improper type number and the rest ignored.\nNote that the improper_coeff command must be\nused for all improper types, though no additional values are\nspecified.",
    "syntax": "improper_style zero [nocoeff]",
    "parameters": " * ",
    "examples": "improper_style zero\nimproper_style zero nocoeff\nimproper_coeff *",
    "restrictions": "\nnone\n\nRelated commands: none\nimproper_style none\nDefault: none"
},
{
    "command": "bond_style class2",
    "html_filename": "bond_class2.html",
    "short_description": "The class2 bond style uses the potential  \\[E = K_2 (r - r_0)^2 + K_3 (r - r_0)^3 + K_4 (r - r_0)^4\\] where \\(r_0\\) is the equilibrium bond distance",
    "description": "The class2 bond style uses the potential\n\n\\[E = K_2 (r - r_0)^2 + K_3 (r - r_0)^3 + K_4 (r - r_0)^4\\]\nwhere \\(r_0\\) is the equilibrium bond distance.\nSee (Sun) for a description of the COMPASS class2 force field.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(r_0\\) (distance)\n\\(K_2\\) (energy/distance^2)\n\\(K_3\\) (energy/distance^3)\n\\(K_4\\) (energy/distance^4)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style class2",
    "parameters": " * ",
    "examples": "bond_style class2\nbond_coeff 1 1.0 100.0 80.0 80.0",
    "restrictions": "This bond style can only be used if LAMMPS was built with the CLASS2\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style fene",
    "html_filename": "bond_fene.html",
    "short_description": "The fene bond style uses the potential  \\[E = -0",
    "description": "The fene bond style uses the potential\n\n\\[E = -0.5 K R_0^2  \\ln \\left[ 1 - \\left(\\frac{r}{R_0}\\right)^2\\right] + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + \\epsilon\\]\nto define a finite extensible nonlinear elastic (FENE) potential\n(Kremer), used for bead-spring polymer models.  The first\nterm is attractive, the 2nd Lennard-Jones term is repulsive.  The\nfirst term extends to \\(R_0\\), the maximum extent of the bond.  The 2nd\nterm is cutoff at \\(2^\\frac{1}{6} \\sigma\\), the minimum of the LJ potential.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^2)\n\\(R_0\\) (distance)\n\\(\\epsilon\\) (energy)\n\\(\\sigma\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style fene",
    "parameters": " * ",
    "examples": "bond_style fene\nbond_coeff 1 30.0 1.5 1.0 1.0",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo.\nYou typically should specify special_bonds fene\nor special_bonds lj/coul 0 1 1 to use this bond\nstyle.  LAMMPS will issue a warning it that’s not the case."
},
{
    "command": "bond_style fene/expand",
    "html_filename": "bond_fene_expand.html",
    "short_description": "The fene/expand bond style uses the potential  \\[E = -0",
    "description": "The fene/expand bond style uses the potential\n\n\\[E = -0.5 K R_0^2 \\ln \\left[1 -\\left( \\frac{\\left(r - \\Delta\\right)}{R_0}\\right)^2 \\right] + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{\\left(r - \\Delta\\right)}\\right)^{12} - \\left(\\frac{\\sigma}{\\left(r - \\Delta\\right)}\\right)^6 \\right] + \\epsilon\\]\nto define a finite extensible nonlinear elastic (FENE) potential\n(Kremer), used for bead-spring polymer models.  The first\nterm is attractive, the 2nd Lennard-Jones term is repulsive.\nThe fene/expand bond style is similar to fene except that an extra\nshift factor of \\(\\Delta\\) (positive or negative) is added to \\(r\\) to\neffectively change the bead size of the bonded atoms.  The first term\nnow extends to \\(R_0 + \\Delta\\) and the 2nd term is cutoff at \\(2^\\frac{1}{6} \\sigma + \\Delta\\).\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^2)\n\\(R_0\\) (distance)\n\\(\\epsilon\\) (energy)\n\\(\\sigma\\) (distance)\n\\(\\Delta\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style fene/expand",
    "parameters": " * ",
    "examples": "bond_style fene/expand\nbond_coeff 1 30.0 1.5 1.0 1.0 0.5",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo.\nYou typically should specify special_bonds fene\nor special_bonds lj/coul 0 1 1 to use this bond\nstyle.  LAMMPS will issue a warning it that’s not the case."
},
{
    "command": "bond_style gromos",
    "html_filename": "bond_gromos.html",
    "short_description": "The gromos bond style uses the potential  \\[E = K (r^2 - r_0^2)^2\\] where \\(r_0\\) is the equilibrium bond distance",
    "description": "The gromos bond style uses the potential\n\n\\[E = K (r^2 - r_0^2)^2\\]\nwhere \\(r_0\\) is the equilibrium bond distance.  Note that the usual 1/4\nfactor is included in \\(K\\).\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^4)\n\\(r_0\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style gromos",
    "parameters": " * ",
    "examples": "bond_style gromos\nbond_coeff 5 80.0 1.2",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style harmonic",
    "html_filename": "bond_harmonic.html",
    "short_description": "The harmonic bond style uses the potential  \\[E = K (r - r_0)^2\\] where \\(r_0\\) is the equilibrium bond distance",
    "description": "The harmonic bond style uses the potential\n\n\\[E = K (r - r_0)^2\\]\nwhere \\(r_0\\) is the equilibrium bond distance.  Note that the usual 1/2\nfactor is included in \\(K\\).\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^2)\n\\(r_0\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style harmonic",
    "parameters": " * ",
    "examples": "bond_style harmonic\nbond_coeff 5 80.0 1.2",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style harmonic/shift",
    "html_filename": "bond_harmonic_shift.html",
    "short_description": "The harmonic/shift bond style is a shifted harmonic bond that uses the potential  \\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\] where \\(r_0\\) is the equilibrium bond distance, and \\(r_c\\) the critical distance",
    "description": "The harmonic/shift bond style is a shifted harmonic bond that uses\nthe potential\n\n\\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\]\nwhere \\(r_0\\) is the equilibrium bond distance, and \\(r_c\\) the critical distance.\nThe potential is \\(-U_{\\text{min}}\\) at \\(r0\\) and zero at \\(r_c\\). The spring constant is\n\\(k = U_{\\text{min}} / [ 2 (r_0-r_c)^2]\\).\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(U_{\\text{min}}\\) (energy)\n\\(r_0\\) (distance)\n\\(r_c\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style harmonic/shift",
    "parameters": " * ",
    "examples": "bond_style harmonic/shift\nbond_coeff 5 10.0 0.5 1.0",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "bond_style harmonic/shift/cut",
    "html_filename": "bond_harmonic_shift_cut.html",
    "short_description": "The harmonic/shift/cut bond style is a shifted harmonic bond that uses the potential  \\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\] where \\(r_0\\) is the equilibrium bond distance, and rc the critical distance",
    "description": "The harmonic/shift/cut bond style is a shifted harmonic bond that\nuses the potential\n\n\\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\]\nwhere \\(r_0\\) is the equilibrium bond distance, and rc the critical distance.\nThe bond potential is zero for distances \\(r > r_c\\). The potential is \\(-U_{\\text{min}}\\)\nat \\(r_0\\) and zero at \\(r_c\\). The spring constant is \\(k = U_{\\text{min}} / [ 2 (r_0-r_c)^2]\\).\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(U_{\\text{min}}\\) (energy)\n\\(r_0\\) (distance)\n\\(r_c\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style harmonic/shift/cut",
    "parameters": " * ",
    "examples": "bond_style harmonic/shift/cut\nbond_coeff 5 10.0 0.5 1.0",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
{
    "command": "bond_style hybrid",
    "html_filename": "bond_hybrid.html",
    "short_description": "The hybrid style enables the use of multiple bond styles in one simulation",
    "description": "The hybrid style enables the use of multiple bond styles in one\nsimulation.  A bond style is assigned to each bond type.  For example,\nbonds in a polymer flow (of bond type 1) could be computed with a\nfene potential and bonds in the wall boundary (of bond type 2) could\nbe computed with a harmonic potential.  The assignment of bond type\nto style is made via the bond_coeff command or in\nthe data file.\nIn the bond_coeff commands, the name of a bond style must be added\nafter the bond type, with the remaining coefficients being those\nappropriate to that style.  In the example above, the 2 bond_coeff\ncommands set bonds of bond type 1 to be computed with a harmonic\npotential with coefficients 80.0, 1.2 for \\(K\\), \\(r_0\\).  All other bond types\n(2-N) are computed with a fene potential with coefficients 30.0,\n1.5, 1.0, 1.0 for \\(K\\), \\(R_0\\), \\(\\epsilon\\), \\(\\sigma\\).\nIf bond coefficients are specified in the data file read via the\nread_data command, then the same rule applies.\nE.g. “harmonic” or “fene” must be added after the bond type, for each\nline in the “Bond Coeffs” section, e.g.\nBond Coeffs\n\n1 harmonic 80.0 1.2\n2 fene 30.0 1.5 1.0 1.0\n...\n\n\nA bond style of none with no additional coefficients can be used in\nplace of a bond style, either in a input script bond_coeff command or\nin the data file, if you desire to turn off interactions for specific\nbond types.",
    "syntax": "bond_style hybrid style1 style2 ...",
    "parameters": " * style1,style2 = list of one or more bond styles",
    "examples": "",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo.\nUnlike other bond styles, the hybrid bond style does not store bond\ncoefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a restart\nfile, you need to re-specify bond_coeff commands."
},
{
    "command": "bond_style mm3",
    "html_filename": "bond_mm3.html",
    "short_description": "The mm3 bond style uses the potential that is anharmonic in the bond as defined in (Allinger)  \\[E = K (r - r_0)^2 \\left[ 1 - 2",
    "description": "The mm3 bond style uses the potential that is anharmonic in the bond\nas defined in (Allinger)\n\n\\[E = K (r - r_0)^2 \\left[ 1 - 2.55(r-r_0) + (7/12) 2.55^2(r-r_0)^2 \\right]\\]\nwhere \\(r_0\\) is the equilibrium value of the bond, and \\(K\\) is a\nprefactor. The anharmonic prefactors have units angstrom^(-n):\n-2.55 angstrom^(-1) and (7/12)2.55^2 angstrom^(-2). The code takes\ncare of the necessary unit conversion for these factors internally.\nNote that the MM3 papers contains an error in Eq (1):\n(7/12)2.55 should be replaced with (7/12)2.55^2\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^2)\n\\(r_0\\) (distance)",
    "syntax": "bond_style mm3",
    "parameters": " * ",
    "examples": "bond_style mm3\nbond_coeff 1 100.0 107.0",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\nUSER_YAFF package.  See the Build package doc\npage for more info."
},
{
    "command": "bond_style morse",
    "html_filename": "bond_morse.html",
    "short_description": "The morse bond style uses the potential  \\[E = D \\left[ 1 - e^{-\\alpha (r - r_0)} \\right]^2\\] where \\(r_0\\) is the equilibrium bond distance, \\(\\alpha\\) is a stiffness parameter, and \\(D\\) determines the depth of the potential well",
    "description": "The morse bond style uses the potential\n\n\\[E = D \\left[ 1 - e^{-\\alpha (r - r_0)} \\right]^2\\]\nwhere \\(r_0\\) is the equilibrium bond distance, \\(\\alpha\\) is a stiffness\nparameter, and \\(D\\) determines the depth of the potential well.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(D\\) (energy)\n\\(\\alpha\\) (inverse distance)\n\\(r_0\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style morse",
    "parameters": " * ",
    "examples": "bond_style morse\nbond_coeff 5 1.0 2.0 1.2",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style none",
    "html_filename": "bond_none.html",
    "short_description": "Using a bond style of none means bond forces and energies are not computed, even if pairs of bonded atoms were listed in the data file read by the read_data command",
    "description": "Using a bond style of none means bond forces and energies are not\ncomputed, even if pairs of bonded atoms were listed in the data file\nread by the read_data command.\nSee the bond_style zero command for a way to\ncalculate bond statistics, but compute no bond interactions.",
    "syntax": "bond_style none",
    "parameters": " * ",
    "examples": "bond_style none",
    "restrictions": "\nnone\n\nRelated commands: none\nbond_style zero\nDefault: none"
},
{
    "command": "bond_style nonlinear",
    "html_filename": "bond_nonlinear.html",
    "short_description": "The nonlinear bond style uses the potential  \\[E = \\frac{\\epsilon (r - r_0)^2}{ [ \\lambda^2 - (r - r_0)^2 ]}\\] to define an anharmonic spring (Rector) of equilibrium length \\(r_0\\) and maximum extension lamda",
    "description": "The nonlinear bond style uses the potential\n\n\\[E = \\frac{\\epsilon (r - r_0)^2}{ [ \\lambda^2 - (r - r_0)^2 ]}\\]\nto define an anharmonic spring (Rector) of equilibrium\nlength \\(r_0\\) and maximum extension lamda.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(\\epsilon\\) (energy)\n\\(r_0\\) (distance)\n\\(\\lambda\\) (distance)\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style nonlinear",
    "parameters": " * ",
    "examples": "bond_style nonlinear\nbond_coeff 2 100.0 1.1 1.4",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style oxdna/fene",
    "html_filename": "bond_oxdna.html",
    "short_description": "The oxdna/fene , oxdna2/fene and oxrna2/fene bond styles use the potential  \\[E = - \\frac{\\epsilon}{2} \\ln \\left[ 1 - \\left(\\frac{r-r_0}{\\Delta}\\right)^2\\right]\\] to define a modified finite extensible nonlinear elastic (FENE) potential (Ouldridge) to model the connectivity of the phosphate backbone in the oxDNA/oxRNA force field for coarse-grained modelling of DNA/RNA",
    "description": "The oxdna/fene , oxdna2/fene and oxrna2/fene bond styles use the potential\n\n\\[E = - \\frac{\\epsilon}{2} \\ln \\left[ 1 - \\left(\\frac{r-r_0}{\\Delta}\\right)^2\\right]\\]\nto define a modified finite extensible nonlinear elastic (FENE)\npotential (Ouldridge) to model the connectivity of the\nphosphate backbone in the oxDNA/oxRNA force field for coarse-grained\nmodelling of DNA/RNA.\nThe following coefficients must be defined for the bond type via the\nbond_coeff command as given in the above example, or\nin the data file or restart files read by the\nread_data or read_restart\ncommands:\n\n\\(\\epsilon\\) (energy)\n\\(\\Delta\\) (distance)\n\\(r_0\\) (distance)\n\n\nNote\nThe oxDNA bond style has to be used together with the\ncorresponding oxDNA pair styles for excluded volume interaction\noxdna/excv , stacking oxdna/stk , cross-stacking oxdna/xstk and\ncoaxial stacking interaction oxdna/coaxstk as well as\nhydrogen-bonding interaction oxdna/hbond (see also documentation of\npair_style oxdna/excv). For the oxDNA2\n(Snodin) bond style the analogous pair styles\noxdna2/excv , oxdna2/stk , oxdna2/xstk , oxdna2/coaxstk ,\noxdna2/hbond and an additional Debye-Hueckel pair style\noxdna2/dh have to be defined. The same applies to the oxRNA2\n(Sulc1) styles.\nThe coefficients in the above example have to be kept fixed and cannot\nbe changed without reparameterizing the entire model.\n\nExample input and data files for DNA and RNA duplexes can be found in\nexamples/USER/cgdna/examples/oxDNA/ , /oxDNA2/ and /oxRNA2/.  A simple python\nsetup tool which creates single straight or helical DNA strands, DNA/RNA\nduplexes or arrays of DNA/RNA duplexes can be found in\nexamples/USER/cgdna/util/.\nPlease cite (Henrich) in any publication that uses\nthis implementation.  The article contains general information\non the model, its implementation and performance as well as the structure of\nthe data and input file. The preprint version of the article can be found\nhere.\nPlease cite also the relevant oxDNA/oxRNA publications. These are\n(Ouldridge) and\n(Ouldridge-DPhil) for oxDNA,\n(Snodin) for oxDNA2,\n(Sulc1) for oxRNA2\nand for sequence-specific hydrogen-bonding and stacking interactions\n(Sulc2).",
    "syntax": "bond_style oxdna/fene",
    "parameters": " * bond_style oxdna2/fene\n * bond_style oxrna2/fene",
    "examples": "bond_style oxdna/fene\nbond_coeff * 2.0 0.25 0.7525\n\nbond_style oxdna2/fene\nbond_coeff * 2.0 0.25 0.7564\n\nbond_style oxrna2/fene\nbond_coeff \\* 2.0 0.25 0.76107",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\nUSER-CGDNA package and the MOLECULE and ASPHERE package.  See the\nBuild package doc page for more info."
},
{
    "command": "bond_style quartic",
    "html_filename": "bond_quartic.html",
    "short_description": "The quartic bond style uses the potential  \\[E = K (r - R_c)^ 2 (r - R_c - B_1) (r - R_c - B_2) + U_0 + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + \\epsilon\\] to define a bond that can be broken as the simulation proceeds (e",
    "description": "The quartic bond style uses the potential\n\n\\[E = K (r - R_c)^ 2 (r - R_c - B_1) (r - R_c - B_2) + U_0 + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + \\epsilon\\]\nto define a bond that can be broken as the simulation proceeds (e.g.\ndue to a polymer being stretched).  The \\(\\sigma\\) and \\(\\epsilon\\) used in the\nLJ portion of the formula are both set equal to 1.0 by LAMMPS.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above, or in\nthe data file or restart files read by the read_data\nor read_restart commands:\n\n\\(K\\) (energy/distance^4)\n\\(B_1\\) (distance)\n\\(B_2\\) (distance)\n\\(R_c\\) (distance)\n\\(U_0\\) (energy)\n\nThis potential was constructed to mimic the FENE bond potential for\ncoarse-grained polymer chains.  When monomers with \\(\\sigma = \\epsilon = 1.0\\)\nare used, the following choice of parameters gives a quartic potential that\nlooks nearly like the FENE potential:\n\n\\[\\begin{split}K &= 1200 \\\\\nB_1 &= -0.55 \\\\\nB_2 &= 0.25 \\\\\nR_c &= 1.3 \\\\\nU_0 &= 34.6878\\end{split}\\]\nDifferent parameters can be specified using the bond_coeff\ncommand, but you will need to choose them carefully so they form a suitable\nbond potential.\n\\(R_c\\) is the cutoff length at which the bond potential goes smoothly to a\nlocal maximum.  If a bond length ever becomes \\(> R_c\\), LAMMPS “breaks”\nthe bond, which means two things.  First, the bond potential is turned\noff by setting its type to 0, and is no longer computed.  Second, a\npairwise interaction between the two atoms is turned on, since they\nare no longer bonded.\nLAMMPS does the second task via a computational sleight-of-hand.  It\nsubtracts the pairwise interaction as part of the bond computation.\nWhen the bond breaks, the subtraction stops.  For this to work, the\npairwise interaction must always be computed by the\npair_style command, whether the bond is broken or\nnot.  This means that special_bonds must be set\nto 1,1,1, as indicated as a restriction below.\nNote that when bonds are dumped to a file via the dump local command, bonds with type 0 are not included.  The\ndelete_bonds command can also be used to query the\nstatus of broken bonds or permanently delete them, e.g.:\ndelete_bonds all stats\ndelete_bonds all bond 0 remove\n\n\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.",
    "syntax": "bond_style quartic",
    "parameters": " * ",
    "examples": "bond_style quartic\nbond_coeff 2 1200 -0.55 0.25 1.3 34.6878",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo.\nThe quartic style requires that special_bonds\nparameters be set to 1,1,1.  Three- and four-body interactions (angle,\ndihedral, etc) cannot be used with quartic bonds."
},
{
    "command": "bond_style table",
    "html_filename": "bond_table.html",
    "short_description": "Style table creates interpolation tables of length N from bond potential and force values listed in a file(s) as a function of bond length",
    "description": "Style table creates interpolation tables of length N from bond\npotential and force values listed in a file(s) as a function of bond\nlength.  The files are read by the bond_coeff\ncommand.\nThe interpolation tables are created by fitting cubic splines to the\nfile values and interpolating energy and force values at each of N\ndistances.  During a simulation, these tables are used to interpolate\nenergy and force values as needed.  The interpolation is done in one\nof 2 styles: linear or spline.\nFor the linear style, the bond length is used to find 2 surrounding\ntable values from which an energy or force is computed by linear\ninterpolation.\nFor the spline style, a cubic spline coefficients are computed and\nstored at each of the N values in the table.  The bond length is\nused to find the appropriate set of coefficients which are used to\nevaluate a cubic polynomial which computes the energy or force.\nThe following coefficients must be defined for each bond type via the\nbond_coeff command as in the example above.\n\nfilename\nkeyword\n\nThe filename specifies a file containing tabulated energy and force\nvalues.  The keyword specifies a section of the file.  The format of\nthis file is described below.\n\nThe format of a tabulated file is as follows (without the\nparenthesized comments):\n# Bond potential for harmonic (one or more comment or blank lines)\n\nHAM                           (keyword is the first text on line)\nN 101 FP 0 0 EQ 0.5           (N, FP, EQ  parameters)\n                              (blank line)\n1 0.00 338.0000 1352.0000     (index, bond-length, energy, force)\n2 0.01 324.6152 1324.9600\n...\n101 1.00 338.0000 -1352.0000\n\n\nA section begins with a non-blank line whose 1st character is not a\n“#”; blank lines or lines starting with “#” can be used as comments\nbetween sections.  The first line begins with a keyword which\nidentifies the section.  The line can contain additional text, but the\ninitial text must match the argument specified in the\nbond_coeff command.  The next line lists (in any\norder) one or more parameters for the table.  Each parameter is a\nkeyword followed by one or more numeric values.\nThe parameter “N” is required and its value is the number of table\nentries that follow.  Note that this may be different than the N\nspecified in the bond_style table command.  Let\nNtable = N in the bond_style command, and Nfile = “N” in the\ntabulated file.  What LAMMPS does is a preliminary interpolation by\ncreating splines using the Nfile tabulated values as nodal points.  It\nuses these to interpolate as needed to generate energy and force\nvalues at Ntable different points.  The resulting tables of length\nNtable are then used as described above, when computing energy and\nforce for individual bond lengths.  This means that if you want the\ninterpolation tables of length Ntable to match exactly what is in the\ntabulated file (with effectively no preliminary interpolation), you\nshould set Ntable = Nfile.\nThe “FP” parameter is optional.  If used, it is followed by two values\nfplo and fphi, which are the derivatives of the force at the innermost\nand outermost bond lengths.  These values are needed by the spline\nconstruction routines.  If not specified by the “FP” parameter, they\nare estimated (less accurately) by the first two and last two force\nvalues in the table.\nThe “EQ” parameter is also optional.  If used, it is followed by a the\nequilibrium bond length, which is used, for example, by the fix shake command.  If not used, the equilibrium bond\nlength is to the distance in the table with the lowest potential energy.\nFollowing a blank line, the next N lines list the tabulated values.\nOn each line, the 1st value is the index from 1 to N, the 2nd value is\nthe bond length r (in distance units), the 3rd value is the energy (in\nenergy units), and the 4th is the force (in force units).  The bond\nlengths must range from a LO value to a HI value, and increase from\none line to the next.  If the actual bond length is ever smaller than\nthe LO value or larger than the HI value, then the calculation is\naborted with an error, so it is advisable to cover the whole range\nof possible bond lengths.\nNote that one file can contain many sections, each with a tabulated\npotential.  LAMMPS reads the file section by section until it finds\none that matches the specified keyword.\n\nStyles with a gpu, intel, kk, omp, or opt suffix are\nfunctionally the same as the corresponding style without the suffix.\nThey have been optimized to run faster, depending on your available\nhardware, as discussed on the Speed packages doc\npage.  The accelerated styles take the same arguments and should\nproduce the same results, except for round-off and precision issues.\nThese accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\nUSER-OMP and OPT packages, respectively.  They are only enabled if\nLAMMPS was built with those packages.  See the Build package doc page for more info.\nYou can specify the accelerated styles explicitly in your input script\nby including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\nsuffix command in your input script.\nSee the Speed packages doc page for more\ninstructions on how to use the accelerated styles effectively.\n\nRestart info:\nThis bond style writes the settings for the “bond_style table”\ncommand to binary restart files, so a bond_style\ncommand does not need to specified in an input script that reads a\nrestart file.  However, the coefficient information is not stored in\nthe restart file, since it is tabulated in the potential files.  Thus,\nbond_coeff commands do need to be specified in the restart input\nscript.",
    "syntax": "bond_style table style N",
    "parameters": " * style = linear or spline = method of interpolation\n * N = use N values in table",
    "examples": "bond_style table linear 1000\nbond_coeff 1 file.table ENTRY1",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\npackage.  See the Build package doc page for more\ninfo."
},
{
    "command": "bond_style zero",
    "html_filename": "bond_zero.html",
    "short_description": "Using an bond style of zero means bond forces and energies are not computed, but the geometry of bond pairs is still accessible to other commands",
    "description": "Using an bond style of zero means bond forces and energies are not\ncomputed, but the geometry of bond pairs is still accessible to other\ncommands.\nAs an example, the compute bond/local\ncommand can be used to compute distances for the list of pairs of bond\natoms listed in the data file read by the read_data\ncommand.  If no bond style is defined, this command cannot be used.\nThe optional nocoeff flag allows to read data files with a BondCoeff\nsection for any bond style. Similarly, any bond_coeff commands\nwill only be checked for the bond type number and the rest ignored.\nNote that the bond_coeff command must be used for\nall bond types. If specified, there can be only one value, which is\ngoing to be used to assign an equilibrium distance, e.g. for use with\nfix shake.",
    "syntax": "bond_style zero [nocoeff]",
    "parameters": " * ",
    "examples": "bond_style zero\nbond_style zero nocoeff\nbond_coeff *\nbond_coeff * 2.14",
    "restrictions": "\nnone"
},
{
    "command": "improper_style sqdistharm",
    "html_filename": "improper_sqdistharm.html",
    "short_description": "The sqdistharm improper style uses the potential  \\[E = K (d^2 - {d_0}^2)^2\\] where \\(d\\) is the distance between the central atom and the plane formed by the other three atoms",
    "description": "The sqdistharm improper style uses the potential\n\n\\[E = K (d^2 - {d_0}^2)^2\\]\nwhere \\(d\\) is the distance between the central atom and the plane formed\nby the other three atoms.  If the 4 atoms in an improper quadruplet\n(listed in the data file read by the read_data\ncommand) are ordered I,J,K,L then the L-atom is assumed to be the\ncentral atom. Note that this is different from the convention used\nin the improper_style distance.\nThe following coefficients must be defined for each improper type via\nthe improper_coeff command as in the example above, or in the data\nfile or restart files read by the read_data or read_restart commands:\n\n\\(K\\) (energy/distance^4)\n\\({d_0}^2\\) (distance^2)\n\nNote that \\({d_0}^2\\) (in units distance^2) has be provided and not \\(d_0\\).",
    "syntax": "improper_style sqdistharm",
    "parameters": " * ",
    "examples": "improper_style sqdistharm\nimproper_coeff 1 50.0 0.1",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\nUSER-MISC package.  See the Build package doc\npage for more info."
},
];
